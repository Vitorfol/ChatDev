[2025-17-09 13:57:04 INFO] **[Preprocessing]**

**ChatDev Starts** (20250917135704)

**Timestamp**: 20250917135704

**config_path**: C:\Users\necta\Desktop\Dev\ChatDev\ChatDev\CompanyConfig\Default\ChatChainConfig.json

**config_phase_path**: C:\Users\necta\Desktop\Dev\ChatDev\ChatDev\CompanyConfig\Default\PhaseConfig.json

**config_role_path**: C:\Users\necta\Desktop\Dev\ChatDev\ChatDev\CompanyConfig\Default\RoleConfig.json

**task_prompt**: [Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes.]

**project_name**: [roleta2]

**Log File**: C:\Users\necta\Desktop\Dev\ChatDev\ChatDev\WareHouse\[roleta2]_DefaultOrganization_20250917135704.log

**ChatDevConfig**:
ChatEnvConfig.with_memory: False
ChatEnvConfig.clear_structure: True
ChatEnvConfig.git_management: False
ChatEnvConfig.gui_design: True
ChatEnvConfig.incremental_develop: False
ChatEnvConfig.background_prompt: ChatDev is a software company powered by multiple intelligent agents, such as chief executive officer, chief human resources officer, chief product officer, chief technology officer, etc, with a multi-agent organizational structure and the mission of 'changing the digital world through programming'.


**ChatGPTConfig**:
ChatGPTConfig(temperature=0.2, top_p=1.0, n=1, stream=False, stop=None, max_tokens=None, presence_penalty=0.0, frequency_penalty=0.0, logit_bias={}, user='')



[2025-17-09 13:57:04 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | [Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes.] |
| **need_reflect** | True |
| **assistant_role_name** | Chief Product Officer |
| **user_role_name** | Chief Executive Officer |
| **phase_prompt** | ChatDev has made products in the following form before: Image: can present information in line chart, bar chart, flow chart, cloud chart, Gantt chart, etc. Document: can present information via .docx files. PowerPoint: can present information via .pptx files. Excel: can present information via .xlsx files. PDF: can present information via .pdf files. Website: can present personal resume, tutorial, products, or ideas, via .html files. Application: can implement visualized game, software, tool, etc, via python. Dashboard: can display a panel visualizing real-time information. Mind Map: can represent ideas, with related concepts arranged around a core concept. As the {assistant_role}, to satisfy the new user's demand and the product should be realizable, you should keep discussing with me to decide which product modality do we want the product to be? Note that we must ONLY discuss the product modality and do not discuss anything else! Once we all have expressed our opinion(s) and agree with the results of the discussion unanimously, any of us must actively terminate the discussion by replying with only one line, which starts with a single word , followed by our final product modality without any other words, e.g., " PowerPoint". |
| **phase_name** | DemandAnalysis |
| **assistant_role_prompt** | {chatdev_prompt} You are Chief Product Officer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. You are responsible for all product-related matters in ChatDev. Usually includes product design, product strategy, product vision, product innovation, project management and product marketing. Here is a new customer's task: {task}. To complete the task, you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully complete a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. To complete the task, I will give you one or more instructions, and you must help me to write a specific solution that appropriately solves the requested instruction based on your expertise and my needs. |
| **chat_turn_limit** | 10 |
| **placeholders** | {} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_3_5_TURBO |

[2025-17-09 13:57:04 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Chief Product Officer |
| **user_role_name** | Chief Executive Officer |
| **assistant_role_prompt** | {chatdev_prompt} You are Chief Product Officer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. You are responsible for all product-related matters in ChatDev. Usually includes product design, product strategy, product vision, product innovation, project management and product marketing. Here is a new customer's task: {task}. To complete the task, you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully complete a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. To complete the task, I will give you one or more instructions, and you must help me to write a specific solution that appropriately solves the requested instruction based on your expertise and my needs. |
| **task_prompt** | [Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes.] |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_3_5_TURBO |
| **background_prompt** | ChatDev is a software company powered by multiple intelligent agents, such as chief executive officer, chief human resources officer, chief product officer, chief technology officer, etc, with a multi-agent organizational structure and the mission of 'changing the digital world through programming'. |

[2025-17-09 13:57:05 INFO] Chief Executive Officer: **[Start Chat]**

[ChatDev is a software company powered by multiple intelligent agents, such as chief executive officer, chief human resources officer, chief product officer, chief technology officer, etc, with a multi-agent organizational structure and the mission of 'changing the digital world through programming'.
You are Chief Product Officer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer.
You are responsible for all product-related matters in ChatDev. Usually includes product design, product strategy, product vision, product innovation, project management and product marketing.
Here is a new customer's task: [Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes.].
To complete the task, you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]

ChatDev has made products in the following form before:

Image: can present information in line chart, bar chart, flow chart, cloud chart, Gantt chart, etc.

Document: can present information via .docx files.

PowerPoint: can present information via .pptx files.

Excel: can present information via .xlsx files.

PDF: can present information via .pdf files.

Website: can present personal resume, tutorial, products, or ideas, via .html files.

Application: can implement visualized game, software, tool, etc, via python.

Dashboard: can display a panel visualizing real-time information.

Mind Map: can represent ideas, with related concepts arranged around a core concept.

As the Chief Product Officer, to satisfy the new user's demand and the product should be realizable, you should keep discussing with me to decide which product modality do we want the product to be?

Note that we must ONLY discuss the product modality and do not discuss anything else! Once we all have expressed our opinion(s) and agree with the results of the discussion unanimously, any of us must actively terminate the discussion by replying with only one line, which starts with a single word <INFO>, followed by our final product modality without any other words, e.g., "<INFO> PowerPoint".

[2025-17-09 13:57:14 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2025-17-09 13:57:14 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 449
completion_tokens: 373
total_tokens: 822
cost: $-1.000000


[2025-17-09 13:57:20 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2025-17-09 13:57:20 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 600
completion_tokens: 141
total_tokens: 741
cost: $-1.000000


[2025-17-09 13:57:20 INFO] Chief Product Officer: **Chief Product Officer<->Chief Executive Officer on : DemandAnalysis, turn 0**

[ChatDev is a software company powered by multiple intelligent agents, such as chief executive officer, chief human resources officer, chief product officer, chief technology officer, etc, with a multi-agent organizational structure and the mission of 'changing the digital world through programming'.
You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully complete a task assigned by a new customer.
Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees.
Here is a new customer's task: [Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes.].
To complete the task, I will give you one or more instructions, and you must help me to write a specific solution that appropriately solves the requested instruction based on your expertise and my needs.]

I recommend the Website modality. The customer's request explicitly describes an interactive web page (name input + spinning wheel + selectable themes), which is naturally implemented as an .html/.css/.js website and is easy to host and share. Alternatives (Application = a desktop/mobile app; Dashboard = more data-focused panel; PowerPoint/Document/PDF/Image/Excel/Mind Map = ill-suited for interactive random selection) are possible but less appropriate.

Do you agree we should produce this as a Website, or do you prefer a different modality?

[2025-17-09 13:57:20 INFO] Chief Executive Officer: **Chief Product Officer<->Chief Executive Officer on : DemandAnalysis, turn 0**

[ChatDev is a software company powered by multiple intelligent agents, such as chief executive officer, chief human resources officer, chief product officer, chief technology officer, etc, with a multi-agent organizational structure and the mission of 'changing the digital world through programming'.
You are Chief Product Officer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer.
You are responsible for all product-related matters in ChatDev. Usually includes product design, product strategy, product vision, product innovation, project management and product marketing.
Here is a new customer's task: [Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes.].
To complete the task, you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]

<INFO> Website

[2025-17-09 13:57:20 INFO] **[Seminar Conclusion]**:

 <INFO> Website

[2025-17-09 13:57:20 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | [Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes.] |
| **need_reflect** | True |
| **assistant_role_name** | Chief Technology Officer |
| **user_role_name** | Chief Executive Officer |
| **phase_prompt** | According to the new user's task and some creative brainstorm ideas listed below:  Task: "{task}". Modality: "{modality}". Ideas: "{ideas}". We have decided to complete the task through a executable software implemented via a programming language.  As the {assistant_role}, to satisfy the new user's demand and make the software realizable, you should propose a concrete programming language. If python can complete this task via Python, please answer Python; otherwise, answer another programming language (e.g., Java, C++, etc,). Note that we must ONLY discuss the target programming language and do not discuss anything else! Once we all have expressed our opinion(s) and agree with the results of the discussion unanimously, any of us must actively terminate the discussion and conclude the best programming language we have discussed without any other words or reasons, return only one line using the format: " " where "" represents a programming language. |
| **phase_name** | LanguageChoose |
| **assistant_role_prompt** | {chatdev_prompt} You are Chief Technology Officer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. You are very familiar to information technology. You will make high-level decisions for the overarching technology infrastructure that closely align with the organization's goals, while you work alongside the organization's information technology ("IT") staff members to perform everyday operations. Here is a new customer's task: {task}. To complete the task, You must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully complete a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. To complete the task, I will give you one or more instructions, and you must help me to write a specific solution that appropriately solves the requested instruction based on your expertise and my needs. |
| **chat_turn_limit** | 10 |
| **placeholders** | {'task': '[Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes.]', 'description': '', 'modality': 'website', 'ideas': ''} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_3_5_TURBO |

[2025-17-09 13:57:20 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Chief Technology Officer |
| **user_role_name** | Chief Executive Officer |
| **assistant_role_prompt** | {chatdev_prompt} You are Chief Technology Officer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. You are very familiar to information technology. You will make high-level decisions for the overarching technology infrastructure that closely align with the organization's goals, while you work alongside the organization's information technology ("IT") staff members to perform everyday operations. Here is a new customer's task: {task}. To complete the task, You must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully complete a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. To complete the task, I will give you one or more instructions, and you must help me to write a specific solution that appropriately solves the requested instruction based on your expertise and my needs. |
| **task_prompt** | [Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes.] |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_3_5_TURBO |
| **background_prompt** | ChatDev is a software company powered by multiple intelligent agents, such as chief executive officer, chief human resources officer, chief product officer, chief technology officer, etc, with a multi-agent organizational structure and the mission of 'changing the digital world through programming'. |

[2025-17-09 13:57:20 INFO] Chief Executive Officer: **[Start Chat]**

[ChatDev is a software company powered by multiple intelligent agents, such as chief executive officer, chief human resources officer, chief product officer, chief technology officer, etc, with a multi-agent organizational structure and the mission of 'changing the digital world through programming'.
You are Chief Technology Officer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer.
You are very familiar to information technology. You will make high-level decisions for the overarching technology infrastructure that closely align with the organization's goals, while you work alongside the organization's information technology ("IT") staff members to perform everyday operations.
Here is a new customer's task: [Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes.].
To complete the task, You must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]

According to the new user's task and some creative brainstorm ideas listed below: 

Task: "[Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes.]".

Modality: "website".

Ideas: "".

We have decided to complete the task through a executable software implemented via a programming language. 

As the Chief Technology Officer, to satisfy the new user's demand and make the software realizable, you should propose a concrete programming language. If python can complete this task via Python, please answer Python; otherwise, answer another programming language (e.g., Java, C++, etc,).

Note that we must ONLY discuss the target programming language and do not discuss anything else! Once we all have expressed our opinion(s) and agree with the results of the discussion unanimously, any of us must actively terminate the discussion and conclude the best programming language we have discussed without any other words or reasons, return only one line using the format: "<INFO> *" where "*" represents a programming language.

[2025-17-09 13:57:28 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2025-17-09 13:57:28 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 417
completion_tokens: 269
total_tokens: 686
cost: $-1.000000


[2025-17-09 13:57:28 INFO] Chief Technology Officer: **Chief Technology Officer<->Chief Executive Officer on : LanguageChoose, turn 0**

[ChatDev is a software company powered by multiple intelligent agents, such as chief executive officer, chief human resources officer, chief product officer, chief technology officer, etc, with a multi-agent organizational structure and the mission of 'changing the digital world through programming'.
You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully complete a task assigned by a new customer.
Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees.
Here is a new customer's task: [Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes.].
To complete the task, I will give you one or more instructions, and you must help me to write a specific solution that appropriately solves the requested instruction based on your expertise and my needs.]

<INFO> Python

[2025-17-09 13:57:28 INFO] **[Seminar Conclusion]**:

 <INFO> Python

[2025-17-09 13:57:28 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | [Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes.] |
| **need_reflect** | False |
| **assistant_role_name** | Programmer |
| **user_role_name** | Chief Technology Officer |
| **phase_prompt** | According to the new user's task and our software designs listed below:  Task: "{task}". Task description: "{description}". Modality: "{modality}". Programming Language: "{language}" Ideas:"{ideas}" We have decided to complete the task through a executable software with multiple files implemented via {language}. As the {assistant_role}, to satisfy the new user's demands, you should write one or multiple files and make sure that every detail of the architecture is, in the end, implemented as code. {gui} Think step by step and reason yourself to the right decisions to make sure we get it right. You will first lay out the names of the core classes, functions, methods that will be necessary, as well as a quick comment on their purpose. Then you will output the content of each file including complete code. Each file must strictly follow a markdown code block format, where the following tokens must be replaced such that "FILENAME" is the lowercase file name including the file extension, "LANGUAGE" in the programming language, "DOCSTRING" is a string literal specified in source code that is used to document a specific segment of code, and "CODE" is the original code: FILENAME ```LANGUAGE ''' DOCSTRING ''' CODE ``` You will start with the "main" file, then go to the ones that are imported by that file, and so on. Please note that the code should be fully functional. Ensure to implement all functions. No placeholders (such as 'pass' in Python). |
| **phase_name** | Coding |
| **assistant_role_prompt** | {chatdev_prompt} You are Programmer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. You can write/create computer software or applications by providing a specific programming language to the computer. You have extensive computing and coding experience in many varieties of programming languages and platforms, such as Python, Java, C, C++, HTML, CSS, JavaScript, XML, SQL, PHP, etc,. Here is a new customer's task: {task}. To complete the task, you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Chief Technology Officer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. You are very familiar to information technology. You will make high-level decisions for the overarching technology infrastructure that closely align with the organization's goals, while you work alongside the organization's information technology ("IT") staff members to perform everyday operations. Here is a new customer's task: {task}. To complete the task, You must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'task': '[Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes.]', 'description': '', 'modality': 'website', 'ideas': '', 'language': ' Python', 'gui': 'The software should be equipped with graphical user interface (GUI) so that user can visually and graphically use it; so you must choose a GUI framework (e.g., in Python, you can implement GUI via tkinter, Pygame, Flexx, PyGUI, etc,).'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_3_5_TURBO |

[2025-17-09 13:57:28 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Programmer |
| **user_role_name** | Chief Technology Officer |
| **assistant_role_prompt** | {chatdev_prompt} You are Programmer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. You can write/create computer software or applications by providing a specific programming language to the computer. You have extensive computing and coding experience in many varieties of programming languages and platforms, such as Python, Java, C, C++, HTML, CSS, JavaScript, XML, SQL, PHP, etc,. Here is a new customer's task: {task}. To complete the task, you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Chief Technology Officer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. You are very familiar to information technology. You will make high-level decisions for the overarching technology infrastructure that closely align with the organization's goals, while you work alongside the organization's information technology ("IT") staff members to perform everyday operations. Here is a new customer's task: {task}. To complete the task, You must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **task_prompt** | [Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes.] |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_3_5_TURBO |
| **background_prompt** | ChatDev is a software company powered by multiple intelligent agents, such as chief executive officer, chief human resources officer, chief product officer, chief technology officer, etc, with a multi-agent organizational structure and the mission of 'changing the digital world through programming'. |

[2025-17-09 13:57:28 INFO] Chief Technology Officer: **[Start Chat]**

[ChatDev is a software company powered by multiple intelligent agents, such as chief executive officer, chief human resources officer, chief product officer, chief technology officer, etc, with a multi-agent organizational structure and the mission of 'changing the digital world through programming'.
You are Programmer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer.
You can write/create computer software or applications by providing a specific programming language to the computer. You have extensive computing and coding experience in many varieties of programming languages and platforms, such as Python, Java, C, C++, HTML, CSS, JavaScript, XML, SQL, PHP, etc,.
Here is a new customer's task: [Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes.].
To complete the task, you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]

According to the new user's task and our software designs listed below: 

Task: "[Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes.]".

Task description: "".

Modality: "website".

Programming Language: " Python"

Ideas:""

We have decided to complete the task through a executable software with multiple files implemented via  Python. As the Programmer, to satisfy the new user's demands, you should write one or multiple files and make sure that every detail of the architecture is, in the end, implemented as code. The software should be equipped with graphical user interface (GUI) so that user can visually and graphically use it; so you must choose a GUI framework (e.g., in Python, you can implement GUI via tkinter, Pygame, Flexx, PyGUI, etc,).

Think step by step and reason yourself to the right decisions to make sure we get it right.

You will first lay out the names of the core classes, functions, methods that will be necessary, as well as a quick comment on their purpose.

Then you will output the content of each file including complete code. Each file must strictly follow a markdown code block format, where the following tokens must be replaced such that "FILENAME" is the lowercase file name including the file extension, "LANGUAGE" in the programming language, "DOCSTRING" is a string literal specified in source code that is used to document a specific segment of code, and "CODE" is the original code:

FILENAME

```LANGUAGE

'''

DOCSTRING

'''

CODE

```

You will start with the "main" file, then go to the ones that are imported by that file, and so on.

Please note that the code should be fully functional. Ensure to implement all functions. No placeholders (such as 'pass' in Python).

[2025-17-09 13:59:45 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2025-17-09 13:59:45 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 603
completion_tokens: 7255
total_tokens: 7858
cost: $-1.000000


[2025-17-09 13:59:45 INFO] Programmer: **Programmer<->Chief Technology Officer on : Coding, turn 0**

[ChatDev is a software company powered by multiple intelligent agents, such as chief executive officer, chief human resources officer, chief product officer, chief technology officer, etc, with a multi-agent organizational structure and the mission of 'changing the digital world through programming'.
You are Chief Technology Officer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer.
You are very familiar to information technology. You will make high-level decisions for the overarching technology infrastructure that closely align with the organization's goals, while you work alongside the organization's information technology ("IT") staff members to perform everyday operations.
Here is a new customer's task: [Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes.].
To complete the task, You must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]

Core components (classes / functions) and their purposes:

- app.py
  - create_app(): create and configure the Flask app
  - index(): serve the main page (templates/index.html)
  - (Flask will serve static files from /static)

- templates/index.html
  - The web page layout and UI: name input, names list, wheel canvas, spin button, theme selector.
  - Loads JS/CSS and wires UI elements.

- static/themes.json
  - JSON describing available themes: name, background color, segment colors, text color, accent.

- static/css/styles.css
  - Base styles and layout. Provides CSS variables that themes update for page visuals.

- static/js/wheel.js
  - Wheel class:
    - constructor(canvas, options): initialize canvas and properties
    - setNames(names): set names and recalculate segments
    - setTheme(theme): set color palette and style
    - draw(): draw wheel and labels
    - spinToIndex(index): animate the wheel to land on the given index; returns a Promise resolved when spin completes
    - getRandomIndex(): returns a random index in current names array

- static/js/main.js
  - UI glue code:
    - load themes.json and populate theme selector
    - read names (textarea / add input), update wheel
    - handle spin click: choose random index and call wheel.spinToIndex, then show winner modal/pop-up
    - manage buttons: add name, clear, import/export, copy winner, etc.

Files (start with main Python file):

app.py

```python

'''
app.py

DOCSTRING:
Flask application that serves the wheel-of-names web app.
Run: pip install flask
Then: python app.py
Access: http://127.0.0.1:5000/
'''

from flask import Flask, render_template
import os

def create_app():
    """
    Create and configure the Flask application.
    """
    app = Flask(__name__, static_folder='static', template_folder='templates')

    @app.route('/')
    def index():
        """
        Serve the main page.
        """
        return render_template('index.html')

    return app

if __name__ == '__main__':
    app = create_app()
    port = int(os.environ.get('PORT', 5000))
    app.run(debug=True, host='0.0.0.0', port=port)
```

templates/index.html

```html

'''
DOCSTRING:
Main HTML page for the Wheel of Names app.
Contains UI elements:
- name input and list
- canvas for wheel
- theme selector
- spin / clear / add buttons
Includes JS files wheel.js and main.js for behavior.
'''

<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Wheel of Names</title>
  <link rel="stylesheet" href="{{ url_for('static', filename='css/styles.css') }}">
</head>
<body>
  <div class="container">
    <header>
      <h1>Wheel of Names</h1>
      <p>Enter names, choose a theme, and spin to pick a random winner.</p>
    </header>

    <main class="main-grid">
      <section class="left-panel">
        <div class="controls">
          <label for="name-input">Add a name</label>
          <div class="input-row">
            <input id="name-input" type="text" placeholder="Enter name and press Add" autocomplete="off">
            <button id="add-name">Add</button>
          </div>

          <label for="names-textarea">Names (one per line)</label>
          <textarea id="names-textarea" placeholder="Alice\nBob\nCharlie"></textarea>

          <div class="buttons-row">
            <button id="load-sample">Load Sample</button>
            <button id="clear-names">Clear</button>
            <button id="import-names">Import</button>
            <button id="export-names">Export</button>
          </div>

          <label for="theme-select">Theme</label>
          <select id="theme-select"></select>

          <div class="spin-controls">
            <button id="spin-btn" class="spin">SPIN</button>
            <div id="result" class="result hidden"></div>
          </div>
        </div>
      </section>

      <section class="right-panel">
        <div class="wheel-wrapper" id="wheel-wrapper">
          <canvas id="wheel-canvas" width="600" height="600"></canvas>
          <div id="pointer">â–¼</div>
        </div>
      </section>
    </main>

    <footer>
      <small>Built with Flask + Canvas. Themes available.</small>
    </footer>
  </div>

  <script src="{{ url_for('static', filename='js/wheel.js') }}"></script>
  <script src="{{ url_for('static', filename='js/main.js') }}"></script>
</body>
</html>
```

static/themes.json

```json

'''
DOCSTRING:
List of themes available for the wheel.
Each theme contains:
- name: display name
- bg: page background color
- text: primary text color
- accent: accent color used for pointer/button
- colors: array of segment colors (will be cycled for segments)
'''

[
  {
    "id": "classic",
    "name": "Classic",
    "bg": "#ffffff",
    "text": "#222222",
    "accent": "#007bff",
    "colors": ["#ffb3b3", "#ffd9b3", "#fff3b3", "#d9ffb3", "#b3ffd9", "#b3e6ff", "#c7b3ff", "#ffb3f2"]
  },
  {
    "id": "dark",
    "name": "Dark",
    "bg": "#121212",
    "text": "#f5f5f5",
    "accent": "#ff6b6b",
    "colors": ["#2e2e34", "#3a3a44", "#4a4a56", "#5a5a68", "#6a6a78", "#7a7a88"]
  },
  {
    "id": "pastel",
    "name": "Pastel",
    "bg": "#f7f7ff",
    "text": "#333333",
    "accent": "#ff8c94",
    "colors": ["#ffd1dc", "#fce1b4", "#e8ffd1", "#d1fff0", "#d1e7ff", "#e6d1ff"]
  },
  {
    "id": "neon",
    "name": "Neon",
    "bg": "#0f0f13",
    "text": "#eaff00",
    "accent": "#00fff5",
    "colors": ["#ff00ff", "#ff8c00", "#00ff00", "#00ffff", "#8c00ff", "#ff0066"]
  }
]
```

static/css/styles.css

```css

'''
DOCSTRING:
Base CSS for the Wheel of Names app.
Defines layout, basic theme variables, and responsive styles.
'''

:root{
  --bg: #ffffff;
  --text: #222222;
  --accent: #007bff;
  --panel-bg: #f6f8fa;
}

*{box-sizing:border-box}
html,body{
  height:100%;
  margin:0;
  font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
  background: var(--bg);
  color: var(--text);
}

.container{
  max-width:1100px;
  margin:24px auto;
  padding:16px;
}

header{ text-align:center; margin-bottom:8px }
h1{ margin:6px 0; font-size:28px }
p{ margin:0; color:var(--text); opacity:0.8 }

.main-grid{
  display:grid;
  grid-template-columns: 360px 1fr;
  gap:20px;
  align-items:start;
  margin-top:18px;
}

.left-panel{
  background:var(--panel-bg);
  padding:14px;
  border-radius:8px;
  box-shadow:0 4px 8px rgba(0,0,0,0.04);
}

.left-panel label{ display:block; margin-top:8px; font-weight:600; margin-bottom:6px }
.input-row{ display:flex; gap:8px }
.input-row input[type="text"]{
  flex:1;
  padding:8px 10px;
  border-radius:6px;
  border:1px solid #ddd;
}
.input-row button{
  padding:8px 12px;
  border-radius:6px;
  background:var(--accent);
  color:white;
  border:none;
  cursor:pointer;
}

textarea{
  width:100%;
  min-height:160px;
  padding:10px;
  border-radius:8px;
  border:1px solid #ddd;
  resize:vertical;
}

.buttons-row{
  display:flex;
  gap:8px;
  margin-top:8px;
  flex-wrap:wrap;
}
.buttons-row button{
  padding:8px 10px;
  border-radius:6px;
  border:1px solid #ccc;
  background:transparent;
  cursor:pointer;
}

.spin-controls{
  display:flex;
  gap:12px;
  margin-top:16px;
  align-items:center;
}
.spin{
  padding:14px 24px;
  background:var(--accent);
  color:white;
  font-weight:700;
  border:none;
  border-radius:10px;
  cursor:pointer;
  font-size:18px;
}
.result{
  padding:10px 12px;
  background:rgba(0,0,0,0.06);
  border-radius:8px;
}
.hidden{ display:none }

.right-panel{
  display:flex;
  align-items:center;
  justify-content:center;
  min-height:420px;
}
.wheel-wrapper{
  position:relative;
  width:600px;
  height:600px;
  display:flex;
  align-items:center;
  justify-content:center;
  margin:auto;
}
#wheel-canvas{
  border-radius:50%;
  box-shadow: 0 12px 30px rgba(0,0,0,0.12);
  background:transparent;
}
#wheel-wrapper #pointer{
  position:absolute;
  top:18px;
  left:50%;
  transform:translateX(-50%);
  font-size:40px;
  color:var(--accent);
  text-shadow:0 2px 4px rgba(0,0,0,0.2);
  pointer-events:none;
}

footer{ text-align:center; margin-top:16px; color:var(--text); opacity:0.7; }

/* Responsive */
@media (max-width:960px){
  .main-grid{ grid-template-columns:1fr; }
  .wheel-wrapper{ width:420px; height:420px; }
  #wheel-canvas{ width:420px; height:420px; }
}
```

static/js/wheel.js

```javascript

/*
'''
DOCSTRING:
wheel.js

Contains a Wheel class that draws the wheel on a canvas and animates spins.
Key methods:
- constructor(canvas, options)
- setNames(names)
- setTheme(theme)
- draw()
- spinToIndex(index) -> Promise resolves with index after animation
- getRandomIndex()
'''
*/

class Wheel {
  constructor(canvas, options = {}) {
    this.canvas = canvas;
    this.ctx = canvas.getContext('2d');
    this.names = options.names || [];
    this.colors = options.colors || ['#ffb3b3', '#ffd9b3', '#fff3b3', '#d9ffb3', '#b3ffd9', '#b3e6ff'];
    this.textColor = options.textColor || '#222';
    this.centerX = canvas.width / 2;
    this.centerY = canvas.height / 2;
    this.radius = Math.min(this.centerX, this.centerY) - 10;
    this.rotation = 0; // degrees
    this.font = options.font || '16px Inter, Arial';
    this.onDraw = options.onDraw || function(){};
    this._animating = false;
    this.draw();
  }

  setNames(names) {
    this.names = names.slice();
    this.draw();
  }

  setTheme(theme) {
    if (!theme) return;
    if (theme.colors && theme.colors.length) this.colors = theme.colors.slice();
    if (theme.text) this.textColor = theme.text;
    this.draw();
  }

  clearCanvas() {
    this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height);
  }

  draw() {
    this.clearCanvas();
    const ctx = this.ctx;
    const n = Math.max(1, this.names.length);
    const seg = 360 / n;
    ctx.save();
    ctx.translate(this.centerX, this.centerY);
    ctx.rotate(this.degToRad(this.rotation));
    // Draw segments
    for (let i = 0; i < n; i++) {
      const start = this.degToRad(i * seg);
      const end = this.degToRad((i + 1) * seg);
      ctx.beginPath();
      ctx.moveTo(0,0);
      ctx.arc(0,0,this.radius,start,end);
      ctx.closePath();
      ctx.fillStyle = this.colors[i % this.colors.length];
      ctx.fill();
      // stroke
      ctx.lineWidth = 2;
      ctx.strokeStyle = 'rgba(0,0,0,0.08)';
      ctx.stroke();
      // Draw label
      ctx.save();
      const angle = start + (end - start) / 2;
      ctx.rotate(angle);
      ctx.translate(this.radius * 0.55, 0);
      ctx.rotate(Math.PI / 2);
      ctx.fillStyle = this.textColor;
      ctx.font = this.font;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      const name = this.names[i] || '';
      this.wrapText(ctx, name, 0, 0, this.radius * 0.35, 18);
      ctx.restore();
    }
    ctx.restore();

    // center circle
    ctx.beginPath();
    ctx.arc(this.centerX, this.centerY, this.radius * 0.12, 0, Math.PI*2);
    ctx.fillStyle = '#ffffff';
    ctx.fill();
    ctx.lineWidth = 2;
    ctx.strokeStyle = 'rgba(0,0,0,0.06)';
    ctx.stroke();

    this.onDraw();
  }

  wrapText(ctx, text, x, y, maxWidth, lineHeight) {
    // A simple wrap for canvas text
    const words = text.split(' ');
    let line = '';
    let yOffset = y;
    for (let n = 0; n < words.length; n++) {
      const testLine = line + words[n] + ' ';
      const metrics = ctx.measureText(testLine);
      const testWidth = metrics.width;
      if (testWidth > maxWidth && n > 0) {
        ctx.fillText(line.trim(), x, yOffset);
        line = words[n] + ' ';
        yOffset += lineHeight;
      } else {
        line = testLine;
      }
    }
    ctx.fillText(line.trim(), x, yOffset);
  }

  degToRad(d) {
    return d * Math.PI / 180;
  }

  radToDeg(r) {
    return r * 180 / Math.PI;
  }

  getRandomIndex() {
    if (!this.names.length) return 0;
    return Math.floor(Math.random() * this.names.length);
  }

  // Spin such that the segment at `index` lands on the pointer at top.
  spinToIndex(index, opts = {}) {
    if (this._animating) return Promise.reject('Already animating');
    if (!this.names.length) return Promise.reject('No names');

    const n = this.names.length;
    const segAngle = 360 / n;

    // We want the center of target segment to be at angle 270deg (top of canvas - adjust if pointer is at top)
    // Our rotation variable rotates the whole wheel clockwise in degrees.
    // Compute the current rotation normalized
    const normalized = ((this.rotation % 360) + 360) % 360;

    // Calculate angle to place the segment center at top (270deg)
    // Center of segment i is at angle: (i * segAngle + segAngle/2)
    // We need rotation such that (centerAngle + rotation) mod 360 = 270
    const centerAngle = index * segAngle + segAngle / 2;
    // Solve for rotation target:
    let targetRotation = 270 - centerAngle;
    // Normalize to 0..360
    targetRotation = ((targetRotation % 360) + 360) % 360;

    // To produce multiple spins, add several full rotations:
    const fullSpins = opts.fullSpins !== undefined ? opts.fullSpins : (3 + Math.floor(Math.random()*3)); // 3-5 spins
    const endRotation = targetRotation + fullSpins * 360 + (opts.randomOffset || 0);

    // We'll animate from current normalized to endRotation, taking into account wrap
    const startRotation = normalized;
    const delta = endRotation - startRotation;

    const duration = opts.duration || 5000; // ms
    const startTime = performance.now();
    this._animating = true;

    return new Promise((resolve) => {
      const animate = (now) => {
        const elapsed = now - startTime;
        const t = Math.min(1, elapsed / duration);
        // ease out cubic
        const eased = 1 - Math.pow(1 - t, 3);
        const current = startRotation + delta * eased;
        this.rotation = current;
        this.draw();
        if (t < 1) {
          requestAnimationFrame(animate);
        } else {
          this._animating = false;
          // Normalize rotation to endRotation mod 360
          this.rotation = ((endRotation % 360) + 360) % 360;
          this.draw();
          resolve(index);
        }
      };
      requestAnimationFrame(animate);
    });
  }
}
```

static/js/main.js

```javascript

/*
'''
DOCSTRING:
main.js

Wires UI to the Wheel class:
- loads themes.json
- populates theme selector
- reads names and updates wheel
- handles spin logic and result display
'''
*/

document.addEventListener('DOMContentLoaded', async () => {
  const canvas = document.getElementById('wheel-canvas');
  const nameInput = document.getElementById('name-input');
  const addBtn = document.getElementById('add-name');
  const namesTextarea = document.getElementById('names-textarea');
  const spinBtn = document.getElementById('spin-btn');
  const resultDiv = document.getElementById('result');
  const themeSelect = document.getElementById('theme-select');
  const loadSampleBtn = document.getElementById('load-sample');
  const clearBtn = document.getElementById('clear-names');
  const importBtn = document.getElementById('import-names');
  const exportBtn = document.getElementById('export-names');

  const wheel = new Wheel(canvas, { names: [], colors: ['#ffb3b3','#ffd9b3','#fff3b3','#d9ffb3'] });

  let themes = [];
  // Load themes.json
  try {
    const resp = await fetch('/static/themes.json');
    themes = await resp.json();
    themes.forEach(t => {
      const opt = document.createElement('option');
      opt.value = t.id;
      opt.textContent = t.name;
      themeSelect.appendChild(opt);
    });
    // apply first theme
    applyTheme(themes[0]);
    themeSelect.value = themes[0].id;
  } catch (err) {
    console.error('Failed to load themes:', err);
  }

  function applyTheme(theme) {
    if (!theme) return;
    document.documentElement.style.setProperty('--bg', theme.bg || '#fff');
    document.documentElement.style.setProperty('--text', theme.text || '#222');
    document.documentElement.style.setProperty('--accent', theme.accent || '#007bff');
    // set panel bg slightly adjusted
    let panelBg = theme.bg;
    // simple luminance tweak
    try {
      panelBg = lightenOrDarkenColor(theme.bg || '#fff', 96);
    } catch(e) {
      panelBg = '#f6f8fa';
    }
    document.documentElement.style.setProperty('--panel-bg', panelBg);
    wheel.setTheme({ colors: theme.colors || [], text: theme.text || '#222' });
  }

  function lightenOrDarkenColor(col, amt) {
    // expects #rrggbb
    let usePound = false;
    if (col[0] === "#") {
      col = col.slice(1);
      usePound = true;
    }
    const num = parseInt(col,16);
    let r = (num >> 16) + amt;
    let b = ((num >> 8) & 0x00FF) + amt;
    let g = (num & 0x0000FF) + amt;
    r = Math.max(Math.min(255, r), 0);
    b = Math.max(Math.min(255, b), 0);
    g = Math.max(Math.min(255, g), 0);
    return (usePound ? "#" : "") + (g | (b << 8) | (r << 16)).toString(16).padStart(6, '0');
  }

  themeSelect.addEventListener('change', () => {
    const id = themeSelect.value;
    const t = themes.find(x => x.id === id);
    if (t) applyTheme(t);
  });

  function parseNamesFromTextarea() {
    const lines = namesTextarea.value.split('\n').map(s => s.trim()).filter(s => s.length);
    return lines;
  }

  function updateWheelFromTextarea() {
    const names = parseNamesFromTextarea();
    wheel.setNames(names);
  }

  addBtn.addEventListener('click', () => {
    const v = nameInput.value.trim();
    if (!v) return;
    const cur = parseNamesFromTextarea();
    cur.push(v);
    namesTextarea.value = cur.join('\n');
    nameInput.value = '';
    updateWheelFromTextarea();
  });

  nameInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
      addBtn.click();
      e.preventDefault();
    }
  });

  namesTextarea.addEventListener('input', () => {
    updateWheelFromTextarea();
  });

  loadSampleBtn.addEventListener('click', () => {
    const sample = ['Alice','Bob','Charlie','Diana','Eva','Frank','George','Helen','Ivy','Jack'];
    namesTextarea.value = sample.join('\n');
    updateWheelFromTextarea();
  });

  clearBtn.addEventListener('click', () => {
    namesTextarea.value = '';
    updateWheelFromTextarea();
    resultDiv.classList.add('hidden');
  });

  importBtn.addEventListener('click', async () => {
    // prompt user for a newline separated list (simple)
    const data = prompt('Paste names (one per line):');
    if (data === null) return;
    namesTextarea.value = data.split('\n').map(s => s.trim()).filter(s => s).join('\n');
    updateWheelFromTextarea();
  });

  exportBtn.addEventListener('click', () => {
    const names = parseNamesFromTextarea();
    const blob = new Blob([names.join('\n')], {type: 'text/plain'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'names.txt';
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  });

  spinBtn.addEventListener('click', async () => {
    const names = parseNamesFromTextarea();
    if (names.length === 0) {
      alert('Please add at least one name.');
      return;
    }
    resultDiv.classList.add('hidden');
    spinBtn.disabled = true;
    spinBtn.textContent = 'Spinning...';
    // pick random index
    const idx = wheel.getRandomIndex();
    try {
      const winnerIndex = await wheel.spinToIndex(idx, { duration: 4500 });
      const winner = names[winnerIndex];
      resultDiv.textContent = `Winner: ${winner}`;
      resultDiv.classList.remove('hidden');
      spinBtn.textContent = 'SPIN';
      spinBtn.disabled = false;
    } catch (err) {
      console.error(err);
      spinBtn.textContent = 'SPIN';
      spinBtn.disabled = false;
    }
  });

  // initial sample
  namesTextarea.value = 'Alice\nBob\nCharlie\nDiana\nEva';
  updateWheelFromTextarea();
});
```

[2025-17-09 13:59:45 INFO] **[Seminar Conclusion]**:

 Core components (classes / functions) and their purposes:

- app.py
  - create_app(): create and configure the Flask app
  - index(): serve the main page (templates/index.html)
  - (Flask will serve static files from /static)

- templates/index.html
  - The web page layout and UI: name input, names list, wheel canvas, spin button, theme selector.
  - Loads JS/CSS and wires UI elements.

- static/themes.json
  - JSON describing available themes: name, background color, segment colors, text color, accent.

- static/css/styles.css
  - Base styles and layout. Provides CSS variables that themes update for page visuals.

- static/js/wheel.js
  - Wheel class:
    - constructor(canvas, options): initialize canvas and properties
    - setNames(names): set names and recalculate segments
    - setTheme(theme): set color palette and style
    - draw(): draw wheel and labels
    - spinToIndex(index): animate the wheel to land on the given index; returns a Promise resolved when spin completes
    - getRandomIndex(): returns a random index in current names array

- static/js/main.js
  - UI glue code:
    - load themes.json and populate theme selector
    - read names (textarea / add input), update wheel
    - handle spin click: choose random index and call wheel.spinToIndex, then show winner modal/pop-up
    - manage buttons: add name, clear, import/export, copy winner, etc.

Files (start with main Python file):

app.py

```python

'''
app.py

DOCSTRING:
Flask application that serves the wheel-of-names web app.
Run: pip install flask
Then: python app.py
Access: http://127.0.0.1:5000/
'''

from flask import Flask, render_template
import os

def create_app():
    """
    Create and configure the Flask application.
    """
    app = Flask(__name__, static_folder='static', template_folder='templates')

    @app.route('/')
    def index():
        """
        Serve the main page.
        """
        return render_template('index.html')

    return app

if __name__ == '__main__':
    app = create_app()
    port = int(os.environ.get('PORT', 5000))
    app.run(debug=True, host='0.0.0.0', port=port)
```

templates/index.html

```html

'''
DOCSTRING:
Main HTML page for the Wheel of Names app.
Contains UI elements:
- name input and list
- canvas for wheel
- theme selector
- spin / clear / add buttons
Includes JS files wheel.js and main.js for behavior.
'''

<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Wheel of Names</title>
  <link rel="stylesheet" href="{{ url_for('static', filename='css/styles.css') }}">
</head>
<body>
  <div class="container">
    <header>
      <h1>Wheel of Names</h1>
      <p>Enter names, choose a theme, and spin to pick a random winner.</p>
    </header>

    <main class="main-grid">
      <section class="left-panel">
        <div class="controls">
          <label for="name-input">Add a name</label>
          <div class="input-row">
            <input id="name-input" type="text" placeholder="Enter name and press Add" autocomplete="off">
            <button id="add-name">Add</button>
          </div>

          <label for="names-textarea">Names (one per line)</label>
          <textarea id="names-textarea" placeholder="Alice\nBob\nCharlie"></textarea>

          <div class="buttons-row">
            <button id="load-sample">Load Sample</button>
            <button id="clear-names">Clear</button>
            <button id="import-names">Import</button>
            <button id="export-names">Export</button>
          </div>

          <label for="theme-select">Theme</label>
          <select id="theme-select"></select>

          <div class="spin-controls">
            <button id="spin-btn" class="spin">SPIN</button>
            <div id="result" class="result hidden"></div>
          </div>
        </div>
      </section>

      <section class="right-panel">
        <div class="wheel-wrapper" id="wheel-wrapper">
          <canvas id="wheel-canvas" width="600" height="600"></canvas>
          <div id="pointer">â–¼</div>
        </div>
      </section>
    </main>

    <footer>
      <small>Built with Flask + Canvas. Themes available.</small>
    </footer>
  </div>

  <script src="{{ url_for('static', filename='js/wheel.js') }}"></script>
  <script src="{{ url_for('static', filename='js/main.js') }}"></script>
</body>
</html>
```

static/themes.json

```json

'''
DOCSTRING:
List of themes available for the wheel.
Each theme contains:
- name: display name
- bg: page background color
- text: primary text color
- accent: accent color used for pointer/button
- colors: array of segment colors (will be cycled for segments)
'''

[
  {
    "id": "classic",
    "name": "Classic",
    "bg": "#ffffff",
    "text": "#222222",
    "accent": "#007bff",
    "colors": ["#ffb3b3", "#ffd9b3", "#fff3b3", "#d9ffb3", "#b3ffd9", "#b3e6ff", "#c7b3ff", "#ffb3f2"]
  },
  {
    "id": "dark",
    "name": "Dark",
    "bg": "#121212",
    "text": "#f5f5f5",
    "accent": "#ff6b6b",
    "colors": ["#2e2e34", "#3a3a44", "#4a4a56", "#5a5a68", "#6a6a78", "#7a7a88"]
  },
  {
    "id": "pastel",
    "name": "Pastel",
    "bg": "#f7f7ff",
    "text": "#333333",
    "accent": "#ff8c94",
    "colors": ["#ffd1dc", "#fce1b4", "#e8ffd1", "#d1fff0", "#d1e7ff", "#e6d1ff"]
  },
  {
    "id": "neon",
    "name": "Neon",
    "bg": "#0f0f13",
    "text": "#eaff00",
    "accent": "#00fff5",
    "colors": ["#ff00ff", "#ff8c00", "#00ff00", "#00ffff", "#8c00ff", "#ff0066"]
  }
]
```

static/css/styles.css

```css

'''
DOCSTRING:
Base CSS for the Wheel of Names app.
Defines layout, basic theme variables, and responsive styles.
'''

:root{
  --bg: #ffffff;
  --text: #222222;
  --accent: #007bff;
  --panel-bg: #f6f8fa;
}

*{box-sizing:border-box}
html,body{
  height:100%;
  margin:0;
  font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
  background: var(--bg);
  color: var(--text);
}

.container{
  max-width:1100px;
  margin:24px auto;
  padding:16px;
}

header{ text-align:center; margin-bottom:8px }
h1{ margin:6px 0; font-size:28px }
p{ margin:0; color:var(--text); opacity:0.8 }

.main-grid{
  display:grid;
  grid-template-columns: 360px 1fr;
  gap:20px;
  align-items:start;
  margin-top:18px;
}

.left-panel{
  background:var(--panel-bg);
  padding:14px;
  border-radius:8px;
  box-shadow:0 4px 8px rgba(0,0,0,0.04);
}

.left-panel label{ display:block; margin-top:8px; font-weight:600; margin-bottom:6px }
.input-row{ display:flex; gap:8px }
.input-row input[type="text"]{
  flex:1;
  padding:8px 10px;
  border-radius:6px;
  border:1px solid #ddd;
}
.input-row button{
  padding:8px 12px;
  border-radius:6px;
  background:var(--accent);
  color:white;
  border:none;
  cursor:pointer;
}

textarea{
  width:100%;
  min-height:160px;
  padding:10px;
  border-radius:8px;
  border:1px solid #ddd;
  resize:vertical;
}

.buttons-row{
  display:flex;
  gap:8px;
  margin-top:8px;
  flex-wrap:wrap;
}
.buttons-row button{
  padding:8px 10px;
  border-radius:6px;
  border:1px solid #ccc;
  background:transparent;
  cursor:pointer;
}

.spin-controls{
  display:flex;
  gap:12px;
  margin-top:16px;
  align-items:center;
}
.spin{
  padding:14px 24px;
  background:var(--accent);
  color:white;
  font-weight:700;
  border:none;
  border-radius:10px;
  cursor:pointer;
  font-size:18px;
}
.result{
  padding:10px 12px;
  background:rgba(0,0,0,0.06);
  border-radius:8px;
}
.hidden{ display:none }

.right-panel{
  display:flex;
  align-items:center;
  justify-content:center;
  min-height:420px;
}
.wheel-wrapper{
  position:relative;
  width:600px;
  height:600px;
  display:flex;
  align-items:center;
  justify-content:center;
  margin:auto;
}
#wheel-canvas{
  border-radius:50%;
  box-shadow: 0 12px 30px rgba(0,0,0,0.12);
  background:transparent;
}
#wheel-wrapper #pointer{
  position:absolute;
  top:18px;
  left:50%;
  transform:translateX(-50%);
  font-size:40px;
  color:var(--accent);
  text-shadow:0 2px 4px rgba(0,0,0,0.2);
  pointer-events:none;
}

footer{ text-align:center; margin-top:16px; color:var(--text); opacity:0.7; }

/* Responsive */
@media (max-width:960px){
  .main-grid{ grid-template-columns:1fr; }
  .wheel-wrapper{ width:420px; height:420px; }
  #wheel-canvas{ width:420px; height:420px; }
}
```

static/js/wheel.js

```javascript

/*
'''
DOCSTRING:
wheel.js

Contains a Wheel class that draws the wheel on a canvas and animates spins.
Key methods:
- constructor(canvas, options)
- setNames(names)
- setTheme(theme)
- draw()
- spinToIndex(index) -> Promise resolves with index after animation
- getRandomIndex()
'''
*/

class Wheel {
  constructor(canvas, options = {}) {
    this.canvas = canvas;
    this.ctx = canvas.getContext('2d');
    this.names = options.names || [];
    this.colors = options.colors || ['#ffb3b3', '#ffd9b3', '#fff3b3', '#d9ffb3', '#b3ffd9', '#b3e6ff'];
    this.textColor = options.textColor || '#222';
    this.centerX = canvas.width / 2;
    this.centerY = canvas.height / 2;
    this.radius = Math.min(this.centerX, this.centerY) - 10;
    this.rotation = 0; // degrees
    this.font = options.font || '16px Inter, Arial';
    this.onDraw = options.onDraw || function(){};
    this._animating = false;
    this.draw();
  }

  setNames(names) {
    this.names = names.slice();
    this.draw();
  }

  setTheme(theme) {
    if (!theme) return;
    if (theme.colors && theme.colors.length) this.colors = theme.colors.slice();
    if (theme.text) this.textColor = theme.text;
    this.draw();
  }

  clearCanvas() {
    this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height);
  }

  draw() {
    this.clearCanvas();
    const ctx = this.ctx;
    const n = Math.max(1, this.names.length);
    const seg = 360 / n;
    ctx.save();
    ctx.translate(this.centerX, this.centerY);
    ctx.rotate(this.degToRad(this.rotation));
    // Draw segments
    for (let i = 0; i < n; i++) {
      const start = this.degToRad(i * seg);
      const end = this.degToRad((i + 1) * seg);
      ctx.beginPath();
      ctx.moveTo(0,0);
      ctx.arc(0,0,this.radius,start,end);
      ctx.closePath();
      ctx.fillStyle = this.colors[i % this.colors.length];
      ctx.fill();
      // stroke
      ctx.lineWidth = 2;
      ctx.strokeStyle = 'rgba(0,0,0,0.08)';
      ctx.stroke();
      // Draw label
      ctx.save();
      const angle = start + (end - start) / 2;
      ctx.rotate(angle);
      ctx.translate(this.radius * 0.55, 0);
      ctx.rotate(Math.PI / 2);
      ctx.fillStyle = this.textColor;
      ctx.font = this.font;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      const name = this.names[i] || '';
      this.wrapText(ctx, name, 0, 0, this.radius * 0.35, 18);
      ctx.restore();
    }
    ctx.restore();

    // center circle
    ctx.beginPath();
    ctx.arc(this.centerX, this.centerY, this.radius * 0.12, 0, Math.PI*2);
    ctx.fillStyle = '#ffffff';
    ctx.fill();
    ctx.lineWidth = 2;
    ctx.strokeStyle = 'rgba(0,0,0,0.06)';
    ctx.stroke();

    this.onDraw();
  }

  wrapText(ctx, text, x, y, maxWidth, lineHeight) {
    // A simple wrap for canvas text
    const words = text.split(' ');
    let line = '';
    let yOffset = y;
    for (let n = 0; n < words.length; n++) {
      const testLine = line + words[n] + ' ';
      const metrics = ctx.measureText(testLine);
      const testWidth = metrics.width;
      if (testWidth > maxWidth && n > 0) {
        ctx.fillText(line.trim(), x, yOffset);
        line = words[n] + ' ';
        yOffset += lineHeight;
      } else {
        line = testLine;
      }
    }
    ctx.fillText(line.trim(), x, yOffset);
  }

  degToRad(d) {
    return d * Math.PI / 180;
  }

  radToDeg(r) {
    return r * 180 / Math.PI;
  }

  getRandomIndex() {
    if (!this.names.length) return 0;
    return Math.floor(Math.random() * this.names.length);
  }

  // Spin such that the segment at `index` lands on the pointer at top.
  spinToIndex(index, opts = {}) {
    if (this._animating) return Promise.reject('Already animating');
    if (!this.names.length) return Promise.reject('No names');

    const n = this.names.length;
    const segAngle = 360 / n;

    // We want the center of target segment to be at angle 270deg (top of canvas - adjust if pointer is at top)
    // Our rotation variable rotates the whole wheel clockwise in degrees.
    // Compute the current rotation normalized
    const normalized = ((this.rotation % 360) + 360) % 360;

    // Calculate angle to place the segment center at top (270deg)
    // Center of segment i is at angle: (i * segAngle + segAngle/2)
    // We need rotation such that (centerAngle + rotation) mod 360 = 270
    const centerAngle = index * segAngle + segAngle / 2;
    // Solve for rotation target:
    let targetRotation = 270 - centerAngle;
    // Normalize to 0..360
    targetRotation = ((targetRotation % 360) + 360) % 360;

    // To produce multiple spins, add several full rotations:
    const fullSpins = opts.fullSpins !== undefined ? opts.fullSpins : (3 + Math.floor(Math.random()*3)); // 3-5 spins
    const endRotation = targetRotation + fullSpins * 360 + (opts.randomOffset || 0);

    // We'll animate from current normalized to endRotation, taking into account wrap
    const startRotation = normalized;
    const delta = endRotation - startRotation;

    const duration = opts.duration || 5000; // ms
    const startTime = performance.now();
    this._animating = true;

    return new Promise((resolve) => {
      const animate = (now) => {
        const elapsed = now - startTime;
        const t = Math.min(1, elapsed / duration);
        // ease out cubic
        const eased = 1 - Math.pow(1 - t, 3);
        const current = startRotation + delta * eased;
        this.rotation = current;
        this.draw();
        if (t < 1) {
          requestAnimationFrame(animate);
        } else {
          this._animating = false;
          // Normalize rotation to endRotation mod 360
          this.rotation = ((endRotation % 360) + 360) % 360;
          this.draw();
          resolve(index);
        }
      };
      requestAnimationFrame(animate);
    });
  }
}
```

static/js/main.js

```javascript

/*
'''
DOCSTRING:
main.js

Wires UI to the Wheel class:
- loads themes.json
- populates theme selector
- reads names and updates wheel
- handles spin logic and result display
'''
*/

document.addEventListener('DOMContentLoaded', async () => {
  const canvas = document.getElementById('wheel-canvas');
  const nameInput = document.getElementById('name-input');
  const addBtn = document.getElementById('add-name');
  const namesTextarea = document.getElementById('names-textarea');
  const spinBtn = document.getElementById('spin-btn');
  const resultDiv = document.getElementById('result');
  const themeSelect = document.getElementById('theme-select');
  const loadSampleBtn = document.getElementById('load-sample');
  const clearBtn = document.getElementById('clear-names');
  const importBtn = document.getElementById('import-names');
  const exportBtn = document.getElementById('export-names');

  const wheel = new Wheel(canvas, { names: [], colors: ['#ffb3b3','#ffd9b3','#fff3b3','#d9ffb3'] });

  let themes = [];
  // Load themes.json
  try {
    const resp = await fetch('/static/themes.json');
    themes = await resp.json();
    themes.forEach(t => {
      const opt = document.createElement('option');
      opt.value = t.id;
      opt.textContent = t.name;
      themeSelect.appendChild(opt);
    });
    // apply first theme
    applyTheme(themes[0]);
    themeSelect.value = themes[0].id;
  } catch (err) {
    console.error('Failed to load themes:', err);
  }

  function applyTheme(theme) {
    if (!theme) return;
    document.documentElement.style.setProperty('--bg', theme.bg || '#fff');
    document.documentElement.style.setProperty('--text', theme.text || '#222');
    document.documentElement.style.setProperty('--accent', theme.accent || '#007bff');
    // set panel bg slightly adjusted
    let panelBg = theme.bg;
    // simple luminance tweak
    try {
      panelBg = lightenOrDarkenColor(theme.bg || '#fff', 96);
    } catch(e) {
      panelBg = '#f6f8fa';
    }
    document.documentElement.style.setProperty('--panel-bg', panelBg);
    wheel.setTheme({ colors: theme.colors || [], text: theme.text || '#222' });
  }

  function lightenOrDarkenColor(col, amt) {
    // expects #rrggbb
    let usePound = false;
    if (col[0] === "#") {
      col = col.slice(1);
      usePound = true;
    }
    const num = parseInt(col,16);
    let r = (num >> 16) + amt;
    let b = ((num >> 8) & 0x00FF) + amt;
    let g = (num & 0x0000FF) + amt;
    r = Math.max(Math.min(255, r), 0);
    b = Math.max(Math.min(255, b), 0);
    g = Math.max(Math.min(255, g), 0);
    return (usePound ? "#" : "") + (g | (b << 8) | (r << 16)).toString(16).padStart(6, '0');
  }

  themeSelect.addEventListener('change', () => {
    const id = themeSelect.value;
    const t = themes.find(x => x.id === id);
    if (t) applyTheme(t);
  });

  function parseNamesFromTextarea() {
    const lines = namesTextarea.value.split('\n').map(s => s.trim()).filter(s => s.length);
    return lines;
  }

  function updateWheelFromTextarea() {
    const names = parseNamesFromTextarea();
    wheel.setNames(names);
  }

  addBtn.addEventListener('click', () => {
    const v = nameInput.value.trim();
    if (!v) return;
    const cur = parseNamesFromTextarea();
    cur.push(v);
    namesTextarea.value = cur.join('\n');
    nameInput.value = '';
    updateWheelFromTextarea();
  });

  nameInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
      addBtn.click();
      e.preventDefault();
    }
  });

  namesTextarea.addEventListener('input', () => {
    updateWheelFromTextarea();
  });

  loadSampleBtn.addEventListener('click', () => {
    const sample = ['Alice','Bob','Charlie','Diana','Eva','Frank','George','Helen','Ivy','Jack'];
    namesTextarea.value = sample.join('\n');
    updateWheelFromTextarea();
  });

  clearBtn.addEventListener('click', () => {
    namesTextarea.value = '';
    updateWheelFromTextarea();
    resultDiv.classList.add('hidden');
  });

  importBtn.addEventListener('click', async () => {
    // prompt user for a newline separated list (simple)
    const data = prompt('Paste names (one per line):');
    if (data === null) return;
    namesTextarea.value = data.split('\n').map(s => s.trim()).filter(s => s).join('\n');
    updateWheelFromTextarea();
  });

  exportBtn.addEventListener('click', () => {
    const names = parseNamesFromTextarea();
    const blob = new Blob([names.join('\n')], {type: 'text/plain'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'names.txt';
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  });

  spinBtn.addEventListener('click', async () => {
    const names = parseNamesFromTextarea();
    if (names.length === 0) {
      alert('Please add at least one name.');
      return;
    }
    resultDiv.classList.add('hidden');
    spinBtn.disabled = true;
    spinBtn.textContent = 'Spinning...';
    // pick random index
    const idx = wheel.getRandomIndex();
    try {
      const winnerIndex = await wheel.spinToIndex(idx, { duration: 4500 });
      const winner = names[winnerIndex];
      resultDiv.textContent = `Winner: ${winner}`;
      resultDiv.classList.remove('hidden');
      spinBtn.textContent = 'SPIN';
      spinBtn.disabled = false;
    } catch (err) {
      console.error(err);
      spinBtn.textContent = 'SPIN';
      spinBtn.disabled = false;
    }
  });

  // initial sample
  namesTextarea.value = 'Alice\nBob\nCharlie\nDiana\nEva';
  updateWheelFromTextarea();
});
```

[2025-17-09 13:59:45 INFO] **[Update Codes]**

main.py updated.


```
'''

'''
--- Old
+++ New
@@ -1 +1,26 @@
-# None
+'''
+app.py
+DOCSTRING:
+Flask application that serves the wheel-of-names web app.
+Run: pip install flask
+Then: python app.py
+Access: http://127.0.0.1:5000/
+'''
+from flask import Flask, render_template
+import os
+def create_app():
+    """
+    Create and configure the Flask application.
+    """
+    app = Flask(__name__, static_folder='static', template_folder='templates')
+    @app.route('/')
+    def index():
+        """
+        Serve the main page.
+        """
+        return render_template('index.html')
+    return app
+if __name__ == '__main__':
+    app = create_app()
+    port = int(os.environ.get('PORT', 5000))
+    app.run(debug=True, host='0.0.0.0', port=port)
```

[2025-17-09 13:59:45 INFO] **[Update Codes]**

index.html updated.


```
'''

'''
--- Old
+++ New
@@ -1 +1,63 @@
-# None
+'''
+DOCSTRING:
+Main HTML page for the Wheel of Names app.
+Contains UI elements:
+- name input and list
+- canvas for wheel
+- theme selector
+- spin / clear / add buttons
+Includes JS files wheel.js and main.js for behavior.
+'''
+<!doctype html>
+<html lang="en">
+<head>
+  <meta charset="utf-8">
+  <meta name="viewport" content="width=device-width, initial-scale=1">
+  <title>Wheel of Names</title>
+  <link rel="stylesheet" href="{{ url_for('static', filename='css/styles.css') }}">
+</head>
+<body>
+  <div class="container">
+    <header>
+      <h1>Wheel of Names</h1>
+      <p>Enter names, choose a theme, and spin to pick a random winner.</p>
+    </header>
+    <main class="main-grid">
+      <section class="left-panel">
+        <div class="controls">
+          <label for="name-input">Add a name</label>
+          <div class="input-row">
+            <input id="name-input" type="text" placeholder="Enter name and press Add" autocomplete="off">
+            <button id="add-name">Add</button>
+          </div>
+          <label for="names-textarea">Names (one per line)</label>
+          <textarea id="names-textarea" placeholder="Alice\nBob\nCharlie"></textarea>
+          <div class="buttons-row">
+            <button id="load-sample">Load Sample</button>
+            <button id="clear-names">Clear</button>
+            <button id="import-names">Import</button>
+            <button id="export-names">Export</button>
+          </div>
+          <label for="theme-select">Theme</label>
+          <select id="theme-select"></select>
+          <div class="spin-controls">
+            <button id="spin-btn" class="spin">SPIN</button>
+            <div id="result" class="result hidden"></div>
+          </div>
+        </div>
+      </section>
+      <section class="right-panel">
+        <div class="wheel-wrapper" id="wheel-wrapper">
+          <canvas id="wheel-canvas" width="600" height="600"></canvas>
+          <div id="pointer">â–¼</div>
+        </div>
+      </section>
+    </main>
+    <footer>
+      <small>Built with Flask + Canvas. Themes available.</small>
+    </footer>
+  </div>
+  <script src="{{ url_for('static', filename='js/wheel.js') }}"></script>
+  <script src="{{ url_for('static', filename='js/main.js') }}"></script>
+</body>
+</html>
```

[2025-17-09 13:59:45 INFO] **[Update Codes]**

themes.json updated.


```
'''

'''
--- Old
+++ New
@@ -1 +1,44 @@
-# None
+'''
+DOCSTRING:
+List of themes available for the wheel.
+Each theme contains:
+- name: display name
+- bg: page background color
+- text: primary text color
+- accent: accent color used for pointer/button
+- colors: array of segment colors (will be cycled for segments)
+'''
+[
+  {
+    "id": "classic",
+    "name": "Classic",
+    "bg": "#ffffff",
+    "text": "#222222",
+    "accent": "#007bff",
+    "colors": ["#ffb3b3", "#ffd9b3", "#fff3b3", "#d9ffb3", "#b3ffd9", "#b3e6ff", "#c7b3ff", "#ffb3f2"]
+  },
+  {
+    "id": "dark",
+    "name": "Dark",
+    "bg": "#121212",
+    "text": "#f5f5f5",
+    "accent": "#ff6b6b",
+    "colors": ["#2e2e34", "#3a3a44", "#4a4a56", "#5a5a68", "#6a6a78", "#7a7a88"]
+  },
+  {
+    "id": "pastel",
+    "name": "Pastel",
+    "bg": "#f7f7ff",
+    "text": "#333333",
+    "accent": "#ff8c94",
+    "colors": ["#ffd1dc", "#fce1b4", "#e8ffd1", "#d1fff0", "#d1e7ff", "#e6d1ff"]
+  },
+  {
+    "id": "neon",
+    "name": "Neon",
+    "bg": "#0f0f13",
+    "text": "#eaff00",
+    "accent": "#00fff5",
+    "colors": ["#ff00ff", "#ff8c00", "#00ff00", "#00ffff", "#8c00ff", "#ff0066"]
+  }
+]
```

[2025-17-09 13:59:45 INFO] **[Update Codes]**

styles.css updated.


```
'''

'''
--- Old
+++ New
@@ -1 +1,136 @@
-# None
+'''
+DOCSTRING:
+Base CSS for the Wheel of Names app.
+Defines layout, basic theme variables, and responsive styles.
+'''
+:root{
+  --bg: #ffffff;
+  --text: #222222;
+  --accent: #007bff;
+  --panel-bg: #f6f8fa;
+}
+*{box-sizing:border-box}
+html,body{
+  height:100%;
+  margin:0;
+  font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
+  background: var(--bg);
+  color: var(--text);
+}
+.container{
+  max-width:1100px;
+  margin:24px auto;
+  padding:16px;
+}
+header{ text-align:center; margin-bottom:8px }
+h1{ margin:6px 0; font-size:28px }
+p{ margin:0; color:var(--text); opacity:0.8 }
+.main-grid{
+  display:grid;
+  grid-template-columns: 360px 1fr;
+  gap:20px;
+  align-items:start;
+  margin-top:18px;
+}
+.left-panel{
+  background:var(--panel-bg);
+  padding:14px;
+  border-radius:8px;
+  box-shadow:0 4px 8px rgba(0,0,0,0.04);
+}
+.left-panel label{ display:block; margin-top:8px; font-weight:600; margin-bottom:6px }
+.input-row{ display:flex; gap:8px }
+.input-row input[type="text"]{
+  flex:1;
+  padding:8px 10px;
+  border-radius:6px;
+  border:1px solid #ddd;
+}
+.input-row button{
+  padding:8px 12px;
+  border-radius:6px;
+  background:var(--accent);
+  color:white;
+  border:none;
+  cursor:pointer;
+}
+textarea{
+  width:100%;
+  min-height:160px;
+  padding:10px;
+  border-radius:8px;
+  border:1px solid #ddd;
+  resize:vertical;
+}
+.buttons-row{
+  display:flex;
+  gap:8px;
+  margin-top:8px;
+  flex-wrap:wrap;
+}
+.buttons-row button{
+  padding:8px 10px;
+  border-radius:6px;
+  border:1px solid #ccc;
+  background:transparent;
+  cursor:pointer;
+}
+.spin-controls{
+  display:flex;
+  gap:12px;
+  margin-top:16px;
+  align-items:center;
+}
+.spin{
+  padding:14px 24px;
+  background:var(--accent);
+  color:white;
+  font-weight:700;
+  border:none;
+  border-radius:10px;
+  cursor:pointer;
+  font-size:18px;
+}
+.result{
+  padding:10px 12px;
+  background:rgba(0,0,0,0.06);
+  border-radius:8px;
+}
+.hidden{ display:none }
+.right-panel{
+  display:flex;
+  align-items:center;
+  justify-content:center;
+  min-height:420px;
+}
+.wheel-wrapper{
+  position:relative;
+  width:600px;
+  height:600px;
+  display:flex;
+  align-items:center;
+  justify-content:center;
+  margin:auto;
+}
+#wheel-canvas{
+  border-radius:50%;
+  box-shadow: 0 12px 30px rgba(0,0,0,0.12);
+  background:transparent;
+}
+#wheel-wrapper #pointer{
+  position:absolute;
+  top:18px;
+  left:50%;
+  transform:translateX(-50%);
+  font-size:40px;
+  color:var(--accent);
+  text-shadow:0 2px 4px rgba(0,0,0,0.2);
+  pointer-events:none;
+}
+footer{ text-align:center; margin-top:16px; color:var(--text); opacity:0.7; }
+/* Responsive */
+@media (max-width:960px){
+  .main-grid{ grid-template-columns:1fr; }
+  .wheel-wrapper{ width:420px; height:420px; }
+  #wheel-canvas{ width:420px; height:420px; }
+}
```

[2025-17-09 13:59:45 INFO] **[Update Codes]**

wheel.js updated.


```
'''

'''
--- Old
+++ New
@@ -1 +1,169 @@
-# None
+/*
+'''
+DOCSTRING:
+wheel.js
+Contains a Wheel class that draws the wheel on a canvas and animates spins.
+Key methods:
+- constructor(canvas, options)
+- setNames(names)
+- setTheme(theme)
+- draw()
+- spinToIndex(index) -> Promise resolves with index after animation
+- getRandomIndex()
+'''
+*/
+class Wheel {
+  constructor(canvas, options = {}) {
+    this.canvas = canvas;
+    this.ctx = canvas.getContext('2d');
+    this.names = options.names || [];
+    this.colors = options.colors || ['#ffb3b3', '#ffd9b3', '#fff3b3', '#d9ffb3', '#b3ffd9', '#b3e6ff'];
+    this.textColor = options.textColor || '#222';
+    this.centerX = canvas.width / 2;
+    this.centerY = canvas.height / 2;
+    this.radius = Math.min(this.centerX, this.centerY) - 10;
+    this.rotation = 0; // degrees
+    this.font = options.font || '16px Inter, Arial';
+    this.onDraw = options.onDraw || function(){};
+    this._animating = false;
+    this.draw();
+  }
+  setNames(names) {
+    this.names = names.slice();
+    this.draw();
+  }
+  setTheme(theme) {
+    if (!theme) return;
+    if (theme.colors && theme.colors.length) this.colors = theme.colors.slice();
+    if (theme.text) this.textColor = theme.text;
+    this.draw();
+  }
+  clearCanvas() {
+    this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height);
+  }
+  draw() {
+    this.clearCanvas();
+    const ctx = this.ctx;
+    const n = Math.max(1, this.names.length);
+    const seg = 360 / n;
+    ctx.save();
+    ctx.translate(this.centerX, this.centerY);
+    ctx.rotate(this.degToRad(this.rotation));
+    // Draw segments
+    for (let i = 0; i < n; i++) {
+      const start = this.degToRad(i * seg);
+      const end = this.degToRad((i + 1) * seg);
+      ctx.beginPath();
+      ctx.moveTo(0,0);
+      ctx.arc(0,0,this.radius,start,end);
+      ctx.closePath();
+      ctx.fillStyle = this.colors[i % this.colors.length];
+      ctx.fill();
+      // stroke
+      ctx.lineWidth = 2;
+      ctx.strokeStyle = 'rgba(0,0,0,0.08)';
+      ctx.stroke();
+      // Draw label
+      ctx.save();
+      const angle = start + (end - start) / 2;
+      ctx.rotate(angle);
+      ctx.translate(this.radius * 0.55, 0);
+      ctx.rotate(Math.PI / 2);
+      ctx.fillStyle = this.textColor;
+      ctx.font = this.font;
+      ctx.textAlign = 'center';
+      ctx.textBaseline = 'middle';
+      const name = this.names[i] || '';
+      this.wrapText(ctx, name, 0, 0, this.radius * 0.35, 18);
+      ctx.restore();
+    }
+    ctx.restore();
+    // center circle
+    ctx.beginPath();
+    ctx.arc(this.centerX, this.centerY, this.radius * 0.12, 0, Math.PI*2);
+    ctx.fillStyle = '#ffffff';
+    ctx.fill();
+    ctx.lineWidth = 2;
+    ctx.strokeStyle = 'rgba(0,0,0,0.06)';
+    ctx.stroke();
+    this.onDraw();
+  }
+  wrapText(ctx, text, x, y, maxWidth, lineHeight) {
+    // A simple wrap for canvas text
+    const words = text.split(' ');
+    let line = '';
+    let yOffset = y;
+    for (let n = 0; n < words.length; n++) {
+      const testLine = line + words[n] + ' ';
+      const metrics = ctx.measureText(testLine);
+      const testWidth = metrics.width;
+      if (testWidth > maxWidth && n > 0) {
+        ctx.fillText(line.trim(), x, yOffset);
+        line = words[n] + ' ';
+        yOffset += lineHeight;
+      } else {
+        line = testLine;
+      }
+    }
+    ctx.fillText(line.trim(), x, yOffset);
+  }
+  degToRad(d) {
+    return d * Math.PI / 180;
+  }
+  radToDeg(r) {
+    return r * 180 / Math.PI;
+  }
+  getRandomIndex() {
+    if (!this.names.length) return 0;
+    return Math.floor(Math.random() * this.names.length);
+  }
+  // Spin such that the segment at `index` lands on the pointer at top.
+  spinToIndex(index, opts = {}) {
+    if (this._animating) return Promise.reject('Already animating');
+    if (!this.names.length) return Promise.reject('No names');
+    const n = this.names.length;
+    const segAngle = 360 / n;
+    // We want the center of target segment to be at angle 270deg (top of canvas - adjust if pointer is at top)
+    // Our rotation variable rotates the whole wheel clockwise in degrees.
+    // Compute the current rotation normalized
+    const normalized = ((this.rotation % 360) + 360) % 360;
+    // Calculate angle to place the segment center at top (270deg)
+    // Center of segment i is at angle: (i * segAngle + segAngle/2)
+    // We need rotation such that (centerAngle + rotation) mod 360 = 270
+    const centerAngle = index * segAngle + segAngle / 2;
+    // Solve for rotation target:
+    let targetRotation = 270 - centerAngle;
+    // Normalize to 0..360
+    targetRotation = ((targetRotation % 360) + 360) % 360;
+    // To produce multiple spins, add several full rotations:
+    const fullSpins = opts.fullSpins !== undefined ? opts.fullSpins : (3 + Math.floor(Math.random()*3)); // 3-5 spins
+    const endRotation = targetRotation + fullSpins * 360 + (opts.randomOffset || 0);
+    // We'll animate from current normalized to endRotation, taking into account wrap
+    const startRotation = normalized;
+    const delta = endRotation - startRotation;
+    const duration = opts.duration || 5000; // ms
+    const startTime = performance.now();
+    this._animating = true;
+    return new Promise((resolve) => {
+      const animate = (now) => {
+        const elapsed = now - startTime;
+        const t = Math.min(1, elapsed / duration);
+        // ease out cubic
+        const eased = 1 - Math.pow(1 - t, 3);
+        const current = startRotation + delta * eased;
+        this.rotation = current;
+        this.draw();
+        if (t < 1) {
+          requestAnimationFrame(animate);
+        } else {
+          this._animating = false;
+          // Normalize rotation to endRotation mod 360
+          this.rotation = ((endRotation % 360) + 360) % 360;
+          this.draw();
+          resolve(index);
+        }
+      };
+      requestAnimationFrame(animate);
+    });
+  }
+}
```

[2025-17-09 13:59:45 INFO] **[Update Codes]**

main.js updated.


```
'''

'''
--- Old
+++ New
@@ -1 +1,161 @@
-# None
+/*
+'''
+DOCSTRING:
+main.js
+Wires UI to the Wheel class:
+- loads themes.json
+- populates theme selector
+- reads names and updates wheel
+- handles spin logic and result display
+'''
+*/
+document.addEventListener('DOMContentLoaded', async () => {
+  const canvas = document.getElementById('wheel-canvas');
+  const nameInput = document.getElementById('name-input');
+  const addBtn = document.getElementById('add-name');
+  const namesTextarea = document.getElementById('names-textarea');
+  const spinBtn = document.getElementById('spin-btn');
+  const resultDiv = document.getElementById('result');
+  const themeSelect = document.getElementById('theme-select');
+  const loadSampleBtn = document.getElementById('load-sample');
+  const clearBtn = document.getElementById('clear-names');
+  const importBtn = document.getElementById('import-names');
+  const exportBtn = document.getElementById('export-names');
+  const wheel = new Wheel(canvas, { names: [], colors: ['#ffb3b3','#ffd9b3','#fff3b3','#d9ffb3'] });
+  let themes = [];
+  // Load themes.json
+  try {
+    const resp = await fetch('/static/themes.json');
+    themes = await resp.json();
+    themes.forEach(t => {
+      const opt = document.createElement('option');
+      opt.value = t.id;
+      opt.textContent = t.name;
+      themeSelect.appendChild(opt);
+    });
+    // apply first theme
+    applyTheme(themes[0]);
+    themeSelect.value = themes[0].id;
+  } catch (err) {
+    console.error('Failed to load themes:', err);
+  }
+  function applyTheme(theme) {
+    if (!theme) return;
+    document.documentElement.style.setProperty('--bg', theme.bg || '#fff');
+    document.documentElement.style.setProperty('--text', theme.text || '#222');
+    document.documentElement.style.setProperty('--accent', theme.accent || '#007bff');
+    // set panel bg slightly adjusted
+    let panelBg = theme.bg;
+    // simple luminance tweak
+    try {
+      panelBg = lightenOrDarkenColor(theme.bg || '#fff', 96);
+    } catch(e) {
+      panelBg = '#f6f8fa';
+    }
+    document.documentElement.style.setProperty('--panel-bg', panelBg);
+    wheel.setTheme({ colors: theme.colors || [], text: theme.text || '#222' });
+  }
+  function lightenOrDarkenColor(col, amt) {
+    // expects #rrggbb
+    let usePound = false;
+    if (col[0] === "#") {
+      col = col.slice(1);
+      usePound = true;
+    }
+    const num = parseInt(col,16);
+    let r = (num >> 16) + amt;
+    let b = ((num >> 8) & 0x00FF) + amt;
+    let g = (num & 0x0000FF) + amt;
+    r = Math.max(Math.min(255, r), 0);
+    b = Math.max(Math.min(255, b), 0);
+    g = Math.max(Math.min(255, g), 0);
+    return (usePound ? "#" : "") + (g | (b << 8) | (r << 16)).toString(16).padStart(6, '0');
+  }
+  themeSelect.addEventListener('change', () => {
+    const id = themeSelect.value;
+    const t = themes.find(x => x.id === id);
+    if (t) applyTheme(t);
+  });
+  function parseNamesFromTextarea() {
+    const lines = namesTextarea.value.split('\n').map(s => s.trim()).filter(s => s.length);
+    return lines;
+  }
+  function updateWheelFromTextarea() {
+    const names = parseNamesFromTextarea();
+    wheel.setNames(names);
+  }
+  addBtn.addEventListener('click', () => {
+    const v = nameInput.value.trim();
+    if (!v) return;
+    const cur = parseNamesFromTextarea();
+    cur.push(v);
+    namesTextarea.value = cur.join('\n');
+    nameInput.value = '';
+    updateWheelFromTextarea();
+  });
+  nameInput.addEventListener('keydown', (e) => {
+    if (e.key === 'Enter') {
+      addBtn.click();
+      e.preventDefault();
+    }
+  });
+  namesTextarea.addEventListener('input', () => {
+    updateWheelFromTextarea();
+  });
+  loadSampleBtn.addEventListener('click', () => {
+    const sample = ['Alice','Bob','Charlie','Diana','Eva','Frank','George','Helen','Ivy','Jack'];
+    namesTextarea.value = sample.join('\n');
+    updateWheelFromTextarea();
+  });
+  clearBtn.addEventListener('click', () => {
+    namesTextarea.value = '';
+    updateWheelFromTextarea();
+    resultDiv.classList.add('hidden');
+  });
+  importBtn.addEventListener('click', async () => {
+    // prompt user for a newline separated list (simple)
+    const data = prompt('Paste names (one per line):');
+    if (data === null) return;
+    namesTextarea.value = data.split('\n').map(s => s.trim()).filter(s => s).join('\n');
+    updateWheelFromTextarea();
+  });
+  exportBtn.addEventListener('click', () => {
+    const names = parseNamesFromTextarea();
+    const blob = new Blob([names.join('\n')], {type: 'text/plain'});
+    const url = URL.createObjectURL(blob);
+    const a = document.createElement('a');
+    a.href = url;
+    a.download = 'names.txt';
+    document.body.appendChild(a);
+    a.click();
+    a.remove();
+    URL.revokeObjectURL(url);
+  });
+  spinBtn.addEventListener('click', async () => {
+    const names = parseNamesFromTextarea();
+    if (names.length === 0) {
+      alert('Please add at least one name.');
+      return;
+    }
+    resultDiv.classList.add('hidden');
+    spinBtn.disabled = true;
+    spinBtn.textContent = 'Spinning...';
+    // pick random index
+    const idx = wheel.getRandomIndex();
+    try {
+      const winnerIndex = await wheel.spinToIndex(idx, { duration: 4500 });
+      const winner = names[winnerIndex];
+      resultDiv.textContent = `Winner: ${winner}`;
+      resultDiv.classList.remove('hidden');
+      spinBtn.textContent = 'SPIN';
+      spinBtn.disabled = false;
+    } catch (err) {
+      console.error(err);
+      spinBtn.textContent = 'SPIN';
+      spinBtn.disabled = false;
+    }
+  });
+  // initial sample
+  namesTextarea.value = 'Alice\nBob\nCharlie\nDiana\nEva';
+  updateWheelFromTextarea();
+});
```

[2025-17-09 13:59:45 INFO] **[Software Info]**:

 

ðŸ’°**cost**=$0.013092

ðŸ”¨**version_updates**=-1

ðŸ“ƒ**num_code_files**=1

ðŸž**num_png_files**=0

ðŸ“š**num_doc_files**=9

ðŸ“ƒ**code_lines**=26

ðŸ“‹**env_lines**=-1

ðŸ“’**manual_lines**=-1

ðŸ—£**num_utterances**=7

ðŸ¤”**num_self_reflections**=0

â“**num_prompt_tokens**=2069

â—**num_completion_tokens**=8038

ðŸŒŸ**num_total_tokens**=10107

[2025-17-09 13:59:45 INFO] **[Execute Detail]**

execute SimplePhase:[CodeComplete] in ComposedPhase:[CodeCompleteAll], cycle 1

[2025-17-09 13:59:45 INFO] **[Execute Detail]**

execute SimplePhase:[CodeReviewComment] in ComposedPhase:[CodeReview], cycle 1

[2025-17-09 13:59:45 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | [Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes.] |
| **need_reflect** | False |
| **assistant_role_name** | Code Reviewer |
| **user_role_name** | Programmer |
| **phase_prompt** | According to the new user's task and our software designs:  Task: "{task}". Modality: "{modality}". Programming Language: "{language}" Ideas: "{ideas}" Codes: "{codes}" As the {assistant_role}, to make the software directly operable without further coding, ChatDev have formulated the following regulations: 1) all referenced classes should be imported; 2) all methods should be implemented; 3) all methods need to have the necessary comments; 4) no potential bugs; 5) The entire project conforms to the tasks proposed by the user; 6) most importantly, do not only check the errors in the code, but also the logic of code. Make sure that user can interact with generated software without losing any feature in the requirement; Now, you should check the above regulations one by one and review the codes in detail, propose one comment with the highest priority about the codes, and give me instructions on how to fix. Tell me your comment with the highest priority and corresponding suggestions on revision. If the codes are perfect and you have no comment on them, return only one line like " Finished". |
| **phase_name** | CodeReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Code Reviewer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. You can help programmers to assess source codes for software troubleshooting, fix bugs to increase code quality and robustness, and offer proposals to improve the source codes. Here is a new customer's task: {task}. To complete the task, you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Programmer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. You can write/create computer software or applications by providing a specific programming language to the computer. You have extensive computing and coding experience in many varieties of programming languages and platforms, such as Python, Java, C, C++, HTML, CSS, JavaScript, XML, SQL, PHP, etc,. Here is a new customer's task: {task}. To complete the task, you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 1, 'task': '[Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes.]', 'modality': 'website', 'ideas': '', 'language': ' Python', 'codes': 'main.py\npython\n\'\'\'\napp.py\nDOCSTRING:\nFlask application that serves the wheel-of-names web app.\nRun: pip install flask\nThen: python app.py\nAccess: http://127.0.0.1:5000/\n\'\'\'\nfrom flask import Flask, render_template\nimport os\ndef create_app():\n    """\n    Create and configure the Flask application.\n    """\n    app = Flask(__name__, static_folder=\'static\', template_folder=\'templates\')\n    @app.route(\'/\')\n    def index():\n        """\n        Serve the main page.\n        """\n        return render_template(\'index.html\')\n    return app\nif __name__ == \'__main__\':\n    app = create_app()\n    port = int(os.environ.get(\'PORT\', 5000))\n    app.run(debug=True, host=\'0.0.0.0\', port=port)\n\n\nindex.html\nhtml\n\'\'\'\nDOCSTRING:\nMain HTML page for the Wheel of Names app.\nContains UI elements:\n- name input and list\n- canvas for wheel\n- theme selector\n- spin / clear / add buttons\nIncludes JS files wheel.js and main.js for behavior.\n\'\'\'\n&lt;!doctype html&gt;\n&lt;html lang="en"&gt;\n&lt;head&gt;\n  &lt;meta charset="utf-8"&gt;\n  &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;\n  &lt;title&gt;Wheel of Names&lt;/title&gt;\n  &lt;link rel="stylesheet" href="{{ url_for(\'static\', filename=\'css/styles.css\') }}"&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div class="container"&gt;\n    &lt;header&gt;\n      &lt;h1&gt;Wheel of Names&lt;/h1&gt;\n      &lt;p&gt;Enter names, choose a theme, and spin to pick a random winner.&lt;/p&gt;\n    &lt;/header&gt;\n    &lt;main class="main-grid"&gt;\n      &lt;section class="left-panel"&gt;\n        &lt;div class="controls"&gt;\n          &lt;label for="name-input"&gt;Add a name&lt;/label&gt;\n          &lt;div class="input-row"&gt;\n            &lt;input id="name-input" type="text" placeholder="Enter name and press Add" autocomplete="off"&gt;\n            &lt;button id="add-name"&gt;Add&lt;/button&gt;\n          &lt;/div&gt;\n          &lt;label for="names-textarea"&gt;Names (one per line)&lt;/label&gt;\n          &lt;textarea id="names-textarea" placeholder="Alice\\nBob\\nCharlie"&gt;&lt;/textarea&gt;\n          &lt;div class="buttons-row"&gt;\n            &lt;button id="load-sample"&gt;Load Sample&lt;/button&gt;\n            &lt;button id="clear-names"&gt;Clear&lt;/button&gt;\n            &lt;button id="import-names"&gt;Import&lt;/button&gt;\n            &lt;button id="export-names"&gt;Export&lt;/button&gt;\n          &lt;/div&gt;\n          &lt;label for="theme-select"&gt;Theme&lt;/label&gt;\n          &lt;select id="theme-select"&gt;&lt;/select&gt;\n          &lt;div class="spin-controls"&gt;\n            &lt;button id="spin-btn" class="spin"&gt;SPIN&lt;/button&gt;\n            &lt;div id="result" class="result hidden"&gt;&lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      &lt;/section&gt;\n      &lt;section class="right-panel"&gt;\n        &lt;div class="wheel-wrapper" id="wheel-wrapper"&gt;\n          &lt;canvas id="wheel-canvas" width="600" height="600"&gt;&lt;/canvas&gt;\n          &lt;div id="pointer"&gt;â–¼&lt;/div&gt;\n        &lt;/div&gt;\n      &lt;/section&gt;\n    &lt;/main&gt;\n    &lt;footer&gt;\n      &lt;small&gt;Built with Flask + Canvas. Themes available.&lt;/small&gt;\n    &lt;/footer&gt;\n  &lt;/div&gt;\n  &lt;script src="{{ url_for(\'static\', filename=\'js/wheel.js\') }}"&gt;&lt;/script&gt;\n  &lt;script src="{{ url_for(\'static\', filename=\'js/main.js\') }}"&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\n\nthemes.json\njson\n\'\'\'\nDOCSTRING:\nList of themes available for the wheel.\nEach theme contains:\n- name: display name\n- bg: page background color\n- text: primary text color\n- accent: accent color used for pointer/button\n- colors: array of segment colors (will be cycled for segments)\n\'\'\'\n[\n  {\n    "id": "classic",\n    "name": "Classic",\n    "bg": "#ffffff",\n    "text": "#222222",\n    "accent": "#007bff",\n    "colors": ["#ffb3b3", "#ffd9b3", "#fff3b3", "#d9ffb3", "#b3ffd9", "#b3e6ff", "#c7b3ff", "#ffb3f2"]\n  },\n  {\n    "id": "dark",\n    "name": "Dark",\n    "bg": "#121212",\n    "text": "#f5f5f5",\n    "accent": "#ff6b6b",\n    "colors": ["#2e2e34", "#3a3a44", "#4a4a56", "#5a5a68", "#6a6a78", "#7a7a88"]\n  },\n  {\n    "id": "pastel",\n    "name": "Pastel",\n    "bg": "#f7f7ff",\n    "text": "#333333",\n    "accent": "#ff8c94",\n    "colors": ["#ffd1dc", "#fce1b4", "#e8ffd1", "#d1fff0", "#d1e7ff", "#e6d1ff"]\n  },\n  {\n    "id": "neon",\n    "name": "Neon",\n    "bg": "#0f0f13",\n    "text": "#eaff00",\n    "accent": "#00fff5",\n    "colors": ["#ff00ff", "#ff8c00", "#00ff00", "#00ffff", "#8c00ff", "#ff0066"]\n  }\n]\n\n\nstyles.css\ncss\n\'\'\'\nDOCSTRING:\nBase CSS for the Wheel of Names app.\nDefines layout, basic theme variables, and responsive styles.\n\'\'\'\n:root{\n  --bg: #ffffff;\n  --text: #222222;\n  --accent: #007bff;\n  --panel-bg: #f6f8fa;\n}\n*{box-sizing:border-box}\nhtml,body{\n  height:100%;\n  margin:0;\n  font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;\n  background: var(--bg);\n  color: var(--text);\n}\n.container{\n  max-width:1100px;\n  margin:24px auto;\n  padding:16px;\n}\nheader{ text-align:center; margin-bottom:8px }\nh1{ margin:6px 0; font-size:28px }\np{ margin:0; color:var(--text); opacity:0.8 }\n.main-grid{\n  display:grid;\n  grid-template-columns: 360px 1fr;\n  gap:20px;\n  align-items:start;\n  margin-top:18px;\n}\n.left-panel{\n  background:var(--panel-bg);\n  padding:14px;\n  border-radius:8px;\n  box-shadow:0 4px 8px rgba(0,0,0,0.04);\n}\n.left-panel label{ display:block; margin-top:8px; font-weight:600; margin-bottom:6px }\n.input-row{ display:flex; gap:8px }\n.input-row input[type="text"]{\n  flex:1;\n  padding:8px 10px;\n  border-radius:6px;\n  border:1px solid #ddd;\n}\n.input-row button{\n  padding:8px 12px;\n  border-radius:6px;\n  background:var(--accent);\n  color:white;\n  border:none;\n  cursor:pointer;\n}\ntextarea{\n  width:100%;\n  min-height:160px;\n  padding:10px;\n  border-radius:8px;\n  border:1px solid #ddd;\n  resize:vertical;\n}\n.buttons-row{\n  display:flex;\n  gap:8px;\n  margin-top:8px;\n  flex-wrap:wrap;\n}\n.buttons-row button{\n  padding:8px 10px;\n  border-radius:6px;\n  border:1px solid #ccc;\n  background:transparent;\n  cursor:pointer;\n}\n.spin-controls{\n  display:flex;\n  gap:12px;\n  margin-top:16px;\n  align-items:center;\n}\n.spin{\n  padding:14px 24px;\n  background:var(--accent);\n  color:white;\n  font-weight:700;\n  border:none;\n  border-radius:10px;\n  cursor:pointer;\n  font-size:18px;\n}\n.result{\n  padding:10px 12px;\n  background:rgba(0,0,0,0.06);\n  border-radius:8px;\n}\n.hidden{ display:none }\n.right-panel{\n  display:flex;\n  align-items:center;\n  justify-content:center;\n  min-height:420px;\n}\n.wheel-wrapper{\n  position:relative;\n  width:600px;\n  height:600px;\n  display:flex;\n  align-items:center;\n  justify-content:center;\n  margin:auto;\n}\n#wheel-canvas{\n  border-radius:50%;\n  box-shadow: 0 12px 30px rgba(0,0,0,0.12);\n  background:transparent;\n}\n#wheel-wrapper #pointer{\n  position:absolute;\n  top:18px;\n  left:50%;\n  transform:translateX(-50%);\n  font-size:40px;\n  color:var(--accent);\n  text-shadow:0 2px 4px rgba(0,0,0,0.2);\n  pointer-events:none;\n}\nfooter{ text-align:center; margin-top:16px; color:var(--text); opacity:0.7; }\n/* Responsive */\n@media (max-width:960px){\n  .main-grid{ grid-template-columns:1fr; }\n  .wheel-wrapper{ width:420px; height:420px; }\n  #wheel-canvas{ width:420px; height:420px; }\n}\n\n\nwheel.js\njs\n/*\n\'\'\'\nDOCSTRING:\nwheel.js\nContains a Wheel class that draws the wheel on a canvas and animates spins.\nKey methods:\n- constructor(canvas, options)\n- setNames(names)\n- setTheme(theme)\n- draw()\n- spinToIndex(index) -&gt; Promise resolves with index after animation\n- getRandomIndex()\n\'\'\'\n*/\nclass Wheel {\n  constructor(canvas, options = {}) {\n    this.canvas = canvas;\n    this.ctx = canvas.getContext(\'2d\');\n    this.names = options.names || [];\n    this.colors = options.colors || [\'#ffb3b3\', \'#ffd9b3\', \'#fff3b3\', \'#d9ffb3\', \'#b3ffd9\', \'#b3e6ff\'];\n    this.textColor = options.textColor || \'#222\';\n    this.centerX = canvas.width / 2;\n    this.centerY = canvas.height / 2;\n    this.radius = Math.min(this.centerX, this.centerY) - 10;\n    this.rotation = 0; // degrees\n    this.font = options.font || \'16px Inter, Arial\';\n    this.onDraw = options.onDraw || function(){};\n    this._animating = false;\n    this.draw();\n  }\n  setNames(names) {\n    this.names = names.slice();\n    this.draw();\n  }\n  setTheme(theme) {\n    if (!theme) return;\n    if (theme.colors &amp;&amp; theme.colors.length) this.colors = theme.colors.slice();\n    if (theme.text) this.textColor = theme.text;\n    this.draw();\n  }\n  clearCanvas() {\n    this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height);\n  }\n  draw() {\n    this.clearCanvas();\n    const ctx = this.ctx;\n    const n = Math.max(1, this.names.length);\n    const seg = 360 / n;\n    ctx.save();\n    ctx.translate(this.centerX, this.centerY);\n    ctx.rotate(this.degToRad(this.rotation));\n    // Draw segments\n    for (let i = 0; i &lt; n; i++) {\n      const start = this.degToRad(i * seg);\n      const end = this.degToRad((i + 1) * seg);\n      ctx.beginPath();\n      ctx.moveTo(0,0);\n      ctx.arc(0,0,this.radius,start,end);\n      ctx.closePath();\n      ctx.fillStyle = this.colors[i % this.colors.length];\n      ctx.fill();\n      // stroke\n      ctx.lineWidth = 2;\n      ctx.strokeStyle = \'rgba(0,0,0,0.08)\';\n      ctx.stroke();\n      // Draw label\n      ctx.save();\n      const angle = start + (end - start) / 2;\n      ctx.rotate(angle);\n      ctx.translate(this.radius * 0.55, 0);\n      ctx.rotate(Math.PI / 2);\n      ctx.fillStyle = this.textColor;\n      ctx.font = this.font;\n      ctx.textAlign = \'center\';\n      ctx.textBaseline = \'middle\';\n      const name = this.names[i] || \'\';\n      this.wrapText(ctx, name, 0, 0, this.radius * 0.35, 18);\n      ctx.restore();\n    }\n    ctx.restore();\n    // center circle\n    ctx.beginPath();\n    ctx.arc(this.centerX, this.centerY, this.radius * 0.12, 0, Math.PI*2);\n    ctx.fillStyle = \'#ffffff\';\n    ctx.fill();\n    ctx.lineWidth = 2;\n    ctx.strokeStyle = \'rgba(0,0,0,0.06)\';\n    ctx.stroke();\n    this.onDraw();\n  }\n  wrapText(ctx, text, x, y, maxWidth, lineHeight) {\n    // A simple wrap for canvas text\n    const words = text.split(\' \');\n    let line = \'\';\n    let yOffset = y;\n    for (let n = 0; n &lt; words.length; n++) {\n      const testLine = line + words[n] + \' \';\n      const metrics = ctx.measureText(testLine);\n      const testWidth = metrics.width;\n      if (testWidth &gt; maxWidth &amp;&amp; n &gt; 0) {\n        ctx.fillText(line.trim(), x, yOffset);\n        line = words[n] + \' \';\n        yOffset += lineHeight;\n      } else {\n        line = testLine;\n      }\n    }\n    ctx.fillText(line.trim(), x, yOffset);\n  }\n  degToRad(d) {\n    return d * Math.PI / 180;\n  }\n  radToDeg(r) {\n    return r * 180 / Math.PI;\n  }\n  getRandomIndex() {\n    if (!this.names.length) return 0;\n    return Math.floor(Math.random() * this.names.length);\n  }\n  // Spin such that the segment at `index` lands on the pointer at top.\n  spinToIndex(index, opts = {}) {\n    if (this._animating) return Promise.reject(\'Already animating\');\n    if (!this.names.length) return Promise.reject(\'No names\');\n    const n = this.names.length;\n    const segAngle = 360 / n;\n    // We want the center of target segment to be at angle 270deg (top of canvas - adjust if pointer is at top)\n    // Our rotation variable rotates the whole wheel clockwise in degrees.\n    // Compute the current rotation normalized\n    const normalized = ((this.rotation % 360) + 360) % 360;\n    // Calculate angle to place the segment center at top (270deg)\n    // Center of segment i is at angle: (i * segAngle + segAngle/2)\n    // We need rotation such that (centerAngle + rotation) mod 360 = 270\n    const centerAngle = index * segAngle + segAngle / 2;\n    // Solve for rotation target:\n    let targetRotation = 270 - centerAngle;\n    // Normalize to 0..360\n    targetRotation = ((targetRotation % 360) + 360) % 360;\n    // To produce multiple spins, add several full rotations:\n    const fullSpins = opts.fullSpins !== undefined ? opts.fullSpins : (3 + Math.floor(Math.random()*3)); // 3-5 spins\n    const endRotation = targetRotation + fullSpins * 360 + (opts.randomOffset || 0);\n    // We\'ll animate from current normalized to endRotation, taking into account wrap\n    const startRotation = normalized;\n    const delta = endRotation - startRotation;\n    const duration = opts.duration || 5000; // ms\n    const startTime = performance.now();\n    this._animating = true;\n    return new Promise((resolve) =&gt; {\n      const animate = (now) =&gt; {\n        const elapsed = now - startTime;\n        const t = Math.min(1, elapsed / duration);\n        // ease out cubic\n        const eased = 1 - Math.pow(1 - t, 3);\n        const current = startRotation + delta * eased;\n        this.rotation = current;\n        this.draw();\n        if (t &lt; 1) {\n          requestAnimationFrame(animate);\n        } else {\n          this._animating = false;\n          // Normalize rotation to endRotation mod 360\n          this.rotation = ((endRotation % 360) + 360) % 360;\n          this.draw();\n          resolve(index);\n        }\n      };\n      requestAnimationFrame(animate);\n    });\n  }\n}\n\n\nmain.js\njs\n/*\n\'\'\'\nDOCSTRING:\nmain.js\nWires UI to the Wheel class:\n- loads themes.json\n- populates theme selector\n- reads names and updates wheel\n- handles spin logic and result display\n\'\'\'\n*/\ndocument.addEventListener(\'DOMContentLoaded\', async () =&gt; {\n  const canvas = document.getElementById(\'wheel-canvas\');\n  const nameInput = document.getElementById(\'name-input\');\n  const addBtn = document.getElementById(\'add-name\');\n  const namesTextarea = document.getElementById(\'names-textarea\');\n  const spinBtn = document.getElementById(\'spin-btn\');\n  const resultDiv = document.getElementById(\'result\');\n  const themeSelect = document.getElementById(\'theme-select\');\n  const loadSampleBtn = document.getElementById(\'load-sample\');\n  const clearBtn = document.getElementById(\'clear-names\');\n  const importBtn = document.getElementById(\'import-names\');\n  const exportBtn = document.getElementById(\'export-names\');\n  const wheel = new Wheel(canvas, { names: [], colors: [\'#ffb3b3\',\'#ffd9b3\',\'#fff3b3\',\'#d9ffb3\'] });\n  let themes = [];\n  // Load themes.json\n  try {\n    const resp = await fetch(\'/static/themes.json\');\n    themes = await resp.json();\n    themes.forEach(t =&gt; {\n      const opt = document.createElement(\'option\');\n      opt.value = t.id;\n      opt.textContent = t.name;\n      themeSelect.appendChild(opt);\n    });\n    // apply first theme\n    applyTheme(themes[0]);\n    themeSelect.value = themes[0].id;\n  } catch (err) {\n    console.error(\'Failed to load themes:\', err);\n  }\n  function applyTheme(theme) {\n    if (!theme) return;\n    document.documentElement.style.setProperty(\'--bg\', theme.bg || \'#fff\');\n    document.documentElement.style.setProperty(\'--text\', theme.text || \'#222\');\n    document.documentElement.style.setProperty(\'--accent\', theme.accent || \'#007bff\');\n    // set panel bg slightly adjusted\n    let panelBg = theme.bg;\n    // simple luminance tweak\n    try {\n      panelBg = lightenOrDarkenColor(theme.bg || \'#fff\', 96);\n    } catch(e) {\n      panelBg = \'#f6f8fa\';\n    }\n    document.documentElement.style.setProperty(\'--panel-bg\', panelBg);\n    wheel.setTheme({ colors: theme.colors || [], text: theme.text || \'#222\' });\n  }\n  function lightenOrDarkenColor(col, amt) {\n    // expects #rrggbb\n    let usePound = false;\n    if (col[0] === "#") {\n      col = col.slice(1);\n      usePound = true;\n    }\n    const num = parseInt(col,16);\n    let r = (num &gt;&gt; 16) + amt;\n    let b = ((num &gt;&gt; 8) &amp; 0x00FF) + amt;\n    let g = (num &amp; 0x0000FF) + amt;\n    r = Math.max(Math.min(255, r), 0);\n    b = Math.max(Math.min(255, b), 0);\n    g = Math.max(Math.min(255, g), 0);\n    return (usePound ? "#" : "") + (g | (b &lt;&lt; 8) | (r &lt;&lt; 16)).toString(16).padStart(6, \'0\');\n  }\n  themeSelect.addEventListener(\'change\', () =&gt; {\n    const id = themeSelect.value;\n    const t = themes.find(x =&gt; x.id === id);\n    if (t) applyTheme(t);\n  });\n  function parseNamesFromTextarea() {\n    const lines = namesTextarea.value.split(\'\\n\').map(s =&gt; s.trim()).filter(s =&gt; s.length);\n    return lines;\n  }\n  function updateWheelFromTextarea() {\n    const names = parseNamesFromTextarea();\n    wheel.setNames(names);\n  }\n  addBtn.addEventListener(\'click\', () =&gt; {\n    const v = nameInput.value.trim();\n    if (!v) return;\n    const cur = parseNamesFromTextarea();\n    cur.push(v);\n    namesTextarea.value = cur.join(\'\\n\');\n    nameInput.value = \'\';\n    updateWheelFromTextarea();\n  });\n  nameInput.addEventListener(\'keydown\', (e) =&gt; {\n    if (e.key === \'Enter\') {\n      addBtn.click();\n      e.preventDefault();\n    }\n  });\n  namesTextarea.addEventListener(\'input\', () =&gt; {\n    updateWheelFromTextarea();\n  });\n  loadSampleBtn.addEventListener(\'click\', () =&gt; {\n    const sample = [\'Alice\',\'Bob\',\'Charlie\',\'Diana\',\'Eva\',\'Frank\',\'George\',\'Helen\',\'Ivy\',\'Jack\'];\n    namesTextarea.value = sample.join(\'\\n\');\n    updateWheelFromTextarea();\n  });\n  clearBtn.addEventListener(\'click\', () =&gt; {\n    namesTextarea.value = \'\';\n    updateWheelFromTextarea();\n    resultDiv.classList.add(\'hidden\');\n  });\n  importBtn.addEventListener(\'click\', async () =&gt; {\n    // prompt user for a newline separated list (simple)\n    const data = prompt(\'Paste names (one per line):\');\n    if (data === null) return;\n    namesTextarea.value = data.split(\'\\n\').map(s =&gt; s.trim()).filter(s =&gt; s).join(\'\\n\');\n    updateWheelFromTextarea();\n  });\n  exportBtn.addEventListener(\'click\', () =&gt; {\n    const names = parseNamesFromTextarea();\n    const blob = new Blob([names.join(\'\\n\')], {type: \'text/plain\'});\n    const url = URL.createObjectURL(blob);\n    const a = document.createElement(\'a\');\n    a.href = url;\n    a.download = \'names.txt\';\n    document.body.appendChild(a);\n    a.click();\n    a.remove();\n    URL.revokeObjectURL(url);\n  });\n  spinBtn.addEventListener(\'click\', async () =&gt; {\n    const names = parseNamesFromTextarea();\n    if (names.length === 0) {\n      alert(\'Please add at least one name.\');\n      return;\n    }\n    resultDiv.classList.add(\'hidden\');\n    spinBtn.disabled = true;\n    spinBtn.textContent = \'Spinning...\';\n    // pick random index\n    const idx = wheel.getRandomIndex();\n    try {\n      const winnerIndex = await wheel.spinToIndex(idx, { duration: 4500 });\n      const winner = names[winnerIndex];\n      resultDiv.textContent = `Winner: ${winner}`;\n      resultDiv.classList.remove(\'hidden\');\n      spinBtn.textContent = \'SPIN\';\n      spinBtn.disabled = false;\n    } catch (err) {\n      console.error(err);\n      spinBtn.textContent = \'SPIN\';\n      spinBtn.disabled = false;\n    }\n  });\n  // initial sample\n  namesTextarea.value = \'Alice\\nBob\\nCharlie\\nDiana\\nEva\';\n  updateWheelFromTextarea();\n});\n\n\n', 'images': ''} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_3_5_TURBO |

[2025-17-09 13:59:45 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Code Reviewer |
| **user_role_name** | Programmer |
| **assistant_role_prompt** | {chatdev_prompt} You are Code Reviewer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. You can help programmers to assess source codes for software troubleshooting, fix bugs to increase code quality and robustness, and offer proposals to improve the source codes. Here is a new customer's task: {task}. To complete the task, you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Programmer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. You can write/create computer software or applications by providing a specific programming language to the computer. You have extensive computing and coding experience in many varieties of programming languages and platforms, such as Python, Java, C, C++, HTML, CSS, JavaScript, XML, SQL, PHP, etc,. Here is a new customer's task: {task}. To complete the task, you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **task_prompt** | [Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes.] |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_3_5_TURBO |
| **background_prompt** | ChatDev is a software company powered by multiple intelligent agents, such as chief executive officer, chief human resources officer, chief product officer, chief technology officer, etc, with a multi-agent organizational structure and the mission of 'changing the digital world through programming'. |

[2025-17-09 13:59:45 INFO] Programmer: **[Start Chat]**

[ChatDev is a software company powered by multiple intelligent agents, such as chief executive officer, chief human resources officer, chief product officer, chief technology officer, etc, with a multi-agent organizational structure and the mission of 'changing the digital world through programming'.
You are Code Reviewer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer.
You can help programmers to assess source codes for software troubleshooting, fix bugs to increase code quality and robustness, and offer proposals to improve the source codes.
Here is a new customer's task: [Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes.].
To complete the task, you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]

According to the new user's task and our software designs: 
Task: "[Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes.]".
Modality: "website".
Programming Language: " Python"
Ideas: ""
Codes:
"main.py
```python
'''
app.py
DOCSTRING:
Flask application that serves the wheel-of-names web app.
Run: pip install flask
Then: python app.py
Access: http://127.0.0.1:5000/
'''
from flask import Flask, render_template
import os
def create_app():
    """
    Create and configure the Flask application.
    """
    app = Flask(__name__, static_folder='static', template_folder='templates')
    @app.route('/')
    def index():
        """
        Serve the main page.
        """
        return render_template('index.html')
    return app
if __name__ == '__main__':
    app = create_app()
    port = int(os.environ.get('PORT', 5000))
    app.run(debug=True, host='0.0.0.0', port=port)
```

index.html
```html
'''
DOCSTRING:
Main HTML page for the Wheel of Names app.
Contains UI elements:
- name input and list
- canvas for wheel
- theme selector
- spin / clear / add buttons
Includes JS files wheel.js and main.js for behavior.
'''
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Wheel of Names</title>
  <link rel="stylesheet" href="{{ url_for('static', filename='css/styles.css') }}">
</head>
<body>
  <div class="container">
    <header>
      <h1>Wheel of Names</h1>
      <p>Enter names, choose a theme, and spin to pick a random winner.</p>
    </header>
    <main class="main-grid">
      <section class="left-panel">
        <div class="controls">
          <label for="name-input">Add a name</label>
          <div class="input-row">
            <input id="name-input" type="text" placeholder="Enter name and press Add" autocomplete="off">
            <button id="add-name">Add</button>
          </div>
          <label for="names-textarea">Names (one per line)</label>
          <textarea id="names-textarea" placeholder="Alice\nBob\nCharlie"></textarea>
          <div class="buttons-row">
            <button id="load-sample">Load Sample</button>
            <button id="clear-names">Clear</button>
            <button id="import-names">Import</button>
            <button id="export-names">Export</button>
          </div>
          <label for="theme-select">Theme</label>
          <select id="theme-select"></select>
          <div class="spin-controls">
            <button id="spin-btn" class="spin">SPIN</button>
            <div id="result" class="result hidden"></div>
          </div>
        </div>
      </section>
      <section class="right-panel">
        <div class="wheel-wrapper" id="wheel-wrapper">
          <canvas id="wheel-canvas" width="600" height="600"></canvas>
          <div id="pointer">â–¼</div>
        </div>
      </section>
    </main>
    <footer>
      <small>Built with Flask + Canvas. Themes available.</small>
    </footer>
  </div>
  <script src="{{ url_for('static', filename='js/wheel.js') }}"></script>
  <script src="{{ url_for('static', filename='js/main.js') }}"></script>
</body>
</html>
```

themes.json
```json
'''
DOCSTRING:
List of themes available for the wheel.
Each theme contains:
- name: display name
- bg: page background color
- text: primary text color
- accent: accent color used for pointer/button
- colors: array of segment colors (will be cycled for segments)
'''
[
  {
    "id": "classic",
    "name": "Classic",
    "bg": "#ffffff",
    "text": "#222222",
    "accent": "#007bff",
    "colors": ["#ffb3b3", "#ffd9b3", "#fff3b3", "#d9ffb3", "#b3ffd9", "#b3e6ff", "#c7b3ff", "#ffb3f2"]
  },
  {
    "id": "dark",
    "name": "Dark",
    "bg": "#121212",
    "text": "#f5f5f5",
    "accent": "#ff6b6b",
    "colors": ["#2e2e34", "#3a3a44", "#4a4a56", "#5a5a68", "#6a6a78", "#7a7a88"]
  },
  {
    "id": "pastel",
    "name": "Pastel",
    "bg": "#f7f7ff",
    "text": "#333333",
    "accent": "#ff8c94",
    "colors": ["#ffd1dc", "#fce1b4", "#e8ffd1", "#d1fff0", "#d1e7ff", "#e6d1ff"]
  },
  {
    "id": "neon",
    "name": "Neon",
    "bg": "#0f0f13",
    "text": "#eaff00",
    "accent": "#00fff5",
    "colors": ["#ff00ff", "#ff8c00", "#00ff00", "#00ffff", "#8c00ff", "#ff0066"]
  }
]
```

styles.css
```css
'''
DOCSTRING:
Base CSS for the Wheel of Names app.
Defines layout, basic theme variables, and responsive styles.
'''
:root{
  --bg: #ffffff;
  --text: #222222;
  --accent: #007bff;
  --panel-bg: #f6f8fa;
}
*{box-sizing:border-box}
html,body{
  height:100%;
  margin:0;
  font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
  background: var(--bg);
  color: var(--text);
}
.container{
  max-width:1100px;
  margin:24px auto;
  padding:16px;
}
header{ text-align:center; margin-bottom:8px }
h1{ margin:6px 0; font-size:28px }
p{ margin:0; color:var(--text); opacity:0.8 }
.main-grid{
  display:grid;
  grid-template-columns: 360px 1fr;
  gap:20px;
  align-items:start;
  margin-top:18px;
}
.left-panel{
  background:var(--panel-bg);
  padding:14px;
  border-radius:8px;
  box-shadow:0 4px 8px rgba(0,0,0,0.04);
}
.left-panel label{ display:block; margin-top:8px; font-weight:600; margin-bottom:6px }
.input-row{ display:flex; gap:8px }
.input-row input[type="text"]{
  flex:1;
  padding:8px 10px;
  border-radius:6px;
  border:1px solid #ddd;
}
.input-row button{
  padding:8px 12px;
  border-radius:6px;
  background:var(--accent);
  color:white;
  border:none;
  cursor:pointer;
}
textarea{
  width:100%;
  min-height:160px;
  padding:10px;
  border-radius:8px;
  border:1px solid #ddd;
  resize:vertical;
}
.buttons-row{
  display:flex;
  gap:8px;
  margin-top:8px;
  flex-wrap:wrap;
}
.buttons-row button{
  padding:8px 10px;
  border-radius:6px;
  border:1px solid #ccc;
  background:transparent;
  cursor:pointer;
}
.spin-controls{
  display:flex;
  gap:12px;
  margin-top:16px;
  align-items:center;
}
.spin{
  padding:14px 24px;
  background:var(--accent);
  color:white;
  font-weight:700;
  border:none;
  border-radius:10px;
  cursor:pointer;
  font-size:18px;
}
.result{
  padding:10px 12px;
  background:rgba(0,0,0,0.06);
  border-radius:8px;
}
.hidden{ display:none }
.right-panel{
  display:flex;
  align-items:center;
  justify-content:center;
  min-height:420px;
}
.wheel-wrapper{
  position:relative;
  width:600px;
  height:600px;
  display:flex;
  align-items:center;
  justify-content:center;
  margin:auto;
}
#wheel-canvas{
  border-radius:50%;
  box-shadow: 0 12px 30px rgba(0,0,0,0.12);
  background:transparent;
}
#wheel-wrapper #pointer{
  position:absolute;
  top:18px;
  left:50%;
  transform:translateX(-50%);
  font-size:40px;
  color:var(--accent);
  text-shadow:0 2px 4px rgba(0,0,0,0.2);
  pointer-events:none;
}
footer{ text-align:center; margin-top:16px; color:var(--text); opacity:0.7; }
/* Responsive */
@media (max-width:960px){
  .main-grid{ grid-template-columns:1fr; }
  .wheel-wrapper{ width:420px; height:420px; }
  #wheel-canvas{ width:420px; height:420px; }
}
```

wheel.js
```js
/*
'''
DOCSTRING:
wheel.js
Contains a Wheel class that draws the wheel on a canvas and animates spins.
Key methods:
- constructor(canvas, options)
- setNames(names)
- setTheme(theme)
- draw()
- spinToIndex(index) -> Promise resolves with index after animation
- getRandomIndex()
'''
*/
class Wheel {
  constructor(canvas, options = {}) {
    this.canvas = canvas;
    this.ctx = canvas.getContext('2d');
    this.names = options.names || [];
    this.colors = options.colors || ['#ffb3b3', '#ffd9b3', '#fff3b3', '#d9ffb3', '#b3ffd9', '#b3e6ff'];
    this.textColor = options.textColor || '#222';
    this.centerX = canvas.width / 2;
    this.centerY = canvas.height / 2;
    this.radius = Math.min(this.centerX, this.centerY) - 10;
    this.rotation = 0; // degrees
    this.font = options.font || '16px Inter, Arial';
    this.onDraw = options.onDraw || function(){};
    this._animating = false;
    this.draw();
  }
  setNames(names) {
    this.names = names.slice();
    this.draw();
  }
  setTheme(theme) {
    if (!theme) return;
    if (theme.colors && theme.colors.length) this.colors = theme.colors.slice();
    if (theme.text) this.textColor = theme.text;
    this.draw();
  }
  clearCanvas() {
    this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height);
  }
  draw() {
    this.clearCanvas();
    const ctx = this.ctx;
    const n = Math.max(1, this.names.length);
    const seg = 360 / n;
    ctx.save();
    ctx.translate(this.centerX, this.centerY);
    ctx.rotate(this.degToRad(this.rotation));
    // Draw segments
    for (let i = 0; i < n; i++) {
      const start = this.degToRad(i * seg);
      const end = this.degToRad((i + 1) * seg);
      ctx.beginPath();
      ctx.moveTo(0,0);
      ctx.arc(0,0,this.radius,start,end);
      ctx.closePath();
      ctx.fillStyle = this.colors[i % this.colors.length];
      ctx.fill();
      // stroke
      ctx.lineWidth = 2;
      ctx.strokeStyle = 'rgba(0,0,0,0.08)';
      ctx.stroke();
      // Draw label
      ctx.save();
      const angle = start + (end - start) / 2;
      ctx.rotate(angle);
      ctx.translate(this.radius * 0.55, 0);
      ctx.rotate(Math.PI / 2);
      ctx.fillStyle = this.textColor;
      ctx.font = this.font;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      const name = this.names[i] || '';
      this.wrapText(ctx, name, 0, 0, this.radius * 0.35, 18);
      ctx.restore();
    }
    ctx.restore();
    // center circle
    ctx.beginPath();
    ctx.arc(this.centerX, this.centerY, this.radius * 0.12, 0, Math.PI*2);
    ctx.fillStyle = '#ffffff';
    ctx.fill();
    ctx.lineWidth = 2;
    ctx.strokeStyle = 'rgba(0,0,0,0.06)';
    ctx.stroke();
    this.onDraw();
  }
  wrapText(ctx, text, x, y, maxWidth, lineHeight) {
    // A simple wrap for canvas text
    const words = text.split(' ');
    let line = '';
    let yOffset = y;
    for (let n = 0; n < words.length; n++) {
      const testLine = line + words[n] + ' ';
      const metrics = ctx.measureText(testLine);
      const testWidth = metrics.width;
      if (testWidth > maxWidth && n > 0) {
        ctx.fillText(line.trim(), x, yOffset);
        line = words[n] + ' ';
        yOffset += lineHeight;
      } else {
        line = testLine;
      }
    }
    ctx.fillText(line.trim(), x, yOffset);
  }
  degToRad(d) {
    return d * Math.PI / 180;
  }
  radToDeg(r) {
    return r * 180 / Math.PI;
  }
  getRandomIndex() {
    if (!this.names.length) return 0;
    return Math.floor(Math.random() * this.names.length);
  }
  // Spin such that the segment at `index` lands on the pointer at top.
  spinToIndex(index, opts = {}) {
    if (this._animating) return Promise.reject('Already animating');
    if (!this.names.length) return Promise.reject('No names');
    const n = this.names.length;
    const segAngle = 360 / n;
    // We want the center of target segment to be at angle 270deg (top of canvas - adjust if pointer is at top)
    // Our rotation variable rotates the whole wheel clockwise in degrees.
    // Compute the current rotation normalized
    const normalized = ((this.rotation % 360) + 360) % 360;
    // Calculate angle to place the segment center at top (270deg)
    // Center of segment i is at angle: (i * segAngle + segAngle/2)
    // We need rotation such that (centerAngle + rotation) mod 360 = 270
    const centerAngle = index * segAngle + segAngle / 2;
    // Solve for rotation target:
    let targetRotation = 270 - centerAngle;
    // Normalize to 0..360
    targetRotation = ((targetRotation % 360) + 360) % 360;
    // To produce multiple spins, add several full rotations:
    const fullSpins = opts.fullSpins !== undefined ? opts.fullSpins : (3 + Math.floor(Math.random()*3)); // 3-5 spins
    const endRotation = targetRotation + fullSpins * 360 + (opts.randomOffset || 0);
    // We'll animate from current normalized to endRotation, taking into account wrap
    const startRotation = normalized;
    const delta = endRotation - startRotation;
    const duration = opts.duration || 5000; // ms
    const startTime = performance.now();
    this._animating = true;
    return new Promise((resolve) => {
      const animate = (now) => {
        const elapsed = now - startTime;
        const t = Math.min(1, elapsed / duration);
        // ease out cubic
        const eased = 1 - Math.pow(1 - t, 3);
        const current = startRotation + delta * eased;
        this.rotation = current;
        this.draw();
        if (t < 1) {
          requestAnimationFrame(animate);
        } else {
          this._animating = false;
          // Normalize rotation to endRotation mod 360
          this.rotation = ((endRotation % 360) + 360) % 360;
          this.draw();
          resolve(index);
        }
      };
      requestAnimationFrame(animate);
    });
  }
}
```

main.js
```js
/*
'''
DOCSTRING:
main.js
Wires UI to the Wheel class:
- loads themes.json
- populates theme selector
- reads names and updates wheel
- handles spin logic and result display
'''
*/
document.addEventListener('DOMContentLoaded', async () => {
  const canvas = document.getElementById('wheel-canvas');
  const nameInput = document.getElementById('name-input');
  const addBtn = document.getElementById('add-name');
  const namesTextarea = document.getElementById('names-textarea');
  const spinBtn = document.getElementById('spin-btn');
  const resultDiv = document.getElementById('result');
  const themeSelect = document.getElementById('theme-select');
  const loadSampleBtn = document.getElementById('load-sample');
  const clearBtn = document.getElementById('clear-names');
  const importBtn = document.getElementById('import-names');
  const exportBtn = document.getElementById('export-names');
  const wheel = new Wheel(canvas, { names: [], colors: ['#ffb3b3','#ffd9b3','#fff3b3','#d9ffb3'] });
  let themes = [];
  // Load themes.json
  try {
    const resp = await fetch('/static/themes.json');
    themes = await resp.json();
    themes.forEach(t => {
      const opt = document.createElement('option');
      opt.value = t.id;
      opt.textContent = t.name;
      themeSelect.appendChild(opt);
    });
    // apply first theme
    applyTheme(themes[0]);
    themeSelect.value = themes[0].id;
  } catch (err) {
    console.error('Failed to load themes:', err);
  }
  function applyTheme(theme) {
    if (!theme) return;
    document.documentElement.style.setProperty('--bg', theme.bg || '#fff');
    document.documentElement.style.setProperty('--text', theme.text || '#222');
    document.documentElement.style.setProperty('--accent', theme.accent || '#007bff');
    // set panel bg slightly adjusted
    let panelBg = theme.bg;
    // simple luminance tweak
    try {
      panelBg = lightenOrDarkenColor(theme.bg || '#fff', 96);
    } catch(e) {
      panelBg = '#f6f8fa';
    }
    document.documentElement.style.setProperty('--panel-bg', panelBg);
    wheel.setTheme({ colors: theme.colors || [], text: theme.text || '#222' });
  }
  function lightenOrDarkenColor(col, amt) {
    // expects #rrggbb
    let usePound = false;
    if (col[0] === "#") {
      col = col.slice(1);
      usePound = true;
    }
    const num = parseInt(col,16);
    let r = (num >> 16) + amt;
    let b = ((num >> 8) & 0x00FF) + amt;
    let g = (num & 0x0000FF) + amt;
    r = Math.max(Math.min(255, r), 0);
    b = Math.max(Math.min(255, b), 0);
    g = Math.max(Math.min(255, g), 0);
    return (usePound ? "#" : "") + (g | (b << 8) | (r << 16)).toString(16).padStart(6, '0');
  }
  themeSelect.addEventListener('change', () => {
    const id = themeSelect.value;
    const t = themes.find(x => x.id === id);
    if (t) applyTheme(t);
  });
  function parseNamesFromTextarea() {
    const lines = namesTextarea.value.split('\n').map(s => s.trim()).filter(s => s.length);
    return lines;
  }
  function updateWheelFromTextarea() {
    const names = parseNamesFromTextarea();
    wheel.setNames(names);
  }
  addBtn.addEventListener('click', () => {
    const v = nameInput.value.trim();
    if (!v) return;
    const cur = parseNamesFromTextarea();
    cur.push(v);
    namesTextarea.value = cur.join('\n');
    nameInput.value = '';
    updateWheelFromTextarea();
  });
  nameInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
      addBtn.click();
      e.preventDefault();
    }
  });
  namesTextarea.addEventListener('input', () => {
    updateWheelFromTextarea();
  });
  loadSampleBtn.addEventListener('click', () => {
    const sample = ['Alice','Bob','Charlie','Diana','Eva','Frank','George','Helen','Ivy','Jack'];
    namesTextarea.value = sample.join('\n');
    updateWheelFromTextarea();
  });
  clearBtn.addEventListener('click', () => {
    namesTextarea.value = '';
    updateWheelFromTextarea();
    resultDiv.classList.add('hidden');
  });
  importBtn.addEventListener('click', async () => {
    // prompt user for a newline separated list (simple)
    const data = prompt('Paste names (one per line):');
    if (data === null) return;
    namesTextarea.value = data.split('\n').map(s => s.trim()).filter(s => s).join('\n');
    updateWheelFromTextarea();
  });
  exportBtn.addEventListener('click', () => {
    const names = parseNamesFromTextarea();
    const blob = new Blob([names.join('\n')], {type: 'text/plain'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'names.txt';
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  });
  spinBtn.addEventListener('click', async () => {
    const names = parseNamesFromTextarea();
    if (names.length === 0) {
      alert('Please add at least one name.');
      return;
    }
    resultDiv.classList.add('hidden');
    spinBtn.disabled = true;
    spinBtn.textContent = 'Spinning...';
    // pick random index
    const idx = wheel.getRandomIndex();
    try {
      const winnerIndex = await wheel.spinToIndex(idx, { duration: 4500 });
      const winner = names[winnerIndex];
      resultDiv.textContent = `Winner: ${winner}`;
      resultDiv.classList.remove('hidden');
      spinBtn.textContent = 'SPIN';
      spinBtn.disabled = false;
    } catch (err) {
      console.error(err);
      spinBtn.textContent = 'SPIN';
      spinBtn.disabled = false;
    }
  });
  // initial sample
  namesTextarea.value = 'Alice\nBob\nCharlie\nDiana\nEva';
  updateWheelFromTextarea();
});
```

"
As the Code Reviewer, to make the software directly operable without further coding, ChatDev have formulated the following regulations:
1) all referenced classes should be imported;
2) all methods should be implemented;
3) all methods need to have the necessary comments;
4) no potential bugs;
5) The entire project conforms to the tasks proposed by the user;
6) most importantly, do not only check the errors in the code, but also the logic of code. Make sure that user can interact with generated software without losing any feature in the requirement;
Now, you should check the above regulations one by one and review the codes in detail, propose one comment with the highest priority about the codes, and give me instructions on how to fix. Tell me your comment with the highest priority and corresponding suggestions on revision. If the codes are perfect and you have no comment on them, return only one line like "<INFO> Finished".

[2025-17-09 14:00:41 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2025-17-09 14:00:41 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 5561
completion_tokens: 3402
total_tokens: 8963
cost: $-1.000000


[2025-17-09 14:00:41 INFO] Code Reviewer: **Code Reviewer<->Programmer on : CodeReviewComment, turn 0**

[ChatDev is a software company powered by multiple intelligent agents, such as chief executive officer, chief human resources officer, chief product officer, chief technology officer, etc, with a multi-agent organizational structure and the mission of 'changing the digital world through programming'.
You are Programmer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer.
You can write/create computer software or applications by providing a specific programming language to the computer. You have extensive computing and coding experience in many varieties of programming languages and platforms, such as Python, Java, C, C++, HTML, CSS, JavaScript, XML, SQL, PHP, etc,.
Here is a new customer's task: [Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes.].
To complete the task, you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]

<PRIORITY> High â€” hardcoded static path for themes.json will break deployments mounted under a URL prefix (and can fail in some deployment configs)

Why this is important
- main.js currently calls fetch('/static/themes.json') using an absolute path starting with '/'. That works for a development server at the site root, but will fail if:
  - the Flask app is mounted under a subpath (example: https://example.com/myapp/), or
  - static_url_path / static_folder are customized, or
  - the app is reverse-proxied to a different prefix.
- If themes.json fails to load, theme selector is empty and the theme application will not work â€” a core feature per the requirements ("possibility of choose a variety of themes").

How to fix (recommended)
- Let Flask generate the correct URL for themes.json via url_for and make that value available to the client-side code. The simplest, robust approach is to inject a small inline script into your Jinja template that sets a global variable with the correct static URL. Then change main.js to use that variable when fetching themes.

Concrete code changes

1) In templates/index.html, add an inline script (place it before including main.js/wheel.js). Example insertion (replace/add inside <body> before your script tags):

  <script>
    // Provide the correct URL for themes.json (generated by Flask)
    window.THEMES_JSON_URL = "{{ url_for('static', filename='themes.json') }}";
  </script>

(You already use url_for for CSS/JS; do the same for the JSON file.)

2) In static/js/main.js, change the theme fetch to use the injected URL instead of the hardcoded path. Replace:

  const resp = await fetch('/static/themes.json');

with:

  const themesUrl = window.THEMES_JSON_URL || '/static/themes.json';
  const resp = await fetch(themesUrl);

(Keeping the fallback to '/static/themes.json' is harmless for local dev but not relied upon for production.)

3) (Optional but recommended) Add a robust fallback if fetch fails (already somewhat done with try/catch). Consider pre-bundling a small defaultThemes array in main.js so the UI still works if fetch fails.

Example combined snippet for main.js:

  // Load themes.json (URL injected by Flask)
  try {
    const themesUrl = window.THEMES_JSON_URL || '/static/themes.json';
    const resp = await fetch(themesUrl);
    if (!resp.ok) throw new Error('HTTP ' + resp.status);
    themes = await resp.json();
    // ... populate selector ...
  } catch (err) {
    console.error('Failed to load themes:', err);
    // fallback: define a minimal default theme so UI still works
    themes = [{
      id: 'fallback',
      name: 'Default',
      bg: '#ffffff',
      text: '#222222',
      accent: '#007bff',
      colors: ['#ffb3b3','#ffd9b3','#fff3b3','#d9ffb3']
    }];
    // populate selector with fallback theme
  }

Why this change fixes it
- url_for builds the correct static URL no matter where the app is mounted or how Flask is configured. Injecting that into the page ensures client-side fetch always targets the actual resource location.

Extra suggestion (non-blocking)
- Consider making lightenOrDarkenColor more robust (support shorthand hex like #fff, handle edge cases) as a follow-up. It currently works for typical 6-digit hexes, but solidifying it will improve theme rendering in edge cases.

If you want, I can produce the exact patch (diff) for index.html and main.js.

[2025-17-09 14:00:41 INFO] **[Seminar Conclusion]**:

 <PRIORITY> High â€” hardcoded static path for themes.json will break deployments mounted under a URL prefix (and can fail in some deployment configs)

Why this is important
- main.js currently calls fetch('/static/themes.json') using an absolute path starting with '/'. That works for a development server at the site root, but will fail if:
  - the Flask app is mounted under a subpath (example: https://example.com/myapp/), or
  - static_url_path / static_folder are customized, or
  - the app is reverse-proxied to a different prefix.
- If themes.json fails to load, theme selector is empty and the theme application will not work â€” a core feature per the requirements ("possibility of choose a variety of themes").

How to fix (recommended)
- Let Flask generate the correct URL for themes.json via url_for and make that value available to the client-side code. The simplest, robust approach is to inject a small inline script into your Jinja template that sets a global variable with the correct static URL. Then change main.js to use that variable when fetching themes.

Concrete code changes

1) In templates/index.html, add an inline script (place it before including main.js/wheel.js). Example insertion (replace/add inside <body> before your script tags):

  <script>
    // Provide the correct URL for themes.json (generated by Flask)
    window.THEMES_JSON_URL = "{{ url_for('static', filename='themes.json') }}";
  </script>

(You already use url_for for CSS/JS; do the same for the JSON file.)

2) In static/js/main.js, change the theme fetch to use the injected URL instead of the hardcoded path. Replace:

  const resp = await fetch('/static/themes.json');

with:

  const themesUrl = window.THEMES_JSON_URL || '/static/themes.json';
  const resp = await fetch(themesUrl);

(Keeping the fallback to '/static/themes.json' is harmless for local dev but not relied upon for production.)

3) (Optional but recommended) Add a robust fallback if fetch fails (already somewhat done with try/catch). Consider pre-bundling a small defaultThemes array in main.js so the UI still works if fetch fails.

Example combined snippet for main.js:

  // Load themes.json (URL injected by Flask)
  try {
    const themesUrl = window.THEMES_JSON_URL || '/static/themes.json';
    const resp = await fetch(themesUrl);
    if (!resp.ok) throw new Error('HTTP ' + resp.status);
    themes = await resp.json();
    // ... populate selector ...
  } catch (err) {
    console.error('Failed to load themes:', err);
    // fallback: define a minimal default theme so UI still works
    themes = [{
      id: 'fallback',
      name: 'Default',
      bg: '#ffffff',
      text: '#222222',
      accent: '#007bff',
      colors: ['#ffb3b3','#ffd9b3','#fff3b3','#d9ffb3']
    }];
    // populate selector with fallback theme
  }

Why this change fixes it
- url_for builds the correct static URL no matter where the app is mounted or how Flask is configured. Injecting that into the page ensures client-side fetch always targets the actual resource location.

Extra suggestion (non-blocking)
- Consider making lightenOrDarkenColor more robust (support shorthand hex like #fff, handle edge cases) as a follow-up. It currently works for typical 6-digit hexes, but solidifying it will improve theme rendering in edge cases.

If you want, I can produce the exact patch (diff) for index.html and main.js.

[2025-17-09 14:00:41 INFO] **[Execute Detail]**

execute SimplePhase:[CodeReviewModification] in ComposedPhase:[CodeReview], cycle 1

[2025-17-09 14:00:41 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | [Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes.] |
| **need_reflect** | False |
| **assistant_role_name** | Programmer |
| **user_role_name** | Code Reviewer |
| **phase_prompt** | According to the new user's task, our designed product modality, languages and ideas, our developed first-edition source codes are listed below:  Task: "{task}". Modality: "{modality}". Programming Language: "{language}" Ideas: "{ideas}" Codes:  "{codes}" Comments on Codes: "{comments}" In the software, each file must strictly follow a markdown code block format, where the following tokens must be replaced such that "FILENAME" is the lowercase file name including the file extension, "LANGUAGE" in the programming language, "DOCSTRING" is a string literal specified in source code that is used to document a specific segment of code, and "CODE" is the original code. Format: FILENAME LANGUAGE ''' DOCSTRING ''' CODE As the {assistant_role}, to satisfy the new user's demand and make the software creative, executive and robust, you should modify corresponding codes according to the comments. Then, output the full and complete codes with all bugs fixed based on the comments. Return all codes strictly following the required format. |
| **phase_name** | CodeReviewModification |
| **assistant_role_prompt** | {chatdev_prompt} You are Programmer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. You can write/create computer software or applications by providing a specific programming language to the computer. You have extensive computing and coding experience in many varieties of programming languages and platforms, such as Python, Java, C, C++, HTML, CSS, JavaScript, XML, SQL, PHP, etc,. Here is a new customer's task: {task}. To complete the task, you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Code Reviewer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. You can help programmers to assess source codes for software troubleshooting, fix bugs to increase code quality and robustness, and offer proposals to improve the source codes. Here is a new customer's task: {task}. To complete the task, you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 1, 'task': '[Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes.]', 'modality': 'website', 'ideas': '', 'language': ' Python', 'codes': 'main.py\npython\n\'\'\'\napp.py\nDOCSTRING:\nFlask application that serves the wheel-of-names web app.\nRun: pip install flask\nThen: python app.py\nAccess: http://127.0.0.1:5000/\n\'\'\'\nfrom flask import Flask, render_template\nimport os\ndef create_app():\n    """\n    Create and configure the Flask application.\n    """\n    app = Flask(__name__, static_folder=\'static\', template_folder=\'templates\')\n    @app.route(\'/\')\n    def index():\n        """\n        Serve the main page.\n        """\n        return render_template(\'index.html\')\n    return app\nif __name__ == \'__main__\':\n    app = create_app()\n    port = int(os.environ.get(\'PORT\', 5000))\n    app.run(debug=True, host=\'0.0.0.0\', port=port)\n\n\nindex.html\nhtml\n\'\'\'\nDOCSTRING:\nMain HTML page for the Wheel of Names app.\nContains UI elements:\n- name input and list\n- canvas for wheel\n- theme selector\n- spin / clear / add buttons\nIncludes JS files wheel.js and main.js for behavior.\n\'\'\'\n&lt;!doctype html&gt;\n&lt;html lang="en"&gt;\n&lt;head&gt;\n  &lt;meta charset="utf-8"&gt;\n  &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;\n  &lt;title&gt;Wheel of Names&lt;/title&gt;\n  &lt;link rel="stylesheet" href="{{ url_for(\'static\', filename=\'css/styles.css\') }}"&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div class="container"&gt;\n    &lt;header&gt;\n      &lt;h1&gt;Wheel of Names&lt;/h1&gt;\n      &lt;p&gt;Enter names, choose a theme, and spin to pick a random winner.&lt;/p&gt;\n    &lt;/header&gt;\n    &lt;main class="main-grid"&gt;\n      &lt;section class="left-panel"&gt;\n        &lt;div class="controls"&gt;\n          &lt;label for="name-input"&gt;Add a name&lt;/label&gt;\n          &lt;div class="input-row"&gt;\n            &lt;input id="name-input" type="text" placeholder="Enter name and press Add" autocomplete="off"&gt;\n            &lt;button id="add-name"&gt;Add&lt;/button&gt;\n          &lt;/div&gt;\n          &lt;label for="names-textarea"&gt;Names (one per line)&lt;/label&gt;\n          &lt;textarea id="names-textarea" placeholder="Alice\\nBob\\nCharlie"&gt;&lt;/textarea&gt;\n          &lt;div class="buttons-row"&gt;\n            &lt;button id="load-sample"&gt;Load Sample&lt;/button&gt;\n            &lt;button id="clear-names"&gt;Clear&lt;/button&gt;\n            &lt;button id="import-names"&gt;Import&lt;/button&gt;\n            &lt;button id="export-names"&gt;Export&lt;/button&gt;\n          &lt;/div&gt;\n          &lt;label for="theme-select"&gt;Theme&lt;/label&gt;\n          &lt;select id="theme-select"&gt;&lt;/select&gt;\n          &lt;div class="spin-controls"&gt;\n            &lt;button id="spin-btn" class="spin"&gt;SPIN&lt;/button&gt;\n            &lt;div id="result" class="result hidden"&gt;&lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      &lt;/section&gt;\n      &lt;section class="right-panel"&gt;\n        &lt;div class="wheel-wrapper" id="wheel-wrapper"&gt;\n          &lt;canvas id="wheel-canvas" width="600" height="600"&gt;&lt;/canvas&gt;\n          &lt;div id="pointer"&gt;â–¼&lt;/div&gt;\n        &lt;/div&gt;\n      &lt;/section&gt;\n    &lt;/main&gt;\n    &lt;footer&gt;\n      &lt;small&gt;Built with Flask + Canvas. Themes available.&lt;/small&gt;\n    &lt;/footer&gt;\n  &lt;/div&gt;\n  &lt;script src="{{ url_for(\'static\', filename=\'js/wheel.js\') }}"&gt;&lt;/script&gt;\n  &lt;script src="{{ url_for(\'static\', filename=\'js/main.js\') }}"&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\n\nthemes.json\njson\n\'\'\'\nDOCSTRING:\nList of themes available for the wheel.\nEach theme contains:\n- name: display name\n- bg: page background color\n- text: primary text color\n- accent: accent color used for pointer/button\n- colors: array of segment colors (will be cycled for segments)\n\'\'\'\n[\n  {\n    "id": "classic",\n    "name": "Classic",\n    "bg": "#ffffff",\n    "text": "#222222",\n    "accent": "#007bff",\n    "colors": ["#ffb3b3", "#ffd9b3", "#fff3b3", "#d9ffb3", "#b3ffd9", "#b3e6ff", "#c7b3ff", "#ffb3f2"]\n  },\n  {\n    "id": "dark",\n    "name": "Dark",\n    "bg": "#121212",\n    "text": "#f5f5f5",\n    "accent": "#ff6b6b",\n    "colors": ["#2e2e34", "#3a3a44", "#4a4a56", "#5a5a68", "#6a6a78", "#7a7a88"]\n  },\n  {\n    "id": "pastel",\n    "name": "Pastel",\n    "bg": "#f7f7ff",\n    "text": "#333333",\n    "accent": "#ff8c94",\n    "colors": ["#ffd1dc", "#fce1b4", "#e8ffd1", "#d1fff0", "#d1e7ff", "#e6d1ff"]\n  },\n  {\n    "id": "neon",\n    "name": "Neon",\n    "bg": "#0f0f13",\n    "text": "#eaff00",\n    "accent": "#00fff5",\n    "colors": ["#ff00ff", "#ff8c00", "#00ff00", "#00ffff", "#8c00ff", "#ff0066"]\n  }\n]\n\n\nstyles.css\ncss\n\'\'\'\nDOCSTRING:\nBase CSS for the Wheel of Names app.\nDefines layout, basic theme variables, and responsive styles.\n\'\'\'\n:root{\n  --bg: #ffffff;\n  --text: #222222;\n  --accent: #007bff;\n  --panel-bg: #f6f8fa;\n}\n*{box-sizing:border-box}\nhtml,body{\n  height:100%;\n  margin:0;\n  font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;\n  background: var(--bg);\n  color: var(--text);\n}\n.container{\n  max-width:1100px;\n  margin:24px auto;\n  padding:16px;\n}\nheader{ text-align:center; margin-bottom:8px }\nh1{ margin:6px 0; font-size:28px }\np{ margin:0; color:var(--text); opacity:0.8 }\n.main-grid{\n  display:grid;\n  grid-template-columns: 360px 1fr;\n  gap:20px;\n  align-items:start;\n  margin-top:18px;\n}\n.left-panel{\n  background:var(--panel-bg);\n  padding:14px;\n  border-radius:8px;\n  box-shadow:0 4px 8px rgba(0,0,0,0.04);\n}\n.left-panel label{ display:block; margin-top:8px; font-weight:600; margin-bottom:6px }\n.input-row{ display:flex; gap:8px }\n.input-row input[type="text"]{\n  flex:1;\n  padding:8px 10px;\n  border-radius:6px;\n  border:1px solid #ddd;\n}\n.input-row button{\n  padding:8px 12px;\n  border-radius:6px;\n  background:var(--accent);\n  color:white;\n  border:none;\n  cursor:pointer;\n}\ntextarea{\n  width:100%;\n  min-height:160px;\n  padding:10px;\n  border-radius:8px;\n  border:1px solid #ddd;\n  resize:vertical;\n}\n.buttons-row{\n  display:flex;\n  gap:8px;\n  margin-top:8px;\n  flex-wrap:wrap;\n}\n.buttons-row button{\n  padding:8px 10px;\n  border-radius:6px;\n  border:1px solid #ccc;\n  background:transparent;\n  cursor:pointer;\n}\n.spin-controls{\n  display:flex;\n  gap:12px;\n  margin-top:16px;\n  align-items:center;\n}\n.spin{\n  padding:14px 24px;\n  background:var(--accent);\n  color:white;\n  font-weight:700;\n  border:none;\n  border-radius:10px;\n  cursor:pointer;\n  font-size:18px;\n}\n.result{\n  padding:10px 12px;\n  background:rgba(0,0,0,0.06);\n  border-radius:8px;\n}\n.hidden{ display:none }\n.right-panel{\n  display:flex;\n  align-items:center;\n  justify-content:center;\n  min-height:420px;\n}\n.wheel-wrapper{\n  position:relative;\n  width:600px;\n  height:600px;\n  display:flex;\n  align-items:center;\n  justify-content:center;\n  margin:auto;\n}\n#wheel-canvas{\n  border-radius:50%;\n  box-shadow: 0 12px 30px rgba(0,0,0,0.12);\n  background:transparent;\n}\n#wheel-wrapper #pointer{\n  position:absolute;\n  top:18px;\n  left:50%;\n  transform:translateX(-50%);\n  font-size:40px;\n  color:var(--accent);\n  text-shadow:0 2px 4px rgba(0,0,0,0.2);\n  pointer-events:none;\n}\nfooter{ text-align:center; margin-top:16px; color:var(--text); opacity:0.7; }\n/* Responsive */\n@media (max-width:960px){\n  .main-grid{ grid-template-columns:1fr; }\n  .wheel-wrapper{ width:420px; height:420px; }\n  #wheel-canvas{ width:420px; height:420px; }\n}\n\n\nwheel.js\njs\n/*\n\'\'\'\nDOCSTRING:\nwheel.js\nContains a Wheel class that draws the wheel on a canvas and animates spins.\nKey methods:\n- constructor(canvas, options)\n- setNames(names)\n- setTheme(theme)\n- draw()\n- spinToIndex(index) -&gt; Promise resolves with index after animation\n- getRandomIndex()\n\'\'\'\n*/\nclass Wheel {\n  constructor(canvas, options = {}) {\n    this.canvas = canvas;\n    this.ctx = canvas.getContext(\'2d\');\n    this.names = options.names || [];\n    this.colors = options.colors || [\'#ffb3b3\', \'#ffd9b3\', \'#fff3b3\', \'#d9ffb3\', \'#b3ffd9\', \'#b3e6ff\'];\n    this.textColor = options.textColor || \'#222\';\n    this.centerX = canvas.width / 2;\n    this.centerY = canvas.height / 2;\n    this.radius = Math.min(this.centerX, this.centerY) - 10;\n    this.rotation = 0; // degrees\n    this.font = options.font || \'16px Inter, Arial\';\n    this.onDraw = options.onDraw || function(){};\n    this._animating = false;\n    this.draw();\n  }\n  setNames(names) {\n    this.names = names.slice();\n    this.draw();\n  }\n  setTheme(theme) {\n    if (!theme) return;\n    if (theme.colors &amp;&amp; theme.colors.length) this.colors = theme.colors.slice();\n    if (theme.text) this.textColor = theme.text;\n    this.draw();\n  }\n  clearCanvas() {\n    this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height);\n  }\n  draw() {\n    this.clearCanvas();\n    const ctx = this.ctx;\n    const n = Math.max(1, this.names.length);\n    const seg = 360 / n;\n    ctx.save();\n    ctx.translate(this.centerX, this.centerY);\n    ctx.rotate(this.degToRad(this.rotation));\n    // Draw segments\n    for (let i = 0; i &lt; n; i++) {\n      const start = this.degToRad(i * seg);\n      const end = this.degToRad((i + 1) * seg);\n      ctx.beginPath();\n      ctx.moveTo(0,0);\n      ctx.arc(0,0,this.radius,start,end);\n      ctx.closePath();\n      ctx.fillStyle = this.colors[i % this.colors.length];\n      ctx.fill();\n      // stroke\n      ctx.lineWidth = 2;\n      ctx.strokeStyle = \'rgba(0,0,0,0.08)\';\n      ctx.stroke();\n      // Draw label\n      ctx.save();\n      const angle = start + (end - start) / 2;\n      ctx.rotate(angle);\n      ctx.translate(this.radius * 0.55, 0);\n      ctx.rotate(Math.PI / 2);\n      ctx.fillStyle = this.textColor;\n      ctx.font = this.font;\n      ctx.textAlign = \'center\';\n      ctx.textBaseline = \'middle\';\n      const name = this.names[i] || \'\';\n      this.wrapText(ctx, name, 0, 0, this.radius * 0.35, 18);\n      ctx.restore();\n    }\n    ctx.restore();\n    // center circle\n    ctx.beginPath();\n    ctx.arc(this.centerX, this.centerY, this.radius * 0.12, 0, Math.PI*2);\n    ctx.fillStyle = \'#ffffff\';\n    ctx.fill();\n    ctx.lineWidth = 2;\n    ctx.strokeStyle = \'rgba(0,0,0,0.06)\';\n    ctx.stroke();\n    this.onDraw();\n  }\n  wrapText(ctx, text, x, y, maxWidth, lineHeight) {\n    // A simple wrap for canvas text\n    const words = text.split(\' \');\n    let line = \'\';\n    let yOffset = y;\n    for (let n = 0; n &lt; words.length; n++) {\n      const testLine = line + words[n] + \' \';\n      const metrics = ctx.measureText(testLine);\n      const testWidth = metrics.width;\n      if (testWidth &gt; maxWidth &amp;&amp; n &gt; 0) {\n        ctx.fillText(line.trim(), x, yOffset);\n        line = words[n] + \' \';\n        yOffset += lineHeight;\n      } else {\n        line = testLine;\n      }\n    }\n    ctx.fillText(line.trim(), x, yOffset);\n  }\n  degToRad(d) {\n    return d * Math.PI / 180;\n  }\n  radToDeg(r) {\n    return r * 180 / Math.PI;\n  }\n  getRandomIndex() {\n    if (!this.names.length) return 0;\n    return Math.floor(Math.random() * this.names.length);\n  }\n  // Spin such that the segment at `index` lands on the pointer at top.\n  spinToIndex(index, opts = {}) {\n    if (this._animating) return Promise.reject(\'Already animating\');\n    if (!this.names.length) return Promise.reject(\'No names\');\n    const n = this.names.length;\n    const segAngle = 360 / n;\n    // We want the center of target segment to be at angle 270deg (top of canvas - adjust if pointer is at top)\n    // Our rotation variable rotates the whole wheel clockwise in degrees.\n    // Compute the current rotation normalized\n    const normalized = ((this.rotation % 360) + 360) % 360;\n    // Calculate angle to place the segment center at top (270deg)\n    // Center of segment i is at angle: (i * segAngle + segAngle/2)\n    // We need rotation such that (centerAngle + rotation) mod 360 = 270\n    const centerAngle = index * segAngle + segAngle / 2;\n    // Solve for rotation target:\n    let targetRotation = 270 - centerAngle;\n    // Normalize to 0..360\n    targetRotation = ((targetRotation % 360) + 360) % 360;\n    // To produce multiple spins, add several full rotations:\n    const fullSpins = opts.fullSpins !== undefined ? opts.fullSpins : (3 + Math.floor(Math.random()*3)); // 3-5 spins\n    const endRotation = targetRotation + fullSpins * 360 + (opts.randomOffset || 0);\n    // We\'ll animate from current normalized to endRotation, taking into account wrap\n    const startRotation = normalized;\n    const delta = endRotation - startRotation;\n    const duration = opts.duration || 5000; // ms\n    const startTime = performance.now();\n    this._animating = true;\n    return new Promise((resolve) =&gt; {\n      const animate = (now) =&gt; {\n        const elapsed = now - startTime;\n        const t = Math.min(1, elapsed / duration);\n        // ease out cubic\n        const eased = 1 - Math.pow(1 - t, 3);\n        const current = startRotation + delta * eased;\n        this.rotation = current;\n        this.draw();\n        if (t &lt; 1) {\n          requestAnimationFrame(animate);\n        } else {\n          this._animating = false;\n          // Normalize rotation to endRotation mod 360\n          this.rotation = ((endRotation % 360) + 360) % 360;\n          this.draw();\n          resolve(index);\n        }\n      };\n      requestAnimationFrame(animate);\n    });\n  }\n}\n\n\nmain.js\njs\n/*\n\'\'\'\nDOCSTRING:\nmain.js\nWires UI to the Wheel class:\n- loads themes.json\n- populates theme selector\n- reads names and updates wheel\n- handles spin logic and result display\n\'\'\'\n*/\ndocument.addEventListener(\'DOMContentLoaded\', async () =&gt; {\n  const canvas = document.getElementById(\'wheel-canvas\');\n  const nameInput = document.getElementById(\'name-input\');\n  const addBtn = document.getElementById(\'add-name\');\n  const namesTextarea = document.getElementById(\'names-textarea\');\n  const spinBtn = document.getElementById(\'spin-btn\');\n  const resultDiv = document.getElementById(\'result\');\n  const themeSelect = document.getElementById(\'theme-select\');\n  const loadSampleBtn = document.getElementById(\'load-sample\');\n  const clearBtn = document.getElementById(\'clear-names\');\n  const importBtn = document.getElementById(\'import-names\');\n  const exportBtn = document.getElementById(\'export-names\');\n  const wheel = new Wheel(canvas, { names: [], colors: [\'#ffb3b3\',\'#ffd9b3\',\'#fff3b3\',\'#d9ffb3\'] });\n  let themes = [];\n  // Load themes.json\n  try {\n    const resp = await fetch(\'/static/themes.json\');\n    themes = await resp.json();\n    themes.forEach(t =&gt; {\n      const opt = document.createElement(\'option\');\n      opt.value = t.id;\n      opt.textContent = t.name;\n      themeSelect.appendChild(opt);\n    });\n    // apply first theme\n    applyTheme(themes[0]);\n    themeSelect.value = themes[0].id;\n  } catch (err) {\n    console.error(\'Failed to load themes:\', err);\n  }\n  function applyTheme(theme) {\n    if (!theme) return;\n    document.documentElement.style.setProperty(\'--bg\', theme.bg || \'#fff\');\n    document.documentElement.style.setProperty(\'--text\', theme.text || \'#222\');\n    document.documentElement.style.setProperty(\'--accent\', theme.accent || \'#007bff\');\n    // set panel bg slightly adjusted\n    let panelBg = theme.bg;\n    // simple luminance tweak\n    try {\n      panelBg = lightenOrDarkenColor(theme.bg || \'#fff\', 96);\n    } catch(e) {\n      panelBg = \'#f6f8fa\';\n    }\n    document.documentElement.style.setProperty(\'--panel-bg\', panelBg);\n    wheel.setTheme({ colors: theme.colors || [], text: theme.text || \'#222\' });\n  }\n  function lightenOrDarkenColor(col, amt) {\n    // expects #rrggbb\n    let usePound = false;\n    if (col[0] === "#") {\n      col = col.slice(1);\n      usePound = true;\n    }\n    const num = parseInt(col,16);\n    let r = (num &gt;&gt; 16) + amt;\n    let b = ((num &gt;&gt; 8) &amp; 0x00FF) + amt;\n    let g = (num &amp; 0x0000FF) + amt;\n    r = Math.max(Math.min(255, r), 0);\n    b = Math.max(Math.min(255, b), 0);\n    g = Math.max(Math.min(255, g), 0);\n    return (usePound ? "#" : "") + (g | (b &lt;&lt; 8) | (r &lt;&lt; 16)).toString(16).padStart(6, \'0\');\n  }\n  themeSelect.addEventListener(\'change\', () =&gt; {\n    const id = themeSelect.value;\n    const t = themes.find(x =&gt; x.id === id);\n    if (t) applyTheme(t);\n  });\n  function parseNamesFromTextarea() {\n    const lines = namesTextarea.value.split(\'\\n\').map(s =&gt; s.trim()).filter(s =&gt; s.length);\n    return lines;\n  }\n  function updateWheelFromTextarea() {\n    const names = parseNamesFromTextarea();\n    wheel.setNames(names);\n  }\n  addBtn.addEventListener(\'click\', () =&gt; {\n    const v = nameInput.value.trim();\n    if (!v) return;\n    const cur = parseNamesFromTextarea();\n    cur.push(v);\n    namesTextarea.value = cur.join(\'\\n\');\n    nameInput.value = \'\';\n    updateWheelFromTextarea();\n  });\n  nameInput.addEventListener(\'keydown\', (e) =&gt; {\n    if (e.key === \'Enter\') {\n      addBtn.click();\n      e.preventDefault();\n    }\n  });\n  namesTextarea.addEventListener(\'input\', () =&gt; {\n    updateWheelFromTextarea();\n  });\n  loadSampleBtn.addEventListener(\'click\', () =&gt; {\n    const sample = [\'Alice\',\'Bob\',\'Charlie\',\'Diana\',\'Eva\',\'Frank\',\'George\',\'Helen\',\'Ivy\',\'Jack\'];\n    namesTextarea.value = sample.join(\'\\n\');\n    updateWheelFromTextarea();\n  });\n  clearBtn.addEventListener(\'click\', () =&gt; {\n    namesTextarea.value = \'\';\n    updateWheelFromTextarea();\n    resultDiv.classList.add(\'hidden\');\n  });\n  importBtn.addEventListener(\'click\', async () =&gt; {\n    // prompt user for a newline separated list (simple)\n    const data = prompt(\'Paste names (one per line):\');\n    if (data === null) return;\n    namesTextarea.value = data.split(\'\\n\').map(s =&gt; s.trim()).filter(s =&gt; s).join(\'\\n\');\n    updateWheelFromTextarea();\n  });\n  exportBtn.addEventListener(\'click\', () =&gt; {\n    const names = parseNamesFromTextarea();\n    const blob = new Blob([names.join(\'\\n\')], {type: \'text/plain\'});\n    const url = URL.createObjectURL(blob);\n    const a = document.createElement(\'a\');\n    a.href = url;\n    a.download = \'names.txt\';\n    document.body.appendChild(a);\n    a.click();\n    a.remove();\n    URL.revokeObjectURL(url);\n  });\n  spinBtn.addEventListener(\'click\', async () =&gt; {\n    const names = parseNamesFromTextarea();\n    if (names.length === 0) {\n      alert(\'Please add at least one name.\');\n      return;\n    }\n    resultDiv.classList.add(\'hidden\');\n    spinBtn.disabled = true;\n    spinBtn.textContent = \'Spinning...\';\n    // pick random index\n    const idx = wheel.getRandomIndex();\n    try {\n      const winnerIndex = await wheel.spinToIndex(idx, { duration: 4500 });\n      const winner = names[winnerIndex];\n      resultDiv.textContent = `Winner: ${winner}`;\n      resultDiv.classList.remove(\'hidden\');\n      spinBtn.textContent = \'SPIN\';\n      spinBtn.disabled = false;\n    } catch (err) {\n      console.error(err);\n      spinBtn.textContent = \'SPIN\';\n      spinBtn.disabled = false;\n    }\n  });\n  // initial sample\n  namesTextarea.value = \'Alice\\nBob\\nCharlie\\nDiana\\nEva\';\n  updateWheelFromTextarea();\n});\n\n\n', 'images': '', 'comments': ' High â€” hardcoded static path for themes.json will break deployments mounted under a URL prefix (and can fail in some deployment configs)\n\nWhy this is important\n- main.js currently calls fetch(\'/static/themes.json\') using an absolute path starting with \'/\'. That works for a development server at the site root, but will fail if:\n  - the Flask app is mounted under a subpath (example: https://example.com/myapp/), or\n  - static_url_path / static_folder are customized, or\n  - the app is reverse-proxied to a different prefix.\n- If themes.json fails to load, theme selector is empty and the theme application will not work â€” a core feature per the requirements ("possibility of choose a variety of themes").\n\nHow to fix (recommended)\n- Let Flask generate the correct URL for themes.json via url_for and make that value available to the client-side code. The simplest, robust approach is to inject a small inline script into your Jinja template that sets a global variable with the correct static URL. Then change main.js to use that variable when fetching themes.\n\nConcrete code changes\n\n1) In templates/index.html, add an inline script (place it before including main.js/wheel.js). Example insertion (replace/add inside  before your script tags):\n\n  \n    // Provide the correct URL for themes.json (generated by Flask)\n    window.THEMES_JSON_URL = "{{ url_for(\'static\', filename=\'themes.json\') }}";\n  \n\n(You already use url_for for CSS/JS; do the same for the JSON file.)\n\n2) In static/js/main.js, change the theme fetch to use the injected URL instead of the hardcoded path. Replace:\n\n  const resp = await fetch(\'/static/themes.json\');\n\nwith:\n\n  const themesUrl = window.THEMES_JSON_URL || \'/static/themes.json\';\n  const resp = await fetch(themesUrl);\n\n(Keeping the fallback to \'/static/themes.json\' is harmless for local dev but not relied upon for production.)\n\n3) (Optional but recommended) Add a robust fallback if fetch fails (already somewhat done with try/catch). Consider pre-bundling a small defaultThemes array in main.js so the UI still works if fetch fails.\n\nExample combined snippet for main.js:\n\n  // Load themes.json (URL injected by Flask)\n  try {\n    const themesUrl = window.THEMES_JSON_URL || \'/static/themes.json\';\n    const resp = await fetch(themesUrl);\n    if (!resp.ok) throw new Error(\'HTTP \' + resp.status);\n    themes = await resp.json();\n    // ... populate selector ...\n  } catch (err) {\n    console.error(\'Failed to load themes:\', err);\n    // fallback: define a minimal default theme so UI still works\n    themes = [{\n      id: \'fallback\',\n      name: \'Default\',\n      bg: \'#ffffff\',\n      text: \'#222222\',\n      accent: \'#007bff\',\n      colors: [\'#ffb3b3\',\'#ffd9b3\',\'#fff3b3\',\'#d9ffb3\']\n    }];\n    // populate selector with fallback theme\n  }\n\nWhy this change fixes it\n- url_for builds the correct static URL no matter where the app is mounted or how Flask is configured. Injecting that into the page ensures client-side fetch always targets the actual resource location.\n\nExtra suggestion (non-blocking)\n- Consider making lightenOrDarkenColor more robust (support shorthand hex like #fff, handle edge cases) as a follow-up. It currently works for typical 6-digit hexes, but solidifying it will improve theme rendering in edge cases.\n\nIf you want, I can produce the exact patch (diff) for index.html and main.js.'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_3_5_TURBO |

[2025-17-09 14:00:41 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Programmer |
| **user_role_name** | Code Reviewer |
| **assistant_role_prompt** | {chatdev_prompt} You are Programmer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. You can write/create computer software or applications by providing a specific programming language to the computer. You have extensive computing and coding experience in many varieties of programming languages and platforms, such as Python, Java, C, C++, HTML, CSS, JavaScript, XML, SQL, PHP, etc,. Here is a new customer's task: {task}. To complete the task, you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Code Reviewer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. You can help programmers to assess source codes for software troubleshooting, fix bugs to increase code quality and robustness, and offer proposals to improve the source codes. Here is a new customer's task: {task}. To complete the task, you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **task_prompt** | [Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes.] |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_3_5_TURBO |
| **background_prompt** | ChatDev is a software company powered by multiple intelligent agents, such as chief executive officer, chief human resources officer, chief product officer, chief technology officer, etc, with a multi-agent organizational structure and the mission of 'changing the digital world through programming'. |

[2025-17-09 14:00:41 INFO] Code Reviewer: **[Start Chat]**

[ChatDev is a software company powered by multiple intelligent agents, such as chief executive officer, chief human resources officer, chief product officer, chief technology officer, etc, with a multi-agent organizational structure and the mission of 'changing the digital world through programming'.
You are Programmer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer.
You can write/create computer software or applications by providing a specific programming language to the computer. You have extensive computing and coding experience in many varieties of programming languages and platforms, such as Python, Java, C, C++, HTML, CSS, JavaScript, XML, SQL, PHP, etc,.
Here is a new customer's task: [Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes.].
To complete the task, you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]

According to the new user's task, our designed product modality, languages and ideas, our developed first-edition source codes are listed below: 
Task: "[Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes.]".
Modality: "website".
Programming Language: " Python"
Ideas: ""
Codes: 
"main.py
```python
'''
app.py
DOCSTRING:
Flask application that serves the wheel-of-names web app.
Run: pip install flask
Then: python app.py
Access: http://127.0.0.1:5000/
'''
from flask import Flask, render_template
import os
def create_app():
    """
    Create and configure the Flask application.
    """
    app = Flask(__name__, static_folder='static', template_folder='templates')
    @app.route('/')
    def index():
        """
        Serve the main page.
        """
        return render_template('index.html')
    return app
if __name__ == '__main__':
    app = create_app()
    port = int(os.environ.get('PORT', 5000))
    app.run(debug=True, host='0.0.0.0', port=port)
```

index.html
```html
'''
DOCSTRING:
Main HTML page for the Wheel of Names app.
Contains UI elements:
- name input and list
- canvas for wheel
- theme selector
- spin / clear / add buttons
Includes JS files wheel.js and main.js for behavior.
'''
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Wheel of Names</title>
  <link rel="stylesheet" href="{{ url_for('static', filename='css/styles.css') }}">
</head>
<body>
  <div class="container">
    <header>
      <h1>Wheel of Names</h1>
      <p>Enter names, choose a theme, and spin to pick a random winner.</p>
    </header>
    <main class="main-grid">
      <section class="left-panel">
        <div class="controls">
          <label for="name-input">Add a name</label>
          <div class="input-row">
            <input id="name-input" type="text" placeholder="Enter name and press Add" autocomplete="off">
            <button id="add-name">Add</button>
          </div>
          <label for="names-textarea">Names (one per line)</label>
          <textarea id="names-textarea" placeholder="Alice\nBob\nCharlie"></textarea>
          <div class="buttons-row">
            <button id="load-sample">Load Sample</button>
            <button id="clear-names">Clear</button>
            <button id="import-names">Import</button>
            <button id="export-names">Export</button>
          </div>
          <label for="theme-select">Theme</label>
          <select id="theme-select"></select>
          <div class="spin-controls">
            <button id="spin-btn" class="spin">SPIN</button>
            <div id="result" class="result hidden"></div>
          </div>
        </div>
      </section>
      <section class="right-panel">
        <div class="wheel-wrapper" id="wheel-wrapper">
          <canvas id="wheel-canvas" width="600" height="600"></canvas>
          <div id="pointer">â–¼</div>
        </div>
      </section>
    </main>
    <footer>
      <small>Built with Flask + Canvas. Themes available.</small>
    </footer>
  </div>
  <script src="{{ url_for('static', filename='js/wheel.js') }}"></script>
  <script src="{{ url_for('static', filename='js/main.js') }}"></script>
</body>
</html>
```

themes.json
```json
'''
DOCSTRING:
List of themes available for the wheel.
Each theme contains:
- name: display name
- bg: page background color
- text: primary text color
- accent: accent color used for pointer/button
- colors: array of segment colors (will be cycled for segments)
'''
[
  {
    "id": "classic",
    "name": "Classic",
    "bg": "#ffffff",
    "text": "#222222",
    "accent": "#007bff",
    "colors": ["#ffb3b3", "#ffd9b3", "#fff3b3", "#d9ffb3", "#b3ffd9", "#b3e6ff", "#c7b3ff", "#ffb3f2"]
  },
  {
    "id": "dark",
    "name": "Dark",
    "bg": "#121212",
    "text": "#f5f5f5",
    "accent": "#ff6b6b",
    "colors": ["#2e2e34", "#3a3a44", "#4a4a56", "#5a5a68", "#6a6a78", "#7a7a88"]
  },
  {
    "id": "pastel",
    "name": "Pastel",
    "bg": "#f7f7ff",
    "text": "#333333",
    "accent": "#ff8c94",
    "colors": ["#ffd1dc", "#fce1b4", "#e8ffd1", "#d1fff0", "#d1e7ff", "#e6d1ff"]
  },
  {
    "id": "neon",
    "name": "Neon",
    "bg": "#0f0f13",
    "text": "#eaff00",
    "accent": "#00fff5",
    "colors": ["#ff00ff", "#ff8c00", "#00ff00", "#00ffff", "#8c00ff", "#ff0066"]
  }
]
```

styles.css
```css
'''
DOCSTRING:
Base CSS for the Wheel of Names app.
Defines layout, basic theme variables, and responsive styles.
'''
:root{
  --bg: #ffffff;
  --text: #222222;
  --accent: #007bff;
  --panel-bg: #f6f8fa;
}
*{box-sizing:border-box}
html,body{
  height:100%;
  margin:0;
  font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
  background: var(--bg);
  color: var(--text);
}
.container{
  max-width:1100px;
  margin:24px auto;
  padding:16px;
}
header{ text-align:center; margin-bottom:8px }
h1{ margin:6px 0; font-size:28px }
p{ margin:0; color:var(--text); opacity:0.8 }
.main-grid{
  display:grid;
  grid-template-columns: 360px 1fr;
  gap:20px;
  align-items:start;
  margin-top:18px;
}
.left-panel{
  background:var(--panel-bg);
  padding:14px;
  border-radius:8px;
  box-shadow:0 4px 8px rgba(0,0,0,0.04);
}
.left-panel label{ display:block; margin-top:8px; font-weight:600; margin-bottom:6px }
.input-row{ display:flex; gap:8px }
.input-row input[type="text"]{
  flex:1;
  padding:8px 10px;
  border-radius:6px;
  border:1px solid #ddd;
}
.input-row button{
  padding:8px 12px;
  border-radius:6px;
  background:var(--accent);
  color:white;
  border:none;
  cursor:pointer;
}
textarea{
  width:100%;
  min-height:160px;
  padding:10px;
  border-radius:8px;
  border:1px solid #ddd;
  resize:vertical;
}
.buttons-row{
  display:flex;
  gap:8px;
  margin-top:8px;
  flex-wrap:wrap;
}
.buttons-row button{
  padding:8px 10px;
  border-radius:6px;
  border:1px solid #ccc;
  background:transparent;
  cursor:pointer;
}
.spin-controls{
  display:flex;
  gap:12px;
  margin-top:16px;
  align-items:center;
}
.spin{
  padding:14px 24px;
  background:var(--accent);
  color:white;
  font-weight:700;
  border:none;
  border-radius:10px;
  cursor:pointer;
  font-size:18px;
}
.result{
  padding:10px 12px;
  background:rgba(0,0,0,0.06);
  border-radius:8px;
}
.hidden{ display:none }
.right-panel{
  display:flex;
  align-items:center;
  justify-content:center;
  min-height:420px;
}
.wheel-wrapper{
  position:relative;
  width:600px;
  height:600px;
  display:flex;
  align-items:center;
  justify-content:center;
  margin:auto;
}
#wheel-canvas{
  border-radius:50%;
  box-shadow: 0 12px 30px rgba(0,0,0,0.12);
  background:transparent;
}
#wheel-wrapper #pointer{
  position:absolute;
  top:18px;
  left:50%;
  transform:translateX(-50%);
  font-size:40px;
  color:var(--accent);
  text-shadow:0 2px 4px rgba(0,0,0,0.2);
  pointer-events:none;
}
footer{ text-align:center; margin-top:16px; color:var(--text); opacity:0.7; }
/* Responsive */
@media (max-width:960px){
  .main-grid{ grid-template-columns:1fr; }
  .wheel-wrapper{ width:420px; height:420px; }
  #wheel-canvas{ width:420px; height:420px; }
}
```

wheel.js
```js
/*
'''
DOCSTRING:
wheel.js
Contains a Wheel class that draws the wheel on a canvas and animates spins.
Key methods:
- constructor(canvas, options)
- setNames(names)
- setTheme(theme)
- draw()
- spinToIndex(index) -> Promise resolves with index after animation
- getRandomIndex()
'''
*/
class Wheel {
  constructor(canvas, options = {}) {
    this.canvas = canvas;
    this.ctx = canvas.getContext('2d');
    this.names = options.names || [];
    this.colors = options.colors || ['#ffb3b3', '#ffd9b3', '#fff3b3', '#d9ffb3', '#b3ffd9', '#b3e6ff'];
    this.textColor = options.textColor || '#222';
    this.centerX = canvas.width / 2;
    this.centerY = canvas.height / 2;
    this.radius = Math.min(this.centerX, this.centerY) - 10;
    this.rotation = 0; // degrees
    this.font = options.font || '16px Inter, Arial';
    this.onDraw = options.onDraw || function(){};
    this._animating = false;
    this.draw();
  }
  setNames(names) {
    this.names = names.slice();
    this.draw();
  }
  setTheme(theme) {
    if (!theme) return;
    if (theme.colors && theme.colors.length) this.colors = theme.colors.slice();
    if (theme.text) this.textColor = theme.text;
    this.draw();
  }
  clearCanvas() {
    this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height);
  }
  draw() {
    this.clearCanvas();
    const ctx = this.ctx;
    const n = Math.max(1, this.names.length);
    const seg = 360 / n;
    ctx.save();
    ctx.translate(this.centerX, this.centerY);
    ctx.rotate(this.degToRad(this.rotation));
    // Draw segments
    for (let i = 0; i < n; i++) {
      const start = this.degToRad(i * seg);
      const end = this.degToRad((i + 1) * seg);
      ctx.beginPath();
      ctx.moveTo(0,0);
      ctx.arc(0,0,this.radius,start,end);
      ctx.closePath();
      ctx.fillStyle = this.colors[i % this.colors.length];
      ctx.fill();
      // stroke
      ctx.lineWidth = 2;
      ctx.strokeStyle = 'rgba(0,0,0,0.08)';
      ctx.stroke();
      // Draw label
      ctx.save();
      const angle = start + (end - start) / 2;
      ctx.rotate(angle);
      ctx.translate(this.radius * 0.55, 0);
      ctx.rotate(Math.PI / 2);
      ctx.fillStyle = this.textColor;
      ctx.font = this.font;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      const name = this.names[i] || '';
      this.wrapText(ctx, name, 0, 0, this.radius * 0.35, 18);
      ctx.restore();
    }
    ctx.restore();
    // center circle
    ctx.beginPath();
    ctx.arc(this.centerX, this.centerY, this.radius * 0.12, 0, Math.PI*2);
    ctx.fillStyle = '#ffffff';
    ctx.fill();
    ctx.lineWidth = 2;
    ctx.strokeStyle = 'rgba(0,0,0,0.06)';
    ctx.stroke();
    this.onDraw();
  }
  wrapText(ctx, text, x, y, maxWidth, lineHeight) {
    // A simple wrap for canvas text
    const words = text.split(' ');
    let line = '';
    let yOffset = y;
    for (let n = 0; n < words.length; n++) {
      const testLine = line + words[n] + ' ';
      const metrics = ctx.measureText(testLine);
      const testWidth = metrics.width;
      if (testWidth > maxWidth && n > 0) {
        ctx.fillText(line.trim(), x, yOffset);
        line = words[n] + ' ';
        yOffset += lineHeight;
      } else {
        line = testLine;
      }
    }
    ctx.fillText(line.trim(), x, yOffset);
  }
  degToRad(d) {
    return d * Math.PI / 180;
  }
  radToDeg(r) {
    return r * 180 / Math.PI;
  }
  getRandomIndex() {
    if (!this.names.length) return 0;
    return Math.floor(Math.random() * this.names.length);
  }
  // Spin such that the segment at `index` lands on the pointer at top.
  spinToIndex(index, opts = {}) {
    if (this._animating) return Promise.reject('Already animating');
    if (!this.names.length) return Promise.reject('No names');
    const n = this.names.length;
    const segAngle = 360 / n;
    // We want the center of target segment to be at angle 270deg (top of canvas - adjust if pointer is at top)
    // Our rotation variable rotates the whole wheel clockwise in degrees.
    // Compute the current rotation normalized
    const normalized = ((this.rotation % 360) + 360) % 360;
    // Calculate angle to place the segment center at top (270deg)
    // Center of segment i is at angle: (i * segAngle + segAngle/2)
    // We need rotation such that (centerAngle + rotation) mod 360 = 270
    const centerAngle = index * segAngle + segAngle / 2;
    // Solve for rotation target:
    let targetRotation = 270 - centerAngle;
    // Normalize to 0..360
    targetRotation = ((targetRotation % 360) + 360) % 360;
    // To produce multiple spins, add several full rotations:
    const fullSpins = opts.fullSpins !== undefined ? opts.fullSpins : (3 + Math.floor(Math.random()*3)); // 3-5 spins
    const endRotation = targetRotation + fullSpins * 360 + (opts.randomOffset || 0);
    // We'll animate from current normalized to endRotation, taking into account wrap
    const startRotation = normalized;
    const delta = endRotation - startRotation;
    const duration = opts.duration || 5000; // ms
    const startTime = performance.now();
    this._animating = true;
    return new Promise((resolve) => {
      const animate = (now) => {
        const elapsed = now - startTime;
        const t = Math.min(1, elapsed / duration);
        // ease out cubic
        const eased = 1 - Math.pow(1 - t, 3);
        const current = startRotation + delta * eased;
        this.rotation = current;
        this.draw();
        if (t < 1) {
          requestAnimationFrame(animate);
        } else {
          this._animating = false;
          // Normalize rotation to endRotation mod 360
          this.rotation = ((endRotation % 360) + 360) % 360;
          this.draw();
          resolve(index);
        }
      };
      requestAnimationFrame(animate);
    });
  }
}
```

main.js
```js
/*
'''
DOCSTRING:
main.js
Wires UI to the Wheel class:
- loads themes.json
- populates theme selector
- reads names and updates wheel
- handles spin logic and result display
'''
*/
document.addEventListener('DOMContentLoaded', async () => {
  const canvas = document.getElementById('wheel-canvas');
  const nameInput = document.getElementById('name-input');
  const addBtn = document.getElementById('add-name');
  const namesTextarea = document.getElementById('names-textarea');
  const spinBtn = document.getElementById('spin-btn');
  const resultDiv = document.getElementById('result');
  const themeSelect = document.getElementById('theme-select');
  const loadSampleBtn = document.getElementById('load-sample');
  const clearBtn = document.getElementById('clear-names');
  const importBtn = document.getElementById('import-names');
  const exportBtn = document.getElementById('export-names');
  const wheel = new Wheel(canvas, { names: [], colors: ['#ffb3b3','#ffd9b3','#fff3b3','#d9ffb3'] });
  let themes = [];
  // Load themes.json
  try {
    const resp = await fetch('/static/themes.json');
    themes = await resp.json();
    themes.forEach(t => {
      const opt = document.createElement('option');
      opt.value = t.id;
      opt.textContent = t.name;
      themeSelect.appendChild(opt);
    });
    // apply first theme
    applyTheme(themes[0]);
    themeSelect.value = themes[0].id;
  } catch (err) {
    console.error('Failed to load themes:', err);
  }
  function applyTheme(theme) {
    if (!theme) return;
    document.documentElement.style.setProperty('--bg', theme.bg || '#fff');
    document.documentElement.style.setProperty('--text', theme.text || '#222');
    document.documentElement.style.setProperty('--accent', theme.accent || '#007bff');
    // set panel bg slightly adjusted
    let panelBg = theme.bg;
    // simple luminance tweak
    try {
      panelBg = lightenOrDarkenColor(theme.bg || '#fff', 96);
    } catch(e) {
      panelBg = '#f6f8fa';
    }
    document.documentElement.style.setProperty('--panel-bg', panelBg);
    wheel.setTheme({ colors: theme.colors || [], text: theme.text || '#222' });
  }
  function lightenOrDarkenColor(col, amt) {
    // expects #rrggbb
    let usePound = false;
    if (col[0] === "#") {
      col = col.slice(1);
      usePound = true;
    }
    const num = parseInt(col,16);
    let r = (num >> 16) + amt;
    let b = ((num >> 8) & 0x00FF) + amt;
    let g = (num & 0x0000FF) + amt;
    r = Math.max(Math.min(255, r), 0);
    b = Math.max(Math.min(255, b), 0);
    g = Math.max(Math.min(255, g), 0);
    return (usePound ? "#" : "") + (g | (b << 8) | (r << 16)).toString(16).padStart(6, '0');
  }
  themeSelect.addEventListener('change', () => {
    const id = themeSelect.value;
    const t = themes.find(x => x.id === id);
    if (t) applyTheme(t);
  });
  function parseNamesFromTextarea() {
    const lines = namesTextarea.value.split('\n').map(s => s.trim()).filter(s => s.length);
    return lines;
  }
  function updateWheelFromTextarea() {
    const names = parseNamesFromTextarea();
    wheel.setNames(names);
  }
  addBtn.addEventListener('click', () => {
    const v = nameInput.value.trim();
    if (!v) return;
    const cur = parseNamesFromTextarea();
    cur.push(v);
    namesTextarea.value = cur.join('\n');
    nameInput.value = '';
    updateWheelFromTextarea();
  });
  nameInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
      addBtn.click();
      e.preventDefault();
    }
  });
  namesTextarea.addEventListener('input', () => {
    updateWheelFromTextarea();
  });
  loadSampleBtn.addEventListener('click', () => {
    const sample = ['Alice','Bob','Charlie','Diana','Eva','Frank','George','Helen','Ivy','Jack'];
    namesTextarea.value = sample.join('\n');
    updateWheelFromTextarea();
  });
  clearBtn.addEventListener('click', () => {
    namesTextarea.value = '';
    updateWheelFromTextarea();
    resultDiv.classList.add('hidden');
  });
  importBtn.addEventListener('click', async () => {
    // prompt user for a newline separated list (simple)
    const data = prompt('Paste names (one per line):');
    if (data === null) return;
    namesTextarea.value = data.split('\n').map(s => s.trim()).filter(s => s).join('\n');
    updateWheelFromTextarea();
  });
  exportBtn.addEventListener('click', () => {
    const names = parseNamesFromTextarea();
    const blob = new Blob([names.join('\n')], {type: 'text/plain'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'names.txt';
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  });
  spinBtn.addEventListener('click', async () => {
    const names = parseNamesFromTextarea();
    if (names.length === 0) {
      alert('Please add at least one name.');
      return;
    }
    resultDiv.classList.add('hidden');
    spinBtn.disabled = true;
    spinBtn.textContent = 'Spinning...';
    // pick random index
    const idx = wheel.getRandomIndex();
    try {
      const winnerIndex = await wheel.spinToIndex(idx, { duration: 4500 });
      const winner = names[winnerIndex];
      resultDiv.textContent = `Winner: ${winner}`;
      resultDiv.classList.remove('hidden');
      spinBtn.textContent = 'SPIN';
      spinBtn.disabled = false;
    } catch (err) {
      console.error(err);
      spinBtn.textContent = 'SPIN';
      spinBtn.disabled = false;
    }
  });
  // initial sample
  namesTextarea.value = 'Alice\nBob\nCharlie\nDiana\nEva';
  updateWheelFromTextarea();
});
```

"
Comments on Codes:
"<PRIORITY> High â€” hardcoded static path for themes.json will break deployments mounted under a URL prefix (and can fail in some deployment configs)

Why this is important
- main.js currently calls fetch('/static/themes.json') using an absolute path starting with '/'. That works for a development server at the site root, but will fail if:
  - the Flask app is mounted under a subpath (example: https://example.com/myapp/), or
  - static_url_path / static_folder are customized, or
  - the app is reverse-proxied to a different prefix.
- If themes.json fails to load, theme selector is empty and the theme application will not work â€” a core feature per the requirements ("possibility of choose a variety of themes").

How to fix (recommended)
- Let Flask generate the correct URL for themes.json via url_for and make that value available to the client-side code. The simplest, robust approach is to inject a small inline script into your Jinja template that sets a global variable with the correct static URL. Then change main.js to use that variable when fetching themes.

Concrete code changes

1) In templates/index.html, add an inline script (place it before including main.js/wheel.js). Example insertion (replace/add inside <body> before your script tags):

  <script>
    // Provide the correct URL for themes.json (generated by Flask)
    window.THEMES_JSON_URL = "{{ url_for('static', filename='themes.json') }}";
  </script>

(You already use url_for for CSS/JS; do the same for the JSON file.)

2) In static/js/main.js, change the theme fetch to use the injected URL instead of the hardcoded path. Replace:

  const resp = await fetch('/static/themes.json');

with:

  const themesUrl = window.THEMES_JSON_URL || '/static/themes.json';
  const resp = await fetch(themesUrl);

(Keeping the fallback to '/static/themes.json' is harmless for local dev but not relied upon for production.)

3) (Optional but recommended) Add a robust fallback if fetch fails (already somewhat done with try/catch). Consider pre-bundling a small defaultThemes array in main.js so the UI still works if fetch fails.

Example combined snippet for main.js:

  // Load themes.json (URL injected by Flask)
  try {
    const themesUrl = window.THEMES_JSON_URL || '/static/themes.json';
    const resp = await fetch(themesUrl);
    if (!resp.ok) throw new Error('HTTP ' + resp.status);
    themes = await resp.json();
    // ... populate selector ...
  } catch (err) {
    console.error('Failed to load themes:', err);
    // fallback: define a minimal default theme so UI still works
    themes = [{
      id: 'fallback',
      name: 'Default',
      bg: '#ffffff',
      text: '#222222',
      accent: '#007bff',
      colors: ['#ffb3b3','#ffd9b3','#fff3b3','#d9ffb3']
    }];
    // populate selector with fallback theme
  }

Why this change fixes it
- url_for builds the correct static URL no matter where the app is mounted or how Flask is configured. Injecting that into the page ensures client-side fetch always targets the actual resource location.

Extra suggestion (non-blocking)
- Consider making lightenOrDarkenColor more robust (support shorthand hex like #fff, handle edge cases) as a follow-up. It currently works for typical 6-digit hexes, but solidifying it will improve theme rendering in edge cases.

If you want, I can produce the exact patch (diff) for index.html and main.js."
In the software, each file must strictly follow a markdown code block format, where the following tokens must be replaced such that "FILENAME" is the lowercase file name including the file extension, "LANGUAGE" in the programming language, "DOCSTRING" is a string literal specified in source code that is used to document a specific segment of code, and "CODE" is the original code. Format:
FILENAME
```LANGUAGE
'''
DOCSTRING
'''
CODE
```
As the Programmer, to satisfy the new user's demand and make the software creative, executive and robust, you should modify corresponding codes according to the comments. Then, output the full and complete codes with all bugs fixed based on the comments. Return all codes strictly following the required format.

[2025-17-09 14:02:51 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2025-17-09 14:02:51 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 6347
completion_tokens: 6747
total_tokens: 13094
cost: $-1.000000


[2025-17-09 14:02:51 INFO] Programmer: **Programmer<->Code Reviewer on : CodeReviewModification, turn 0**

[ChatDev is a software company powered by multiple intelligent agents, such as chief executive officer, chief human resources officer, chief product officer, chief technology officer, etc, with a multi-agent organizational structure and the mission of 'changing the digital world through programming'.
You are Code Reviewer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer.
You can help programmers to assess source codes for software troubleshooting, fix bugs to increase code quality and robustness, and offer proposals to improve the source codes.
Here is a new customer's task: [Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes.].
To complete the task, you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]

main.py
```python
'''
Flask application that serves the wheel-of-names web app.
Run: pip install flask
Then: python main.py
Access: http://127.0.0.1:5000/
'''
from flask import Flask, render_template
import os

def create_app():
    """
    Create and configure the Flask application.
    """
    app = Flask(__name__, static_folder='static', template_folder='templates')

    @app.route('/')
    def index():
        """
        Serve the main page.
        """
        return render_template('index.html')

    return app

if __name__ == '__main__':
    app = create_app()
    port = int(os.environ.get('PORT', 5000))
    app.run(debug=True, host='0.0.0.0', port=port)
```

index.html
```html
'''
DOCSTRING:
Main HTML page for the Wheel of Names app.
Contains UI elements:
- name input and list
- canvas for wheel
- theme selector
- spin / clear / add buttons
Includes JS files wheel.js and main.js for behavior.
Also injects a dynamically generated URL for themes.json using Flask's url_for so the client can reliably fetch the resource even when the app is mounted under a subpath.
'''
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Wheel of Names</title>
  <link rel="stylesheet" href="{{ url_for('static', filename='css/styles.css') }}">
</head>
<body>
  <div class="container">
    <header>
      <h1>Wheel of Names</h1>
      <p>Enter names, choose a theme, and spin to pick a random winner.</p>
    </header>
    <main class="main-grid">
      <section class="left-panel">
        <div class="controls">
          <label for="name-input">Add a name</label>
          <div class="input-row">
            <input id="name-input" type="text" placeholder="Enter name and press Add" autocomplete="off">
            <button id="add-name">Add</button>
          </div>
          <label for="names-textarea">Names (one per line)</label>
          <textarea id="names-textarea" placeholder="Alice\nBob\nCharlie"></textarea>
          <div class="buttons-row">
            <button id="load-sample">Load Sample</button>
            <button id="clear-names">Clear</button>
            <button id="import-names">Import</button>
            <button id="export-names">Export</button>
          </div>
          <label for="theme-select">Theme</label>
          <select id="theme-select"></select>
          <div class="spin-controls">
            <button id="spin-btn" class="spin">SPIN</button>
            <div id="result" class="result hidden"></div>
          </div>
        </div>
      </section>
      <section class="right-panel">
        <div class="wheel-wrapper" id="wheel-wrapper">
          <canvas id="wheel-canvas" width="600" height="600"></canvas>
          <div id="pointer">â–¼</div>
        </div>
      </section>
    </main>
    <footer>
      <small>Built with Flask + Canvas. Themes available.</small>
    </footer>
  </div>

  <!-- Provide the correct URL for themes.json (generated by Flask).
       This ensures the client can fetch themes.json even when the app is mounted under a prefix. -->
  <script>
    window.THEMES_JSON_URL = "{{ url_for('static', filename='themes.json') }}";
  </script>

  <script src="{{ url_for('static', filename='js/wheel.js') }}"></script>
  <script src="{{ url_for('static', filename='js/main.js') }}"></script>
</body>
</html>
```

themes.json
```json
'''
DOCSTRING:
List of themes available for the wheel.
Each theme contains:
- name: display name
- bg: page background color
- text: primary text color
- accent: accent color used for pointer/button
- colors: array of segment colors (will be cycled for segments)
'''
[
  {
    "id": "classic",
    "name": "Classic",
    "bg": "#ffffff",
    "text": "#222222",
    "accent": "#007bff",
    "colors": ["#ffb3b3", "#ffd9b3", "#fff3b3", "#d9ffb3", "#b3ffd9", "#b3e6ff", "#c7b3ff", "#ffb3f2"]
  },
  {
    "id": "dark",
    "name": "Dark",
    "bg": "#121212",
    "text": "#f5f5f5",
    "accent": "#ff6b6b",
    "colors": ["#2e2e34", "#3a3a44", "#4a4a56", "#5a5a68", "#6a6a78", "#7a7a88"]
  },
  {
    "id": "pastel",
    "name": "Pastel",
    "bg": "#f7f7ff",
    "text": "#333333",
    "accent": "#ff8c94",
    "colors": ["#ffd1dc", "#fce1b4", "#e8ffd1", "#d1fff0", "#d1e7ff", "#e6d1ff"]
  },
  {
    "id": "neon",
    "name": "Neon",
    "bg": "#0f0f13",
    "text": "#eaff00",
    "accent": "#00fff5",
    "colors": ["#ff00ff", "#ff8c00", "#00ff00", "#00ffff", "#8c00ff", "#ff0066"]
  }
]
```

styles.css
```css
'''
DOCSTRING:
Base CSS for the Wheel of Names app.
Defines layout, basic theme variables, and responsive styles.
'''
:root{
  --bg: #ffffff;
  --text: #222222;
  --accent: #007bff;
  --panel-bg: #f6f8fa;
}
*{box-sizing:border-box}
html,body{
  height:100%;
  margin:0;
  font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
  background: var(--bg);
  color: var(--text);
}
.container{
  max-width:1100px;
  margin:24px auto;
  padding:16px;
}
header{ text-align:center; margin-bottom:8px }
h1{ margin:6px 0; font-size:28px }
p{ margin:0; color:var(--text); opacity:0.8 }
.main-grid{
  display:grid;
  grid-template-columns: 360px 1fr;
  gap:20px;
  align-items:start;
  margin-top:18px;
}
.left-panel{
  background:var(--panel-bg);
  padding:14px;
  border-radius:8px;
  box-shadow:0 4px 8px rgba(0,0,0,0.04);
}
.left-panel label{ display:block; margin-top:8px; font-weight:600; margin-bottom:6px }
.input-row{ display:flex; gap:8px }
.input-row input[type="text"]{
  flex:1;
  padding:8px 10px;
  border-radius:6px;
  border:1px solid #ddd;
}
.input-row button{
  padding:8px 12px;
  border-radius:6px;
  background:var(--accent);
  color:white;
  border:none;
  cursor:pointer;
}
textarea{
  width:100%;
  min-height:160px;
  padding:10px;
  border-radius:8px;
  border:1px solid #ddd;
  resize:vertical;
}
.buttons-row{
  display:flex;
  gap:8px;
  margin-top:8px;
  flex-wrap:wrap;
}
.buttons-row button{
  padding:8px 10px;
  border-radius:6px;
  border:1px solid #ccc;
  background:transparent;
  cursor:pointer;
}
.spin-controls{
  display:flex;
  gap:12px;
  margin-top:16px;
  align-items:center;
}
.spin{
  padding:14px 24px;
  background:var(--accent);
  color:white;
  font-weight:700;
  border:none;
  border-radius:10px;
  cursor:pointer;
  font-size:18px;
}
.result{
  padding:10px 12px;
  background:rgba(0,0,0,0.06);
  border-radius:8px;
}
.hidden{ display:none }
.right-panel{
  display:flex;
  align-items:center;
  justify-content:center;
  min-height:420px;
}
.wheel-wrapper{
  position:relative;
  width:600px;
  height:600px;
  display:flex;
  align-items:center;
  justify-content:center;
  margin:auto;
}
#wheel-canvas{
  border-radius:50%;
  box-shadow: 0 12px 30px rgba(0,0,0,0.12);
  background:transparent;
}
#wheel-wrapper #pointer{
  position:absolute;
  top:18px;
  left:50%;
  transform:translateX(-50%);
  font-size:40px;
  color:var(--accent);
  text-shadow:0 2px 4px rgba(0,0,0,0.2);
  pointer-events:none;
}
footer{ text-align:center; margin-top:16px; color:var(--text); opacity:0.7; }
/* Responsive */
@media (max-width:960px){
  .main-grid{ grid-template-columns:1fr; }
  .wheel-wrapper{ width:420px; height:420px; }
  #wheel-canvas{ width:420px; height:420px; }
}
```

wheel.js
```js
/*
'''
DOCSTRING:
wheel.js
Contains a Wheel class that draws the wheel on a canvas and animates spins.
Key methods:
- constructor(canvas, options)
- setNames(names)
- setTheme(theme)
- draw()
- spinToIndex(index) -> Promise resolves with index after animation
- getRandomIndex()
'''
*/
class Wheel {
  constructor(canvas, options = {}) {
    this.canvas = canvas;
    this.ctx = canvas.getContext('2d');
    this.names = options.names || [];
    this.colors = options.colors || ['#ffb3b3', '#ffd9b3', '#fff3b3', '#d9ffb3', '#b3ffd9', '#b3e6ff'];
    this.textColor = options.textColor || '#222';
    this.centerX = canvas.width / 2;
    this.centerY = canvas.height / 2;
    this.radius = Math.min(this.centerX, this.centerY) - 10;
    this.rotation = 0; // degrees
    this.font = options.font || '16px Inter, Arial';
    this.onDraw = options.onDraw || function(){};
    this._animating = false;
    this.draw();
  }
  setNames(names) {
    this.names = names.slice();
    this.draw();
  }
  setTheme(theme) {
    if (!theme) return;
    if (theme.colors && theme.colors.length) this.colors = theme.colors.slice();
    if (theme.text) this.textColor = theme.text;
    this.draw();
  }
  clearCanvas() {
    this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height);
  }
  draw() {
    this.clearCanvas();
    const ctx = this.ctx;
    const n = Math.max(1, this.names.length);
    const seg = 360 / n;
    ctx.save();
    ctx.translate(this.centerX, this.centerY);
    ctx.rotate(this.degToRad(this.rotation));
    // Draw segments
    for (let i = 0; i < n; i++) {
      const start = this.degToRad(i * seg);
      const end = this.degToRad((i + 1) * seg);
      ctx.beginPath();
      ctx.moveTo(0,0);
      ctx.arc(0,0,this.radius,start,end);
      ctx.closePath();
      ctx.fillStyle = this.colors[i % this.colors.length];
      ctx.fill();
      // stroke
      ctx.lineWidth = 2;
      ctx.strokeStyle = 'rgba(0,0,0,0.08)';
      ctx.stroke();
      // Draw label
      ctx.save();
      const angle = start + (end - start) / 2;
      ctx.rotate(angle);
      ctx.translate(this.radius * 0.55, 0);
      ctx.rotate(Math.PI / 2);
      ctx.fillStyle = this.textColor;
      ctx.font = this.font;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      const name = this.names[i] || '';
      this.wrapText(ctx, name, 0, 0, this.radius * 0.35, 18);
      ctx.restore();
    }
    ctx.restore();
    // center circle
    ctx.beginPath();
    ctx.arc(this.centerX, this.centerY, this.radius * 0.12, 0, Math.PI*2);
    ctx.fillStyle = '#ffffff';
    ctx.fill();
    ctx.lineWidth = 2;
    ctx.strokeStyle = 'rgba(0,0,0,0.06)';
    ctx.stroke();
    this.onDraw();
  }
  wrapText(ctx, text, x, y, maxWidth, lineHeight) {
    // A simple wrap for canvas text
    const words = text.split(' ');
    let line = '';
    let yOffset = y;
    for (let n = 0; n < words.length; n++) {
      const testLine = line + words[n] + ' ';
      const metrics = ctx.measureText(testLine);
      const testWidth = metrics.width;
      if (testWidth > maxWidth && n > 0) {
        ctx.fillText(line.trim(), x, yOffset);
        line = words[n] + ' ';
        yOffset += lineHeight;
      } else {
        line = testLine;
      }
    }
    ctx.fillText(line.trim(), x, yOffset);
  }
  degToRad(d) {
    return d * Math.PI / 180;
  }
  radToDeg(r) {
    return r * 180 / Math.PI;
  }
  getRandomIndex() {
    if (!this.names.length) return 0;
    return Math.floor(Math.random() * this.names.length);
  }
  // Spin such that the segment at `index` lands on the pointer at top.
  spinToIndex(index, opts = {}) {
    if (this._animating) return Promise.reject('Already animating');
    if (!this.names.length) return Promise.reject('No names');
    const n = this.names.length;
    const segAngle = 360 / n;
    // We want the center of target segment to be at angle 270deg (top of canvas - adjust if pointer is at top)
    // Our rotation variable rotates the whole wheel clockwise in degrees.
    // Compute the current rotation normalized
    const normalized = ((this.rotation % 360) + 360) % 360;
    // Calculate angle to place the segment center at top (270deg)
    // Center of segment i is at angle: (i * segAngle + segAngle/2)
    // We need rotation such that (centerAngle + rotation) mod 360 = 270
    const centerAngle = index * segAngle + segAngle / 2;
    // Solve for rotation target:
    let targetRotation = 270 - centerAngle;
    // Normalize to 0..360
    targetRotation = ((targetRotation % 360) + 360) % 360;
    // To produce multiple spins, add several full rotations:
    const fullSpins = opts.fullSpins !== undefined ? opts.fullSpins : (3 + Math.floor(Math.random()*3)); // 3-5 spins
    const endRotation = targetRotation + fullSpins * 360 + (opts.randomOffset || 0);
    // We'll animate from current normalized to endRotation, taking into account wrap
    const startRotation = normalized;
    const delta = endRotation - startRotation;
    const duration = opts.duration || 5000; // ms
    const startTime = performance.now();
    this._animating = true;
    return new Promise((resolve) => {
      const animate = (now) => {
        const elapsed = now - startTime;
        const t = Math.min(1, elapsed / duration);
        // ease out cubic
        const eased = 1 - Math.pow(1 - t, 3);
        const current = startRotation + delta * eased;
        this.rotation = current;
        this.draw();
        if (t < 1) {
          requestAnimationFrame(animate);
        } else {
          this._animating = false;
          // Normalize rotation to endRotation mod 360
          this.rotation = ((endRotation % 360) + 360) % 360;
          this.draw();
          resolve(index);
        }
      };
      requestAnimationFrame(animate);
    });
  }
}
```

main.js
```js
/*
'''
DOCSTRING:
main.js
Wires UI to the Wheel class:
- loads themes.json (URL injected by Flask)
- populates theme selector
- reads names and updates wheel
- handles spin logic and result display
Includes robust fallback if fetching themes.json fails.
'''
*/
document.addEventListener('DOMContentLoaded', async () => {
  const canvas = document.getElementById('wheel-canvas');
  const nameInput = document.getElementById('name-input');
  const addBtn = document.getElementById('add-name');
  const namesTextarea = document.getElementById('names-textarea');
  const spinBtn = document.getElementById('spin-btn');
  const resultDiv = document.getElementById('result');
  const themeSelect = document.getElementById('theme-select');
  const loadSampleBtn = document.getElementById('load-sample');
  const clearBtn = document.getElementById('clear-names');
  const importBtn = document.getElementById('import-names');
  const exportBtn = document.getElementById('export-names');
  const wheel = new Wheel(canvas, { names: [], colors: ['#ffb3b3','#ffd9b3','#fff3b3','#d9ffb3'] });
  let themes = [];

  // A small fallback theme set in case fetching themes.json fails.
  const defaultThemes = [
    {
      id: 'fallback',
      name: 'Default',
      bg: '#ffffff',
      text: '#222222',
      accent: '#007bff',
      colors: ['#ffb3b3','#ffd9b3','#fff3b3','#d9ffb3']
    }
  ];

  // Helper to populate theme selector
  function populateThemeSelector(list) {
    themeSelect.innerHTML = '';
    list.forEach(t => {
      const opt = document.createElement('option');
      opt.value = t.id;
      opt.textContent = t.name;
      themeSelect.appendChild(opt);
    });
  }

  // Load themes.json (URL injected by Flask)
  try {
    const themesUrl = window.THEMES_JSON_URL || '/static/themes.json';
    const resp = await fetch(themesUrl);
    if (!resp.ok) throw new Error('HTTP ' + resp.status);
    themes = await resp.json();
    if (!Array.isArray(themes) || themes.length === 0) throw new Error('No themes found');
    populateThemeSelector(themes);
    // apply first theme
    applyTheme(themes[0]);
    themeSelect.value = themes[0].id;
  } catch (err) {
    console.error('Failed to load themes:', err);
    // fallback
    themes = defaultThemes;
    populateThemeSelector(themes);
    applyTheme(themes[0]);
    themeSelect.value = themes[0].id;
  }

  function applyTheme(theme) {
    if (!theme) return;
    document.documentElement.style.setProperty('--bg', theme.bg || '#fff');
    document.documentElement.style.setProperty('--text', theme.text || '#222');
    document.documentElement.style.setProperty('--accent', theme.accent || '#007bff');
    // set panel bg slightly adjusted
    let panelBg = theme.bg;
    // robust luminance tweak (supports 3/6 digit hex)
    try {
      panelBg = lightenOrDarkenColor(theme.bg || '#fff', 18);
    } catch(e) {
      panelBg = '#f6f8fa';
    }
    document.documentElement.style.setProperty('--panel-bg', panelBg);
    wheel.setTheme({ colors: theme.colors || [], text: theme.text || '#222' });
  }

  function lightenOrDarkenColor(col, amt) {
    // accepts #rgb or #rrggbb. amt can be negative to darken.
    if (typeof col !== 'string') throw new Error('Invalid color');
    let colStr = col.trim();
    if (colStr[0] === '#') colStr = colStr.slice(1);
    if (colStr.length === 3) {
      colStr = colStr.split('').map(c => c + c).join('');
    }
    if (colStr.length !== 6) throw new Error('Invalid hex color');
    const num = parseInt(colStr, 16);
    let r = (num >> 16) & 0xFF;
    let g = (num >> 8) & 0xFF;
    let b = num & 0xFF;
    r = Math.max(0, Math.min(255, r + amt));
    g = Math.max(0, Math.min(255, g + amt));
    b = Math.max(0, Math.min(255, b + amt));
    const newHex = '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
    return newHex;
  }

  themeSelect.addEventListener('change', () => {
    const id = themeSelect.value;
    const t = themes.find(x => x.id === id);
    if (t) applyTheme(t);
  });

  function parseNamesFromTextarea() {
    const lines = namesTextarea.value.split('\n').map(s => s.trim()).filter(s => s.length);
    return lines;
  }

  function updateWheelFromTextarea() {
    const names = parseNamesFromTextarea();
    wheel.setNames(names);
  }

  addBtn.addEventListener('click', () => {
    const v = nameInput.value.trim();
    if (!v) return;
    const cur = parseNamesFromTextarea();
    cur.push(v);
    namesTextarea.value = cur.join('\n');
    nameInput.value = '';
    updateWheelFromTextarea();
  });

  nameInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
      addBtn.click();
      e.preventDefault();
    }
  });

  namesTextarea.addEventListener('input', () => {
    updateWheelFromTextarea();
  });

  loadSampleBtn.addEventListener('click', () => {
    const sample = ['Alice','Bob','Charlie','Diana','Eva','Frank','George','Helen','Ivy','Jack'];
    namesTextarea.value = sample.join('\n');
    updateWheelFromTextarea();
  });

  clearBtn.addEventListener('click', () => {
    namesTextarea.value = '';
    updateWheelFromTextarea();
    resultDiv.classList.add('hidden');
  });

  importBtn.addEventListener('click', async () => {
    // prompt user for a newline separated list (simple)
    const data = prompt('Paste names (one per line):');
    if (data === null) return;
    namesTextarea.value = data.split('\n').map(s => s.trim()).filter(s => s).join('\n');
    updateWheelFromTextarea();
  });

  exportBtn.addEventListener('click', () => {
    const names = parseNamesFromTextarea();
    const blob = new Blob([names.join('\n')], {type: 'text/plain'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'names.txt';
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  });

  spinBtn.addEventListener('click', async () => {
    const names = parseNamesFromTextarea();
    if (names.length === 0) {
      alert('Please add at least one name.');
      return;
    }
    resultDiv.classList.add('hidden');
    spinBtn.disabled = true;
    spinBtn.textContent = 'Spinning...';
    // pick random index
    const idx = wheel.getRandomIndex();
    try {
      const winnerIndex = await wheel.spinToIndex(idx, { duration: 4500 });
      const winner = names[winnerIndex];
      resultDiv.textContent = `Winner: ${winner}`;
      resultDiv.classList.remove('hidden');
      spinBtn.textContent = 'SPIN';
      spinBtn.disabled = false;
    } catch (err) {
      console.error(err);
      spinBtn.textContent = 'SPIN';
      spinBtn.disabled = false;
    }
  });

  // initial sample
  namesTextarea.value = 'Alice\nBob\nCharlie\nDiana\nEva';
  updateWheelFromTextarea();
});
```

[2025-17-09 14:02:51 INFO] **[Seminar Conclusion]**:

 main.py
```python
'''
Flask application that serves the wheel-of-names web app.
Run: pip install flask
Then: python main.py
Access: http://127.0.0.1:5000/
'''
from flask import Flask, render_template
import os

def create_app():
    """
    Create and configure the Flask application.
    """
    app = Flask(__name__, static_folder='static', template_folder='templates')

    @app.route('/')
    def index():
        """
        Serve the main page.
        """
        return render_template('index.html')

    return app

if __name__ == '__main__':
    app = create_app()
    port = int(os.environ.get('PORT', 5000))
    app.run(debug=True, host='0.0.0.0', port=port)
```

index.html
```html
'''
DOCSTRING:
Main HTML page for the Wheel of Names app.
Contains UI elements:
- name input and list
- canvas for wheel
- theme selector
- spin / clear / add buttons
Includes JS files wheel.js and main.js for behavior.
Also injects a dynamically generated URL for themes.json using Flask's url_for so the client can reliably fetch the resource even when the app is mounted under a subpath.
'''
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Wheel of Names</title>
  <link rel="stylesheet" href="{{ url_for('static', filename='css/styles.css') }}">
</head>
<body>
  <div class="container">
    <header>
      <h1>Wheel of Names</h1>
      <p>Enter names, choose a theme, and spin to pick a random winner.</p>
    </header>
    <main class="main-grid">
      <section class="left-panel">
        <div class="controls">
          <label for="name-input">Add a name</label>
          <div class="input-row">
            <input id="name-input" type="text" placeholder="Enter name and press Add" autocomplete="off">
            <button id="add-name">Add</button>
          </div>
          <label for="names-textarea">Names (one per line)</label>
          <textarea id="names-textarea" placeholder="Alice\nBob\nCharlie"></textarea>
          <div class="buttons-row">
            <button id="load-sample">Load Sample</button>
            <button id="clear-names">Clear</button>
            <button id="import-names">Import</button>
            <button id="export-names">Export</button>
          </div>
          <label for="theme-select">Theme</label>
          <select id="theme-select"></select>
          <div class="spin-controls">
            <button id="spin-btn" class="spin">SPIN</button>
            <div id="result" class="result hidden"></div>
          </div>
        </div>
      </section>
      <section class="right-panel">
        <div class="wheel-wrapper" id="wheel-wrapper">
          <canvas id="wheel-canvas" width="600" height="600"></canvas>
          <div id="pointer">â–¼</div>
        </div>
      </section>
    </main>
    <footer>
      <small>Built with Flask + Canvas. Themes available.</small>
    </footer>
  </div>

  <!-- Provide the correct URL for themes.json (generated by Flask).
       This ensures the client can fetch themes.json even when the app is mounted under a prefix. -->
  <script>
    window.THEMES_JSON_URL = "{{ url_for('static', filename='themes.json') }}";
  </script>

  <script src="{{ url_for('static', filename='js/wheel.js') }}"></script>
  <script src="{{ url_for('static', filename='js/main.js') }}"></script>
</body>
</html>
```

themes.json
```json
'''
DOCSTRING:
List of themes available for the wheel.
Each theme contains:
- name: display name
- bg: page background color
- text: primary text color
- accent: accent color used for pointer/button
- colors: array of segment colors (will be cycled for segments)
'''
[
  {
    "id": "classic",
    "name": "Classic",
    "bg": "#ffffff",
    "text": "#222222",
    "accent": "#007bff",
    "colors": ["#ffb3b3", "#ffd9b3", "#fff3b3", "#d9ffb3", "#b3ffd9", "#b3e6ff", "#c7b3ff", "#ffb3f2"]
  },
  {
    "id": "dark",
    "name": "Dark",
    "bg": "#121212",
    "text": "#f5f5f5",
    "accent": "#ff6b6b",
    "colors": ["#2e2e34", "#3a3a44", "#4a4a56", "#5a5a68", "#6a6a78", "#7a7a88"]
  },
  {
    "id": "pastel",
    "name": "Pastel",
    "bg": "#f7f7ff",
    "text": "#333333",
    "accent": "#ff8c94",
    "colors": ["#ffd1dc", "#fce1b4", "#e8ffd1", "#d1fff0", "#d1e7ff", "#e6d1ff"]
  },
  {
    "id": "neon",
    "name": "Neon",
    "bg": "#0f0f13",
    "text": "#eaff00",
    "accent": "#00fff5",
    "colors": ["#ff00ff", "#ff8c00", "#00ff00", "#00ffff", "#8c00ff", "#ff0066"]
  }
]
```

styles.css
```css
'''
DOCSTRING:
Base CSS for the Wheel of Names app.
Defines layout, basic theme variables, and responsive styles.
'''
:root{
  --bg: #ffffff;
  --text: #222222;
  --accent: #007bff;
  --panel-bg: #f6f8fa;
}
*{box-sizing:border-box}
html,body{
  height:100%;
  margin:0;
  font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
  background: var(--bg);
  color: var(--text);
}
.container{
  max-width:1100px;
  margin:24px auto;
  padding:16px;
}
header{ text-align:center; margin-bottom:8px }
h1{ margin:6px 0; font-size:28px }
p{ margin:0; color:var(--text); opacity:0.8 }
.main-grid{
  display:grid;
  grid-template-columns: 360px 1fr;
  gap:20px;
  align-items:start;
  margin-top:18px;
}
.left-panel{
  background:var(--panel-bg);
  padding:14px;
  border-radius:8px;
  box-shadow:0 4px 8px rgba(0,0,0,0.04);
}
.left-panel label{ display:block; margin-top:8px; font-weight:600; margin-bottom:6px }
.input-row{ display:flex; gap:8px }
.input-row input[type="text"]{
  flex:1;
  padding:8px 10px;
  border-radius:6px;
  border:1px solid #ddd;
}
.input-row button{
  padding:8px 12px;
  border-radius:6px;
  background:var(--accent);
  color:white;
  border:none;
  cursor:pointer;
}
textarea{
  width:100%;
  min-height:160px;
  padding:10px;
  border-radius:8px;
  border:1px solid #ddd;
  resize:vertical;
}
.buttons-row{
  display:flex;
  gap:8px;
  margin-top:8px;
  flex-wrap:wrap;
}
.buttons-row button{
  padding:8px 10px;
  border-radius:6px;
  border:1px solid #ccc;
  background:transparent;
  cursor:pointer;
}
.spin-controls{
  display:flex;
  gap:12px;
  margin-top:16px;
  align-items:center;
}
.spin{
  padding:14px 24px;
  background:var(--accent);
  color:white;
  font-weight:700;
  border:none;
  border-radius:10px;
  cursor:pointer;
  font-size:18px;
}
.result{
  padding:10px 12px;
  background:rgba(0,0,0,0.06);
  border-radius:8px;
}
.hidden{ display:none }
.right-panel{
  display:flex;
  align-items:center;
  justify-content:center;
  min-height:420px;
}
.wheel-wrapper{
  position:relative;
  width:600px;
  height:600px;
  display:flex;
  align-items:center;
  justify-content:center;
  margin:auto;
}
#wheel-canvas{
  border-radius:50%;
  box-shadow: 0 12px 30px rgba(0,0,0,0.12);
  background:transparent;
}
#wheel-wrapper #pointer{
  position:absolute;
  top:18px;
  left:50%;
  transform:translateX(-50%);
  font-size:40px;
  color:var(--accent);
  text-shadow:0 2px 4px rgba(0,0,0,0.2);
  pointer-events:none;
}
footer{ text-align:center; margin-top:16px; color:var(--text); opacity:0.7; }
/* Responsive */
@media (max-width:960px){
  .main-grid{ grid-template-columns:1fr; }
  .wheel-wrapper{ width:420px; height:420px; }
  #wheel-canvas{ width:420px; height:420px; }
}
```

wheel.js
```js
/*
'''
DOCSTRING:
wheel.js
Contains a Wheel class that draws the wheel on a canvas and animates spins.
Key methods:
- constructor(canvas, options)
- setNames(names)
- setTheme(theme)
- draw()
- spinToIndex(index) -> Promise resolves with index after animation
- getRandomIndex()
'''
*/
class Wheel {
  constructor(canvas, options = {}) {
    this.canvas = canvas;
    this.ctx = canvas.getContext('2d');
    this.names = options.names || [];
    this.colors = options.colors || ['#ffb3b3', '#ffd9b3', '#fff3b3', '#d9ffb3', '#b3ffd9', '#b3e6ff'];
    this.textColor = options.textColor || '#222';
    this.centerX = canvas.width / 2;
    this.centerY = canvas.height / 2;
    this.radius = Math.min(this.centerX, this.centerY) - 10;
    this.rotation = 0; // degrees
    this.font = options.font || '16px Inter, Arial';
    this.onDraw = options.onDraw || function(){};
    this._animating = false;
    this.draw();
  }
  setNames(names) {
    this.names = names.slice();
    this.draw();
  }
  setTheme(theme) {
    if (!theme) return;
    if (theme.colors && theme.colors.length) this.colors = theme.colors.slice();
    if (theme.text) this.textColor = theme.text;
    this.draw();
  }
  clearCanvas() {
    this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height);
  }
  draw() {
    this.clearCanvas();
    const ctx = this.ctx;
    const n = Math.max(1, this.names.length);
    const seg = 360 / n;
    ctx.save();
    ctx.translate(this.centerX, this.centerY);
    ctx.rotate(this.degToRad(this.rotation));
    // Draw segments
    for (let i = 0; i < n; i++) {
      const start = this.degToRad(i * seg);
      const end = this.degToRad((i + 1) * seg);
      ctx.beginPath();
      ctx.moveTo(0,0);
      ctx.arc(0,0,this.radius,start,end);
      ctx.closePath();
      ctx.fillStyle = this.colors[i % this.colors.length];
      ctx.fill();
      // stroke
      ctx.lineWidth = 2;
      ctx.strokeStyle = 'rgba(0,0,0,0.08)';
      ctx.stroke();
      // Draw label
      ctx.save();
      const angle = start + (end - start) / 2;
      ctx.rotate(angle);
      ctx.translate(this.radius * 0.55, 0);
      ctx.rotate(Math.PI / 2);
      ctx.fillStyle = this.textColor;
      ctx.font = this.font;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      const name = this.names[i] || '';
      this.wrapText(ctx, name, 0, 0, this.radius * 0.35, 18);
      ctx.restore();
    }
    ctx.restore();
    // center circle
    ctx.beginPath();
    ctx.arc(this.centerX, this.centerY, this.radius * 0.12, 0, Math.PI*2);
    ctx.fillStyle = '#ffffff';
    ctx.fill();
    ctx.lineWidth = 2;
    ctx.strokeStyle = 'rgba(0,0,0,0.06)';
    ctx.stroke();
    this.onDraw();
  }
  wrapText(ctx, text, x, y, maxWidth, lineHeight) {
    // A simple wrap for canvas text
    const words = text.split(' ');
    let line = '';
    let yOffset = y;
    for (let n = 0; n < words.length; n++) {
      const testLine = line + words[n] + ' ';
      const metrics = ctx.measureText(testLine);
      const testWidth = metrics.width;
      if (testWidth > maxWidth && n > 0) {
        ctx.fillText(line.trim(), x, yOffset);
        line = words[n] + ' ';
        yOffset += lineHeight;
      } else {
        line = testLine;
      }
    }
    ctx.fillText(line.trim(), x, yOffset);
  }
  degToRad(d) {
    return d * Math.PI / 180;
  }
  radToDeg(r) {
    return r * 180 / Math.PI;
  }
  getRandomIndex() {
    if (!this.names.length) return 0;
    return Math.floor(Math.random() * this.names.length);
  }
  // Spin such that the segment at `index` lands on the pointer at top.
  spinToIndex(index, opts = {}) {
    if (this._animating) return Promise.reject('Already animating');
    if (!this.names.length) return Promise.reject('No names');
    const n = this.names.length;
    const segAngle = 360 / n;
    // We want the center of target segment to be at angle 270deg (top of canvas - adjust if pointer is at top)
    // Our rotation variable rotates the whole wheel clockwise in degrees.
    // Compute the current rotation normalized
    const normalized = ((this.rotation % 360) + 360) % 360;
    // Calculate angle to place the segment center at top (270deg)
    // Center of segment i is at angle: (i * segAngle + segAngle/2)
    // We need rotation such that (centerAngle + rotation) mod 360 = 270
    const centerAngle = index * segAngle + segAngle / 2;
    // Solve for rotation target:
    let targetRotation = 270 - centerAngle;
    // Normalize to 0..360
    targetRotation = ((targetRotation % 360) + 360) % 360;
    // To produce multiple spins, add several full rotations:
    const fullSpins = opts.fullSpins !== undefined ? opts.fullSpins : (3 + Math.floor(Math.random()*3)); // 3-5 spins
    const endRotation = targetRotation + fullSpins * 360 + (opts.randomOffset || 0);
    // We'll animate from current normalized to endRotation, taking into account wrap
    const startRotation = normalized;
    const delta = endRotation - startRotation;
    const duration = opts.duration || 5000; // ms
    const startTime = performance.now();
    this._animating = true;
    return new Promise((resolve) => {
      const animate = (now) => {
        const elapsed = now - startTime;
        const t = Math.min(1, elapsed / duration);
        // ease out cubic
        const eased = 1 - Math.pow(1 - t, 3);
        const current = startRotation + delta * eased;
        this.rotation = current;
        this.draw();
        if (t < 1) {
          requestAnimationFrame(animate);
        } else {
          this._animating = false;
          // Normalize rotation to endRotation mod 360
          this.rotation = ((endRotation % 360) + 360) % 360;
          this.draw();
          resolve(index);
        }
      };
      requestAnimationFrame(animate);
    });
  }
}
```

main.js
```js
/*
'''
DOCSTRING:
main.js
Wires UI to the Wheel class:
- loads themes.json (URL injected by Flask)
- populates theme selector
- reads names and updates wheel
- handles spin logic and result display
Includes robust fallback if fetching themes.json fails.
'''
*/
document.addEventListener('DOMContentLoaded', async () => {
  const canvas = document.getElementById('wheel-canvas');
  const nameInput = document.getElementById('name-input');
  const addBtn = document.getElementById('add-name');
  const namesTextarea = document.getElementById('names-textarea');
  const spinBtn = document.getElementById('spin-btn');
  const resultDiv = document.getElementById('result');
  const themeSelect = document.getElementById('theme-select');
  const loadSampleBtn = document.getElementById('load-sample');
  const clearBtn = document.getElementById('clear-names');
  const importBtn = document.getElementById('import-names');
  const exportBtn = document.getElementById('export-names');
  const wheel = new Wheel(canvas, { names: [], colors: ['#ffb3b3','#ffd9b3','#fff3b3','#d9ffb3'] });
  let themes = [];

  // A small fallback theme set in case fetching themes.json fails.
  const defaultThemes = [
    {
      id: 'fallback',
      name: 'Default',
      bg: '#ffffff',
      text: '#222222',
      accent: '#007bff',
      colors: ['#ffb3b3','#ffd9b3','#fff3b3','#d9ffb3']
    }
  ];

  // Helper to populate theme selector
  function populateThemeSelector(list) {
    themeSelect.innerHTML = '';
    list.forEach(t => {
      const opt = document.createElement('option');
      opt.value = t.id;
      opt.textContent = t.name;
      themeSelect.appendChild(opt);
    });
  }

  // Load themes.json (URL injected by Flask)
  try {
    const themesUrl = window.THEMES_JSON_URL || '/static/themes.json';
    const resp = await fetch(themesUrl);
    if (!resp.ok) throw new Error('HTTP ' + resp.status);
    themes = await resp.json();
    if (!Array.isArray(themes) || themes.length === 0) throw new Error('No themes found');
    populateThemeSelector(themes);
    // apply first theme
    applyTheme(themes[0]);
    themeSelect.value = themes[0].id;
  } catch (err) {
    console.error('Failed to load themes:', err);
    // fallback
    themes = defaultThemes;
    populateThemeSelector(themes);
    applyTheme(themes[0]);
    themeSelect.value = themes[0].id;
  }

  function applyTheme(theme) {
    if (!theme) return;
    document.documentElement.style.setProperty('--bg', theme.bg || '#fff');
    document.documentElement.style.setProperty('--text', theme.text || '#222');
    document.documentElement.style.setProperty('--accent', theme.accent || '#007bff');
    // set panel bg slightly adjusted
    let panelBg = theme.bg;
    // robust luminance tweak (supports 3/6 digit hex)
    try {
      panelBg = lightenOrDarkenColor(theme.bg || '#fff', 18);
    } catch(e) {
      panelBg = '#f6f8fa';
    }
    document.documentElement.style.setProperty('--panel-bg', panelBg);
    wheel.setTheme({ colors: theme.colors || [], text: theme.text || '#222' });
  }

  function lightenOrDarkenColor(col, amt) {
    // accepts #rgb or #rrggbb. amt can be negative to darken.
    if (typeof col !== 'string') throw new Error('Invalid color');
    let colStr = col.trim();
    if (colStr[0] === '#') colStr = colStr.slice(1);
    if (colStr.length === 3) {
      colStr = colStr.split('').map(c => c + c).join('');
    }
    if (colStr.length !== 6) throw new Error('Invalid hex color');
    const num = parseInt(colStr, 16);
    let r = (num >> 16) & 0xFF;
    let g = (num >> 8) & 0xFF;
    let b = num & 0xFF;
    r = Math.max(0, Math.min(255, r + amt));
    g = Math.max(0, Math.min(255, g + amt));
    b = Math.max(0, Math.min(255, b + amt));
    const newHex = '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
    return newHex;
  }

  themeSelect.addEventListener('change', () => {
    const id = themeSelect.value;
    const t = themes.find(x => x.id === id);
    if (t) applyTheme(t);
  });

  function parseNamesFromTextarea() {
    const lines = namesTextarea.value.split('\n').map(s => s.trim()).filter(s => s.length);
    return lines;
  }

  function updateWheelFromTextarea() {
    const names = parseNamesFromTextarea();
    wheel.setNames(names);
  }

  addBtn.addEventListener('click', () => {
    const v = nameInput.value.trim();
    if (!v) return;
    const cur = parseNamesFromTextarea();
    cur.push(v);
    namesTextarea.value = cur.join('\n');
    nameInput.value = '';
    updateWheelFromTextarea();
  });

  nameInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
      addBtn.click();
      e.preventDefault();
    }
  });

  namesTextarea.addEventListener('input', () => {
    updateWheelFromTextarea();
  });

  loadSampleBtn.addEventListener('click', () => {
    const sample = ['Alice','Bob','Charlie','Diana','Eva','Frank','George','Helen','Ivy','Jack'];
    namesTextarea.value = sample.join('\n');
    updateWheelFromTextarea();
  });

  clearBtn.addEventListener('click', () => {
    namesTextarea.value = '';
    updateWheelFromTextarea();
    resultDiv.classList.add('hidden');
  });

  importBtn.addEventListener('click', async () => {
    // prompt user for a newline separated list (simple)
    const data = prompt('Paste names (one per line):');
    if (data === null) return;
    namesTextarea.value = data.split('\n').map(s => s.trim()).filter(s => s).join('\n');
    updateWheelFromTextarea();
  });

  exportBtn.addEventListener('click', () => {
    const names = parseNamesFromTextarea();
    const blob = new Blob([names.join('\n')], {type: 'text/plain'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'names.txt';
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  });

  spinBtn.addEventListener('click', async () => {
    const names = parseNamesFromTextarea();
    if (names.length === 0) {
      alert('Please add at least one name.');
      return;
    }
    resultDiv.classList.add('hidden');
    spinBtn.disabled = true;
    spinBtn.textContent = 'Spinning...';
    // pick random index
    const idx = wheel.getRandomIndex();
    try {
      const winnerIndex = await wheel.spinToIndex(idx, { duration: 4500 });
      const winner = names[winnerIndex];
      resultDiv.textContent = `Winner: ${winner}`;
      resultDiv.classList.remove('hidden');
      spinBtn.textContent = 'SPIN';
      spinBtn.disabled = false;
    } catch (err) {
      console.error(err);
      spinBtn.textContent = 'SPIN';
      spinBtn.disabled = false;
    }
  });

  // initial sample
  namesTextarea.value = 'Alice\nBob\nCharlie\nDiana\nEva';
  updateWheelFromTextarea();
});
```

[2025-17-09 14:02:51 INFO] **[Update Codes]**

main.py updated.


```
'''

'''
--- Old
+++ New
@@ -1,9 +1,7 @@
 '''
-app.py
-DOCSTRING:
 Flask application that serves the wheel-of-names web app.
 Run: pip install flask
-Then: python app.py
+Then: python main.py
 Access: http://127.0.0.1:5000/
 '''
 from flask import Flask, render_template
```

[2025-17-09 14:02:51 INFO] **[Update Codes]**

index.html updated.


```
'''

'''
--- Old
+++ New
@@ -7,6 +7,7 @@
 - theme selector
 - spin / clear / add buttons
 Includes JS files wheel.js and main.js for behavior.
+Also injects a dynamically generated URL for themes.json using Flask's url_for so the client can reliably fetch the resource even when the app is mounted under a subpath.
 '''
 <!doctype html>
 <html lang="en">
@@ -57,6 +58,11 @@
       <small>Built with Flask + Canvas. Themes available.</small>
     </footer>
   </div>
+  <!-- Provide the correct URL for themes.json (generated by Flask).
+       This ensures the client can fetch themes.json even when the app is mounted under a prefix. -->
+  <script>
+    window.THEMES_JSON_URL = "{{ url_for('static', filename='themes.json') }}";
+  </script>
   <script src="{{ url_for('static', filename='js/wheel.js') }}"></script>
   <script src="{{ url_for('static', filename='js/main.js') }}"></script>
 </body>
```

[2025-17-09 14:02:51 INFO] **[Update Codes]**

main.js updated.


```
'''

'''
--- Old
+++ New
@@ -3,10 +3,11 @@
 DOCSTRING:
 main.js
 Wires UI to the Wheel class:
-- loads themes.json
+- loads themes.json (URL injected by Flask)
 - populates theme selector
 - reads names and updates wheel
 - handles spin logic and result display
+Includes robust fallback if fetching themes.json fails.
 '''
 */
 document.addEventListener('DOMContentLoaded', async () => {
@@ -23,21 +24,45 @@
   const exportBtn = document.getElementById('export-names');
   const wheel = new Wheel(canvas, { names: [], colors: ['#ffb3b3','#ffd9b3','#fff3b3','#d9ffb3'] });
   let themes = [];
-  // Load themes.json
-  try {
-    const resp = await fetch('/static/themes.json');
-    themes = await resp.json();
-    themes.forEach(t => {
+  // A small fallback theme set in case fetching themes.json fails.
+  const defaultThemes = [
+    {
+      id: 'fallback',
+      name: 'Default',
+      bg: '#ffffff',
+      text: '#222222',
+      accent: '#007bff',
+      colors: ['#ffb3b3','#ffd9b3','#fff3b3','#d9ffb3']
+    }
+  ];
+  // Helper to populate theme selector
+  function populateThemeSelector(list) {
+    themeSelect.innerHTML = '';
+    list.forEach(t => {
       const opt = document.createElement('option');
       opt.value = t.id;
       opt.textContent = t.name;
       themeSelect.appendChild(opt);
     });
+  }
+  // Load themes.json (URL injected by Flask)
+  try {
+    const themesUrl = window.THEMES_JSON_URL || '/static/themes.json';
+    const resp = await fetch(themesUrl);
+    if (!resp.ok) throw new Error('HTTP ' + resp.status);
+    themes = await resp.json();
+    if (!Array.isArray(themes) || themes.length === 0) throw new Error('No themes found');
+    populateThemeSelector(themes);
     // apply first theme
     applyTheme(themes[0]);
     themeSelect.value = themes[0].id;
   } catch (err) {
     console.error('Failed to load themes:', err);
+    // fallback
+    themes = defaultThemes;
+    populateThemeSelector(themes);
+    applyTheme(themes[0]);
+    themeSelect.value = themes[0].id;
   }
   function applyTheme(theme) {
     if (!theme) return;
@@ -46,9 +71,9 @@
     document.documentElement.style.setProperty('--accent', theme.accent || '#007bff');
     // set panel bg slightly adjusted
     let panelBg = theme.bg;
-    // simple luminance tweak
+    // robust luminance tweak (supports 3/6 digit hex)
     try {
-      panelBg = lightenOrDarkenColor(theme.bg || '#fff', 96);
+      panelBg = lightenOrDarkenColor(theme.bg || '#fff', 18);
     } catch(e) {
       panelBg = '#f6f8fa';
     }
@@ -56,20 +81,23 @@
     wheel.setTheme({ colors: theme.colors || [], text: theme.text || '#222' });
   }
   function lightenOrDarkenColor(col, amt) {
-    // expects #rrggbb
-    let usePound = false;
-    if (col[0] === "#") {
-      col = col.slice(1);
-      usePound = true;
+    // accepts #rgb or #rrggbb. amt can be negative to darken.
+    if (typeof col !== 'string') throw new Error('Invalid color');
+    let colStr = col.trim();
+    if (colStr[0] === '#') colStr = colStr.slice(1);
+    if (colStr.length === 3) {
+      colStr = colStr.split('').map(c => c + c).join('');
     }
-    const num = parseInt(col,16);
-    let r = (num >> 16) + amt;
-    let b = ((num >> 8) & 0x00FF) + amt;
-    let g = (num & 0x0000FF) + amt;
-    r = Math.max(Math.min(255, r), 0);
-    b = Math.max(Math.min(255, b), 0);
-    g = Math.max(Math.min(255, g), 0);
-    return (usePound ? "#" : "") + (g | (b << 8) | (r << 16)).toString(16).padStart(6, '0');
+    if (colStr.length !== 6) throw new Error('Invalid hex color');
+    const num = parseInt(colStr, 16);
+    let r = (num >> 16) & 0xFF;
+    let g = (num >> 8) & 0xFF;
+    let b = num & 0xFF;
+    r = Math.max(0, Math.min(255, r + amt));
+    g = Math.max(0, Math.min(255, g + amt));
+    b = Math.max(0, Math.min(255, b + amt));
+    const newHex = '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
+    return newHex;
   }
   themeSelect.addEventListener('change', () => {
     const id = themeSelect.value;
```

[2025-17-09 14:02:51 INFO] **[Software Info]**:

 

ðŸ’°**cost**=$0.034269

ðŸ”¨**version_updates**=-1

ðŸ“ƒ**num_code_files**=1

ðŸž**num_png_files**=0

ðŸ“š**num_doc_files**=9

ðŸ“ƒ**code_lines**=24

ðŸ“‹**env_lines**=-1

ðŸ“’**manual_lines**=-1

ðŸ—£**num_utterances**=11

ðŸ¤”**num_self_reflections**=0

â“**num_prompt_tokens**=13977

â—**num_completion_tokens**=18187

ðŸŒŸ**num_total_tokens**=32164

[2025-17-09 14:02:51 INFO] **[Execute Detail]**

execute SimplePhase:[CodeReviewComment] in ComposedPhase:[CodeReview], cycle 2

[2025-17-09 14:02:51 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | [Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes.] |
| **need_reflect** | False |
| **assistant_role_name** | Code Reviewer |
| **user_role_name** | Programmer |
| **phase_prompt** | According to the new user's task and our software designs:  Task: "{task}". Modality: "{modality}". Programming Language: "{language}" Ideas: "{ideas}" Codes: "{codes}" As the {assistant_role}, to make the software directly operable without further coding, ChatDev have formulated the following regulations: 1) all referenced classes should be imported; 2) all methods should be implemented; 3) all methods need to have the necessary comments; 4) no potential bugs; 5) The entire project conforms to the tasks proposed by the user; 6) most importantly, do not only check the errors in the code, but also the logic of code. Make sure that user can interact with generated software without losing any feature in the requirement; Now, you should check the above regulations one by one and review the codes in detail, propose one comment with the highest priority about the codes, and give me instructions on how to fix. Tell me your comment with the highest priority and corresponding suggestions on revision. If the codes are perfect and you have no comment on them, return only one line like " Finished". |
| **phase_name** | CodeReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Code Reviewer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. You can help programmers to assess source codes for software troubleshooting, fix bugs to increase code quality and robustness, and offer proposals to improve the source codes. Here is a new customer's task: {task}. To complete the task, you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Programmer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. You can write/create computer software or applications by providing a specific programming language to the computer. You have extensive computing and coding experience in many varieties of programming languages and platforms, such as Python, Java, C, C++, HTML, CSS, JavaScript, XML, SQL, PHP, etc,. Here is a new customer's task: {task}. To complete the task, you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': 'main.py\npython\n\'\'\'\nFlask application that serves the wheel-of-names web app.\nRun: pip install flask\nThen: python main.py\nAccess: http://127.0.0.1:5000/\n\'\'\'\nfrom flask import Flask, render_template\nimport os\n\ndef create_app():\n    """\n    Create and configure the Flask application.\n    """\n    app = Flask(__name__, static_folder=\'static\', template_folder=\'templates\')\n\n    @app.route(\'/\')\n    def index():\n        """\n        Serve the main page.\n        """\n        return render_template(\'index.html\')\n\n    return app\n\nif __name__ == \'__main__\':\n    app = create_app()\n    port = int(os.environ.get(\'PORT\', 5000))\n    app.run(debug=True, host=\'0.0.0.0\', port=port)\n\n\nindex.html\nhtml\n\'\'\'\nDOCSTRING:\nMain HTML page for the Wheel of Names app.\nContains UI elements:\n- name input and list\n- canvas for wheel\n- theme selector\n- spin / clear / add buttons\nIncludes JS files wheel.js and main.js for behavior.\nAlso injects a dynamically generated URL for themes.json using Flask\'s url_for so the client can reliably fetch the resource even when the app is mounted under a subpath.\n\'\'\'\n&lt;!doctype html&gt;\n&lt;html lang="en"&gt;\n&lt;head&gt;\n  &lt;meta charset="utf-8"&gt;\n  &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;\n  &lt;title&gt;Wheel of Names&lt;/title&gt;\n  &lt;link rel="stylesheet" href="{{ url_for(\'static\', filename=\'css/styles.css\') }}"&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div class="container"&gt;\n    &lt;header&gt;\n      &lt;h1&gt;Wheel of Names&lt;/h1&gt;\n      &lt;p&gt;Enter names, choose a theme, and spin to pick a random winner.&lt;/p&gt;\n    &lt;/header&gt;\n    &lt;main class="main-grid"&gt;\n      &lt;section class="left-panel"&gt;\n        &lt;div class="controls"&gt;\n          &lt;label for="name-input"&gt;Add a name&lt;/label&gt;\n          &lt;div class="input-row"&gt;\n            &lt;input id="name-input" type="text" placeholder="Enter name and press Add" autocomplete="off"&gt;\n            &lt;button id="add-name"&gt;Add&lt;/button&gt;\n          &lt;/div&gt;\n          &lt;label for="names-textarea"&gt;Names (one per line)&lt;/label&gt;\n          &lt;textarea id="names-textarea" placeholder="Alice\\nBob\\nCharlie"&gt;&lt;/textarea&gt;\n          &lt;div class="buttons-row"&gt;\n            &lt;button id="load-sample"&gt;Load Sample&lt;/button&gt;\n            &lt;button id="clear-names"&gt;Clear&lt;/button&gt;\n            &lt;button id="import-names"&gt;Import&lt;/button&gt;\n            &lt;button id="export-names"&gt;Export&lt;/button&gt;\n          &lt;/div&gt;\n          &lt;label for="theme-select"&gt;Theme&lt;/label&gt;\n          &lt;select id="theme-select"&gt;&lt;/select&gt;\n          &lt;div class="spin-controls"&gt;\n            &lt;button id="spin-btn" class="spin"&gt;SPIN&lt;/button&gt;\n            &lt;div id="result" class="result hidden"&gt;&lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      &lt;/section&gt;\n      &lt;section class="right-panel"&gt;\n        &lt;div class="wheel-wrapper" id="wheel-wrapper"&gt;\n          &lt;canvas id="wheel-canvas" width="600" height="600"&gt;&lt;/canvas&gt;\n          &lt;div id="pointer"&gt;â–¼&lt;/div&gt;\n        &lt;/div&gt;\n      &lt;/section&gt;\n    &lt;/main&gt;\n    &lt;footer&gt;\n      &lt;small&gt;Built with Flask + Canvas. Themes available.&lt;/small&gt;\n    &lt;/footer&gt;\n  &lt;/div&gt;\n\n  &lt;!-- Provide the correct URL for themes.json (generated by Flask).\n       This ensures the client can fetch themes.json even when the app is mounted under a prefix. --&gt;\n  &lt;script&gt;\n    window.THEMES_JSON_URL = "{{ url_for(\'static\', filename=\'themes.json\') }}";\n  &lt;/script&gt;\n\n  &lt;script src="{{ url_for(\'static\', filename=\'js/wheel.js\') }}"&gt;&lt;/script&gt;\n  &lt;script src="{{ url_for(\'static\', filename=\'js/main.js\') }}"&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\n\nthemes.json\njson\n\'\'\'\nDOCSTRING:\nList of themes available for the wheel.\nEach theme contains:\n- name: display name\n- bg: page background color\n- text: primary text color\n- accent: accent color used for pointer/button\n- colors: array of segment colors (will be cycled for segments)\n\'\'\'\n[\n  {\n    "id": "classic",\n    "name": "Classic",\n    "bg": "#ffffff",\n    "text": "#222222",\n    "accent": "#007bff",\n    "colors": ["#ffb3b3", "#ffd9b3", "#fff3b3", "#d9ffb3", "#b3ffd9", "#b3e6ff", "#c7b3ff", "#ffb3f2"]\n  },\n  {\n    "id": "dark",\n    "name": "Dark",\n    "bg": "#121212",\n    "text": "#f5f5f5",\n    "accent": "#ff6b6b",\n    "colors": ["#2e2e34", "#3a3a44", "#4a4a56", "#5a5a68", "#6a6a78", "#7a7a88"]\n  },\n  {\n    "id": "pastel",\n    "name": "Pastel",\n    "bg": "#f7f7ff",\n    "text": "#333333",\n    "accent": "#ff8c94",\n    "colors": ["#ffd1dc", "#fce1b4", "#e8ffd1", "#d1fff0", "#d1e7ff", "#e6d1ff"]\n  },\n  {\n    "id": "neon",\n    "name": "Neon",\n    "bg": "#0f0f13",\n    "text": "#eaff00",\n    "accent": "#00fff5",\n    "colors": ["#ff00ff", "#ff8c00", "#00ff00", "#00ffff", "#8c00ff", "#ff0066"]\n  }\n]\n\n\nstyles.css\ncss\n\'\'\'\nDOCSTRING:\nBase CSS for the Wheel of Names app.\nDefines layout, basic theme variables, and responsive styles.\n\'\'\'\n:root{\n  --bg: #ffffff;\n  --text: #222222;\n  --accent: #007bff;\n  --panel-bg: #f6f8fa;\n}\n*{box-sizing:border-box}\nhtml,body{\n  height:100%;\n  margin:0;\n  font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;\n  background: var(--bg);\n  color: var(--text);\n}\n.container{\n  max-width:1100px;\n  margin:24px auto;\n  padding:16px;\n}\nheader{ text-align:center; margin-bottom:8px }\nh1{ margin:6px 0; font-size:28px }\np{ margin:0; color:var(--text); opacity:0.8 }\n.main-grid{\n  display:grid;\n  grid-template-columns: 360px 1fr;\n  gap:20px;\n  align-items:start;\n  margin-top:18px;\n}\n.left-panel{\n  background:var(--panel-bg);\n  padding:14px;\n  border-radius:8px;\n  box-shadow:0 4px 8px rgba(0,0,0,0.04);\n}\n.left-panel label{ display:block; margin-top:8px; font-weight:600; margin-bottom:6px }\n.input-row{ display:flex; gap:8px }\n.input-row input[type="text"]{\n  flex:1;\n  padding:8px 10px;\n  border-radius:6px;\n  border:1px solid #ddd;\n}\n.input-row button{\n  padding:8px 12px;\n  border-radius:6px;\n  background:var(--accent);\n  color:white;\n  border:none;\n  cursor:pointer;\n}\ntextarea{\n  width:100%;\n  min-height:160px;\n  padding:10px;\n  border-radius:8px;\n  border:1px solid #ddd;\n  resize:vertical;\n}\n.buttons-row{\n  display:flex;\n  gap:8px;\n  margin-top:8px;\n  flex-wrap:wrap;\n}\n.buttons-row button{\n  padding:8px 10px;\n  border-radius:6px;\n  border:1px solid #ccc;\n  background:transparent;\n  cursor:pointer;\n}\n.spin-controls{\n  display:flex;\n  gap:12px;\n  margin-top:16px;\n  align-items:center;\n}\n.spin{\n  padding:14px 24px;\n  background:var(--accent);\n  color:white;\n  font-weight:700;\n  border:none;\n  border-radius:10px;\n  cursor:pointer;\n  font-size:18px;\n}\n.result{\n  padding:10px 12px;\n  background:rgba(0,0,0,0.06);\n  border-radius:8px;\n}\n.hidden{ display:none }\n.right-panel{\n  display:flex;\n  align-items:center;\n  justify-content:center;\n  min-height:420px;\n}\n.wheel-wrapper{\n  position:relative;\n  width:600px;\n  height:600px;\n  display:flex;\n  align-items:center;\n  justify-content:center;\n  margin:auto;\n}\n#wheel-canvas{\n  border-radius:50%;\n  box-shadow: 0 12px 30px rgba(0,0,0,0.12);\n  background:transparent;\n}\n#wheel-wrapper #pointer{\n  position:absolute;\n  top:18px;\n  left:50%;\n  transform:translateX(-50%);\n  font-size:40px;\n  color:var(--accent);\n  text-shadow:0 2px 4px rgba(0,0,0,0.2);\n  pointer-events:none;\n}\nfooter{ text-align:center; margin-top:16px; color:var(--text); opacity:0.7; }\n/* Responsive */\n@media (max-width:960px){\n  .main-grid{ grid-template-columns:1fr; }\n  .wheel-wrapper{ width:420px; height:420px; }\n  #wheel-canvas{ width:420px; height:420px; }\n}\n\n\nwheel.js\njs\n/*\n\'\'\'\nDOCSTRING:\nwheel.js\nContains a Wheel class that draws the wheel on a canvas and animates spins.\nKey methods:\n- constructor(canvas, options)\n- setNames(names)\n- setTheme(theme)\n- draw()\n- spinToIndex(index) -&gt; Promise resolves with index after animation\n- getRandomIndex()\n\'\'\'\n*/\nclass Wheel {\n  constructor(canvas, options = {}) {\n    this.canvas = canvas;\n    this.ctx = canvas.getContext(\'2d\');\n    this.names = options.names || [];\n    this.colors = options.colors || [\'#ffb3b3\', \'#ffd9b3\', \'#fff3b3\', \'#d9ffb3\', \'#b3ffd9\', \'#b3e6ff\'];\n    this.textColor = options.textColor || \'#222\';\n    this.centerX = canvas.width / 2;\n    this.centerY = canvas.height / 2;\n    this.radius = Math.min(this.centerX, this.centerY) - 10;\n    this.rotation = 0; // degrees\n    this.font = options.font || \'16px Inter, Arial\';\n    this.onDraw = options.onDraw || function(){};\n    this._animating = false;\n    this.draw();\n  }\n  setNames(names) {\n    this.names = names.slice();\n    this.draw();\n  }\n  setTheme(theme) {\n    if (!theme) return;\n    if (theme.colors &amp;&amp; theme.colors.length) this.colors = theme.colors.slice();\n    if (theme.text) this.textColor = theme.text;\n    this.draw();\n  }\n  clearCanvas() {\n    this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height);\n  }\n  draw() {\n    this.clearCanvas();\n    const ctx = this.ctx;\n    const n = Math.max(1, this.names.length);\n    const seg = 360 / n;\n    ctx.save();\n    ctx.translate(this.centerX, this.centerY);\n    ctx.rotate(this.degToRad(this.rotation));\n    // Draw segments\n    for (let i = 0; i &lt; n; i++) {\n      const start = this.degToRad(i * seg);\n      const end = this.degToRad((i + 1) * seg);\n      ctx.beginPath();\n      ctx.moveTo(0,0);\n      ctx.arc(0,0,this.radius,start,end);\n      ctx.closePath();\n      ctx.fillStyle = this.colors[i % this.colors.length];\n      ctx.fill();\n      // stroke\n      ctx.lineWidth = 2;\n      ctx.strokeStyle = \'rgba(0,0,0,0.08)\';\n      ctx.stroke();\n      // Draw label\n      ctx.save();\n      const angle = start + (end - start) / 2;\n      ctx.rotate(angle);\n      ctx.translate(this.radius * 0.55, 0);\n      ctx.rotate(Math.PI / 2);\n      ctx.fillStyle = this.textColor;\n      ctx.font = this.font;\n      ctx.textAlign = \'center\';\n      ctx.textBaseline = \'middle\';\n      const name = this.names[i] || \'\';\n      this.wrapText(ctx, name, 0, 0, this.radius * 0.35, 18);\n      ctx.restore();\n    }\n    ctx.restore();\n    // center circle\n    ctx.beginPath();\n    ctx.arc(this.centerX, this.centerY, this.radius * 0.12, 0, Math.PI*2);\n    ctx.fillStyle = \'#ffffff\';\n    ctx.fill();\n    ctx.lineWidth = 2;\n    ctx.strokeStyle = \'rgba(0,0,0,0.06)\';\n    ctx.stroke();\n    this.onDraw();\n  }\n  wrapText(ctx, text, x, y, maxWidth, lineHeight) {\n    // A simple wrap for canvas text\n    const words = text.split(\' \');\n    let line = \'\';\n    let yOffset = y;\n    for (let n = 0; n &lt; words.length; n++) {\n      const testLine = line + words[n] + \' \';\n      const metrics = ctx.measureText(testLine);\n      const testWidth = metrics.width;\n      if (testWidth &gt; maxWidth &amp;&amp; n &gt; 0) {\n        ctx.fillText(line.trim(), x, yOffset);\n        line = words[n] + \' \';\n        yOffset += lineHeight;\n      } else {\n        line = testLine;\n      }\n    }\n    ctx.fillText(line.trim(), x, yOffset);\n  }\n  degToRad(d) {\n    return d * Math.PI / 180;\n  }\n  radToDeg(r) {\n    return r * 180 / Math.PI;\n  }\n  getRandomIndex() {\n    if (!this.names.length) return 0;\n    return Math.floor(Math.random() * this.names.length);\n  }\n  // Spin such that the segment at `index` lands on the pointer at top.\n  spinToIndex(index, opts = {}) {\n    if (this._animating) return Promise.reject(\'Already animating\');\n    if (!this.names.length) return Promise.reject(\'No names\');\n    const n = this.names.length;\n    const segAngle = 360 / n;\n    // We want the center of target segment to be at angle 270deg (top of canvas - adjust if pointer is at top)\n    // Our rotation variable rotates the whole wheel clockwise in degrees.\n    // Compute the current rotation normalized\n    const normalized = ((this.rotation % 360) + 360) % 360;\n    // Calculate angle to place the segment center at top (270deg)\n    // Center of segment i is at angle: (i * segAngle + segAngle/2)\n    // We need rotation such that (centerAngle + rotation) mod 360 = 270\n    const centerAngle = index * segAngle + segAngle / 2;\n    // Solve for rotation target:\n    let targetRotation = 270 - centerAngle;\n    // Normalize to 0..360\n    targetRotation = ((targetRotation % 360) + 360) % 360;\n    // To produce multiple spins, add several full rotations:\n    const fullSpins = opts.fullSpins !== undefined ? opts.fullSpins : (3 + Math.floor(Math.random()*3)); // 3-5 spins\n    const endRotation = targetRotation + fullSpins * 360 + (opts.randomOffset || 0);\n    // We\'ll animate from current normalized to endRotation, taking into account wrap\n    const startRotation = normalized;\n    const delta = endRotation - startRotation;\n    const duration = opts.duration || 5000; // ms\n    const startTime = performance.now();\n    this._animating = true;\n    return new Promise((resolve) =&gt; {\n      const animate = (now) =&gt; {\n        const elapsed = now - startTime;\n        const t = Math.min(1, elapsed / duration);\n        // ease out cubic\n        const eased = 1 - Math.pow(1 - t, 3);\n        const current = startRotation + delta * eased;\n        this.rotation = current;\n        this.draw();\n        if (t &lt; 1) {\n          requestAnimationFrame(animate);\n        } else {\n          this._animating = false;\n          // Normalize rotation to endRotation mod 360\n          this.rotation = ((endRotation % 360) + 360) % 360;\n          this.draw();\n          resolve(index);\n        }\n      };\n      requestAnimationFrame(animate);\n    });\n  }\n}\n\n\nmain.js\njs\n/*\n\'\'\'\nDOCSTRING:\nmain.js\nWires UI to the Wheel class:\n- loads themes.json (URL injected by Flask)\n- populates theme selector\n- reads names and updates wheel\n- handles spin logic and result display\nIncludes robust fallback if fetching themes.json fails.\n\'\'\'\n*/\ndocument.addEventListener(\'DOMContentLoaded\', async () =&gt; {\n  const canvas = document.getElementById(\'wheel-canvas\');\n  const nameInput = document.getElementById(\'name-input\');\n  const addBtn = document.getElementById(\'add-name\');\n  const namesTextarea = document.getElementById(\'names-textarea\');\n  const spinBtn = document.getElementById(\'spin-btn\');\n  const resultDiv = document.getElementById(\'result\');\n  const themeSelect = document.getElementById(\'theme-select\');\n  const loadSampleBtn = document.getElementById(\'load-sample\');\n  const clearBtn = document.getElementById(\'clear-names\');\n  const importBtn = document.getElementById(\'import-names\');\n  const exportBtn = document.getElementById(\'export-names\');\n  const wheel = new Wheel(canvas, { names: [], colors: [\'#ffb3b3\',\'#ffd9b3\',\'#fff3b3\',\'#d9ffb3\'] });\n  let themes = [];\n\n  // A small fallback theme set in case fetching themes.json fails.\n  const defaultThemes = [\n    {\n      id: \'fallback\',\n      name: \'Default\',\n      bg: \'#ffffff\',\n      text: \'#222222\',\n      accent: \'#007bff\',\n      colors: [\'#ffb3b3\',\'#ffd9b3\',\'#fff3b3\',\'#d9ffb3\']\n    }\n  ];\n\n  // Helper to populate theme selector\n  function populateThemeSelector(list) {\n    themeSelect.innerHTML = \'\';\n    list.forEach(t =&gt; {\n      const opt = document.createElement(\'option\');\n      opt.value = t.id;\n      opt.textContent = t.name;\n      themeSelect.appendChild(opt);\n    });\n  }\n\n  // Load themes.json (URL injected by Flask)\n  try {\n    const themesUrl = window.THEMES_JSON_URL || \'/static/themes.json\';\n    const resp = await fetch(themesUrl);\n    if (!resp.ok) throw new Error(\'HTTP \' + resp.status);\n    themes = await resp.json();\n    if (!Array.isArray(themes) || themes.length === 0) throw new Error(\'No themes found\');\n    populateThemeSelector(themes);\n    // apply first theme\n    applyTheme(themes[0]);\n    themeSelect.value = themes[0].id;\n  } catch (err) {\n    console.error(\'Failed to load themes:\', err);\n    // fallback\n    themes = defaultThemes;\n    populateThemeSelector(themes);\n    applyTheme(themes[0]);\n    themeSelect.value = themes[0].id;\n  }\n\n  function applyTheme(theme) {\n    if (!theme) return;\n    document.documentElement.style.setProperty(\'--bg\', theme.bg || \'#fff\');\n    document.documentElement.style.setProperty(\'--text\', theme.text || \'#222\');\n    document.documentElement.style.setProperty(\'--accent\', theme.accent || \'#007bff\');\n    // set panel bg slightly adjusted\n    let panelBg = theme.bg;\n    // robust luminance tweak (supports 3/6 digit hex)\n    try {\n      panelBg = lightenOrDarkenColor(theme.bg || \'#fff\', 18);\n    } catch(e) {\n      panelBg = \'#f6f8fa\';\n    }\n    document.documentElement.style.setProperty(\'--panel-bg\', panelBg);\n    wheel.setTheme({ colors: theme.colors || [], text: theme.text || \'#222\' });\n  }\n\n  function lightenOrDarkenColor(col, amt) {\n    // accepts #rgb or #rrggbb. amt can be negative to darken.\n    if (typeof col !== \'string\') throw new Error(\'Invalid color\');\n    let colStr = col.trim();\n    if (colStr[0] === \'#\') colStr = colStr.slice(1);\n    if (colStr.length === 3) {\n      colStr = colStr.split(\'\').map(c =&gt; c + c).join(\'\');\n    }\n    if (colStr.length !== 6) throw new Error(\'Invalid hex color\');\n    const num = parseInt(colStr, 16);\n    let r = (num &gt;&gt; 16) &amp; 0xFF;\n    let g = (num &gt;&gt; 8) &amp; 0xFF;\n    let b = num &amp; 0xFF;\n    r = Math.max(0, Math.min(255, r + amt));\n    g = Math.max(0, Math.min(255, g + amt));\n    b = Math.max(0, Math.min(255, b + amt));\n    const newHex = \'#\' + ((1 &lt;&lt; 24) + (r &lt;&lt; 16) + (g &lt;&lt; 8) + b).toString(16).slice(1);\n    return newHex;\n  }\n\n  themeSelect.addEventListener(\'change\', () =&gt; {\n    const id = themeSelect.value;\n    const t = themes.find(x =&gt; x.id === id);\n    if (t) applyTheme(t);\n  });\n\n  function parseNamesFromTextarea() {\n    const lines = namesTextarea.value.split(\'\\n\').map(s =&gt; s.trim()).filter(s =&gt; s.length);\n    return lines;\n  }\n\n  function updateWheelFromTextarea() {\n    const names = parseNamesFromTextarea();\n    wheel.setNames(names);\n  }\n\n  addBtn.addEventListener(\'click\', () =&gt; {\n    const v = nameInput.value.trim();\n    if (!v) return;\n    const cur = parseNamesFromTextarea();\n    cur.push(v);\n    namesTextarea.value = cur.join(\'\\n\');\n    nameInput.value = \'\';\n    updateWheelFromTextarea();\n  });\n\n  nameInput.addEventListener(\'keydown\', (e) =&gt; {\n    if (e.key === \'Enter\') {\n      addBtn.click();\n      e.preventDefault();\n    }\n  });\n\n  namesTextarea.addEventListener(\'input\', () =&gt; {\n    updateWheelFromTextarea();\n  });\n\n  loadSampleBtn.addEventListener(\'click\', () =&gt; {\n    const sample = [\'Alice\',\'Bob\',\'Charlie\',\'Diana\',\'Eva\',\'Frank\',\'George\',\'Helen\',\'Ivy\',\'Jack\'];\n    namesTextarea.value = sample.join(\'\\n\');\n    updateWheelFromTextarea();\n  });\n\n  clearBtn.addEventListener(\'click\', () =&gt; {\n    namesTextarea.value = \'\';\n    updateWheelFromTextarea();\n    resultDiv.classList.add(\'hidden\');\n  });\n\n  importBtn.addEventListener(\'click\', async () =&gt; {\n    // prompt user for a newline separated list (simple)\n    const data = prompt(\'Paste names (one per line):\');\n    if (data === null) return;\n    namesTextarea.value = data.split(\'\\n\').map(s =&gt; s.trim()).filter(s =&gt; s).join(\'\\n\');\n    updateWheelFromTextarea();\n  });\n\n  exportBtn.addEventListener(\'click\', () =&gt; {\n    const names = parseNamesFromTextarea();\n    const blob = new Blob([names.join(\'\\n\')], {type: \'text/plain\'});\n    const url = URL.createObjectURL(blob);\n    const a = document.createElement(\'a\');\n    a.href = url;\n    a.download = \'names.txt\';\n    document.body.appendChild(a);\n    a.click();\n    a.remove();\n    URL.revokeObjectURL(url);\n  });\n\n  spinBtn.addEventListener(\'click\', async () =&gt; {\n    const names = parseNamesFromTextarea();\n    if (names.length === 0) {\n      alert(\'Please add at least one name.\');\n      return;\n    }\n    resultDiv.classList.add(\'hidden\');\n    spinBtn.disabled = true;\n    spinBtn.textContent = \'Spinning...\';\n    // pick random index\n    const idx = wheel.getRandomIndex();\n    try {\n      const winnerIndex = await wheel.spinToIndex(idx, { duration: 4500 });\n      const winner = names[winnerIndex];\n      resultDiv.textContent = `Winner: ${winner}`;\n      resultDiv.classList.remove(\'hidden\');\n      spinBtn.textContent = \'SPIN\';\n      spinBtn.disabled = false;\n    } catch (err) {\n      console.error(err);\n      spinBtn.textContent = \'SPIN\';\n      spinBtn.disabled = false;\n    }\n  });\n\n  // initial sample\n  namesTextarea.value = \'Alice\\nBob\\nCharlie\\nDiana\\nEva\';\n  updateWheelFromTextarea();\n});\n', 'cycle_index': 2, 'task': '[Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes.]', 'modality': 'website', 'ideas': '', 'language': ' Python', 'codes': 'main.py\npython\n\'\'\'\nFlask application that serves the wheel-of-names web app.\nRun: pip install flask\nThen: python main.py\nAccess: http://127.0.0.1:5000/\n\'\'\'\nfrom flask import Flask, render_template\nimport os\ndef create_app():\n    """\n    Create and configure the Flask application.\n    """\n    app = Flask(__name__, static_folder=\'static\', template_folder=\'templates\')\n    @app.route(\'/\')\n    def index():\n        """\n        Serve the main page.\n        """\n        return render_template(\'index.html\')\n    return app\nif __name__ == \'__main__\':\n    app = create_app()\n    port = int(os.environ.get(\'PORT\', 5000))\n    app.run(debug=True, host=\'0.0.0.0\', port=port)\n\n\nindex.html\nhtml\n\'\'\'\nDOCSTRING:\nMain HTML page for the Wheel of Names app.\nContains UI elements:\n- name input and list\n- canvas for wheel\n- theme selector\n- spin / clear / add buttons\nIncludes JS files wheel.js and main.js for behavior.\nAlso injects a dynamically generated URL for themes.json using Flask\'s url_for so the client can reliably fetch the resource even when the app is mounted under a subpath.\n\'\'\'\n&lt;!doctype html&gt;\n&lt;html lang="en"&gt;\n&lt;head&gt;\n  &lt;meta charset="utf-8"&gt;\n  &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;\n  &lt;title&gt;Wheel of Names&lt;/title&gt;\n  &lt;link rel="stylesheet" href="{{ url_for(\'static\', filename=\'css/styles.css\') }}"&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div class="container"&gt;\n    &lt;header&gt;\n      &lt;h1&gt;Wheel of Names&lt;/h1&gt;\n      &lt;p&gt;Enter names, choose a theme, and spin to pick a random winner.&lt;/p&gt;\n    &lt;/header&gt;\n    &lt;main class="main-grid"&gt;\n      &lt;section class="left-panel"&gt;\n        &lt;div class="controls"&gt;\n          &lt;label for="name-input"&gt;Add a name&lt;/label&gt;\n          &lt;div class="input-row"&gt;\n            &lt;input id="name-input" type="text" placeholder="Enter name and press Add" autocomplete="off"&gt;\n            &lt;button id="add-name"&gt;Add&lt;/button&gt;\n          &lt;/div&gt;\n          &lt;label for="names-textarea"&gt;Names (one per line)&lt;/label&gt;\n          &lt;textarea id="names-textarea" placeholder="Alice\\nBob\\nCharlie"&gt;&lt;/textarea&gt;\n          &lt;div class="buttons-row"&gt;\n            &lt;button id="load-sample"&gt;Load Sample&lt;/button&gt;\n            &lt;button id="clear-names"&gt;Clear&lt;/button&gt;\n            &lt;button id="import-names"&gt;Import&lt;/button&gt;\n            &lt;button id="export-names"&gt;Export&lt;/button&gt;\n          &lt;/div&gt;\n          &lt;label for="theme-select"&gt;Theme&lt;/label&gt;\n          &lt;select id="theme-select"&gt;&lt;/select&gt;\n          &lt;div class="spin-controls"&gt;\n            &lt;button id="spin-btn" class="spin"&gt;SPIN&lt;/button&gt;\n            &lt;div id="result" class="result hidden"&gt;&lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      &lt;/section&gt;\n      &lt;section class="right-panel"&gt;\n        &lt;div class="wheel-wrapper" id="wheel-wrapper"&gt;\n          &lt;canvas id="wheel-canvas" width="600" height="600"&gt;&lt;/canvas&gt;\n          &lt;div id="pointer"&gt;â–¼&lt;/div&gt;\n        &lt;/div&gt;\n      &lt;/section&gt;\n    &lt;/main&gt;\n    &lt;footer&gt;\n      &lt;small&gt;Built with Flask + Canvas. Themes available.&lt;/small&gt;\n    &lt;/footer&gt;\n  &lt;/div&gt;\n  &lt;!-- Provide the correct URL for themes.json (generated by Flask).\n       This ensures the client can fetch themes.json even when the app is mounted under a prefix. --&gt;\n  &lt;script&gt;\n    window.THEMES_JSON_URL = "{{ url_for(\'static\', filename=\'themes.json\') }}";\n  &lt;/script&gt;\n  &lt;script src="{{ url_for(\'static\', filename=\'js/wheel.js\') }}"&gt;&lt;/script&gt;\n  &lt;script src="{{ url_for(\'static\', filename=\'js/main.js\') }}"&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\n\nthemes.json\njson\n\'\'\'\nDOCSTRING:\nList of themes available for the wheel.\nEach theme contains:\n- name: display name\n- bg: page background color\n- text: primary text color\n- accent: accent color used for pointer/button\n- colors: array of segment colors (will be cycled for segments)\n\'\'\'\n[\n  {\n    "id": "classic",\n    "name": "Classic",\n    "bg": "#ffffff",\n    "text": "#222222",\n    "accent": "#007bff",\n    "colors": ["#ffb3b3", "#ffd9b3", "#fff3b3", "#d9ffb3", "#b3ffd9", "#b3e6ff", "#c7b3ff", "#ffb3f2"]\n  },\n  {\n    "id": "dark",\n    "name": "Dark",\n    "bg": "#121212",\n    "text": "#f5f5f5",\n    "accent": "#ff6b6b",\n    "colors": ["#2e2e34", "#3a3a44", "#4a4a56", "#5a5a68", "#6a6a78", "#7a7a88"]\n  },\n  {\n    "id": "pastel",\n    "name": "Pastel",\n    "bg": "#f7f7ff",\n    "text": "#333333",\n    "accent": "#ff8c94",\n    "colors": ["#ffd1dc", "#fce1b4", "#e8ffd1", "#d1fff0", "#d1e7ff", "#e6d1ff"]\n  },\n  {\n    "id": "neon",\n    "name": "Neon",\n    "bg": "#0f0f13",\n    "text": "#eaff00",\n    "accent": "#00fff5",\n    "colors": ["#ff00ff", "#ff8c00", "#00ff00", "#00ffff", "#8c00ff", "#ff0066"]\n  }\n]\n\n\nstyles.css\ncss\n\'\'\'\nDOCSTRING:\nBase CSS for the Wheel of Names app.\nDefines layout, basic theme variables, and responsive styles.\n\'\'\'\n:root{\n  --bg: #ffffff;\n  --text: #222222;\n  --accent: #007bff;\n  --panel-bg: #f6f8fa;\n}\n*{box-sizing:border-box}\nhtml,body{\n  height:100%;\n  margin:0;\n  font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;\n  background: var(--bg);\n  color: var(--text);\n}\n.container{\n  max-width:1100px;\n  margin:24px auto;\n  padding:16px;\n}\nheader{ text-align:center; margin-bottom:8px }\nh1{ margin:6px 0; font-size:28px }\np{ margin:0; color:var(--text); opacity:0.8 }\n.main-grid{\n  display:grid;\n  grid-template-columns: 360px 1fr;\n  gap:20px;\n  align-items:start;\n  margin-top:18px;\n}\n.left-panel{\n  background:var(--panel-bg);\n  padding:14px;\n  border-radius:8px;\n  box-shadow:0 4px 8px rgba(0,0,0,0.04);\n}\n.left-panel label{ display:block; margin-top:8px; font-weight:600; margin-bottom:6px }\n.input-row{ display:flex; gap:8px }\n.input-row input[type="text"]{\n  flex:1;\n  padding:8px 10px;\n  border-radius:6px;\n  border:1px solid #ddd;\n}\n.input-row button{\n  padding:8px 12px;\n  border-radius:6px;\n  background:var(--accent);\n  color:white;\n  border:none;\n  cursor:pointer;\n}\ntextarea{\n  width:100%;\n  min-height:160px;\n  padding:10px;\n  border-radius:8px;\n  border:1px solid #ddd;\n  resize:vertical;\n}\n.buttons-row{\n  display:flex;\n  gap:8px;\n  margin-top:8px;\n  flex-wrap:wrap;\n}\n.buttons-row button{\n  padding:8px 10px;\n  border-radius:6px;\n  border:1px solid #ccc;\n  background:transparent;\n  cursor:pointer;\n}\n.spin-controls{\n  display:flex;\n  gap:12px;\n  margin-top:16px;\n  align-items:center;\n}\n.spin{\n  padding:14px 24px;\n  background:var(--accent);\n  color:white;\n  font-weight:700;\n  border:none;\n  border-radius:10px;\n  cursor:pointer;\n  font-size:18px;\n}\n.result{\n  padding:10px 12px;\n  background:rgba(0,0,0,0.06);\n  border-radius:8px;\n}\n.hidden{ display:none }\n.right-panel{\n  display:flex;\n  align-items:center;\n  justify-content:center;\n  min-height:420px;\n}\n.wheel-wrapper{\n  position:relative;\n  width:600px;\n  height:600px;\n  display:flex;\n  align-items:center;\n  justify-content:center;\n  margin:auto;\n}\n#wheel-canvas{\n  border-radius:50%;\n  box-shadow: 0 12px 30px rgba(0,0,0,0.12);\n  background:transparent;\n}\n#wheel-wrapper #pointer{\n  position:absolute;\n  top:18px;\n  left:50%;\n  transform:translateX(-50%);\n  font-size:40px;\n  color:var(--accent);\n  text-shadow:0 2px 4px rgba(0,0,0,0.2);\n  pointer-events:none;\n}\nfooter{ text-align:center; margin-top:16px; color:var(--text); opacity:0.7; }\n/* Responsive */\n@media (max-width:960px){\n  .main-grid{ grid-template-columns:1fr; }\n  .wheel-wrapper{ width:420px; height:420px; }\n  #wheel-canvas{ width:420px; height:420px; }\n}\n\n\nwheel.js\njs\n/*\n\'\'\'\nDOCSTRING:\nwheel.js\nContains a Wheel class that draws the wheel on a canvas and animates spins.\nKey methods:\n- constructor(canvas, options)\n- setNames(names)\n- setTheme(theme)\n- draw()\n- spinToIndex(index) -&gt; Promise resolves with index after animation\n- getRandomIndex()\n\'\'\'\n*/\nclass Wheel {\n  constructor(canvas, options = {}) {\n    this.canvas = canvas;\n    this.ctx = canvas.getContext(\'2d\');\n    this.names = options.names || [];\n    this.colors = options.colors || [\'#ffb3b3\', \'#ffd9b3\', \'#fff3b3\', \'#d9ffb3\', \'#b3ffd9\', \'#b3e6ff\'];\n    this.textColor = options.textColor || \'#222\';\n    this.centerX = canvas.width / 2;\n    this.centerY = canvas.height / 2;\n    this.radius = Math.min(this.centerX, this.centerY) - 10;\n    this.rotation = 0; // degrees\n    this.font = options.font || \'16px Inter, Arial\';\n    this.onDraw = options.onDraw || function(){};\n    this._animating = false;\n    this.draw();\n  }\n  setNames(names) {\n    this.names = names.slice();\n    this.draw();\n  }\n  setTheme(theme) {\n    if (!theme) return;\n    if (theme.colors &amp;&amp; theme.colors.length) this.colors = theme.colors.slice();\n    if (theme.text) this.textColor = theme.text;\n    this.draw();\n  }\n  clearCanvas() {\n    this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height);\n  }\n  draw() {\n    this.clearCanvas();\n    const ctx = this.ctx;\n    const n = Math.max(1, this.names.length);\n    const seg = 360 / n;\n    ctx.save();\n    ctx.translate(this.centerX, this.centerY);\n    ctx.rotate(this.degToRad(this.rotation));\n    // Draw segments\n    for (let i = 0; i &lt; n; i++) {\n      const start = this.degToRad(i * seg);\n      const end = this.degToRad((i + 1) * seg);\n      ctx.beginPath();\n      ctx.moveTo(0,0);\n      ctx.arc(0,0,this.radius,start,end);\n      ctx.closePath();\n      ctx.fillStyle = this.colors[i % this.colors.length];\n      ctx.fill();\n      // stroke\n      ctx.lineWidth = 2;\n      ctx.strokeStyle = \'rgba(0,0,0,0.08)\';\n      ctx.stroke();\n      // Draw label\n      ctx.save();\n      const angle = start + (end - start) / 2;\n      ctx.rotate(angle);\n      ctx.translate(this.radius * 0.55, 0);\n      ctx.rotate(Math.PI / 2);\n      ctx.fillStyle = this.textColor;\n      ctx.font = this.font;\n      ctx.textAlign = \'center\';\n      ctx.textBaseline = \'middle\';\n      const name = this.names[i] || \'\';\n      this.wrapText(ctx, name, 0, 0, this.radius * 0.35, 18);\n      ctx.restore();\n    }\n    ctx.restore();\n    // center circle\n    ctx.beginPath();\n    ctx.arc(this.centerX, this.centerY, this.radius * 0.12, 0, Math.PI*2);\n    ctx.fillStyle = \'#ffffff\';\n    ctx.fill();\n    ctx.lineWidth = 2;\n    ctx.strokeStyle = \'rgba(0,0,0,0.06)\';\n    ctx.stroke();\n    this.onDraw();\n  }\n  wrapText(ctx, text, x, y, maxWidth, lineHeight) {\n    // A simple wrap for canvas text\n    const words = text.split(\' \');\n    let line = \'\';\n    let yOffset = y;\n    for (let n = 0; n &lt; words.length; n++) {\n      const testLine = line + words[n] + \' \';\n      const metrics = ctx.measureText(testLine);\n      const testWidth = metrics.width;\n      if (testWidth &gt; maxWidth &amp;&amp; n &gt; 0) {\n        ctx.fillText(line.trim(), x, yOffset);\n        line = words[n] + \' \';\n        yOffset += lineHeight;\n      } else {\n        line = testLine;\n      }\n    }\n    ctx.fillText(line.trim(), x, yOffset);\n  }\n  degToRad(d) {\n    return d * Math.PI / 180;\n  }\n  radToDeg(r) {\n    return r * 180 / Math.PI;\n  }\n  getRandomIndex() {\n    if (!this.names.length) return 0;\n    return Math.floor(Math.random() * this.names.length);\n  }\n  // Spin such that the segment at `index` lands on the pointer at top.\n  spinToIndex(index, opts = {}) {\n    if (this._animating) return Promise.reject(\'Already animating\');\n    if (!this.names.length) return Promise.reject(\'No names\');\n    const n = this.names.length;\n    const segAngle = 360 / n;\n    // We want the center of target segment to be at angle 270deg (top of canvas - adjust if pointer is at top)\n    // Our rotation variable rotates the whole wheel clockwise in degrees.\n    // Compute the current rotation normalized\n    const normalized = ((this.rotation % 360) + 360) % 360;\n    // Calculate angle to place the segment center at top (270deg)\n    // Center of segment i is at angle: (i * segAngle + segAngle/2)\n    // We need rotation such that (centerAngle + rotation) mod 360 = 270\n    const centerAngle = index * segAngle + segAngle / 2;\n    // Solve for rotation target:\n    let targetRotation = 270 - centerAngle;\n    // Normalize to 0..360\n    targetRotation = ((targetRotation % 360) + 360) % 360;\n    // To produce multiple spins, add several full rotations:\n    const fullSpins = opts.fullSpins !== undefined ? opts.fullSpins : (3 + Math.floor(Math.random()*3)); // 3-5 spins\n    const endRotation = targetRotation + fullSpins * 360 + (opts.randomOffset || 0);\n    // We\'ll animate from current normalized to endRotation, taking into account wrap\n    const startRotation = normalized;\n    const delta = endRotation - startRotation;\n    const duration = opts.duration || 5000; // ms\n    const startTime = performance.now();\n    this._animating = true;\n    return new Promise((resolve) =&gt; {\n      const animate = (now) =&gt; {\n        const elapsed = now - startTime;\n        const t = Math.min(1, elapsed / duration);\n        // ease out cubic\n        const eased = 1 - Math.pow(1 - t, 3);\n        const current = startRotation + delta * eased;\n        this.rotation = current;\n        this.draw();\n        if (t &lt; 1) {\n          requestAnimationFrame(animate);\n        } else {\n          this._animating = false;\n          // Normalize rotation to endRotation mod 360\n          this.rotation = ((endRotation % 360) + 360) % 360;\n          this.draw();\n          resolve(index);\n        }\n      };\n      requestAnimationFrame(animate);\n    });\n  }\n}\n\n\nmain.js\njs\n/*\n\'\'\'\nDOCSTRING:\nmain.js\nWires UI to the Wheel class:\n- loads themes.json (URL injected by Flask)\n- populates theme selector\n- reads names and updates wheel\n- handles spin logic and result display\nIncludes robust fallback if fetching themes.json fails.\n\'\'\'\n*/\ndocument.addEventListener(\'DOMContentLoaded\', async () =&gt; {\n  const canvas = document.getElementById(\'wheel-canvas\');\n  const nameInput = document.getElementById(\'name-input\');\n  const addBtn = document.getElementById(\'add-name\');\n  const namesTextarea = document.getElementById(\'names-textarea\');\n  const spinBtn = document.getElementById(\'spin-btn\');\n  const resultDiv = document.getElementById(\'result\');\n  const themeSelect = document.getElementById(\'theme-select\');\n  const loadSampleBtn = document.getElementById(\'load-sample\');\n  const clearBtn = document.getElementById(\'clear-names\');\n  const importBtn = document.getElementById(\'import-names\');\n  const exportBtn = document.getElementById(\'export-names\');\n  const wheel = new Wheel(canvas, { names: [], colors: [\'#ffb3b3\',\'#ffd9b3\',\'#fff3b3\',\'#d9ffb3\'] });\n  let themes = [];\n  // A small fallback theme set in case fetching themes.json fails.\n  const defaultThemes = [\n    {\n      id: \'fallback\',\n      name: \'Default\',\n      bg: \'#ffffff\',\n      text: \'#222222\',\n      accent: \'#007bff\',\n      colors: [\'#ffb3b3\',\'#ffd9b3\',\'#fff3b3\',\'#d9ffb3\']\n    }\n  ];\n  // Helper to populate theme selector\n  function populateThemeSelector(list) {\n    themeSelect.innerHTML = \'\';\n    list.forEach(t =&gt; {\n      const opt = document.createElement(\'option\');\n      opt.value = t.id;\n      opt.textContent = t.name;\n      themeSelect.appendChild(opt);\n    });\n  }\n  // Load themes.json (URL injected by Flask)\n  try {\n    const themesUrl = window.THEMES_JSON_URL || \'/static/themes.json\';\n    const resp = await fetch(themesUrl);\n    if (!resp.ok) throw new Error(\'HTTP \' + resp.status);\n    themes = await resp.json();\n    if (!Array.isArray(themes) || themes.length === 0) throw new Error(\'No themes found\');\n    populateThemeSelector(themes);\n    // apply first theme\n    applyTheme(themes[0]);\n    themeSelect.value = themes[0].id;\n  } catch (err) {\n    console.error(\'Failed to load themes:\', err);\n    // fallback\n    themes = defaultThemes;\n    populateThemeSelector(themes);\n    applyTheme(themes[0]);\n    themeSelect.value = themes[0].id;\n  }\n  function applyTheme(theme) {\n    if (!theme) return;\n    document.documentElement.style.setProperty(\'--bg\', theme.bg || \'#fff\');\n    document.documentElement.style.setProperty(\'--text\', theme.text || \'#222\');\n    document.documentElement.style.setProperty(\'--accent\', theme.accent || \'#007bff\');\n    // set panel bg slightly adjusted\n    let panelBg = theme.bg;\n    // robust luminance tweak (supports 3/6 digit hex)\n    try {\n      panelBg = lightenOrDarkenColor(theme.bg || \'#fff\', 18);\n    } catch(e) {\n      panelBg = \'#f6f8fa\';\n    }\n    document.documentElement.style.setProperty(\'--panel-bg\', panelBg);\n    wheel.setTheme({ colors: theme.colors || [], text: theme.text || \'#222\' });\n  }\n  function lightenOrDarkenColor(col, amt) {\n    // accepts #rgb or #rrggbb. amt can be negative to darken.\n    if (typeof col !== \'string\') throw new Error(\'Invalid color\');\n    let colStr = col.trim();\n    if (colStr[0] === \'#\') colStr = colStr.slice(1);\n    if (colStr.length === 3) {\n      colStr = colStr.split(\'\').map(c =&gt; c + c).join(\'\');\n    }\n    if (colStr.length !== 6) throw new Error(\'Invalid hex color\');\n    const num = parseInt(colStr, 16);\n    let r = (num &gt;&gt; 16) &amp; 0xFF;\n    let g = (num &gt;&gt; 8) &amp; 0xFF;\n    let b = num &amp; 0xFF;\n    r = Math.max(0, Math.min(255, r + amt));\n    g = Math.max(0, Math.min(255, g + amt));\n    b = Math.max(0, Math.min(255, b + amt));\n    const newHex = \'#\' + ((1 &lt;&lt; 24) + (r &lt;&lt; 16) + (g &lt;&lt; 8) + b).toString(16).slice(1);\n    return newHex;\n  }\n  themeSelect.addEventListener(\'change\', () =&gt; {\n    const id = themeSelect.value;\n    const t = themes.find(x =&gt; x.id === id);\n    if (t) applyTheme(t);\n  });\n  function parseNamesFromTextarea() {\n    const lines = namesTextarea.value.split(\'\\n\').map(s =&gt; s.trim()).filter(s =&gt; s.length);\n    return lines;\n  }\n  function updateWheelFromTextarea() {\n    const names = parseNamesFromTextarea();\n    wheel.setNames(names);\n  }\n  addBtn.addEventListener(\'click\', () =&gt; {\n    const v = nameInput.value.trim();\n    if (!v) return;\n    const cur = parseNamesFromTextarea();\n    cur.push(v);\n    namesTextarea.value = cur.join(\'\\n\');\n    nameInput.value = \'\';\n    updateWheelFromTextarea();\n  });\n  nameInput.addEventListener(\'keydown\', (e) =&gt; {\n    if (e.key === \'Enter\') {\n      addBtn.click();\n      e.preventDefault();\n    }\n  });\n  namesTextarea.addEventListener(\'input\', () =&gt; {\n    updateWheelFromTextarea();\n  });\n  loadSampleBtn.addEventListener(\'click\', () =&gt; {\n    const sample = [\'Alice\',\'Bob\',\'Charlie\',\'Diana\',\'Eva\',\'Frank\',\'George\',\'Helen\',\'Ivy\',\'Jack\'];\n    namesTextarea.value = sample.join(\'\\n\');\n    updateWheelFromTextarea();\n  });\n  clearBtn.addEventListener(\'click\', () =&gt; {\n    namesTextarea.value = \'\';\n    updateWheelFromTextarea();\n    resultDiv.classList.add(\'hidden\');\n  });\n  importBtn.addEventListener(\'click\', async () =&gt; {\n    // prompt user for a newline separated list (simple)\n    const data = prompt(\'Paste names (one per line):\');\n    if (data === null) return;\n    namesTextarea.value = data.split(\'\\n\').map(s =&gt; s.trim()).filter(s =&gt; s).join(\'\\n\');\n    updateWheelFromTextarea();\n  });\n  exportBtn.addEventListener(\'click\', () =&gt; {\n    const names = parseNamesFromTextarea();\n    const blob = new Blob([names.join(\'\\n\')], {type: \'text/plain\'});\n    const url = URL.createObjectURL(blob);\n    const a = document.createElement(\'a\');\n    a.href = url;\n    a.download = \'names.txt\';\n    document.body.appendChild(a);\n    a.click();\n    a.remove();\n    URL.revokeObjectURL(url);\n  });\n  spinBtn.addEventListener(\'click\', async () =&gt; {\n    const names = parseNamesFromTextarea();\n    if (names.length === 0) {\n      alert(\'Please add at least one name.\');\n      return;\n    }\n    resultDiv.classList.add(\'hidden\');\n    spinBtn.disabled = true;\n    spinBtn.textContent = \'Spinning...\';\n    // pick random index\n    const idx = wheel.getRandomIndex();\n    try {\n      const winnerIndex = await wheel.spinToIndex(idx, { duration: 4500 });\n      const winner = names[winnerIndex];\n      resultDiv.textContent = `Winner: ${winner}`;\n      resultDiv.classList.remove(\'hidden\');\n      spinBtn.textContent = \'SPIN\';\n      spinBtn.disabled = false;\n    } catch (err) {\n      console.error(err);\n      spinBtn.textContent = \'SPIN\';\n      spinBtn.disabled = false;\n    }\n  });\n  // initial sample\n  namesTextarea.value = \'Alice\\nBob\\nCharlie\\nDiana\\nEva\';\n  updateWheelFromTextarea();\n});\n\n\n', 'images': '', 'comments': ' High â€” hardcoded static path for themes.json will break deployments mounted under a URL prefix (and can fail in some deployment configs)\n\nWhy this is important\n- main.js currently calls fetch(\'/static/themes.json\') using an absolute path starting with \'/\'. That works for a development server at the site root, but will fail if:\n  - the Flask app is mounted under a subpath (example: https://example.com/myapp/), or\n  - static_url_path / static_folder are customized, or\n  - the app is reverse-proxied to a different prefix.\n- If themes.json fails to load, theme selector is empty and the theme application will not work â€” a core feature per the requirements ("possibility of choose a variety of themes").\n\nHow to fix (recommended)\n- Let Flask generate the correct URL for themes.json via url_for and make that value available to the client-side code. The simplest, robust approach is to inject a small inline script into your Jinja template that sets a global variable with the correct static URL. Then change main.js to use that variable when fetching themes.\n\nConcrete code changes\n\n1) In templates/index.html, add an inline script (place it before including main.js/wheel.js). Example insertion (replace/add inside  before your script tags):\n\n  \n    // Provide the correct URL for themes.json (generated by Flask)\n    window.THEMES_JSON_URL = "{{ url_for(\'static\', filename=\'themes.json\') }}";\n  \n\n(You already use url_for for CSS/JS; do the same for the JSON file.)\n\n2) In static/js/main.js, change the theme fetch to use the injected URL instead of the hardcoded path. Replace:\n\n  const resp = await fetch(\'/static/themes.json\');\n\nwith:\n\n  const themesUrl = window.THEMES_JSON_URL || \'/static/themes.json\';\n  const resp = await fetch(themesUrl);\n\n(Keeping the fallback to \'/static/themes.json\' is harmless for local dev but not relied upon for production.)\n\n3) (Optional but recommended) Add a robust fallback if fetch fails (already somewhat done with try/catch). Consider pre-bundling a small defaultThemes array in main.js so the UI still works if fetch fails.\n\nExample combined snippet for main.js:\n\n  // Load themes.json (URL injected by Flask)\n  try {\n    const themesUrl = window.THEMES_JSON_URL || \'/static/themes.json\';\n    const resp = await fetch(themesUrl);\n    if (!resp.ok) throw new Error(\'HTTP \' + resp.status);\n    themes = await resp.json();\n    // ... populate selector ...\n  } catch (err) {\n    console.error(\'Failed to load themes:\', err);\n    // fallback: define a minimal default theme so UI still works\n    themes = [{\n      id: \'fallback\',\n      name: \'Default\',\n      bg: \'#ffffff\',\n      text: \'#222222\',\n      accent: \'#007bff\',\n      colors: [\'#ffb3b3\',\'#ffd9b3\',\'#fff3b3\',\'#d9ffb3\']\n    }];\n    // populate selector with fallback theme\n  }\n\nWhy this change fixes it\n- url_for builds the correct static URL no matter where the app is mounted or how Flask is configured. Injecting that into the page ensures client-side fetch always targets the actual resource location.\n\nExtra suggestion (non-blocking)\n- Consider making lightenOrDarkenColor more robust (support shorthand hex like #fff, handle edge cases) as a follow-up. It currently works for typical 6-digit hexes, but solidifying it will improve theme rendering in edge cases.\n\nIf you want, I can produce the exact patch (diff) for index.html and main.js.'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_3_5_TURBO |

[2025-17-09 14:02:51 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Code Reviewer |
| **user_role_name** | Programmer |
| **assistant_role_prompt** | {chatdev_prompt} You are Code Reviewer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. You can help programmers to assess source codes for software troubleshooting, fix bugs to increase code quality and robustness, and offer proposals to improve the source codes. Here is a new customer's task: {task}. To complete the task, you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Programmer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. You can write/create computer software or applications by providing a specific programming language to the computer. You have extensive computing and coding experience in many varieties of programming languages and platforms, such as Python, Java, C, C++, HTML, CSS, JavaScript, XML, SQL, PHP, etc,. Here is a new customer's task: {task}. To complete the task, you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **task_prompt** | [Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes.] |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_3_5_TURBO |
| **background_prompt** | ChatDev is a software company powered by multiple intelligent agents, such as chief executive officer, chief human resources officer, chief product officer, chief technology officer, etc, with a multi-agent organizational structure and the mission of 'changing the digital world through programming'. |

[2025-17-09 14:02:51 INFO] Programmer: **[Start Chat]**

[ChatDev is a software company powered by multiple intelligent agents, such as chief executive officer, chief human resources officer, chief product officer, chief technology officer, etc, with a multi-agent organizational structure and the mission of 'changing the digital world through programming'.
You are Code Reviewer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer.
You can help programmers to assess source codes for software troubleshooting, fix bugs to increase code quality and robustness, and offer proposals to improve the source codes.
Here is a new customer's task: [Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes.].
To complete the task, you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]

According to the new user's task and our software designs: 
Task: "[Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes.]".
Modality: "website".
Programming Language: " Python"
Ideas: ""
Codes:
"main.py
```python
'''
Flask application that serves the wheel-of-names web app.
Run: pip install flask
Then: python main.py
Access: http://127.0.0.1:5000/
'''
from flask import Flask, render_template
import os
def create_app():
    """
    Create and configure the Flask application.
    """
    app = Flask(__name__, static_folder='static', template_folder='templates')
    @app.route('/')
    def index():
        """
        Serve the main page.
        """
        return render_template('index.html')
    return app
if __name__ == '__main__':
    app = create_app()
    port = int(os.environ.get('PORT', 5000))
    app.run(debug=True, host='0.0.0.0', port=port)
```

index.html
```html
'''
DOCSTRING:
Main HTML page for the Wheel of Names app.
Contains UI elements:
- name input and list
- canvas for wheel
- theme selector
- spin / clear / add buttons
Includes JS files wheel.js and main.js for behavior.
Also injects a dynamically generated URL for themes.json using Flask's url_for so the client can reliably fetch the resource even when the app is mounted under a subpath.
'''
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Wheel of Names</title>
  <link rel="stylesheet" href="{{ url_for('static', filename='css/styles.css') }}">
</head>
<body>
  <div class="container">
    <header>
      <h1>Wheel of Names</h1>
      <p>Enter names, choose a theme, and spin to pick a random winner.</p>
    </header>
    <main class="main-grid">
      <section class="left-panel">
        <div class="controls">
          <label for="name-input">Add a name</label>
          <div class="input-row">
            <input id="name-input" type="text" placeholder="Enter name and press Add" autocomplete="off">
            <button id="add-name">Add</button>
          </div>
          <label for="names-textarea">Names (one per line)</label>
          <textarea id="names-textarea" placeholder="Alice\nBob\nCharlie"></textarea>
          <div class="buttons-row">
            <button id="load-sample">Load Sample</button>
            <button id="clear-names">Clear</button>
            <button id="import-names">Import</button>
            <button id="export-names">Export</button>
          </div>
          <label for="theme-select">Theme</label>
          <select id="theme-select"></select>
          <div class="spin-controls">
            <button id="spin-btn" class="spin">SPIN</button>
            <div id="result" class="result hidden"></div>
          </div>
        </div>
      </section>
      <section class="right-panel">
        <div class="wheel-wrapper" id="wheel-wrapper">
          <canvas id="wheel-canvas" width="600" height="600"></canvas>
          <div id="pointer">â–¼</div>
        </div>
      </section>
    </main>
    <footer>
      <small>Built with Flask + Canvas. Themes available.</small>
    </footer>
  </div>
  <!-- Provide the correct URL for themes.json (generated by Flask).
       This ensures the client can fetch themes.json even when the app is mounted under a prefix. -->
  <script>
    window.THEMES_JSON_URL = "{{ url_for('static', filename='themes.json') }}";
  </script>
  <script src="{{ url_for('static', filename='js/wheel.js') }}"></script>
  <script src="{{ url_for('static', filename='js/main.js') }}"></script>
</body>
</html>
```

themes.json
```json
'''
DOCSTRING:
List of themes available for the wheel.
Each theme contains:
- name: display name
- bg: page background color
- text: primary text color
- accent: accent color used for pointer/button
- colors: array of segment colors (will be cycled for segments)
'''
[
  {
    "id": "classic",
    "name": "Classic",
    "bg": "#ffffff",
    "text": "#222222",
    "accent": "#007bff",
    "colors": ["#ffb3b3", "#ffd9b3", "#fff3b3", "#d9ffb3", "#b3ffd9", "#b3e6ff", "#c7b3ff", "#ffb3f2"]
  },
  {
    "id": "dark",
    "name": "Dark",
    "bg": "#121212",
    "text": "#f5f5f5",
    "accent": "#ff6b6b",
    "colors": ["#2e2e34", "#3a3a44", "#4a4a56", "#5a5a68", "#6a6a78", "#7a7a88"]
  },
  {
    "id": "pastel",
    "name": "Pastel",
    "bg": "#f7f7ff",
    "text": "#333333",
    "accent": "#ff8c94",
    "colors": ["#ffd1dc", "#fce1b4", "#e8ffd1", "#d1fff0", "#d1e7ff", "#e6d1ff"]
  },
  {
    "id": "neon",
    "name": "Neon",
    "bg": "#0f0f13",
    "text": "#eaff00",
    "accent": "#00fff5",
    "colors": ["#ff00ff", "#ff8c00", "#00ff00", "#00ffff", "#8c00ff", "#ff0066"]
  }
]
```

styles.css
```css
'''
DOCSTRING:
Base CSS for the Wheel of Names app.
Defines layout, basic theme variables, and responsive styles.
'''
:root{
  --bg: #ffffff;
  --text: #222222;
  --accent: #007bff;
  --panel-bg: #f6f8fa;
}
*{box-sizing:border-box}
html,body{
  height:100%;
  margin:0;
  font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
  background: var(--bg);
  color: var(--text);
}
.container{
  max-width:1100px;
  margin:24px auto;
  padding:16px;
}
header{ text-align:center; margin-bottom:8px }
h1{ margin:6px 0; font-size:28px }
p{ margin:0; color:var(--text); opacity:0.8 }
.main-grid{
  display:grid;
  grid-template-columns: 360px 1fr;
  gap:20px;
  align-items:start;
  margin-top:18px;
}
.left-panel{
  background:var(--panel-bg);
  padding:14px;
  border-radius:8px;
  box-shadow:0 4px 8px rgba(0,0,0,0.04);
}
.left-panel label{ display:block; margin-top:8px; font-weight:600; margin-bottom:6px }
.input-row{ display:flex; gap:8px }
.input-row input[type="text"]{
  flex:1;
  padding:8px 10px;
  border-radius:6px;
  border:1px solid #ddd;
}
.input-row button{
  padding:8px 12px;
  border-radius:6px;
  background:var(--accent);
  color:white;
  border:none;
  cursor:pointer;
}
textarea{
  width:100%;
  min-height:160px;
  padding:10px;
  border-radius:8px;
  border:1px solid #ddd;
  resize:vertical;
}
.buttons-row{
  display:flex;
  gap:8px;
  margin-top:8px;
  flex-wrap:wrap;
}
.buttons-row button{
  padding:8px 10px;
  border-radius:6px;
  border:1px solid #ccc;
  background:transparent;
  cursor:pointer;
}
.spin-controls{
  display:flex;
  gap:12px;
  margin-top:16px;
  align-items:center;
}
.spin{
  padding:14px 24px;
  background:var(--accent);
  color:white;
  font-weight:700;
  border:none;
  border-radius:10px;
  cursor:pointer;
  font-size:18px;
}
.result{
  padding:10px 12px;
  background:rgba(0,0,0,0.06);
  border-radius:8px;
}
.hidden{ display:none }
.right-panel{
  display:flex;
  align-items:center;
  justify-content:center;
  min-height:420px;
}
.wheel-wrapper{
  position:relative;
  width:600px;
  height:600px;
  display:flex;
  align-items:center;
  justify-content:center;
  margin:auto;
}
#wheel-canvas{
  border-radius:50%;
  box-shadow: 0 12px 30px rgba(0,0,0,0.12);
  background:transparent;
}
#wheel-wrapper #pointer{
  position:absolute;
  top:18px;
  left:50%;
  transform:translateX(-50%);
  font-size:40px;
  color:var(--accent);
  text-shadow:0 2px 4px rgba(0,0,0,0.2);
  pointer-events:none;
}
footer{ text-align:center; margin-top:16px; color:var(--text); opacity:0.7; }
/* Responsive */
@media (max-width:960px){
  .main-grid{ grid-template-columns:1fr; }
  .wheel-wrapper{ width:420px; height:420px; }
  #wheel-canvas{ width:420px; height:420px; }
}
```

wheel.js
```js
/*
'''
DOCSTRING:
wheel.js
Contains a Wheel class that draws the wheel on a canvas and animates spins.
Key methods:
- constructor(canvas, options)
- setNames(names)
- setTheme(theme)
- draw()
- spinToIndex(index) -> Promise resolves with index after animation
- getRandomIndex()
'''
*/
class Wheel {
  constructor(canvas, options = {}) {
    this.canvas = canvas;
    this.ctx = canvas.getContext('2d');
    this.names = options.names || [];
    this.colors = options.colors || ['#ffb3b3', '#ffd9b3', '#fff3b3', '#d9ffb3', '#b3ffd9', '#b3e6ff'];
    this.textColor = options.textColor || '#222';
    this.centerX = canvas.width / 2;
    this.centerY = canvas.height / 2;
    this.radius = Math.min(this.centerX, this.centerY) - 10;
    this.rotation = 0; // degrees
    this.font = options.font || '16px Inter, Arial';
    this.onDraw = options.onDraw || function(){};
    this._animating = false;
    this.draw();
  }
  setNames(names) {
    this.names = names.slice();
    this.draw();
  }
  setTheme(theme) {
    if (!theme) return;
    if (theme.colors && theme.colors.length) this.colors = theme.colors.slice();
    if (theme.text) this.textColor = theme.text;
    this.draw();
  }
  clearCanvas() {
    this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height);
  }
  draw() {
    this.clearCanvas();
    const ctx = this.ctx;
    const n = Math.max(1, this.names.length);
    const seg = 360 / n;
    ctx.save();
    ctx.translate(this.centerX, this.centerY);
    ctx.rotate(this.degToRad(this.rotation));
    // Draw segments
    for (let i = 0; i < n; i++) {
      const start = this.degToRad(i * seg);
      const end = this.degToRad((i + 1) * seg);
      ctx.beginPath();
      ctx.moveTo(0,0);
      ctx.arc(0,0,this.radius,start,end);
      ctx.closePath();
      ctx.fillStyle = this.colors[i % this.colors.length];
      ctx.fill();
      // stroke
      ctx.lineWidth = 2;
      ctx.strokeStyle = 'rgba(0,0,0,0.08)';
      ctx.stroke();
      // Draw label
      ctx.save();
      const angle = start + (end - start) / 2;
      ctx.rotate(angle);
      ctx.translate(this.radius * 0.55, 0);
      ctx.rotate(Math.PI / 2);
      ctx.fillStyle = this.textColor;
      ctx.font = this.font;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      const name = this.names[i] || '';
      this.wrapText(ctx, name, 0, 0, this.radius * 0.35, 18);
      ctx.restore();
    }
    ctx.restore();
    // center circle
    ctx.beginPath();
    ctx.arc(this.centerX, this.centerY, this.radius * 0.12, 0, Math.PI*2);
    ctx.fillStyle = '#ffffff';
    ctx.fill();
    ctx.lineWidth = 2;
    ctx.strokeStyle = 'rgba(0,0,0,0.06)';
    ctx.stroke();
    this.onDraw();
  }
  wrapText(ctx, text, x, y, maxWidth, lineHeight) {
    // A simple wrap for canvas text
    const words = text.split(' ');
    let line = '';
    let yOffset = y;
    for (let n = 0; n < words.length; n++) {
      const testLine = line + words[n] + ' ';
      const metrics = ctx.measureText(testLine);
      const testWidth = metrics.width;
      if (testWidth > maxWidth && n > 0) {
        ctx.fillText(line.trim(), x, yOffset);
        line = words[n] + ' ';
        yOffset += lineHeight;
      } else {
        line = testLine;
      }
    }
    ctx.fillText(line.trim(), x, yOffset);
  }
  degToRad(d) {
    return d * Math.PI / 180;
  }
  radToDeg(r) {
    return r * 180 / Math.PI;
  }
  getRandomIndex() {
    if (!this.names.length) return 0;
    return Math.floor(Math.random() * this.names.length);
  }
  // Spin such that the segment at `index` lands on the pointer at top.
  spinToIndex(index, opts = {}) {
    if (this._animating) return Promise.reject('Already animating');
    if (!this.names.length) return Promise.reject('No names');
    const n = this.names.length;
    const segAngle = 360 / n;
    // We want the center of target segment to be at angle 270deg (top of canvas - adjust if pointer is at top)
    // Our rotation variable rotates the whole wheel clockwise in degrees.
    // Compute the current rotation normalized
    const normalized = ((this.rotation % 360) + 360) % 360;
    // Calculate angle to place the segment center at top (270deg)
    // Center of segment i is at angle: (i * segAngle + segAngle/2)
    // We need rotation such that (centerAngle + rotation) mod 360 = 270
    const centerAngle = index * segAngle + segAngle / 2;
    // Solve for rotation target:
    let targetRotation = 270 - centerAngle;
    // Normalize to 0..360
    targetRotation = ((targetRotation % 360) + 360) % 360;
    // To produce multiple spins, add several full rotations:
    const fullSpins = opts.fullSpins !== undefined ? opts.fullSpins : (3 + Math.floor(Math.random()*3)); // 3-5 spins
    const endRotation = targetRotation + fullSpins * 360 + (opts.randomOffset || 0);
    // We'll animate from current normalized to endRotation, taking into account wrap
    const startRotation = normalized;
    const delta = endRotation - startRotation;
    const duration = opts.duration || 5000; // ms
    const startTime = performance.now();
    this._animating = true;
    return new Promise((resolve) => {
      const animate = (now) => {
        const elapsed = now - startTime;
        const t = Math.min(1, elapsed / duration);
        // ease out cubic
        const eased = 1 - Math.pow(1 - t, 3);
        const current = startRotation + delta * eased;
        this.rotation = current;
        this.draw();
        if (t < 1) {
          requestAnimationFrame(animate);
        } else {
          this._animating = false;
          // Normalize rotation to endRotation mod 360
          this.rotation = ((endRotation % 360) + 360) % 360;
          this.draw();
          resolve(index);
        }
      };
      requestAnimationFrame(animate);
    });
  }
}
```

main.js
```js
/*
'''
DOCSTRING:
main.js
Wires UI to the Wheel class:
- loads themes.json (URL injected by Flask)
- populates theme selector
- reads names and updates wheel
- handles spin logic and result display
Includes robust fallback if fetching themes.json fails.
'''
*/
document.addEventListener('DOMContentLoaded', async () => {
  const canvas = document.getElementById('wheel-canvas');
  const nameInput = document.getElementById('name-input');
  const addBtn = document.getElementById('add-name');
  const namesTextarea = document.getElementById('names-textarea');
  const spinBtn = document.getElementById('spin-btn');
  const resultDiv = document.getElementById('result');
  const themeSelect = document.getElementById('theme-select');
  const loadSampleBtn = document.getElementById('load-sample');
  const clearBtn = document.getElementById('clear-names');
  const importBtn = document.getElementById('import-names');
  const exportBtn = document.getElementById('export-names');
  const wheel = new Wheel(canvas, { names: [], colors: ['#ffb3b3','#ffd9b3','#fff3b3','#d9ffb3'] });
  let themes = [];
  // A small fallback theme set in case fetching themes.json fails.
  const defaultThemes = [
    {
      id: 'fallback',
      name: 'Default',
      bg: '#ffffff',
      text: '#222222',
      accent: '#007bff',
      colors: ['#ffb3b3','#ffd9b3','#fff3b3','#d9ffb3']
    }
  ];
  // Helper to populate theme selector
  function populateThemeSelector(list) {
    themeSelect.innerHTML = '';
    list.forEach(t => {
      const opt = document.createElement('option');
      opt.value = t.id;
      opt.textContent = t.name;
      themeSelect.appendChild(opt);
    });
  }
  // Load themes.json (URL injected by Flask)
  try {
    const themesUrl = window.THEMES_JSON_URL || '/static/themes.json';
    const resp = await fetch(themesUrl);
    if (!resp.ok) throw new Error('HTTP ' + resp.status);
    themes = await resp.json();
    if (!Array.isArray(themes) || themes.length === 0) throw new Error('No themes found');
    populateThemeSelector(themes);
    // apply first theme
    applyTheme(themes[0]);
    themeSelect.value = themes[0].id;
  } catch (err) {
    console.error('Failed to load themes:', err);
    // fallback
    themes = defaultThemes;
    populateThemeSelector(themes);
    applyTheme(themes[0]);
    themeSelect.value = themes[0].id;
  }
  function applyTheme(theme) {
    if (!theme) return;
    document.documentElement.style.setProperty('--bg', theme.bg || '#fff');
    document.documentElement.style.setProperty('--text', theme.text || '#222');
    document.documentElement.style.setProperty('--accent', theme.accent || '#007bff');
    // set panel bg slightly adjusted
    let panelBg = theme.bg;
    // robust luminance tweak (supports 3/6 digit hex)
    try {
      panelBg = lightenOrDarkenColor(theme.bg || '#fff', 18);
    } catch(e) {
      panelBg = '#f6f8fa';
    }
    document.documentElement.style.setProperty('--panel-bg', panelBg);
    wheel.setTheme({ colors: theme.colors || [], text: theme.text || '#222' });
  }
  function lightenOrDarkenColor(col, amt) {
    // accepts #rgb or #rrggbb. amt can be negative to darken.
    if (typeof col !== 'string') throw new Error('Invalid color');
    let colStr = col.trim();
    if (colStr[0] === '#') colStr = colStr.slice(1);
    if (colStr.length === 3) {
      colStr = colStr.split('').map(c => c + c).join('');
    }
    if (colStr.length !== 6) throw new Error('Invalid hex color');
    const num = parseInt(colStr, 16);
    let r = (num >> 16) & 0xFF;
    let g = (num >> 8) & 0xFF;
    let b = num & 0xFF;
    r = Math.max(0, Math.min(255, r + amt));
    g = Math.max(0, Math.min(255, g + amt));
    b = Math.max(0, Math.min(255, b + amt));
    const newHex = '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
    return newHex;
  }
  themeSelect.addEventListener('change', () => {
    const id = themeSelect.value;
    const t = themes.find(x => x.id === id);
    if (t) applyTheme(t);
  });
  function parseNamesFromTextarea() {
    const lines = namesTextarea.value.split('\n').map(s => s.trim()).filter(s => s.length);
    return lines;
  }
  function updateWheelFromTextarea() {
    const names = parseNamesFromTextarea();
    wheel.setNames(names);
  }
  addBtn.addEventListener('click', () => {
    const v = nameInput.value.trim();
    if (!v) return;
    const cur = parseNamesFromTextarea();
    cur.push(v);
    namesTextarea.value = cur.join('\n');
    nameInput.value = '';
    updateWheelFromTextarea();
  });
  nameInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
      addBtn.click();
      e.preventDefault();
    }
  });
  namesTextarea.addEventListener('input', () => {
    updateWheelFromTextarea();
  });
  loadSampleBtn.addEventListener('click', () => {
    const sample = ['Alice','Bob','Charlie','Diana','Eva','Frank','George','Helen','Ivy','Jack'];
    namesTextarea.value = sample.join('\n');
    updateWheelFromTextarea();
  });
  clearBtn.addEventListener('click', () => {
    namesTextarea.value = '';
    updateWheelFromTextarea();
    resultDiv.classList.add('hidden');
  });
  importBtn.addEventListener('click', async () => {
    // prompt user for a newline separated list (simple)
    const data = prompt('Paste names (one per line):');
    if (data === null) return;
    namesTextarea.value = data.split('\n').map(s => s.trim()).filter(s => s).join('\n');
    updateWheelFromTextarea();
  });
  exportBtn.addEventListener('click', () => {
    const names = parseNamesFromTextarea();
    const blob = new Blob([names.join('\n')], {type: 'text/plain'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'names.txt';
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  });
  spinBtn.addEventListener('click', async () => {
    const names = parseNamesFromTextarea();
    if (names.length === 0) {
      alert('Please add at least one name.');
      return;
    }
    resultDiv.classList.add('hidden');
    spinBtn.disabled = true;
    spinBtn.textContent = 'Spinning...';
    // pick random index
    const idx = wheel.getRandomIndex();
    try {
      const winnerIndex = await wheel.spinToIndex(idx, { duration: 4500 });
      const winner = names[winnerIndex];
      resultDiv.textContent = `Winner: ${winner}`;
      resultDiv.classList.remove('hidden');
      spinBtn.textContent = 'SPIN';
      spinBtn.disabled = false;
    } catch (err) {
      console.error(err);
      spinBtn.textContent = 'SPIN';
      spinBtn.disabled = false;
    }
  });
  // initial sample
  namesTextarea.value = 'Alice\nBob\nCharlie\nDiana\nEva';
  updateWheelFromTextarea();
});
```

"
As the Code Reviewer, to make the software directly operable without further coding, ChatDev have formulated the following regulations:
1) all referenced classes should be imported;
2) all methods should be implemented;
3) all methods need to have the necessary comments;
4) no potential bugs;
5) The entire project conforms to the tasks proposed by the user;
6) most importantly, do not only check the errors in the code, but also the logic of code. Make sure that user can interact with generated software without losing any feature in the requirement;
Now, you should check the above regulations one by one and review the codes in detail, propose one comment with the highest priority about the codes, and give me instructions on how to fix. Tell me your comment with the highest priority and corresponding suggestions on revision. If the codes are perfect and you have no comment on them, return only one line like "<INFO> Finished".

[2025-17-09 14:03:41 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2025-17-09 14:03:41 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 5961
completion_tokens: 2279
total_tokens: 8240
cost: $-1.000000


[2025-17-09 14:03:41 INFO] Code Reviewer: **Code Reviewer<->Programmer on : CodeReviewComment, turn 0**

[ChatDev is a software company powered by multiple intelligent agents, such as chief executive officer, chief human resources officer, chief product officer, chief technology officer, etc, with a multi-agent organizational structure and the mission of 'changing the digital world through programming'.
You are Programmer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer.
You can write/create computer software or applications by providing a specific programming language to the computer. You have extensive computing and coding experience in many varieties of programming languages and platforms, such as Python, Java, C, C++, HTML, CSS, JavaScript, XML, SQL, PHP, etc,.
Here is a new customer's task: [Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes.].
To complete the task, you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]

<PRIORITY> Highest-priority problem: invalid "triple-quote" docstrings present in static asset files (index.html, styles.css, themes.json). These stray triple single-quote blocks will make HTML/CSS/JSON invalid at runtime â€” causing the page/CSS to break and the client-side fetch of themes.json to fail (so themes won't load and the wheel won't style correctly).

Why it's critical
- index.html begins with Python-style/triple-quote docstring text â€” HTML will contain unexpected literal ''' and the browser may treat it as text content before the DOCTYPE/HTML, breaking layout and script execution.
- styles.css begins with triple quotes instead of a CSS comment â€” the CSS parser will choke or ignore rules, breaking all styling.
- themes.json contains triple-quote docstrings and therefore is not valid JSON â€” fetch() will fail or JSON.parse will throw, falling back to your default theme but also causing confusing console errors.
Because themes drive colors, themes.json failure will degrade core functionality (themes cannot be chosen/applied) and the UI may be unusable.

How to fix (step-by-step)
1) index.html
- Remove the Python-style triple-quoted docstring block at the very top.
- If you want an in-file comment, use an HTML comment: <!-- ... -->.
Example: replace the first lines (the '''DOCSTRING...''') with either nothing or an HTML comment. At minimum the file should begin with:
<!doctype html>
<html lang="en">
  ...
(Do NOT leave any ''' markers outside of proper HTML comments.)

2) styles.css
- Remove the leading triple single quotes and wrap any explanatory text in a CSS comment (/* ... */) or remove it entirely.
Example: change the top from:
'''
DOCSTRING:
Base CSS ...
'''
to either:
/* DOCSTRING:
   Base CSS for the Wheel of Names app.
*/
or simply remove those lines so the file starts with :root{...}

3) themes.json
- Remove the triple-quoted docstring wrappers and all non-JSON comment text. JSON must be pure data â€” no comments or stray strings.
Replace the file exactly with valid JSON, e.g.:
[
  {
    "id": "classic",
    "name": "Classic",
    "bg": "#ffffff",
    "text": "#222222",
    "accent": "#007bff",
    "colors": ["#ffb3b3", "#ffd9b3", "#fff3b3", "#d9ffb3", "#b3ffd9", "#b3e6ff", "#c7b3ff", "#ffb3f2"]
  },
  {
    "id": "dark",
    "name": "Dark",
    "bg": "#121212",
    "text": "#f5f5f5",
    "accent": "#ff6b6b",
    "colors": ["#2e2e34", "#3a3a44", "#4a4a56", "#5a5a68", "#6a6a78", "#7a7a88"]
  },
  {
    "id": "pastel",
    "name": "Pastel",
    "bg": "#f7f7ff",
    "text": "#333333",
    "accent": "#ff8c94",
    "colors": ["#ffd1dc", "#fce1b4", "#e8ffd1", "#d1fff0", "#d1e7ff", "#e6d1ff"]
  },
  {
    "id": "neon",
    "name": "Neon",
    "bg": "#0f0f13",
    "text": "#eaff00",
    "accent": "#00fff5",
    "colors": ["#ff00ff", "#ff8c00", "#00ff00", "#00ffff", "#8c00ff", "#ff0066"]
  }
]

4) Validate and test
- Put corrected files in your Flask project:
  - templates/index.html
  - static/css/styles.css
  - static/js/wheel.js and static/js/main.js
  - static/themes.json
- Run the app: python main.py
- Open browser console (F12) and Network tab:
  - Confirm themes.json returns 200 and is valid JSON.
  - Confirm no CSS parse errors and that styles apply.
  - Try selecting themes and spinning the wheel.

Optional further improvements (not blocking)
- Make canvas drawing crisp on high-DPI screens by handling window.devicePixelRatio (resize canvas drawing buffer accordingly). This improves rendering quality but is not required to make the app operable.
- Add a small check in main.js to log a clear error if themes.json parsing fails, to help debugging.

Summary
Remove all Python-style triple-quoted docstrings from static files and replace with appropriate comment styles (HTML/CSS) or remove for JSON. Fixing this will make your frontend valid and allow themes.json to be fetched and parsed, restoring the theme selection and visual behavior required by the user.

[2025-17-09 14:03:41 INFO] **[Seminar Conclusion]**:

 <PRIORITY> Highest-priority problem: invalid "triple-quote" docstrings present in static asset files (index.html, styles.css, themes.json). These stray triple single-quote blocks will make HTML/CSS/JSON invalid at runtime â€” causing the page/CSS to break and the client-side fetch of themes.json to fail (so themes won't load and the wheel won't style correctly).

Why it's critical
- index.html begins with Python-style/triple-quote docstring text â€” HTML will contain unexpected literal ''' and the browser may treat it as text content before the DOCTYPE/HTML, breaking layout and script execution.
- styles.css begins with triple quotes instead of a CSS comment â€” the CSS parser will choke or ignore rules, breaking all styling.
- themes.json contains triple-quote docstrings and therefore is not valid JSON â€” fetch() will fail or JSON.parse will throw, falling back to your default theme but also causing confusing console errors.
Because themes drive colors, themes.json failure will degrade core functionality (themes cannot be chosen/applied) and the UI may be unusable.

How to fix (step-by-step)
1) index.html
- Remove the Python-style triple-quoted docstring block at the very top.
- If you want an in-file comment, use an HTML comment: <!-- ... -->.
Example: replace the first lines (the '''DOCSTRING...''') with either nothing or an HTML comment. At minimum the file should begin with:
<!doctype html>
<html lang="en">
  ...
(Do NOT leave any ''' markers outside of proper HTML comments.)

2) styles.css
- Remove the leading triple single quotes and wrap any explanatory text in a CSS comment (/* ... */) or remove it entirely.
Example: change the top from:
'''
DOCSTRING:
Base CSS ...
'''
to either:
/* DOCSTRING:
   Base CSS for the Wheel of Names app.
*/
or simply remove those lines so the file starts with :root{...}

3) themes.json
- Remove the triple-quoted docstring wrappers and all non-JSON comment text. JSON must be pure data â€” no comments or stray strings.
Replace the file exactly with valid JSON, e.g.:
[
  {
    "id": "classic",
    "name": "Classic",
    "bg": "#ffffff",
    "text": "#222222",
    "accent": "#007bff",
    "colors": ["#ffb3b3", "#ffd9b3", "#fff3b3", "#d9ffb3", "#b3ffd9", "#b3e6ff", "#c7b3ff", "#ffb3f2"]
  },
  {
    "id": "dark",
    "name": "Dark",
    "bg": "#121212",
    "text": "#f5f5f5",
    "accent": "#ff6b6b",
    "colors": ["#2e2e34", "#3a3a44", "#4a4a56", "#5a5a68", "#6a6a78", "#7a7a88"]
  },
  {
    "id": "pastel",
    "name": "Pastel",
    "bg": "#f7f7ff",
    "text": "#333333",
    "accent": "#ff8c94",
    "colors": ["#ffd1dc", "#fce1b4", "#e8ffd1", "#d1fff0", "#d1e7ff", "#e6d1ff"]
  },
  {
    "id": "neon",
    "name": "Neon",
    "bg": "#0f0f13",
    "text": "#eaff00",
    "accent": "#00fff5",
    "colors": ["#ff00ff", "#ff8c00", "#00ff00", "#00ffff", "#8c00ff", "#ff0066"]
  }
]

4) Validate and test
- Put corrected files in your Flask project:
  - templates/index.html
  - static/css/styles.css
  - static/js/wheel.js and static/js/main.js
  - static/themes.json
- Run the app: python main.py
- Open browser console (F12) and Network tab:
  - Confirm themes.json returns 200 and is valid JSON.
  - Confirm no CSS parse errors and that styles apply.
  - Try selecting themes and spinning the wheel.

Optional further improvements (not blocking)
- Make canvas drawing crisp on high-DPI screens by handling window.devicePixelRatio (resize canvas drawing buffer accordingly). This improves rendering quality but is not required to make the app operable.
- Add a small check in main.js to log a clear error if themes.json parsing fails, to help debugging.

Summary
Remove all Python-style triple-quoted docstrings from static files and replace with appropriate comment styles (HTML/CSS) or remove for JSON. Fixing this will make your frontend valid and allow themes.json to be fetched and parsed, restoring the theme selection and visual behavior required by the user.

[2025-17-09 14:03:41 INFO] **[Execute Detail]**

execute SimplePhase:[CodeReviewModification] in ComposedPhase:[CodeReview], cycle 2

[2025-17-09 14:03:41 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | [Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes.] |
| **need_reflect** | False |
| **assistant_role_name** | Programmer |
| **user_role_name** | Code Reviewer |
| **phase_prompt** | According to the new user's task, our designed product modality, languages and ideas, our developed first-edition source codes are listed below:  Task: "{task}". Modality: "{modality}". Programming Language: "{language}" Ideas: "{ideas}" Codes:  "{codes}" Comments on Codes: "{comments}" In the software, each file must strictly follow a markdown code block format, where the following tokens must be replaced such that "FILENAME" is the lowercase file name including the file extension, "LANGUAGE" in the programming language, "DOCSTRING" is a string literal specified in source code that is used to document a specific segment of code, and "CODE" is the original code. Format: FILENAME LANGUAGE ''' DOCSTRING ''' CODE As the {assistant_role}, to satisfy the new user's demand and make the software creative, executive and robust, you should modify corresponding codes according to the comments. Then, output the full and complete codes with all bugs fixed based on the comments. Return all codes strictly following the required format. |
| **phase_name** | CodeReviewModification |
| **assistant_role_prompt** | {chatdev_prompt} You are Programmer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. You can write/create computer software or applications by providing a specific programming language to the computer. You have extensive computing and coding experience in many varieties of programming languages and platforms, such as Python, Java, C, C++, HTML, CSS, JavaScript, XML, SQL, PHP, etc,. Here is a new customer's task: {task}. To complete the task, you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Code Reviewer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. You can help programmers to assess source codes for software troubleshooting, fix bugs to increase code quality and robustness, and offer proposals to improve the source codes. Here is a new customer's task: {task}. To complete the task, you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': 'main.py\npython\n\'\'\'\nFlask application that serves the wheel-of-names web app.\nRun: pip install flask\nThen: python main.py\nAccess: http://127.0.0.1:5000/\n\'\'\'\nfrom flask import Flask, render_template\nimport os\n\ndef create_app():\n    """\n    Create and configure the Flask application.\n    """\n    app = Flask(__name__, static_folder=\'static\', template_folder=\'templates\')\n\n    @app.route(\'/\')\n    def index():\n        """\n        Serve the main page.\n        """\n        return render_template(\'index.html\')\n\n    return app\n\nif __name__ == \'__main__\':\n    app = create_app()\n    port = int(os.environ.get(\'PORT\', 5000))\n    app.run(debug=True, host=\'0.0.0.0\', port=port)\n\n\nindex.html\nhtml\n\'\'\'\nDOCSTRING:\nMain HTML page for the Wheel of Names app.\nContains UI elements:\n- name input and list\n- canvas for wheel\n- theme selector\n- spin / clear / add buttons\nIncludes JS files wheel.js and main.js for behavior.\nAlso injects a dynamically generated URL for themes.json using Flask\'s url_for so the client can reliably fetch the resource even when the app is mounted under a subpath.\n\'\'\'\n&lt;!doctype html&gt;\n&lt;html lang="en"&gt;\n&lt;head&gt;\n  &lt;meta charset="utf-8"&gt;\n  &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;\n  &lt;title&gt;Wheel of Names&lt;/title&gt;\n  &lt;link rel="stylesheet" href="{{ url_for(\'static\', filename=\'css/styles.css\') }}"&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div class="container"&gt;\n    &lt;header&gt;\n      &lt;h1&gt;Wheel of Names&lt;/h1&gt;\n      &lt;p&gt;Enter names, choose a theme, and spin to pick a random winner.&lt;/p&gt;\n    &lt;/header&gt;\n    &lt;main class="main-grid"&gt;\n      &lt;section class="left-panel"&gt;\n        &lt;div class="controls"&gt;\n          &lt;label for="name-input"&gt;Add a name&lt;/label&gt;\n          &lt;div class="input-row"&gt;\n            &lt;input id="name-input" type="text" placeholder="Enter name and press Add" autocomplete="off"&gt;\n            &lt;button id="add-name"&gt;Add&lt;/button&gt;\n          &lt;/div&gt;\n          &lt;label for="names-textarea"&gt;Names (one per line)&lt;/label&gt;\n          &lt;textarea id="names-textarea" placeholder="Alice\\nBob\\nCharlie"&gt;&lt;/textarea&gt;\n          &lt;div class="buttons-row"&gt;\n            &lt;button id="load-sample"&gt;Load Sample&lt;/button&gt;\n            &lt;button id="clear-names"&gt;Clear&lt;/button&gt;\n            &lt;button id="import-names"&gt;Import&lt;/button&gt;\n            &lt;button id="export-names"&gt;Export&lt;/button&gt;\n          &lt;/div&gt;\n          &lt;label for="theme-select"&gt;Theme&lt;/label&gt;\n          &lt;select id="theme-select"&gt;&lt;/select&gt;\n          &lt;div class="spin-controls"&gt;\n            &lt;button id="spin-btn" class="spin"&gt;SPIN&lt;/button&gt;\n            &lt;div id="result" class="result hidden"&gt;&lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      &lt;/section&gt;\n      &lt;section class="right-panel"&gt;\n        &lt;div class="wheel-wrapper" id="wheel-wrapper"&gt;\n          &lt;canvas id="wheel-canvas" width="600" height="600"&gt;&lt;/canvas&gt;\n          &lt;div id="pointer"&gt;â–¼&lt;/div&gt;\n        &lt;/div&gt;\n      &lt;/section&gt;\n    &lt;/main&gt;\n    &lt;footer&gt;\n      &lt;small&gt;Built with Flask + Canvas. Themes available.&lt;/small&gt;\n    &lt;/footer&gt;\n  &lt;/div&gt;\n\n  &lt;!-- Provide the correct URL for themes.json (generated by Flask).\n       This ensures the client can fetch themes.json even when the app is mounted under a prefix. --&gt;\n  &lt;script&gt;\n    window.THEMES_JSON_URL = "{{ url_for(\'static\', filename=\'themes.json\') }}";\n  &lt;/script&gt;\n\n  &lt;script src="{{ url_for(\'static\', filename=\'js/wheel.js\') }}"&gt;&lt;/script&gt;\n  &lt;script src="{{ url_for(\'static\', filename=\'js/main.js\') }}"&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\n\nthemes.json\njson\n\'\'\'\nDOCSTRING:\nList of themes available for the wheel.\nEach theme contains:\n- name: display name\n- bg: page background color\n- text: primary text color\n- accent: accent color used for pointer/button\n- colors: array of segment colors (will be cycled for segments)\n\'\'\'\n[\n  {\n    "id": "classic",\n    "name": "Classic",\n    "bg": "#ffffff",\n    "text": "#222222",\n    "accent": "#007bff",\n    "colors": ["#ffb3b3", "#ffd9b3", "#fff3b3", "#d9ffb3", "#b3ffd9", "#b3e6ff", "#c7b3ff", "#ffb3f2"]\n  },\n  {\n    "id": "dark",\n    "name": "Dark",\n    "bg": "#121212",\n    "text": "#f5f5f5",\n    "accent": "#ff6b6b",\n    "colors": ["#2e2e34", "#3a3a44", "#4a4a56", "#5a5a68", "#6a6a78", "#7a7a88"]\n  },\n  {\n    "id": "pastel",\n    "name": "Pastel",\n    "bg": "#f7f7ff",\n    "text": "#333333",\n    "accent": "#ff8c94",\n    "colors": ["#ffd1dc", "#fce1b4", "#e8ffd1", "#d1fff0", "#d1e7ff", "#e6d1ff"]\n  },\n  {\n    "id": "neon",\n    "name": "Neon",\n    "bg": "#0f0f13",\n    "text": "#eaff00",\n    "accent": "#00fff5",\n    "colors": ["#ff00ff", "#ff8c00", "#00ff00", "#00ffff", "#8c00ff", "#ff0066"]\n  }\n]\n\n\nstyles.css\ncss\n\'\'\'\nDOCSTRING:\nBase CSS for the Wheel of Names app.\nDefines layout, basic theme variables, and responsive styles.\n\'\'\'\n:root{\n  --bg: #ffffff;\n  --text: #222222;\n  --accent: #007bff;\n  --panel-bg: #f6f8fa;\n}\n*{box-sizing:border-box}\nhtml,body{\n  height:100%;\n  margin:0;\n  font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;\n  background: var(--bg);\n  color: var(--text);\n}\n.container{\n  max-width:1100px;\n  margin:24px auto;\n  padding:16px;\n}\nheader{ text-align:center; margin-bottom:8px }\nh1{ margin:6px 0; font-size:28px }\np{ margin:0; color:var(--text); opacity:0.8 }\n.main-grid{\n  display:grid;\n  grid-template-columns: 360px 1fr;\n  gap:20px;\n  align-items:start;\n  margin-top:18px;\n}\n.left-panel{\n  background:var(--panel-bg);\n  padding:14px;\n  border-radius:8px;\n  box-shadow:0 4px 8px rgba(0,0,0,0.04);\n}\n.left-panel label{ display:block; margin-top:8px; font-weight:600; margin-bottom:6px }\n.input-row{ display:flex; gap:8px }\n.input-row input[type="text"]{\n  flex:1;\n  padding:8px 10px;\n  border-radius:6px;\n  border:1px solid #ddd;\n}\n.input-row button{\n  padding:8px 12px;\n  border-radius:6px;\n  background:var(--accent);\n  color:white;\n  border:none;\n  cursor:pointer;\n}\ntextarea{\n  width:100%;\n  min-height:160px;\n  padding:10px;\n  border-radius:8px;\n  border:1px solid #ddd;\n  resize:vertical;\n}\n.buttons-row{\n  display:flex;\n  gap:8px;\n  margin-top:8px;\n  flex-wrap:wrap;\n}\n.buttons-row button{\n  padding:8px 10px;\n  border-radius:6px;\n  border:1px solid #ccc;\n  background:transparent;\n  cursor:pointer;\n}\n.spin-controls{\n  display:flex;\n  gap:12px;\n  margin-top:16px;\n  align-items:center;\n}\n.spin{\n  padding:14px 24px;\n  background:var(--accent);\n  color:white;\n  font-weight:700;\n  border:none;\n  border-radius:10px;\n  cursor:pointer;\n  font-size:18px;\n}\n.result{\n  padding:10px 12px;\n  background:rgba(0,0,0,0.06);\n  border-radius:8px;\n}\n.hidden{ display:none }\n.right-panel{\n  display:flex;\n  align-items:center;\n  justify-content:center;\n  min-height:420px;\n}\n.wheel-wrapper{\n  position:relative;\n  width:600px;\n  height:600px;\n  display:flex;\n  align-items:center;\n  justify-content:center;\n  margin:auto;\n}\n#wheel-canvas{\n  border-radius:50%;\n  box-shadow: 0 12px 30px rgba(0,0,0,0.12);\n  background:transparent;\n}\n#wheel-wrapper #pointer{\n  position:absolute;\n  top:18px;\n  left:50%;\n  transform:translateX(-50%);\n  font-size:40px;\n  color:var(--accent);\n  text-shadow:0 2px 4px rgba(0,0,0,0.2);\n  pointer-events:none;\n}\nfooter{ text-align:center; margin-top:16px; color:var(--text); opacity:0.7; }\n/* Responsive */\n@media (max-width:960px){\n  .main-grid{ grid-template-columns:1fr; }\n  .wheel-wrapper{ width:420px; height:420px; }\n  #wheel-canvas{ width:420px; height:420px; }\n}\n\n\nwheel.js\njs\n/*\n\'\'\'\nDOCSTRING:\nwheel.js\nContains a Wheel class that draws the wheel on a canvas and animates spins.\nKey methods:\n- constructor(canvas, options)\n- setNames(names)\n- setTheme(theme)\n- draw()\n- spinToIndex(index) -&gt; Promise resolves with index after animation\n- getRandomIndex()\n\'\'\'\n*/\nclass Wheel {\n  constructor(canvas, options = {}) {\n    this.canvas = canvas;\n    this.ctx = canvas.getContext(\'2d\');\n    this.names = options.names || [];\n    this.colors = options.colors || [\'#ffb3b3\', \'#ffd9b3\', \'#fff3b3\', \'#d9ffb3\', \'#b3ffd9\', \'#b3e6ff\'];\n    this.textColor = options.textColor || \'#222\';\n    this.centerX = canvas.width / 2;\n    this.centerY = canvas.height / 2;\n    this.radius = Math.min(this.centerX, this.centerY) - 10;\n    this.rotation = 0; // degrees\n    this.font = options.font || \'16px Inter, Arial\';\n    this.onDraw = options.onDraw || function(){};\n    this._animating = false;\n    this.draw();\n  }\n  setNames(names) {\n    this.names = names.slice();\n    this.draw();\n  }\n  setTheme(theme) {\n    if (!theme) return;\n    if (theme.colors &amp;&amp; theme.colors.length) this.colors = theme.colors.slice();\n    if (theme.text) this.textColor = theme.text;\n    this.draw();\n  }\n  clearCanvas() {\n    this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height);\n  }\n  draw() {\n    this.clearCanvas();\n    const ctx = this.ctx;\n    const n = Math.max(1, this.names.length);\n    const seg = 360 / n;\n    ctx.save();\n    ctx.translate(this.centerX, this.centerY);\n    ctx.rotate(this.degToRad(this.rotation));\n    // Draw segments\n    for (let i = 0; i &lt; n; i++) {\n      const start = this.degToRad(i * seg);\n      const end = this.degToRad((i + 1) * seg);\n      ctx.beginPath();\n      ctx.moveTo(0,0);\n      ctx.arc(0,0,this.radius,start,end);\n      ctx.closePath();\n      ctx.fillStyle = this.colors[i % this.colors.length];\n      ctx.fill();\n      // stroke\n      ctx.lineWidth = 2;\n      ctx.strokeStyle = \'rgba(0,0,0,0.08)\';\n      ctx.stroke();\n      // Draw label\n      ctx.save();\n      const angle = start + (end - start) / 2;\n      ctx.rotate(angle);\n      ctx.translate(this.radius * 0.55, 0);\n      ctx.rotate(Math.PI / 2);\n      ctx.fillStyle = this.textColor;\n      ctx.font = this.font;\n      ctx.textAlign = \'center\';\n      ctx.textBaseline = \'middle\';\n      const name = this.names[i] || \'\';\n      this.wrapText(ctx, name, 0, 0, this.radius * 0.35, 18);\n      ctx.restore();\n    }\n    ctx.restore();\n    // center circle\n    ctx.beginPath();\n    ctx.arc(this.centerX, this.centerY, this.radius * 0.12, 0, Math.PI*2);\n    ctx.fillStyle = \'#ffffff\';\n    ctx.fill();\n    ctx.lineWidth = 2;\n    ctx.strokeStyle = \'rgba(0,0,0,0.06)\';\n    ctx.stroke();\n    this.onDraw();\n  }\n  wrapText(ctx, text, x, y, maxWidth, lineHeight) {\n    // A simple wrap for canvas text\n    const words = text.split(\' \');\n    let line = \'\';\n    let yOffset = y;\n    for (let n = 0; n &lt; words.length; n++) {\n      const testLine = line + words[n] + \' \';\n      const metrics = ctx.measureText(testLine);\n      const testWidth = metrics.width;\n      if (testWidth &gt; maxWidth &amp;&amp; n &gt; 0) {\n        ctx.fillText(line.trim(), x, yOffset);\n        line = words[n] + \' \';\n        yOffset += lineHeight;\n      } else {\n        line = testLine;\n      }\n    }\n    ctx.fillText(line.trim(), x, yOffset);\n  }\n  degToRad(d) {\n    return d * Math.PI / 180;\n  }\n  radToDeg(r) {\n    return r * 180 / Math.PI;\n  }\n  getRandomIndex() {\n    if (!this.names.length) return 0;\n    return Math.floor(Math.random() * this.names.length);\n  }\n  // Spin such that the segment at `index` lands on the pointer at top.\n  spinToIndex(index, opts = {}) {\n    if (this._animating) return Promise.reject(\'Already animating\');\n    if (!this.names.length) return Promise.reject(\'No names\');\n    const n = this.names.length;\n    const segAngle = 360 / n;\n    // We want the center of target segment to be at angle 270deg (top of canvas - adjust if pointer is at top)\n    // Our rotation variable rotates the whole wheel clockwise in degrees.\n    // Compute the current rotation normalized\n    const normalized = ((this.rotation % 360) + 360) % 360;\n    // Calculate angle to place the segment center at top (270deg)\n    // Center of segment i is at angle: (i * segAngle + segAngle/2)\n    // We need rotation such that (centerAngle + rotation) mod 360 = 270\n    const centerAngle = index * segAngle + segAngle / 2;\n    // Solve for rotation target:\n    let targetRotation = 270 - centerAngle;\n    // Normalize to 0..360\n    targetRotation = ((targetRotation % 360) + 360) % 360;\n    // To produce multiple spins, add several full rotations:\n    const fullSpins = opts.fullSpins !== undefined ? opts.fullSpins : (3 + Math.floor(Math.random()*3)); // 3-5 spins\n    const endRotation = targetRotation + fullSpins * 360 + (opts.randomOffset || 0);\n    // We\'ll animate from current normalized to endRotation, taking into account wrap\n    const startRotation = normalized;\n    const delta = endRotation - startRotation;\n    const duration = opts.duration || 5000; // ms\n    const startTime = performance.now();\n    this._animating = true;\n    return new Promise((resolve) =&gt; {\n      const animate = (now) =&gt; {\n        const elapsed = now - startTime;\n        const t = Math.min(1, elapsed / duration);\n        // ease out cubic\n        const eased = 1 - Math.pow(1 - t, 3);\n        const current = startRotation + delta * eased;\n        this.rotation = current;\n        this.draw();\n        if (t &lt; 1) {\n          requestAnimationFrame(animate);\n        } else {\n          this._animating = false;\n          // Normalize rotation to endRotation mod 360\n          this.rotation = ((endRotation % 360) + 360) % 360;\n          this.draw();\n          resolve(index);\n        }\n      };\n      requestAnimationFrame(animate);\n    });\n  }\n}\n\n\nmain.js\njs\n/*\n\'\'\'\nDOCSTRING:\nmain.js\nWires UI to the Wheel class:\n- loads themes.json (URL injected by Flask)\n- populates theme selector\n- reads names and updates wheel\n- handles spin logic and result display\nIncludes robust fallback if fetching themes.json fails.\n\'\'\'\n*/\ndocument.addEventListener(\'DOMContentLoaded\', async () =&gt; {\n  const canvas = document.getElementById(\'wheel-canvas\');\n  const nameInput = document.getElementById(\'name-input\');\n  const addBtn = document.getElementById(\'add-name\');\n  const namesTextarea = document.getElementById(\'names-textarea\');\n  const spinBtn = document.getElementById(\'spin-btn\');\n  const resultDiv = document.getElementById(\'result\');\n  const themeSelect = document.getElementById(\'theme-select\');\n  const loadSampleBtn = document.getElementById(\'load-sample\');\n  const clearBtn = document.getElementById(\'clear-names\');\n  const importBtn = document.getElementById(\'import-names\');\n  const exportBtn = document.getElementById(\'export-names\');\n  const wheel = new Wheel(canvas, { names: [], colors: [\'#ffb3b3\',\'#ffd9b3\',\'#fff3b3\',\'#d9ffb3\'] });\n  let themes = [];\n\n  // A small fallback theme set in case fetching themes.json fails.\n  const defaultThemes = [\n    {\n      id: \'fallback\',\n      name: \'Default\',\n      bg: \'#ffffff\',\n      text: \'#222222\',\n      accent: \'#007bff\',\n      colors: [\'#ffb3b3\',\'#ffd9b3\',\'#fff3b3\',\'#d9ffb3\']\n    }\n  ];\n\n  // Helper to populate theme selector\n  function populateThemeSelector(list) {\n    themeSelect.innerHTML = \'\';\n    list.forEach(t =&gt; {\n      const opt = document.createElement(\'option\');\n      opt.value = t.id;\n      opt.textContent = t.name;\n      themeSelect.appendChild(opt);\n    });\n  }\n\n  // Load themes.json (URL injected by Flask)\n  try {\n    const themesUrl = window.THEMES_JSON_URL || \'/static/themes.json\';\n    const resp = await fetch(themesUrl);\n    if (!resp.ok) throw new Error(\'HTTP \' + resp.status);\n    themes = await resp.json();\n    if (!Array.isArray(themes) || themes.length === 0) throw new Error(\'No themes found\');\n    populateThemeSelector(themes);\n    // apply first theme\n    applyTheme(themes[0]);\n    themeSelect.value = themes[0].id;\n  } catch (err) {\n    console.error(\'Failed to load themes:\', err);\n    // fallback\n    themes = defaultThemes;\n    populateThemeSelector(themes);\n    applyTheme(themes[0]);\n    themeSelect.value = themes[0].id;\n  }\n\n  function applyTheme(theme) {\n    if (!theme) return;\n    document.documentElement.style.setProperty(\'--bg\', theme.bg || \'#fff\');\n    document.documentElement.style.setProperty(\'--text\', theme.text || \'#222\');\n    document.documentElement.style.setProperty(\'--accent\', theme.accent || \'#007bff\');\n    // set panel bg slightly adjusted\n    let panelBg = theme.bg;\n    // robust luminance tweak (supports 3/6 digit hex)\n    try {\n      panelBg = lightenOrDarkenColor(theme.bg || \'#fff\', 18);\n    } catch(e) {\n      panelBg = \'#f6f8fa\';\n    }\n    document.documentElement.style.setProperty(\'--panel-bg\', panelBg);\n    wheel.setTheme({ colors: theme.colors || [], text: theme.text || \'#222\' });\n  }\n\n  function lightenOrDarkenColor(col, amt) {\n    // accepts #rgb or #rrggbb. amt can be negative to darken.\n    if (typeof col !== \'string\') throw new Error(\'Invalid color\');\n    let colStr = col.trim();\n    if (colStr[0] === \'#\') colStr = colStr.slice(1);\n    if (colStr.length === 3) {\n      colStr = colStr.split(\'\').map(c =&gt; c + c).join(\'\');\n    }\n    if (colStr.length !== 6) throw new Error(\'Invalid hex color\');\n    const num = parseInt(colStr, 16);\n    let r = (num &gt;&gt; 16) &amp; 0xFF;\n    let g = (num &gt;&gt; 8) &amp; 0xFF;\n    let b = num &amp; 0xFF;\n    r = Math.max(0, Math.min(255, r + amt));\n    g = Math.max(0, Math.min(255, g + amt));\n    b = Math.max(0, Math.min(255, b + amt));\n    const newHex = \'#\' + ((1 &lt;&lt; 24) + (r &lt;&lt; 16) + (g &lt;&lt; 8) + b).toString(16).slice(1);\n    return newHex;\n  }\n\n  themeSelect.addEventListener(\'change\', () =&gt; {\n    const id = themeSelect.value;\n    const t = themes.find(x =&gt; x.id === id);\n    if (t) applyTheme(t);\n  });\n\n  function parseNamesFromTextarea() {\n    const lines = namesTextarea.value.split(\'\\n\').map(s =&gt; s.trim()).filter(s =&gt; s.length);\n    return lines;\n  }\n\n  function updateWheelFromTextarea() {\n    const names = parseNamesFromTextarea();\n    wheel.setNames(names);\n  }\n\n  addBtn.addEventListener(\'click\', () =&gt; {\n    const v = nameInput.value.trim();\n    if (!v) return;\n    const cur = parseNamesFromTextarea();\n    cur.push(v);\n    namesTextarea.value = cur.join(\'\\n\');\n    nameInput.value = \'\';\n    updateWheelFromTextarea();\n  });\n\n  nameInput.addEventListener(\'keydown\', (e) =&gt; {\n    if (e.key === \'Enter\') {\n      addBtn.click();\n      e.preventDefault();\n    }\n  });\n\n  namesTextarea.addEventListener(\'input\', () =&gt; {\n    updateWheelFromTextarea();\n  });\n\n  loadSampleBtn.addEventListener(\'click\', () =&gt; {\n    const sample = [\'Alice\',\'Bob\',\'Charlie\',\'Diana\',\'Eva\',\'Frank\',\'George\',\'Helen\',\'Ivy\',\'Jack\'];\n    namesTextarea.value = sample.join(\'\\n\');\n    updateWheelFromTextarea();\n  });\n\n  clearBtn.addEventListener(\'click\', () =&gt; {\n    namesTextarea.value = \'\';\n    updateWheelFromTextarea();\n    resultDiv.classList.add(\'hidden\');\n  });\n\n  importBtn.addEventListener(\'click\', async () =&gt; {\n    // prompt user for a newline separated list (simple)\n    const data = prompt(\'Paste names (one per line):\');\n    if (data === null) return;\n    namesTextarea.value = data.split(\'\\n\').map(s =&gt; s.trim()).filter(s =&gt; s).join(\'\\n\');\n    updateWheelFromTextarea();\n  });\n\n  exportBtn.addEventListener(\'click\', () =&gt; {\n    const names = parseNamesFromTextarea();\n    const blob = new Blob([names.join(\'\\n\')], {type: \'text/plain\'});\n    const url = URL.createObjectURL(blob);\n    const a = document.createElement(\'a\');\n    a.href = url;\n    a.download = \'names.txt\';\n    document.body.appendChild(a);\n    a.click();\n    a.remove();\n    URL.revokeObjectURL(url);\n  });\n\n  spinBtn.addEventListener(\'click\', async () =&gt; {\n    const names = parseNamesFromTextarea();\n    if (names.length === 0) {\n      alert(\'Please add at least one name.\');\n      return;\n    }\n    resultDiv.classList.add(\'hidden\');\n    spinBtn.disabled = true;\n    spinBtn.textContent = \'Spinning...\';\n    // pick random index\n    const idx = wheel.getRandomIndex();\n    try {\n      const winnerIndex = await wheel.spinToIndex(idx, { duration: 4500 });\n      const winner = names[winnerIndex];\n      resultDiv.textContent = `Winner: ${winner}`;\n      resultDiv.classList.remove(\'hidden\');\n      spinBtn.textContent = \'SPIN\';\n      spinBtn.disabled = false;\n    } catch (err) {\n      console.error(err);\n      spinBtn.textContent = \'SPIN\';\n      spinBtn.disabled = false;\n    }\n  });\n\n  // initial sample\n  namesTextarea.value = \'Alice\\nBob\\nCharlie\\nDiana\\nEva\';\n  updateWheelFromTextarea();\n});\n', 'cycle_index': 2, 'task': '[Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes.]', 'modality': 'website', 'ideas': '', 'language': ' Python', 'codes': 'main.py\npython\n\'\'\'\nFlask application that serves the wheel-of-names web app.\nRun: pip install flask\nThen: python main.py\nAccess: http://127.0.0.1:5000/\n\'\'\'\nfrom flask import Flask, render_template\nimport os\ndef create_app():\n    """\n    Create and configure the Flask application.\n    """\n    app = Flask(__name__, static_folder=\'static\', template_folder=\'templates\')\n    @app.route(\'/\')\n    def index():\n        """\n        Serve the main page.\n        """\n        return render_template(\'index.html\')\n    return app\nif __name__ == \'__main__\':\n    app = create_app()\n    port = int(os.environ.get(\'PORT\', 5000))\n    app.run(debug=True, host=\'0.0.0.0\', port=port)\n\n\nindex.html\nhtml\n\'\'\'\nDOCSTRING:\nMain HTML page for the Wheel of Names app.\nContains UI elements:\n- name input and list\n- canvas for wheel\n- theme selector\n- spin / clear / add buttons\nIncludes JS files wheel.js and main.js for behavior.\nAlso injects a dynamically generated URL for themes.json using Flask\'s url_for so the client can reliably fetch the resource even when the app is mounted under a subpath.\n\'\'\'\n&lt;!doctype html&gt;\n&lt;html lang="en"&gt;\n&lt;head&gt;\n  &lt;meta charset="utf-8"&gt;\n  &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;\n  &lt;title&gt;Wheel of Names&lt;/title&gt;\n  &lt;link rel="stylesheet" href="{{ url_for(\'static\', filename=\'css/styles.css\') }}"&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div class="container"&gt;\n    &lt;header&gt;\n      &lt;h1&gt;Wheel of Names&lt;/h1&gt;\n      &lt;p&gt;Enter names, choose a theme, and spin to pick a random winner.&lt;/p&gt;\n    &lt;/header&gt;\n    &lt;main class="main-grid"&gt;\n      &lt;section class="left-panel"&gt;\n        &lt;div class="controls"&gt;\n          &lt;label for="name-input"&gt;Add a name&lt;/label&gt;\n          &lt;div class="input-row"&gt;\n            &lt;input id="name-input" type="text" placeholder="Enter name and press Add" autocomplete="off"&gt;\n            &lt;button id="add-name"&gt;Add&lt;/button&gt;\n          &lt;/div&gt;\n          &lt;label for="names-textarea"&gt;Names (one per line)&lt;/label&gt;\n          &lt;textarea id="names-textarea" placeholder="Alice\\nBob\\nCharlie"&gt;&lt;/textarea&gt;\n          &lt;div class="buttons-row"&gt;\n            &lt;button id="load-sample"&gt;Load Sample&lt;/button&gt;\n            &lt;button id="clear-names"&gt;Clear&lt;/button&gt;\n            &lt;button id="import-names"&gt;Import&lt;/button&gt;\n            &lt;button id="export-names"&gt;Export&lt;/button&gt;\n          &lt;/div&gt;\n          &lt;label for="theme-select"&gt;Theme&lt;/label&gt;\n          &lt;select id="theme-select"&gt;&lt;/select&gt;\n          &lt;div class="spin-controls"&gt;\n            &lt;button id="spin-btn" class="spin"&gt;SPIN&lt;/button&gt;\n            &lt;div id="result" class="result hidden"&gt;&lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      &lt;/section&gt;\n      &lt;section class="right-panel"&gt;\n        &lt;div class="wheel-wrapper" id="wheel-wrapper"&gt;\n          &lt;canvas id="wheel-canvas" width="600" height="600"&gt;&lt;/canvas&gt;\n          &lt;div id="pointer"&gt;â–¼&lt;/div&gt;\n        &lt;/div&gt;\n      &lt;/section&gt;\n    &lt;/main&gt;\n    &lt;footer&gt;\n      &lt;small&gt;Built with Flask + Canvas. Themes available.&lt;/small&gt;\n    &lt;/footer&gt;\n  &lt;/div&gt;\n  &lt;!-- Provide the correct URL for themes.json (generated by Flask).\n       This ensures the client can fetch themes.json even when the app is mounted under a prefix. --&gt;\n  &lt;script&gt;\n    window.THEMES_JSON_URL = "{{ url_for(\'static\', filename=\'themes.json\') }}";\n  &lt;/script&gt;\n  &lt;script src="{{ url_for(\'static\', filename=\'js/wheel.js\') }}"&gt;&lt;/script&gt;\n  &lt;script src="{{ url_for(\'static\', filename=\'js/main.js\') }}"&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\n\nthemes.json\njson\n\'\'\'\nDOCSTRING:\nList of themes available for the wheel.\nEach theme contains:\n- name: display name\n- bg: page background color\n- text: primary text color\n- accent: accent color used for pointer/button\n- colors: array of segment colors (will be cycled for segments)\n\'\'\'\n[\n  {\n    "id": "classic",\n    "name": "Classic",\n    "bg": "#ffffff",\n    "text": "#222222",\n    "accent": "#007bff",\n    "colors": ["#ffb3b3", "#ffd9b3", "#fff3b3", "#d9ffb3", "#b3ffd9", "#b3e6ff", "#c7b3ff", "#ffb3f2"]\n  },\n  {\n    "id": "dark",\n    "name": "Dark",\n    "bg": "#121212",\n    "text": "#f5f5f5",\n    "accent": "#ff6b6b",\n    "colors": ["#2e2e34", "#3a3a44", "#4a4a56", "#5a5a68", "#6a6a78", "#7a7a88"]\n  },\n  {\n    "id": "pastel",\n    "name": "Pastel",\n    "bg": "#f7f7ff",\n    "text": "#333333",\n    "accent": "#ff8c94",\n    "colors": ["#ffd1dc", "#fce1b4", "#e8ffd1", "#d1fff0", "#d1e7ff", "#e6d1ff"]\n  },\n  {\n    "id": "neon",\n    "name": "Neon",\n    "bg": "#0f0f13",\n    "text": "#eaff00",\n    "accent": "#00fff5",\n    "colors": ["#ff00ff", "#ff8c00", "#00ff00", "#00ffff", "#8c00ff", "#ff0066"]\n  }\n]\n\n\nstyles.css\ncss\n\'\'\'\nDOCSTRING:\nBase CSS for the Wheel of Names app.\nDefines layout, basic theme variables, and responsive styles.\n\'\'\'\n:root{\n  --bg: #ffffff;\n  --text: #222222;\n  --accent: #007bff;\n  --panel-bg: #f6f8fa;\n}\n*{box-sizing:border-box}\nhtml,body{\n  height:100%;\n  margin:0;\n  font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;\n  background: var(--bg);\n  color: var(--text);\n}\n.container{\n  max-width:1100px;\n  margin:24px auto;\n  padding:16px;\n}\nheader{ text-align:center; margin-bottom:8px }\nh1{ margin:6px 0; font-size:28px }\np{ margin:0; color:var(--text); opacity:0.8 }\n.main-grid{\n  display:grid;\n  grid-template-columns: 360px 1fr;\n  gap:20px;\n  align-items:start;\n  margin-top:18px;\n}\n.left-panel{\n  background:var(--panel-bg);\n  padding:14px;\n  border-radius:8px;\n  box-shadow:0 4px 8px rgba(0,0,0,0.04);\n}\n.left-panel label{ display:block; margin-top:8px; font-weight:600; margin-bottom:6px }\n.input-row{ display:flex; gap:8px }\n.input-row input[type="text"]{\n  flex:1;\n  padding:8px 10px;\n  border-radius:6px;\n  border:1px solid #ddd;\n}\n.input-row button{\n  padding:8px 12px;\n  border-radius:6px;\n  background:var(--accent);\n  color:white;\n  border:none;\n  cursor:pointer;\n}\ntextarea{\n  width:100%;\n  min-height:160px;\n  padding:10px;\n  border-radius:8px;\n  border:1px solid #ddd;\n  resize:vertical;\n}\n.buttons-row{\n  display:flex;\n  gap:8px;\n  margin-top:8px;\n  flex-wrap:wrap;\n}\n.buttons-row button{\n  padding:8px 10px;\n  border-radius:6px;\n  border:1px solid #ccc;\n  background:transparent;\n  cursor:pointer;\n}\n.spin-controls{\n  display:flex;\n  gap:12px;\n  margin-top:16px;\n  align-items:center;\n}\n.spin{\n  padding:14px 24px;\n  background:var(--accent);\n  color:white;\n  font-weight:700;\n  border:none;\n  border-radius:10px;\n  cursor:pointer;\n  font-size:18px;\n}\n.result{\n  padding:10px 12px;\n  background:rgba(0,0,0,0.06);\n  border-radius:8px;\n}\n.hidden{ display:none }\n.right-panel{\n  display:flex;\n  align-items:center;\n  justify-content:center;\n  min-height:420px;\n}\n.wheel-wrapper{\n  position:relative;\n  width:600px;\n  height:600px;\n  display:flex;\n  align-items:center;\n  justify-content:center;\n  margin:auto;\n}\n#wheel-canvas{\n  border-radius:50%;\n  box-shadow: 0 12px 30px rgba(0,0,0,0.12);\n  background:transparent;\n}\n#wheel-wrapper #pointer{\n  position:absolute;\n  top:18px;\n  left:50%;\n  transform:translateX(-50%);\n  font-size:40px;\n  color:var(--accent);\n  text-shadow:0 2px 4px rgba(0,0,0,0.2);\n  pointer-events:none;\n}\nfooter{ text-align:center; margin-top:16px; color:var(--text); opacity:0.7; }\n/* Responsive */\n@media (max-width:960px){\n  .main-grid{ grid-template-columns:1fr; }\n  .wheel-wrapper{ width:420px; height:420px; }\n  #wheel-canvas{ width:420px; height:420px; }\n}\n\n\nwheel.js\njs\n/*\n\'\'\'\nDOCSTRING:\nwheel.js\nContains a Wheel class that draws the wheel on a canvas and animates spins.\nKey methods:\n- constructor(canvas, options)\n- setNames(names)\n- setTheme(theme)\n- draw()\n- spinToIndex(index) -&gt; Promise resolves with index after animation\n- getRandomIndex()\n\'\'\'\n*/\nclass Wheel {\n  constructor(canvas, options = {}) {\n    this.canvas = canvas;\n    this.ctx = canvas.getContext(\'2d\');\n    this.names = options.names || [];\n    this.colors = options.colors || [\'#ffb3b3\', \'#ffd9b3\', \'#fff3b3\', \'#d9ffb3\', \'#b3ffd9\', \'#b3e6ff\'];\n    this.textColor = options.textColor || \'#222\';\n    this.centerX = canvas.width / 2;\n    this.centerY = canvas.height / 2;\n    this.radius = Math.min(this.centerX, this.centerY) - 10;\n    this.rotation = 0; // degrees\n    this.font = options.font || \'16px Inter, Arial\';\n    this.onDraw = options.onDraw || function(){};\n    this._animating = false;\n    this.draw();\n  }\n  setNames(names) {\n    this.names = names.slice();\n    this.draw();\n  }\n  setTheme(theme) {\n    if (!theme) return;\n    if (theme.colors &amp;&amp; theme.colors.length) this.colors = theme.colors.slice();\n    if (theme.text) this.textColor = theme.text;\n    this.draw();\n  }\n  clearCanvas() {\n    this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height);\n  }\n  draw() {\n    this.clearCanvas();\n    const ctx = this.ctx;\n    const n = Math.max(1, this.names.length);\n    const seg = 360 / n;\n    ctx.save();\n    ctx.translate(this.centerX, this.centerY);\n    ctx.rotate(this.degToRad(this.rotation));\n    // Draw segments\n    for (let i = 0; i &lt; n; i++) {\n      const start = this.degToRad(i * seg);\n      const end = this.degToRad((i + 1) * seg);\n      ctx.beginPath();\n      ctx.moveTo(0,0);\n      ctx.arc(0,0,this.radius,start,end);\n      ctx.closePath();\n      ctx.fillStyle = this.colors[i % this.colors.length];\n      ctx.fill();\n      // stroke\n      ctx.lineWidth = 2;\n      ctx.strokeStyle = \'rgba(0,0,0,0.08)\';\n      ctx.stroke();\n      // Draw label\n      ctx.save();\n      const angle = start + (end - start) / 2;\n      ctx.rotate(angle);\n      ctx.translate(this.radius * 0.55, 0);\n      ctx.rotate(Math.PI / 2);\n      ctx.fillStyle = this.textColor;\n      ctx.font = this.font;\n      ctx.textAlign = \'center\';\n      ctx.textBaseline = \'middle\';\n      const name = this.names[i] || \'\';\n      this.wrapText(ctx, name, 0, 0, this.radius * 0.35, 18);\n      ctx.restore();\n    }\n    ctx.restore();\n    // center circle\n    ctx.beginPath();\n    ctx.arc(this.centerX, this.centerY, this.radius * 0.12, 0, Math.PI*2);\n    ctx.fillStyle = \'#ffffff\';\n    ctx.fill();\n    ctx.lineWidth = 2;\n    ctx.strokeStyle = \'rgba(0,0,0,0.06)\';\n    ctx.stroke();\n    this.onDraw();\n  }\n  wrapText(ctx, text, x, y, maxWidth, lineHeight) {\n    // A simple wrap for canvas text\n    const words = text.split(\' \');\n    let line = \'\';\n    let yOffset = y;\n    for (let n = 0; n &lt; words.length; n++) {\n      const testLine = line + words[n] + \' \';\n      const metrics = ctx.measureText(testLine);\n      const testWidth = metrics.width;\n      if (testWidth &gt; maxWidth &amp;&amp; n &gt; 0) {\n        ctx.fillText(line.trim(), x, yOffset);\n        line = words[n] + \' \';\n        yOffset += lineHeight;\n      } else {\n        line = testLine;\n      }\n    }\n    ctx.fillText(line.trim(), x, yOffset);\n  }\n  degToRad(d) {\n    return d * Math.PI / 180;\n  }\n  radToDeg(r) {\n    return r * 180 / Math.PI;\n  }\n  getRandomIndex() {\n    if (!this.names.length) return 0;\n    return Math.floor(Math.random() * this.names.length);\n  }\n  // Spin such that the segment at `index` lands on the pointer at top.\n  spinToIndex(index, opts = {}) {\n    if (this._animating) return Promise.reject(\'Already animating\');\n    if (!this.names.length) return Promise.reject(\'No names\');\n    const n = this.names.length;\n    const segAngle = 360 / n;\n    // We want the center of target segment to be at angle 270deg (top of canvas - adjust if pointer is at top)\n    // Our rotation variable rotates the whole wheel clockwise in degrees.\n    // Compute the current rotation normalized\n    const normalized = ((this.rotation % 360) + 360) % 360;\n    // Calculate angle to place the segment center at top (270deg)\n    // Center of segment i is at angle: (i * segAngle + segAngle/2)\n    // We need rotation such that (centerAngle + rotation) mod 360 = 270\n    const centerAngle = index * segAngle + segAngle / 2;\n    // Solve for rotation target:\n    let targetRotation = 270 - centerAngle;\n    // Normalize to 0..360\n    targetRotation = ((targetRotation % 360) + 360) % 360;\n    // To produce multiple spins, add several full rotations:\n    const fullSpins = opts.fullSpins !== undefined ? opts.fullSpins : (3 + Math.floor(Math.random()*3)); // 3-5 spins\n    const endRotation = targetRotation + fullSpins * 360 + (opts.randomOffset || 0);\n    // We\'ll animate from current normalized to endRotation, taking into account wrap\n    const startRotation = normalized;\n    const delta = endRotation - startRotation;\n    const duration = opts.duration || 5000; // ms\n    const startTime = performance.now();\n    this._animating = true;\n    return new Promise((resolve) =&gt; {\n      const animate = (now) =&gt; {\n        const elapsed = now - startTime;\n        const t = Math.min(1, elapsed / duration);\n        // ease out cubic\n        const eased = 1 - Math.pow(1 - t, 3);\n        const current = startRotation + delta * eased;\n        this.rotation = current;\n        this.draw();\n        if (t &lt; 1) {\n          requestAnimationFrame(animate);\n        } else {\n          this._animating = false;\n          // Normalize rotation to endRotation mod 360\n          this.rotation = ((endRotation % 360) + 360) % 360;\n          this.draw();\n          resolve(index);\n        }\n      };\n      requestAnimationFrame(animate);\n    });\n  }\n}\n\n\nmain.js\njs\n/*\n\'\'\'\nDOCSTRING:\nmain.js\nWires UI to the Wheel class:\n- loads themes.json (URL injected by Flask)\n- populates theme selector\n- reads names and updates wheel\n- handles spin logic and result display\nIncludes robust fallback if fetching themes.json fails.\n\'\'\'\n*/\ndocument.addEventListener(\'DOMContentLoaded\', async () =&gt; {\n  const canvas = document.getElementById(\'wheel-canvas\');\n  const nameInput = document.getElementById(\'name-input\');\n  const addBtn = document.getElementById(\'add-name\');\n  const namesTextarea = document.getElementById(\'names-textarea\');\n  const spinBtn = document.getElementById(\'spin-btn\');\n  const resultDiv = document.getElementById(\'result\');\n  const themeSelect = document.getElementById(\'theme-select\');\n  const loadSampleBtn = document.getElementById(\'load-sample\');\n  const clearBtn = document.getElementById(\'clear-names\');\n  const importBtn = document.getElementById(\'import-names\');\n  const exportBtn = document.getElementById(\'export-names\');\n  const wheel = new Wheel(canvas, { names: [], colors: [\'#ffb3b3\',\'#ffd9b3\',\'#fff3b3\',\'#d9ffb3\'] });\n  let themes = [];\n  // A small fallback theme set in case fetching themes.json fails.\n  const defaultThemes = [\n    {\n      id: \'fallback\',\n      name: \'Default\',\n      bg: \'#ffffff\',\n      text: \'#222222\',\n      accent: \'#007bff\',\n      colors: [\'#ffb3b3\',\'#ffd9b3\',\'#fff3b3\',\'#d9ffb3\']\n    }\n  ];\n  // Helper to populate theme selector\n  function populateThemeSelector(list) {\n    themeSelect.innerHTML = \'\';\n    list.forEach(t =&gt; {\n      const opt = document.createElement(\'option\');\n      opt.value = t.id;\n      opt.textContent = t.name;\n      themeSelect.appendChild(opt);\n    });\n  }\n  // Load themes.json (URL injected by Flask)\n  try {\n    const themesUrl = window.THEMES_JSON_URL || \'/static/themes.json\';\n    const resp = await fetch(themesUrl);\n    if (!resp.ok) throw new Error(\'HTTP \' + resp.status);\n    themes = await resp.json();\n    if (!Array.isArray(themes) || themes.length === 0) throw new Error(\'No themes found\');\n    populateThemeSelector(themes);\n    // apply first theme\n    applyTheme(themes[0]);\n    themeSelect.value = themes[0].id;\n  } catch (err) {\n    console.error(\'Failed to load themes:\', err);\n    // fallback\n    themes = defaultThemes;\n    populateThemeSelector(themes);\n    applyTheme(themes[0]);\n    themeSelect.value = themes[0].id;\n  }\n  function applyTheme(theme) {\n    if (!theme) return;\n    document.documentElement.style.setProperty(\'--bg\', theme.bg || \'#fff\');\n    document.documentElement.style.setProperty(\'--text\', theme.text || \'#222\');\n    document.documentElement.style.setProperty(\'--accent\', theme.accent || \'#007bff\');\n    // set panel bg slightly adjusted\n    let panelBg = theme.bg;\n    // robust luminance tweak (supports 3/6 digit hex)\n    try {\n      panelBg = lightenOrDarkenColor(theme.bg || \'#fff\', 18);\n    } catch(e) {\n      panelBg = \'#f6f8fa\';\n    }\n    document.documentElement.style.setProperty(\'--panel-bg\', panelBg);\n    wheel.setTheme({ colors: theme.colors || [], text: theme.text || \'#222\' });\n  }\n  function lightenOrDarkenColor(col, amt) {\n    // accepts #rgb or #rrggbb. amt can be negative to darken.\n    if (typeof col !== \'string\') throw new Error(\'Invalid color\');\n    let colStr = col.trim();\n    if (colStr[0] === \'#\') colStr = colStr.slice(1);\n    if (colStr.length === 3) {\n      colStr = colStr.split(\'\').map(c =&gt; c + c).join(\'\');\n    }\n    if (colStr.length !== 6) throw new Error(\'Invalid hex color\');\n    const num = parseInt(colStr, 16);\n    let r = (num &gt;&gt; 16) &amp; 0xFF;\n    let g = (num &gt;&gt; 8) &amp; 0xFF;\n    let b = num &amp; 0xFF;\n    r = Math.max(0, Math.min(255, r + amt));\n    g = Math.max(0, Math.min(255, g + amt));\n    b = Math.max(0, Math.min(255, b + amt));\n    const newHex = \'#\' + ((1 &lt;&lt; 24) + (r &lt;&lt; 16) + (g &lt;&lt; 8) + b).toString(16).slice(1);\n    return newHex;\n  }\n  themeSelect.addEventListener(\'change\', () =&gt; {\n    const id = themeSelect.value;\n    const t = themes.find(x =&gt; x.id === id);\n    if (t) applyTheme(t);\n  });\n  function parseNamesFromTextarea() {\n    const lines = namesTextarea.value.split(\'\\n\').map(s =&gt; s.trim()).filter(s =&gt; s.length);\n    return lines;\n  }\n  function updateWheelFromTextarea() {\n    const names = parseNamesFromTextarea();\n    wheel.setNames(names);\n  }\n  addBtn.addEventListener(\'click\', () =&gt; {\n    const v = nameInput.value.trim();\n    if (!v) return;\n    const cur = parseNamesFromTextarea();\n    cur.push(v);\n    namesTextarea.value = cur.join(\'\\n\');\n    nameInput.value = \'\';\n    updateWheelFromTextarea();\n  });\n  nameInput.addEventListener(\'keydown\', (e) =&gt; {\n    if (e.key === \'Enter\') {\n      addBtn.click();\n      e.preventDefault();\n    }\n  });\n  namesTextarea.addEventListener(\'input\', () =&gt; {\n    updateWheelFromTextarea();\n  });\n  loadSampleBtn.addEventListener(\'click\', () =&gt; {\n    const sample = [\'Alice\',\'Bob\',\'Charlie\',\'Diana\',\'Eva\',\'Frank\',\'George\',\'Helen\',\'Ivy\',\'Jack\'];\n    namesTextarea.value = sample.join(\'\\n\');\n    updateWheelFromTextarea();\n  });\n  clearBtn.addEventListener(\'click\', () =&gt; {\n    namesTextarea.value = \'\';\n    updateWheelFromTextarea();\n    resultDiv.classList.add(\'hidden\');\n  });\n  importBtn.addEventListener(\'click\', async () =&gt; {\n    // prompt user for a newline separated list (simple)\n    const data = prompt(\'Paste names (one per line):\');\n    if (data === null) return;\n    namesTextarea.value = data.split(\'\\n\').map(s =&gt; s.trim()).filter(s =&gt; s).join(\'\\n\');\n    updateWheelFromTextarea();\n  });\n  exportBtn.addEventListener(\'click\', () =&gt; {\n    const names = parseNamesFromTextarea();\n    const blob = new Blob([names.join(\'\\n\')], {type: \'text/plain\'});\n    const url = URL.createObjectURL(blob);\n    const a = document.createElement(\'a\');\n    a.href = url;\n    a.download = \'names.txt\';\n    document.body.appendChild(a);\n    a.click();\n    a.remove();\n    URL.revokeObjectURL(url);\n  });\n  spinBtn.addEventListener(\'click\', async () =&gt; {\n    const names = parseNamesFromTextarea();\n    if (names.length === 0) {\n      alert(\'Please add at least one name.\');\n      return;\n    }\n    resultDiv.classList.add(\'hidden\');\n    spinBtn.disabled = true;\n    spinBtn.textContent = \'Spinning...\';\n    // pick random index\n    const idx = wheel.getRandomIndex();\n    try {\n      const winnerIndex = await wheel.spinToIndex(idx, { duration: 4500 });\n      const winner = names[winnerIndex];\n      resultDiv.textContent = `Winner: ${winner}`;\n      resultDiv.classList.remove(\'hidden\');\n      spinBtn.textContent = \'SPIN\';\n      spinBtn.disabled = false;\n    } catch (err) {\n      console.error(err);\n      spinBtn.textContent = \'SPIN\';\n      spinBtn.disabled = false;\n    }\n  });\n  // initial sample\n  namesTextarea.value = \'Alice\\nBob\\nCharlie\\nDiana\\nEva\';\n  updateWheelFromTextarea();\n});\n\n\n', 'images': '', 'comments': ' Highest-priority problem: invalid "triple-quote" docstrings present in static asset files (index.html, styles.css, themes.json). These stray triple single-quote blocks will make HTML/CSS/JSON invalid at runtime â€” causing the page/CSS to break and the client-side fetch of themes.json to fail (so themes won\'t load and the wheel won\'t style correctly).\n\nWhy it\'s critical\n- index.html begins with Python-style/triple-quote docstring text â€” HTML will contain unexpected literal \'\'\' and the browser may treat it as text content before the DOCTYPE/HTML, breaking layout and script execution.\n- styles.css begins with triple quotes instead of a CSS comment â€” the CSS parser will choke or ignore rules, breaking all styling.\n- themes.json contains triple-quote docstrings and therefore is not valid JSON â€” fetch() will fail or JSON.parse will throw, falling back to your default theme but also causing confusing console errors.\nBecause themes drive colors, themes.json failure will degrade core functionality (themes cannot be chosen/applied) and the UI may be unusable.\n\nHow to fix (step-by-step)\n1) index.html\n- Remove the Python-style triple-quoted docstring block at the very top.\n- If you want an in-file comment, use an HTML comment: .\nExample: replace the first lines (the \'\'\'DOCSTRING...\'\'\') with either nothing or an HTML comment. At minimum the file should begin with:\n&lt;!doctype html&gt;\n\n  ...\n(Do NOT leave any \'\'\' markers outside of proper HTML comments.)\n\n2) styles.css\n- Remove the leading triple single quotes and wrap any explanatory text in a CSS comment (/ ... /) or remove it entirely.\nExample: change the top from:\n\'\'\'\nDOCSTRING:\nBase CSS ...\n\'\'\'\nto either:\n/ DOCSTRING:\n   Base CSS for the Wheel of Names app.\n/\nor simply remove those lines so the file starts with :root{...}\n\n3) themes.json\n- Remove the triple-quoted docstring wrappers and all non-JSON comment text. JSON must be pure data â€” no comments or stray strings.\nReplace the file exactly with valid JSON, e.g.:\n[\n  {\n    "id": "classic",\n    "name": "Classic",\n    "bg": "#ffffff",\n    "text": "#222222",\n    "accent": "#007bff",\n    "colors": ["#ffb3b3", "#ffd9b3", "#fff3b3", "#d9ffb3", "#b3ffd9", "#b3e6ff", "#c7b3ff", "#ffb3f2"]\n  },\n  {\n    "id": "dark",\n    "name": "Dark",\n    "bg": "#121212",\n    "text": "#f5f5f5",\n    "accent": "#ff6b6b",\n    "colors": ["#2e2e34", "#3a3a44", "#4a4a56", "#5a5a68", "#6a6a78", "#7a7a88"]\n  },\n  {\n    "id": "pastel",\n    "name": "Pastel",\n    "bg": "#f7f7ff",\n    "text": "#333333",\n    "accent": "#ff8c94",\n    "colors": ["#ffd1dc", "#fce1b4", "#e8ffd1", "#d1fff0", "#d1e7ff", "#e6d1ff"]\n  },\n  {\n    "id": "neon",\n    "name": "Neon",\n    "bg": "#0f0f13",\n    "text": "#eaff00",\n    "accent": "#00fff5",\n    "colors": ["#ff00ff", "#ff8c00", "#00ff00", "#00ffff", "#8c00ff", "#ff0066"]\n  }\n]\n\n4) Validate and test\n- Put corrected files in your Flask project:\n  - templates/index.html\n  - static/css/styles.css\n  - static/js/wheel.js and static/js/main.js\n  - static/themes.json\n- Run the app: python main.py\n- Open browser console (F12) and Network tab:\n  - Confirm themes.json returns 200 and is valid JSON.\n  - Confirm no CSS parse errors and that styles apply.\n  - Try selecting themes and spinning the wheel.\n\nOptional further improvements (not blocking)\n- Make canvas drawing crisp on high-DPI screens by handling window.devicePixelRatio (resize canvas drawing buffer accordingly). This improves rendering quality but is not required to make the app operable.\n- Add a small check in main.js to log a clear error if themes.json parsing fails, to help debugging.\n\nSummary\nRemove all Python-style triple-quoted docstrings from static files and replace with appropriate comment styles (HTML/CSS) or remove for JSON. Fixing this will make your frontend valid and allow themes.json to be fetched and parsed, restoring the theme selection and visual behavior required by the user.'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_3_5_TURBO |

[2025-17-09 14:03:41 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Programmer |
| **user_role_name** | Code Reviewer |
| **assistant_role_prompt** | {chatdev_prompt} You are Programmer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. You can write/create computer software or applications by providing a specific programming language to the computer. You have extensive computing and coding experience in many varieties of programming languages and platforms, such as Python, Java, C, C++, HTML, CSS, JavaScript, XML, SQL, PHP, etc,. Here is a new customer's task: {task}. To complete the task, you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Code Reviewer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. You can help programmers to assess source codes for software troubleshooting, fix bugs to increase code quality and robustness, and offer proposals to improve the source codes. Here is a new customer's task: {task}. To complete the task, you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **task_prompt** | [Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes.] |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_3_5_TURBO |
| **background_prompt** | ChatDev is a software company powered by multiple intelligent agents, such as chief executive officer, chief human resources officer, chief product officer, chief technology officer, etc, with a multi-agent organizational structure and the mission of 'changing the digital world through programming'. |

[2025-17-09 14:03:41 INFO] Code Reviewer: **[Start Chat]**

[ChatDev is a software company powered by multiple intelligent agents, such as chief executive officer, chief human resources officer, chief product officer, chief technology officer, etc, with a multi-agent organizational structure and the mission of 'changing the digital world through programming'.
You are Programmer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer.
You can write/create computer software or applications by providing a specific programming language to the computer. You have extensive computing and coding experience in many varieties of programming languages and platforms, such as Python, Java, C, C++, HTML, CSS, JavaScript, XML, SQL, PHP, etc,.
Here is a new customer's task: [Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes.].
To complete the task, you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]

According to the new user's task, our designed product modality, languages and ideas, our developed first-edition source codes are listed below: 
Task: "[Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes.]".
Modality: "website".
Programming Language: " Python"
Ideas: ""
Codes: 
"main.py
```python
'''
Flask application that serves the wheel-of-names web app.
Run: pip install flask
Then: python main.py
Access: http://127.0.0.1:5000/
'''
from flask import Flask, render_template
import os
def create_app():
    """
    Create and configure the Flask application.
    """
    app = Flask(__name__, static_folder='static', template_folder='templates')
    @app.route('/')
    def index():
        """
        Serve the main page.
        """
        return render_template('index.html')
    return app
if __name__ == '__main__':
    app = create_app()
    port = int(os.environ.get('PORT', 5000))
    app.run(debug=True, host='0.0.0.0', port=port)
```

index.html
```html
'''
DOCSTRING:
Main HTML page for the Wheel of Names app.
Contains UI elements:
- name input and list
- canvas for wheel
- theme selector
- spin / clear / add buttons
Includes JS files wheel.js and main.js for behavior.
Also injects a dynamically generated URL for themes.json using Flask's url_for so the client can reliably fetch the resource even when the app is mounted under a subpath.
'''
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Wheel of Names</title>
  <link rel="stylesheet" href="{{ url_for('static', filename='css/styles.css') }}">
</head>
<body>
  <div class="container">
    <header>
      <h1>Wheel of Names</h1>
      <p>Enter names, choose a theme, and spin to pick a random winner.</p>
    </header>
    <main class="main-grid">
      <section class="left-panel">
        <div class="controls">
          <label for="name-input">Add a name</label>
          <div class="input-row">
            <input id="name-input" type="text" placeholder="Enter name and press Add" autocomplete="off">
            <button id="add-name">Add</button>
          </div>
          <label for="names-textarea">Names (one per line)</label>
          <textarea id="names-textarea" placeholder="Alice\nBob\nCharlie"></textarea>
          <div class="buttons-row">
            <button id="load-sample">Load Sample</button>
            <button id="clear-names">Clear</button>
            <button id="import-names">Import</button>
            <button id="export-names">Export</button>
          </div>
          <label for="theme-select">Theme</label>
          <select id="theme-select"></select>
          <div class="spin-controls">
            <button id="spin-btn" class="spin">SPIN</button>
            <div id="result" class="result hidden"></div>
          </div>
        </div>
      </section>
      <section class="right-panel">
        <div class="wheel-wrapper" id="wheel-wrapper">
          <canvas id="wheel-canvas" width="600" height="600"></canvas>
          <div id="pointer">â–¼</div>
        </div>
      </section>
    </main>
    <footer>
      <small>Built with Flask + Canvas. Themes available.</small>
    </footer>
  </div>
  <!-- Provide the correct URL for themes.json (generated by Flask).
       This ensures the client can fetch themes.json even when the app is mounted under a prefix. -->
  <script>
    window.THEMES_JSON_URL = "{{ url_for('static', filename='themes.json') }}";
  </script>
  <script src="{{ url_for('static', filename='js/wheel.js') }}"></script>
  <script src="{{ url_for('static', filename='js/main.js') }}"></script>
</body>
</html>
```

themes.json
```json
'''
DOCSTRING:
List of themes available for the wheel.
Each theme contains:
- name: display name
- bg: page background color
- text: primary text color
- accent: accent color used for pointer/button
- colors: array of segment colors (will be cycled for segments)
'''
[
  {
    "id": "classic",
    "name": "Classic",
    "bg": "#ffffff",
    "text": "#222222",
    "accent": "#007bff",
    "colors": ["#ffb3b3", "#ffd9b3", "#fff3b3", "#d9ffb3", "#b3ffd9", "#b3e6ff", "#c7b3ff", "#ffb3f2"]
  },
  {
    "id": "dark",
    "name": "Dark",
    "bg": "#121212",
    "text": "#f5f5f5",
    "accent": "#ff6b6b",
    "colors": ["#2e2e34", "#3a3a44", "#4a4a56", "#5a5a68", "#6a6a78", "#7a7a88"]
  },
  {
    "id": "pastel",
    "name": "Pastel",
    "bg": "#f7f7ff",
    "text": "#333333",
    "accent": "#ff8c94",
    "colors": ["#ffd1dc", "#fce1b4", "#e8ffd1", "#d1fff0", "#d1e7ff", "#e6d1ff"]
  },
  {
    "id": "neon",
    "name": "Neon",
    "bg": "#0f0f13",
    "text": "#eaff00",
    "accent": "#00fff5",
    "colors": ["#ff00ff", "#ff8c00", "#00ff00", "#00ffff", "#8c00ff", "#ff0066"]
  }
]
```

styles.css
```css
'''
DOCSTRING:
Base CSS for the Wheel of Names app.
Defines layout, basic theme variables, and responsive styles.
'''
:root{
  --bg: #ffffff;
  --text: #222222;
  --accent: #007bff;
  --panel-bg: #f6f8fa;
}
*{box-sizing:border-box}
html,body{
  height:100%;
  margin:0;
  font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
  background: var(--bg);
  color: var(--text);
}
.container{
  max-width:1100px;
  margin:24px auto;
  padding:16px;
}
header{ text-align:center; margin-bottom:8px }
h1{ margin:6px 0; font-size:28px }
p{ margin:0; color:var(--text); opacity:0.8 }
.main-grid{
  display:grid;
  grid-template-columns: 360px 1fr;
  gap:20px;
  align-items:start;
  margin-top:18px;
}
.left-panel{
  background:var(--panel-bg);
  padding:14px;
  border-radius:8px;
  box-shadow:0 4px 8px rgba(0,0,0,0.04);
}
.left-panel label{ display:block; margin-top:8px; font-weight:600; margin-bottom:6px }
.input-row{ display:flex; gap:8px }
.input-row input[type="text"]{
  flex:1;
  padding:8px 10px;
  border-radius:6px;
  border:1px solid #ddd;
}
.input-row button{
  padding:8px 12px;
  border-radius:6px;
  background:var(--accent);
  color:white;
  border:none;
  cursor:pointer;
}
textarea{
  width:100%;
  min-height:160px;
  padding:10px;
  border-radius:8px;
  border:1px solid #ddd;
  resize:vertical;
}
.buttons-row{
  display:flex;
  gap:8px;
  margin-top:8px;
  flex-wrap:wrap;
}
.buttons-row button{
  padding:8px 10px;
  border-radius:6px;
  border:1px solid #ccc;
  background:transparent;
  cursor:pointer;
}
.spin-controls{
  display:flex;
  gap:12px;
  margin-top:16px;
  align-items:center;
}
.spin{
  padding:14px 24px;
  background:var(--accent);
  color:white;
  font-weight:700;
  border:none;
  border-radius:10px;
  cursor:pointer;
  font-size:18px;
}
.result{
  padding:10px 12px;
  background:rgba(0,0,0,0.06);
  border-radius:8px;
}
.hidden{ display:none }
.right-panel{
  display:flex;
  align-items:center;
  justify-content:center;
  min-height:420px;
}
.wheel-wrapper{
  position:relative;
  width:600px;
  height:600px;
  display:flex;
  align-items:center;
  justify-content:center;
  margin:auto;
}
#wheel-canvas{
  border-radius:50%;
  box-shadow: 0 12px 30px rgba(0,0,0,0.12);
  background:transparent;
}
#wheel-wrapper #pointer{
  position:absolute;
  top:18px;
  left:50%;
  transform:translateX(-50%);
  font-size:40px;
  color:var(--accent);
  text-shadow:0 2px 4px rgba(0,0,0,0.2);
  pointer-events:none;
}
footer{ text-align:center; margin-top:16px; color:var(--text); opacity:0.7; }
/* Responsive */
@media (max-width:960px){
  .main-grid{ grid-template-columns:1fr; }
  .wheel-wrapper{ width:420px; height:420px; }
  #wheel-canvas{ width:420px; height:420px; }
}
```

wheel.js
```js
/*
'''
DOCSTRING:
wheel.js
Contains a Wheel class that draws the wheel on a canvas and animates spins.
Key methods:
- constructor(canvas, options)
- setNames(names)
- setTheme(theme)
- draw()
- spinToIndex(index) -> Promise resolves with index after animation
- getRandomIndex()
'''
*/
class Wheel {
  constructor(canvas, options = {}) {
    this.canvas = canvas;
    this.ctx = canvas.getContext('2d');
    this.names = options.names || [];
    this.colors = options.colors || ['#ffb3b3', '#ffd9b3', '#fff3b3', '#d9ffb3', '#b3ffd9', '#b3e6ff'];
    this.textColor = options.textColor || '#222';
    this.centerX = canvas.width / 2;
    this.centerY = canvas.height / 2;
    this.radius = Math.min(this.centerX, this.centerY) - 10;
    this.rotation = 0; // degrees
    this.font = options.font || '16px Inter, Arial';
    this.onDraw = options.onDraw || function(){};
    this._animating = false;
    this.draw();
  }
  setNames(names) {
    this.names = names.slice();
    this.draw();
  }
  setTheme(theme) {
    if (!theme) return;
    if (theme.colors && theme.colors.length) this.colors = theme.colors.slice();
    if (theme.text) this.textColor = theme.text;
    this.draw();
  }
  clearCanvas() {
    this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height);
  }
  draw() {
    this.clearCanvas();
    const ctx = this.ctx;
    const n = Math.max(1, this.names.length);
    const seg = 360 / n;
    ctx.save();
    ctx.translate(this.centerX, this.centerY);
    ctx.rotate(this.degToRad(this.rotation));
    // Draw segments
    for (let i = 0; i < n; i++) {
      const start = this.degToRad(i * seg);
      const end = this.degToRad((i + 1) * seg);
      ctx.beginPath();
      ctx.moveTo(0,0);
      ctx.arc(0,0,this.radius,start,end);
      ctx.closePath();
      ctx.fillStyle = this.colors[i % this.colors.length];
      ctx.fill();
      // stroke
      ctx.lineWidth = 2;
      ctx.strokeStyle = 'rgba(0,0,0,0.08)';
      ctx.stroke();
      // Draw label
      ctx.save();
      const angle = start + (end - start) / 2;
      ctx.rotate(angle);
      ctx.translate(this.radius * 0.55, 0);
      ctx.rotate(Math.PI / 2);
      ctx.fillStyle = this.textColor;
      ctx.font = this.font;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      const name = this.names[i] || '';
      this.wrapText(ctx, name, 0, 0, this.radius * 0.35, 18);
      ctx.restore();
    }
    ctx.restore();
    // center circle
    ctx.beginPath();
    ctx.arc(this.centerX, this.centerY, this.radius * 0.12, 0, Math.PI*2);
    ctx.fillStyle = '#ffffff';
    ctx.fill();
    ctx.lineWidth = 2;
    ctx.strokeStyle = 'rgba(0,0,0,0.06)';
    ctx.stroke();
    this.onDraw();
  }
  wrapText(ctx, text, x, y, maxWidth, lineHeight) {
    // A simple wrap for canvas text
    const words = text.split(' ');
    let line = '';
    let yOffset = y;
    for (let n = 0; n < words.length; n++) {
      const testLine = line + words[n] + ' ';
      const metrics = ctx.measureText(testLine);
      const testWidth = metrics.width;
      if (testWidth > maxWidth && n > 0) {
        ctx.fillText(line.trim(), x, yOffset);
        line = words[n] + ' ';
        yOffset += lineHeight;
      } else {
        line = testLine;
      }
    }
    ctx.fillText(line.trim(), x, yOffset);
  }
  degToRad(d) {
    return d * Math.PI / 180;
  }
  radToDeg(r) {
    return r * 180 / Math.PI;
  }
  getRandomIndex() {
    if (!this.names.length) return 0;
    return Math.floor(Math.random() * this.names.length);
  }
  // Spin such that the segment at `index` lands on the pointer at top.
  spinToIndex(index, opts = {}) {
    if (this._animating) return Promise.reject('Already animating');
    if (!this.names.length) return Promise.reject('No names');
    const n = this.names.length;
    const segAngle = 360 / n;
    // We want the center of target segment to be at angle 270deg (top of canvas - adjust if pointer is at top)
    // Our rotation variable rotates the whole wheel clockwise in degrees.
    // Compute the current rotation normalized
    const normalized = ((this.rotation % 360) + 360) % 360;
    // Calculate angle to place the segment center at top (270deg)
    // Center of segment i is at angle: (i * segAngle + segAngle/2)
    // We need rotation such that (centerAngle + rotation) mod 360 = 270
    const centerAngle = index * segAngle + segAngle / 2;
    // Solve for rotation target:
    let targetRotation = 270 - centerAngle;
    // Normalize to 0..360
    targetRotation = ((targetRotation % 360) + 360) % 360;
    // To produce multiple spins, add several full rotations:
    const fullSpins = opts.fullSpins !== undefined ? opts.fullSpins : (3 + Math.floor(Math.random()*3)); // 3-5 spins
    const endRotation = targetRotation + fullSpins * 360 + (opts.randomOffset || 0);
    // We'll animate from current normalized to endRotation, taking into account wrap
    const startRotation = normalized;
    const delta = endRotation - startRotation;
    const duration = opts.duration || 5000; // ms
    const startTime = performance.now();
    this._animating = true;
    return new Promise((resolve) => {
      const animate = (now) => {
        const elapsed = now - startTime;
        const t = Math.min(1, elapsed / duration);
        // ease out cubic
        const eased = 1 - Math.pow(1 - t, 3);
        const current = startRotation + delta * eased;
        this.rotation = current;
        this.draw();
        if (t < 1) {
          requestAnimationFrame(animate);
        } else {
          this._animating = false;
          // Normalize rotation to endRotation mod 360
          this.rotation = ((endRotation % 360) + 360) % 360;
          this.draw();
          resolve(index);
        }
      };
      requestAnimationFrame(animate);
    });
  }
}
```

main.js
```js
/*
'''
DOCSTRING:
main.js
Wires UI to the Wheel class:
- loads themes.json (URL injected by Flask)
- populates theme selector
- reads names and updates wheel
- handles spin logic and result display
Includes robust fallback if fetching themes.json fails.
'''
*/
document.addEventListener('DOMContentLoaded', async () => {
  const canvas = document.getElementById('wheel-canvas');
  const nameInput = document.getElementById('name-input');
  const addBtn = document.getElementById('add-name');
  const namesTextarea = document.getElementById('names-textarea');
  const spinBtn = document.getElementById('spin-btn');
  const resultDiv = document.getElementById('result');
  const themeSelect = document.getElementById('theme-select');
  const loadSampleBtn = document.getElementById('load-sample');
  const clearBtn = document.getElementById('clear-names');
  const importBtn = document.getElementById('import-names');
  const exportBtn = document.getElementById('export-names');
  const wheel = new Wheel(canvas, { names: [], colors: ['#ffb3b3','#ffd9b3','#fff3b3','#d9ffb3'] });
  let themes = [];
  // A small fallback theme set in case fetching themes.json fails.
  const defaultThemes = [
    {
      id: 'fallback',
      name: 'Default',
      bg: '#ffffff',
      text: '#222222',
      accent: '#007bff',
      colors: ['#ffb3b3','#ffd9b3','#fff3b3','#d9ffb3']
    }
  ];
  // Helper to populate theme selector
  function populateThemeSelector(list) {
    themeSelect.innerHTML = '';
    list.forEach(t => {
      const opt = document.createElement('option');
      opt.value = t.id;
      opt.textContent = t.name;
      themeSelect.appendChild(opt);
    });
  }
  // Load themes.json (URL injected by Flask)
  try {
    const themesUrl = window.THEMES_JSON_URL || '/static/themes.json';
    const resp = await fetch(themesUrl);
    if (!resp.ok) throw new Error('HTTP ' + resp.status);
    themes = await resp.json();
    if (!Array.isArray(themes) || themes.length === 0) throw new Error('No themes found');
    populateThemeSelector(themes);
    // apply first theme
    applyTheme(themes[0]);
    themeSelect.value = themes[0].id;
  } catch (err) {
    console.error('Failed to load themes:', err);
    // fallback
    themes = defaultThemes;
    populateThemeSelector(themes);
    applyTheme(themes[0]);
    themeSelect.value = themes[0].id;
  }
  function applyTheme(theme) {
    if (!theme) return;
    document.documentElement.style.setProperty('--bg', theme.bg || '#fff');
    document.documentElement.style.setProperty('--text', theme.text || '#222');
    document.documentElement.style.setProperty('--accent', theme.accent || '#007bff');
    // set panel bg slightly adjusted
    let panelBg = theme.bg;
    // robust luminance tweak (supports 3/6 digit hex)
    try {
      panelBg = lightenOrDarkenColor(theme.bg || '#fff', 18);
    } catch(e) {
      panelBg = '#f6f8fa';
    }
    document.documentElement.style.setProperty('--panel-bg', panelBg);
    wheel.setTheme({ colors: theme.colors || [], text: theme.text || '#222' });
  }
  function lightenOrDarkenColor(col, amt) {
    // accepts #rgb or #rrggbb. amt can be negative to darken.
    if (typeof col !== 'string') throw new Error('Invalid color');
    let colStr = col.trim();
    if (colStr[0] === '#') colStr = colStr.slice(1);
    if (colStr.length === 3) {
      colStr = colStr.split('').map(c => c + c).join('');
    }
    if (colStr.length !== 6) throw new Error('Invalid hex color');
    const num = parseInt(colStr, 16);
    let r = (num >> 16) & 0xFF;
    let g = (num >> 8) & 0xFF;
    let b = num & 0xFF;
    r = Math.max(0, Math.min(255, r + amt));
    g = Math.max(0, Math.min(255, g + amt));
    b = Math.max(0, Math.min(255, b + amt));
    const newHex = '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
    return newHex;
  }
  themeSelect.addEventListener('change', () => {
    const id = themeSelect.value;
    const t = themes.find(x => x.id === id);
    if (t) applyTheme(t);
  });
  function parseNamesFromTextarea() {
    const lines = namesTextarea.value.split('\n').map(s => s.trim()).filter(s => s.length);
    return lines;
  }
  function updateWheelFromTextarea() {
    const names = parseNamesFromTextarea();
    wheel.setNames(names);
  }
  addBtn.addEventListener('click', () => {
    const v = nameInput.value.trim();
    if (!v) return;
    const cur = parseNamesFromTextarea();
    cur.push(v);
    namesTextarea.value = cur.join('\n');
    nameInput.value = '';
    updateWheelFromTextarea();
  });
  nameInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
      addBtn.click();
      e.preventDefault();
    }
  });
  namesTextarea.addEventListener('input', () => {
    updateWheelFromTextarea();
  });
  loadSampleBtn.addEventListener('click', () => {
    const sample = ['Alice','Bob','Charlie','Diana','Eva','Frank','George','Helen','Ivy','Jack'];
    namesTextarea.value = sample.join('\n');
    updateWheelFromTextarea();
  });
  clearBtn.addEventListener('click', () => {
    namesTextarea.value = '';
    updateWheelFromTextarea();
    resultDiv.classList.add('hidden');
  });
  importBtn.addEventListener('click', async () => {
    // prompt user for a newline separated list (simple)
    const data = prompt('Paste names (one per line):');
    if (data === null) return;
    namesTextarea.value = data.split('\n').map(s => s.trim()).filter(s => s).join('\n');
    updateWheelFromTextarea();
  });
  exportBtn.addEventListener('click', () => {
    const names = parseNamesFromTextarea();
    const blob = new Blob([names.join('\n')], {type: 'text/plain'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'names.txt';
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  });
  spinBtn.addEventListener('click', async () => {
    const names = parseNamesFromTextarea();
    if (names.length === 0) {
      alert('Please add at least one name.');
      return;
    }
    resultDiv.classList.add('hidden');
    spinBtn.disabled = true;
    spinBtn.textContent = 'Spinning...';
    // pick random index
    const idx = wheel.getRandomIndex();
    try {
      const winnerIndex = await wheel.spinToIndex(idx, { duration: 4500 });
      const winner = names[winnerIndex];
      resultDiv.textContent = `Winner: ${winner}`;
      resultDiv.classList.remove('hidden');
      spinBtn.textContent = 'SPIN';
      spinBtn.disabled = false;
    } catch (err) {
      console.error(err);
      spinBtn.textContent = 'SPIN';
      spinBtn.disabled = false;
    }
  });
  // initial sample
  namesTextarea.value = 'Alice\nBob\nCharlie\nDiana\nEva';
  updateWheelFromTextarea();
});
```

"
Comments on Codes:
"<PRIORITY> Highest-priority problem: invalid "triple-quote" docstrings present in static asset files (index.html, styles.css, themes.json). These stray triple single-quote blocks will make HTML/CSS/JSON invalid at runtime â€” causing the page/CSS to break and the client-side fetch of themes.json to fail (so themes won't load and the wheel won't style correctly).

Why it's critical
- index.html begins with Python-style/triple-quote docstring text â€” HTML will contain unexpected literal ''' and the browser may treat it as text content before the DOCTYPE/HTML, breaking layout and script execution.
- styles.css begins with triple quotes instead of a CSS comment â€” the CSS parser will choke or ignore rules, breaking all styling.
- themes.json contains triple-quote docstrings and therefore is not valid JSON â€” fetch() will fail or JSON.parse will throw, falling back to your default theme but also causing confusing console errors.
Because themes drive colors, themes.json failure will degrade core functionality (themes cannot be chosen/applied) and the UI may be unusable.

How to fix (step-by-step)
1) index.html
- Remove the Python-style triple-quoted docstring block at the very top.
- If you want an in-file comment, use an HTML comment: <!-- ... -->.
Example: replace the first lines (the '''DOCSTRING...''') with either nothing or an HTML comment. At minimum the file should begin with:
<!doctype html>
<html lang="en">
  ...
(Do NOT leave any ''' markers outside of proper HTML comments.)

2) styles.css
- Remove the leading triple single quotes and wrap any explanatory text in a CSS comment (/* ... */) or remove it entirely.
Example: change the top from:
'''
DOCSTRING:
Base CSS ...
'''
to either:
/* DOCSTRING:
   Base CSS for the Wheel of Names app.
*/
or simply remove those lines so the file starts with :root{...}

3) themes.json
- Remove the triple-quoted docstring wrappers and all non-JSON comment text. JSON must be pure data â€” no comments or stray strings.
Replace the file exactly with valid JSON, e.g.:
[
  {
    "id": "classic",
    "name": "Classic",
    "bg": "#ffffff",
    "text": "#222222",
    "accent": "#007bff",
    "colors": ["#ffb3b3", "#ffd9b3", "#fff3b3", "#d9ffb3", "#b3ffd9", "#b3e6ff", "#c7b3ff", "#ffb3f2"]
  },
  {
    "id": "dark",
    "name": "Dark",
    "bg": "#121212",
    "text": "#f5f5f5",
    "accent": "#ff6b6b",
    "colors": ["#2e2e34", "#3a3a44", "#4a4a56", "#5a5a68", "#6a6a78", "#7a7a88"]
  },
  {
    "id": "pastel",
    "name": "Pastel",
    "bg": "#f7f7ff",
    "text": "#333333",
    "accent": "#ff8c94",
    "colors": ["#ffd1dc", "#fce1b4", "#e8ffd1", "#d1fff0", "#d1e7ff", "#e6d1ff"]
  },
  {
    "id": "neon",
    "name": "Neon",
    "bg": "#0f0f13",
    "text": "#eaff00",
    "accent": "#00fff5",
    "colors": ["#ff00ff", "#ff8c00", "#00ff00", "#00ffff", "#8c00ff", "#ff0066"]
  }
]

4) Validate and test
- Put corrected files in your Flask project:
  - templates/index.html
  - static/css/styles.css
  - static/js/wheel.js and static/js/main.js
  - static/themes.json
- Run the app: python main.py
- Open browser console (F12) and Network tab:
  - Confirm themes.json returns 200 and is valid JSON.
  - Confirm no CSS parse errors and that styles apply.
  - Try selecting themes and spinning the wheel.

Optional further improvements (not blocking)
- Make canvas drawing crisp on high-DPI screens by handling window.devicePixelRatio (resize canvas drawing buffer accordingly). This improves rendering quality but is not required to make the app operable.
- Add a small check in main.js to log a clear error if themes.json parsing fails, to help debugging.

Summary
Remove all Python-style triple-quoted docstrings from static files and replace with appropriate comment styles (HTML/CSS) or remove for JSON. Fixing this will make your frontend valid and allow themes.json to be fetched and parsed, restoring the theme selection and visual behavior required by the user."
In the software, each file must strictly follow a markdown code block format, where the following tokens must be replaced such that "FILENAME" is the lowercase file name including the file extension, "LANGUAGE" in the programming language, "DOCSTRING" is a string literal specified in source code that is used to document a specific segment of code, and "CODE" is the original code. Format:
FILENAME
```LANGUAGE
'''
DOCSTRING
'''
CODE
```
As the Programmer, to satisfy the new user's demand and make the software creative, executive and robust, you should modify corresponding codes according to the comments. Then, output the full and complete codes with all bugs fixed based on the comments. Return all codes strictly following the required format.

[2025-17-09 14:06:42 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2025-17-09 14:06:42 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 7031
completion_tokens: 8019
total_tokens: 15050
cost: $-1.000000


[2025-17-09 14:06:42 INFO] Programmer: **Programmer<->Code Reviewer on : CodeReviewModification, turn 0**

[ChatDev is a software company powered by multiple intelligent agents, such as chief executive officer, chief human resources officer, chief product officer, chief technology officer, etc, with a multi-agent organizational structure and the mission of 'changing the digital world through programming'.
You are Code Reviewer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer.
You can help programmers to assess source codes for software troubleshooting, fix bugs to increase code quality and robustness, and offer proposals to improve the source codes.
Here is a new customer's task: [Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes.].
To complete the task, you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]

main.py
```python
'''
Flask application that serves the wheel-of-names web app.
Run: pip install flask
Then: python main.py
Access: http://127.0.0.1:5000/
'''
from flask import Flask, render_template
import os

def create_app():
    """
    Create and configure the Flask application.
    Serves templates from 'templates' and static files from 'static'.
    """
    app = Flask(__name__, static_folder='static', template_folder='templates')

    @app.route('/')
    def index():
        """
        Serve the main page.
        """
        return render_template('index.html')

    return app

if __name__ == '__main__':
    app = create_app()
    port = int(os.environ.get('PORT', 5000))
    # debug=True for development; set to False in production
    app.run(debug=True, host='0.0.0.0', port=port)
```

index.html
```html
'''
DOCSTRING:
Main HTML page for the Wheel of Names app.
Contains UI elements:
- name input and list
- canvas for wheel
- theme selector
- spin / clear / add buttons
Includes JS files wheel.js and main.js for behavior.
Also injects a dynamically generated URL for themes.json using Flask's url_for so the client can reliably fetch the resource even when the app is mounted under a subpath.
'''
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Wheel of Names</title>
  <!-- Main stylesheet -->
  <link rel="stylesheet" href="{{ url_for('static', filename='css/styles.css') }}">
</head>
<body>
  <div class="container">
    <header>
      <h1>Wheel of Names</h1>
      <p>Enter names, choose a theme, and spin to pick a random winner.</p>
    </header>
    <main class="main-grid">
      <section class="left-panel">
        <div class="controls">
          <label for="name-input">Add a name</label>
          <div class="input-row">
            <input id="name-input" type="text" placeholder="Enter name and press Add" autocomplete="off">
            <button id="add-name" type="button">Add</button>
          </div>

          <label for="names-textarea">Names (one per line)</label>
          <textarea id="names-textarea" placeholder="Alice\nBob\nCharlie"></textarea>

          <div class="buttons-row">
            <button id="load-sample" type="button">Load Sample</button>
            <button id="clear-names" type="button">Clear</button>
            <button id="import-names" type="button">Import</button>
            <button id="export-names" type="button">Export</button>
          </div>

          <label for="theme-select">Theme</label>
          <select id="theme-select" aria-label="Theme selector"></select>

          <div class="spin-controls">
            <button id="spin-btn" class="spin" type="button">SPIN</button>
            <div id="result" class="result hidden" aria-live="polite"></div>
          </div>
        </div>
      </section>

      <section class="right-panel">
        <div class="wheel-wrapper" id="wheel-wrapper">
          <!-- Canvas will be scaled for high-DPI via JS -->
          <canvas id="wheel-canvas" width="600" height="600" aria-label="Wheel of names"></canvas>
          <div id="pointer" aria-hidden="true">â–¼</div>
        </div>
      </section>
    </main>

    <footer>
      <small>Built with Flask + Canvas. Themes available.</small>
    </footer>
  </div>

  <!-- Provide the correct URL for themes.json (generated by Flask).
       This ensures the client can fetch themes.json even when the app is mounted under a prefix. -->
  <script>
    window.THEMES_JSON_URL = "{{ url_for('static', filename='themes.json') }}";
  </script>

  <script src="{{ url_for('static', filename='js/wheel.js') }}"></script>
  <script src="{{ url_for('static', filename='js/main.js') }}"></script>
</body>
</html>
```

themes.json
```json
'''
DOCSTRING:
List of themes available for the wheel.
Each theme contains:
- id: machine id
- name: display name
- bg: page background color
- text: primary text color
- accent: accent color used for pointer/button
- colors: array of segment colors (will be cycled for segments)
'''
[
  {
    "id": "classic",
    "name": "Classic",
    "bg": "#ffffff",
    "text": "#222222",
    "accent": "#007bff",
    "colors": ["#ffb3b3", "#ffd9b3", "#fff3b3", "#d9ffb3", "#b3ffd9", "#b3e6ff", "#c7b3ff", "#ffb3f2"]
  },
  {
    "id": "dark",
    "name": "Dark",
    "bg": "#121212",
    "text": "#f5f5f5",
    "accent": "#ff6b6b",
    "colors": ["#2e2e34", "#3a3a44", "#4a4a56", "#5a5a68", "#6a6a78", "#7a7a88"]
  },
  {
    "id": "pastel",
    "name": "Pastel",
    "bg": "#f7f7ff",
    "text": "#333333",
    "accent": "#ff8c94",
    "colors": ["#ffd1dc", "#fce1b4", "#e8ffd1", "#d1fff0", "#d1e7ff", "#e6d1ff"]
  },
  {
    "id": "neon",
    "name": "Neon",
    "bg": "#0f0f13",
    "text": "#eaff00",
    "accent": "#00fff5",
    "colors": ["#ff00ff", "#ff8c00", "#00ff00", "#00ffff", "#8c00ff", "#ff0066"]
  }
]
```

styles.css
```css
'''
DOCSTRING:
Base CSS for the Wheel of Names app.
Defines layout, basic theme variables, and responsive styles.
'''
/* Base CSS and theme variables */
:root{
  --bg: #ffffff;
  --text: #222222;
  --accent: #007bff;
  --panel-bg: #f6f8fa;
}
*{box-sizing:border-box}
html,body{
  height:100%;
  margin:0;
  font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
  background: var(--bg);
  color: var(--text);
}
.container{
  max-width:1100px;
  margin:24px auto;
  padding:16px;
}
header{ text-align:center; margin-bottom:8px }
h1{ margin:6px 0; font-size:28px }
p{ margin:0; color:var(--text); opacity:0.8 }
.main-grid{
  display:grid;
  grid-template-columns: 360px 1fr;
  gap:20px;
  align-items:start;
  margin-top:18px;
}
.left-panel{
  background:var(--panel-bg);
  padding:14px;
  border-radius:8px;
  box-shadow:0 4px 8px rgba(0,0,0,0.04);
}
.left-panel label{ display:block; margin-top:8px; font-weight:600; margin-bottom:6px }
.input-row{ display:flex; gap:8px }
.input-row input[type="text"]{
  flex:1;
  padding:8px 10px;
  border-radius:6px;
  border:1px solid #ddd;
  background:white;
  color:inherit;
}
.input-row button{
  padding:8px 12px;
  border-radius:6px;
  background:var(--accent);
  color:white;
  border:none;
  cursor:pointer;
}
textarea{
  width:100%;
  min-height:160px;
  padding:10px;
  border-radius:8px;
  border:1px solid #ddd;
  resize:vertical;
  background:white;
  color:inherit;
}
.buttons-row{
  display:flex;
  gap:8px;
  margin-top:8px;
  flex-wrap:wrap;
}
.buttons-row button{
  padding:8px 10px;
  border-radius:6px;
  border:1px solid #ccc;
  background:transparent;
  cursor:pointer;
}
.spin-controls{
  display:flex;
  gap:12px;
  margin-top:16px;
  align-items:center;
}
.spin{
  padding:14px 24px;
  background:var(--accent);
  color:white;
  font-weight:700;
  border:none;
  border-radius:10px;
  cursor:pointer;
  font-size:18px;
}
.result{
  padding:10px 12px;
  background:rgba(0,0,0,0.06);
  border-radius:8px;
}
.hidden{ display:none }
.right-panel{
  display:flex;
  align-items:center;
  justify-content:center;
  min-height:420px;
}
.wheel-wrapper{
  position:relative;
  width:600px;
  height:600px;
  display:flex;
  align-items:center;
  justify-content:center;
  margin:auto;
}
#wheel-canvas{
  border-radius:50%;
  box-shadow: 0 12px 30px rgba(0,0,0,0.12);
  background:transparent;
  /* ensure the canvas element scales responsively in layout; the backing store will be adjusted in JS */
  width:100%;
  height:100%;
  display:block;
}
#wheel-wrapper #pointer{
  position:absolute;
  top:18px;
  left:50%;
  transform:translateX(-50%);
  font-size:40px;
  color:var(--accent);
  text-shadow:0 2px 4px rgba(0,0,0,0.2);
  pointer-events:none;
}
footer{ text-align:center; margin-top:16px; color:var(--text); opacity:0.7; }
/* Responsive */
@media (max-width:960px){
  .main-grid{ grid-template-columns:1fr; }
  .wheel-wrapper{ width:420px; height:420px; }
  #wheel-canvas{ width:420px; height:420px; }
}
```

wheel.js
```javascript
'''
DOCSTRING:
wheel.js
Contains a Wheel class that draws the wheel on a canvas and animates spins.
Key methods:
- constructor(canvas, options)
- setNames(names)
- setTheme(theme)
- draw()
- resize() -> handle high-DPI displays
- spinToIndex(index) -> Promise resolves with index after animation
- getRandomIndex()
'''
/* A small utility to requestAnimationFrame safely (browser-provided) */
class Wheel {
  constructor(canvas, options = {}) {
    this.canvas = canvas;
    this.ctx = canvas.getContext('2d');
    this.names = options.names || [];
    this.colors = options.colors || ['#ffb3b3', '#ffd9b3', '#fff3b3', '#d9ffb3', '#b3ffd9', '#b3e6ff'];
    this.textColor = options.textColor || '#222';
    this.rotation = 0; // degrees
    this.font = options.font || '16px Inter, Arial';
    this.onDraw = options.onDraw || function(){};
    this._animating = false;

    // Set up high-DPI friendly canvas and metrics
    this.resize();

    // Redraw once created
    this.draw();

    // Optional: handle container resize via ResizeObserver if available
    if (window.ResizeObserver) {
      try {
        const ro = new ResizeObserver(() => this.resize());
        ro.observe(this.canvas.parentElement || this.canvas);
        this._resizeObserver = ro;
      } catch (e) {
        // ignore
      }
    } else {
      window.addEventListener('resize', () => this.resize());
    }
  }

  resize() {
    // Make the canvas crisp on high-DPI screens.
    const dpr = window.devicePixelRatio || 1;
    const rect = this.canvas.getBoundingClientRect();
    // Fallback to element width/height attributes if bounding rect is 0
    const cssWidth = rect.width || this.canvas.clientWidth || this.canvas.width / (dpr || 1);
    const cssHeight = rect.height || this.canvas.clientHeight || this.canvas.height / (dpr || 1);

    // Set backing store size
    this.canvas.width = Math.max(1, Math.round(cssWidth * dpr));
    this.canvas.height = Math.max(1, Math.round(cssHeight * dpr));
    // Keep CSS size consistent
    this.canvas.style.width = cssWidth + 'px';
    this.canvas.style.height = cssHeight + 'px';
    // Reset transform so we can set a scale for dpr
    this.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

    // Use CSS pixel coordinates for drawing from now on
    this.centerX = cssWidth / 2;
    this.centerY = cssHeight / 2;
    this.radius = Math.min(cssWidth, cssHeight) / 2 - 10;

    // Recompute font size based on canvas size to keep labels legible
    // If user supplied a font (with px), keep it; otherwise set a sensible value.
    if (!this.font || typeof this.font !== 'string') {
      this.font = Math.max(12, Math.round(this.radius * 0.06)) + 'px Inter, Arial';
    } else {
      // keep user's font but ensure text scale reasonable
      // (we don't attempt to parse px here; leaving as provided)
    }

    this.draw();
  }

  setNames(names) {
    this.names = names.slice();
    this.draw();
  }

  setTheme(theme) {
    if (!theme) return;
    if (theme.colors && theme.colors.length) this.colors = theme.colors.slice();
    if (theme.text) this.textColor = theme.text;
    this.draw();
  }

  clearCanvas() {
    // Clear the visible canvas area (CSS pixels)
    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
  }

  draw() {
    this.clearCanvas();
    const ctx = this.ctx;
    const n = Math.max(1, this.names.length);
    const seg = 360 / n;

    ctx.save();
    // Translate to center using CSS pixel coordinates
    ctx.translate(this.centerX, this.centerY);
    ctx.rotate(this.degToRad(this.rotation));

    // Draw segments
    for (let i = 0; i < n; i++) {
      const start = this.degToRad(i * seg);
      const end = this.degToRad((i + 1) * seg);
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.arc(0, 0, this.radius, start, end);
      ctx.closePath();
      ctx.fillStyle = this.colors[i % this.colors.length];
      ctx.fill();

      // stroke
      ctx.lineWidth = Math.max(1, this.radius * 0.008);
      ctx.strokeStyle = 'rgba(0,0,0,0.08)';
      ctx.stroke();

      // Draw label
      ctx.save();
      const angle = start + (end - start) / 2;
      ctx.rotate(angle);
      ctx.translate(this.radius * 0.55, 0);
      ctx.rotate(Math.PI / 2);
      ctx.fillStyle = this.textColor;
      // Set font size relative to radius if not provided precisely
      ctx.font = this.font;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      const name = this.names[i] || '';
      this.wrapText(ctx, name, 0, 0, this.radius * 0.35, parseInt(Math.max(12, this.radius * 0.06), 10));
      ctx.restore();
    }

    ctx.restore();

    // center circle
    ctx.beginPath();
    ctx.arc(this.centerX, this.centerY, this.radius * 0.12, 0, Math.PI * 2);
    // Fill with background-like color; allow theme override by drawing over it in CSS if necessary
    ctx.fillStyle = '#ffffff';
    ctx.fill();
    ctx.lineWidth = Math.max(1, this.radius * 0.008);
    ctx.strokeStyle = 'rgba(0,0,0,0.06)';
    ctx.stroke();

    this.onDraw();
  }

  wrapText(ctx, text, x, y, maxWidth, lineHeight) {
    // A simple wrap for canvas text
    const words = String(text).split(' ');
    let line = '';
    let yOffset = y;
    for (let n = 0; n < words.length; n++) {
      const testLine = line + words[n] + ' ';
      const metrics = ctx.measureText(testLine);
      const testWidth = metrics.width;
      if (testWidth > maxWidth && n > 0) {
        ctx.fillText(line.trim(), x, yOffset);
        line = words[n] + ' ';
        yOffset += lineHeight;
      } else {
        line = testLine;
      }
    }
    ctx.fillText(line.trim(), x, yOffset);
  }

  degToRad(d) {
    return d * Math.PI / 180;
  }

  radToDeg(r) {
    return r * 180 / Math.PI;
  }

  getRandomIndex() {
    if (!this.names.length) return 0;
    return Math.floor(Math.random() * this.names.length);
  }

  // Spin such that the segment at `index` lands on the pointer at top.
  spinToIndex(index, opts = {}) {
    if (this._animating) return Promise.reject('Already animating');
    if (!this.names.length) return Promise.reject('No names');
    const n = this.names.length;
    const segAngle = 360 / n;

    // Normalize current rotation to [0, 360)
    const normalized = ((this.rotation % 360) + 360) % 360;

    // Center of segment i is at angle: (i * segAngle + segAngle/2)
    const centerAngle = index * segAngle + segAngle / 2;

    // We want (centerAngle + rotation) mod 360 = 270 (pointing upward if pointer is at top)
    let targetRotation = 270 - centerAngle;
    targetRotation = ((targetRotation % 360) + 360) % 360;

    const fullSpins = opts.fullSpins !== undefined ? opts.fullSpins : (3 + Math.floor(Math.random() * 3)); // 3-5 spins
    const endRotation = targetRotation + fullSpins * 360 + (opts.randomOffset || 0);

    const startRotation = normalized;
    const delta = endRotation - startRotation;
    const duration = opts.duration || 5000; // ms
    const startTime = performance.now();
    this._animating = true;

    return new Promise((resolve) => {
      const animate = (now) => {
        const elapsed = now - startTime;
        const t = Math.min(1, elapsed / duration);
        // ease out cubic
        const eased = 1 - Math.pow(1 - t, 3);
        const current = startRotation + delta * eased;
        this.rotation = current;
        this.draw();
        if (t < 1) {
          requestAnimationFrame(animate);
        } else {
          this._animating = false;
          // Normalize rotation to endRotation mod 360
          this.rotation = ((endRotation % 360) + 360) % 360;
          this.draw();
          resolve(index);
        }
      };
      requestAnimationFrame(animate);
    });
  }
}
```

main.js
```javascript
'''
DOCSTRING:
main.js
Wires UI to the Wheel class:
- loads themes.json (URL injected by Flask)
- populates theme selector
- reads names and updates wheel
- handles spin logic and result display
Includes robust fallback if fetching themes.json fails.
'''
/* DOM wiring and app logic */
document.addEventListener('DOMContentLoaded', async () => {
  const canvas = document.getElementById('wheel-canvas');
  const nameInput = document.getElementById('name-input');
  const addBtn = document.getElementById('add-name');
  const namesTextarea = document.getElementById('names-textarea');
  const spinBtn = document.getElementById('spin-btn');
  const resultDiv = document.getElementById('result');
  const themeSelect = document.getElementById('theme-select');
  const loadSampleBtn = document.getElementById('load-sample');
  const clearBtn = document.getElementById('clear-names');
  const importBtn = document.getElementById('import-names');
  const exportBtn = document.getElementById('export-names');

  const wheel = new Wheel(canvas, { names: [], colors: ['#ffb3b3','#ffd9b3','#fff3b3','#d9ffb3'] });

  let themes = [];

  // A small fallback theme set in case fetching themes.json fails.
  const defaultThemes = [
    {
      id: 'fallback',
      name: 'Default',
      bg: '#ffffff',
      text: '#222222',
      accent: '#007bff',
      colors: ['#ffb3b3','#ffd9b3','#fff3b3','#d9ffb3']
    }
  ];

  // Helper to populate theme selector
  function populateThemeSelector(list) {
    themeSelect.innerHTML = '';
    list.forEach(t => {
      const opt = document.createElement('option');
      opt.value = t.id;
      opt.textContent = t.name;
      themeSelect.appendChild(opt);
    });
  }

  // Load themes.json (URL injected by Flask)
  try {
    const themesUrl = window.THEMES_JSON_URL || '/static/themes.json';
    const resp = await fetch(themesUrl, {cache: 'no-cache'});
    if (!resp.ok) throw new Error('HTTP ' + resp.status);
    themes = await resp.json();
    if (!Array.isArray(themes) || themes.length === 0) throw new Error('No themes found');
    populateThemeSelector(themes);
    // apply first theme
    applyTheme(themes[0]);
    themeSelect.value = themes[0].id;
  } catch (err) {
    console.error('Failed to load themes:', err);
    // fallback
    themes = defaultThemes;
    populateThemeSelector(themes);
    applyTheme(themes[0]);
    themeSelect.value = themes[0].id;
  }

  function applyTheme(theme) {
    if (!theme) return;
    document.documentElement.style.setProperty('--bg', theme.bg || '#fff');
    document.documentElement.style.setProperty('--text', theme.text || '#222');
    document.documentElement.style.setProperty('--accent', theme.accent || '#007bff');
    // set panel bg slightly adjusted
    let panelBg = theme.bg;
    try {
      panelBg = lightenOrDarkenColor(theme.bg || '#fff', 18);
    } catch(e) {
      panelBg = '#f6f8fa';
    }
    document.documentElement.style.setProperty('--panel-bg', panelBg);
    wheel.setTheme({ colors: theme.colors || [], text: theme.text || '#222' });

    // recolor pointer (DOM element)
    const pointer = document.getElementById('pointer');
    if (pointer) pointer.style.color = theme.accent || '';
    // recolor spin button
    const spin = document.getElementById('spin-btn');
    if (spin) spin.style.background = theme.accent || '';
  }

  function lightenOrDarkenColor(col, amt) {
    // accepts #rgb or #rrggbb. amt can be negative to darken.
    if (typeof col !== 'string') throw new Error('Invalid color');
    let colStr = col.trim();
    if (colStr[0] === '#') colStr = colStr.slice(1);
    if (colStr.length === 3) {
      colStr = colStr.split('').map(c => c + c).join('');
    }
    if (colStr.length !== 6) throw new Error('Invalid hex color');
    const num = parseInt(colStr, 16);
    let r = (num >> 16) & 0xFF;
    let g = (num >> 8) & 0xFF;
    let b = num & 0xFF;
    r = Math.max(0, Math.min(255, r + amt));
    g = Math.max(0, Math.min(255, g + amt));
    b = Math.max(0, Math.min(255, b + amt));
    const newHex = '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
    return newHex;
  }

  themeSelect.addEventListener('change', () => {
    const id = themeSelect.value;
    const t = themes.find(x => x.id === id);
    if (t) applyTheme(t);
  });

  function parseNamesFromTextarea() {
    const lines = namesTextarea.value.split('\n').map(s => s.trim()).filter(s => s.length);
    return lines;
  }

  function updateWheelFromTextarea() {
    const names = parseNamesFromTextarea();
    wheel.setNames(names);
  }

  addBtn.addEventListener('click', () => {
    const v = nameInput.value.trim();
    if (!v) return;
    const cur = parseNamesFromTextarea();
    cur.push(v);
    namesTextarea.value = cur.join('\n');
    nameInput.value = '';
    updateWheelFromTextarea();
  });

  nameInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
      addBtn.click();
      e.preventDefault();
    }
  });

  namesTextarea.addEventListener('input', () => {
    updateWheelFromTextarea();
  });

  loadSampleBtn.addEventListener('click', () => {
    const sample = ['Alice','Bob','Charlie','Diana','Eva','Frank','George','Helen','Ivy','Jack'];
    namesTextarea.value = sample.join('\n');
    updateWheelFromTextarea();
  });

  clearBtn.addEventListener('click', () => {
    namesTextarea.value = '';
    updateWheelFromTextarea();
    resultDiv.classList.add('hidden');
  });

  importBtn.addEventListener('click', async () => {
    // prompt user for a newline separated list (simple)
    const data = prompt('Paste names (one per line):');
    if (data === null) return;
    namesTextarea.value = data.split('\n').map(s => s.trim()).filter(s => s).join('\n');
    updateWheelFromTextarea();
  });

  exportBtn.addEventListener('click', () => {
    const names = parseNamesFromTextarea();
    const blob = new Blob([names.join('\n')], {type: 'text/plain'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'names.txt';
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  });

  spinBtn.addEventListener('click', async () => {
    const names = parseNamesFromTextarea();
    if (names.length === 0) {
      alert('Please add at least one name.');
      return;
    }
    resultDiv.classList.add('hidden');
    spinBtn.disabled = true;
    spinBtn.textContent = 'Spinning...';

    // Ensure wheel has latest names before selecting index
    wheel.setNames(names);

    // pick random index
    const idx = wheel.getRandomIndex();
    try {
      const winnerIndex = await wheel.spinToIndex(idx, { duration: 4500 });
      const winner = names[winnerIndex];
      resultDiv.textContent = `Winner: ${winner}`;
      resultDiv.classList.remove('hidden');
      spinBtn.textContent = 'SPIN';
      spinBtn.disabled = false;
    } catch (err) {
      console.error(err);
      spinBtn.textContent = 'SPIN';
      spinBtn.disabled = false;
    }
  });

  // initial sample and initial canvas sizing
  namesTextarea.value = 'Alice\nBob\nCharlie\nDiana\nEva';
  updateWheelFromTextarea();

  // Ensure wheel draws crisply at startup and on resize
  function handleResize() {
    if (typeof wheel.resize === 'function') {
      wheel.resize();
    } else {
      // fallback: redraw
      wheel.draw();
    }
  }
  window.addEventListener('resize', handleResize);
  // Run a resize after a short delay to ensure layout settled
  setTimeout(handleResize, 50);
});
```

[2025-17-09 14:06:42 INFO] **[Seminar Conclusion]**:

 main.py
```python
'''
Flask application that serves the wheel-of-names web app.
Run: pip install flask
Then: python main.py
Access: http://127.0.0.1:5000/
'''
from flask import Flask, render_template
import os

def create_app():
    """
    Create and configure the Flask application.
    Serves templates from 'templates' and static files from 'static'.
    """
    app = Flask(__name__, static_folder='static', template_folder='templates')

    @app.route('/')
    def index():
        """
        Serve the main page.
        """
        return render_template('index.html')

    return app

if __name__ == '__main__':
    app = create_app()
    port = int(os.environ.get('PORT', 5000))
    # debug=True for development; set to False in production
    app.run(debug=True, host='0.0.0.0', port=port)
```

index.html
```html
'''
DOCSTRING:
Main HTML page for the Wheel of Names app.
Contains UI elements:
- name input and list
- canvas for wheel
- theme selector
- spin / clear / add buttons
Includes JS files wheel.js and main.js for behavior.
Also injects a dynamically generated URL for themes.json using Flask's url_for so the client can reliably fetch the resource even when the app is mounted under a subpath.
'''
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Wheel of Names</title>
  <!-- Main stylesheet -->
  <link rel="stylesheet" href="{{ url_for('static', filename='css/styles.css') }}">
</head>
<body>
  <div class="container">
    <header>
      <h1>Wheel of Names</h1>
      <p>Enter names, choose a theme, and spin to pick a random winner.</p>
    </header>
    <main class="main-grid">
      <section class="left-panel">
        <div class="controls">
          <label for="name-input">Add a name</label>
          <div class="input-row">
            <input id="name-input" type="text" placeholder="Enter name and press Add" autocomplete="off">
            <button id="add-name" type="button">Add</button>
          </div>

          <label for="names-textarea">Names (one per line)</label>
          <textarea id="names-textarea" placeholder="Alice\nBob\nCharlie"></textarea>

          <div class="buttons-row">
            <button id="load-sample" type="button">Load Sample</button>
            <button id="clear-names" type="button">Clear</button>
            <button id="import-names" type="button">Import</button>
            <button id="export-names" type="button">Export</button>
          </div>

          <label for="theme-select">Theme</label>
          <select id="theme-select" aria-label="Theme selector"></select>

          <div class="spin-controls">
            <button id="spin-btn" class="spin" type="button">SPIN</button>
            <div id="result" class="result hidden" aria-live="polite"></div>
          </div>
        </div>
      </section>

      <section class="right-panel">
        <div class="wheel-wrapper" id="wheel-wrapper">
          <!-- Canvas will be scaled for high-DPI via JS -->
          <canvas id="wheel-canvas" width="600" height="600" aria-label="Wheel of names"></canvas>
          <div id="pointer" aria-hidden="true">â–¼</div>
        </div>
      </section>
    </main>

    <footer>
      <small>Built with Flask + Canvas. Themes available.</small>
    </footer>
  </div>

  <!-- Provide the correct URL for themes.json (generated by Flask).
       This ensures the client can fetch themes.json even when the app is mounted under a prefix. -->
  <script>
    window.THEMES_JSON_URL = "{{ url_for('static', filename='themes.json') }}";
  </script>

  <script src="{{ url_for('static', filename='js/wheel.js') }}"></script>
  <script src="{{ url_for('static', filename='js/main.js') }}"></script>
</body>
</html>
```

themes.json
```json
'''
DOCSTRING:
List of themes available for the wheel.
Each theme contains:
- id: machine id
- name: display name
- bg: page background color
- text: primary text color
- accent: accent color used for pointer/button
- colors: array of segment colors (will be cycled for segments)
'''
[
  {
    "id": "classic",
    "name": "Classic",
    "bg": "#ffffff",
    "text": "#222222",
    "accent": "#007bff",
    "colors": ["#ffb3b3", "#ffd9b3", "#fff3b3", "#d9ffb3", "#b3ffd9", "#b3e6ff", "#c7b3ff", "#ffb3f2"]
  },
  {
    "id": "dark",
    "name": "Dark",
    "bg": "#121212",
    "text": "#f5f5f5",
    "accent": "#ff6b6b",
    "colors": ["#2e2e34", "#3a3a44", "#4a4a56", "#5a5a68", "#6a6a78", "#7a7a88"]
  },
  {
    "id": "pastel",
    "name": "Pastel",
    "bg": "#f7f7ff",
    "text": "#333333",
    "accent": "#ff8c94",
    "colors": ["#ffd1dc", "#fce1b4", "#e8ffd1", "#d1fff0", "#d1e7ff", "#e6d1ff"]
  },
  {
    "id": "neon",
    "name": "Neon",
    "bg": "#0f0f13",
    "text": "#eaff00",
    "accent": "#00fff5",
    "colors": ["#ff00ff", "#ff8c00", "#00ff00", "#00ffff", "#8c00ff", "#ff0066"]
  }
]
```

styles.css
```css
'''
DOCSTRING:
Base CSS for the Wheel of Names app.
Defines layout, basic theme variables, and responsive styles.
'''
/* Base CSS and theme variables */
:root{
  --bg: #ffffff;
  --text: #222222;
  --accent: #007bff;
  --panel-bg: #f6f8fa;
}
*{box-sizing:border-box}
html,body{
  height:100%;
  margin:0;
  font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
  background: var(--bg);
  color: var(--text);
}
.container{
  max-width:1100px;
  margin:24px auto;
  padding:16px;
}
header{ text-align:center; margin-bottom:8px }
h1{ margin:6px 0; font-size:28px }
p{ margin:0; color:var(--text); opacity:0.8 }
.main-grid{
  display:grid;
  grid-template-columns: 360px 1fr;
  gap:20px;
  align-items:start;
  margin-top:18px;
}
.left-panel{
  background:var(--panel-bg);
  padding:14px;
  border-radius:8px;
  box-shadow:0 4px 8px rgba(0,0,0,0.04);
}
.left-panel label{ display:block; margin-top:8px; font-weight:600; margin-bottom:6px }
.input-row{ display:flex; gap:8px }
.input-row input[type="text"]{
  flex:1;
  padding:8px 10px;
  border-radius:6px;
  border:1px solid #ddd;
  background:white;
  color:inherit;
}
.input-row button{
  padding:8px 12px;
  border-radius:6px;
  background:var(--accent);
  color:white;
  border:none;
  cursor:pointer;
}
textarea{
  width:100%;
  min-height:160px;
  padding:10px;
  border-radius:8px;
  border:1px solid #ddd;
  resize:vertical;
  background:white;
  color:inherit;
}
.buttons-row{
  display:flex;
  gap:8px;
  margin-top:8px;
  flex-wrap:wrap;
}
.buttons-row button{
  padding:8px 10px;
  border-radius:6px;
  border:1px solid #ccc;
  background:transparent;
  cursor:pointer;
}
.spin-controls{
  display:flex;
  gap:12px;
  margin-top:16px;
  align-items:center;
}
.spin{
  padding:14px 24px;
  background:var(--accent);
  color:white;
  font-weight:700;
  border:none;
  border-radius:10px;
  cursor:pointer;
  font-size:18px;
}
.result{
  padding:10px 12px;
  background:rgba(0,0,0,0.06);
  border-radius:8px;
}
.hidden{ display:none }
.right-panel{
  display:flex;
  align-items:center;
  justify-content:center;
  min-height:420px;
}
.wheel-wrapper{
  position:relative;
  width:600px;
  height:600px;
  display:flex;
  align-items:center;
  justify-content:center;
  margin:auto;
}
#wheel-canvas{
  border-radius:50%;
  box-shadow: 0 12px 30px rgba(0,0,0,0.12);
  background:transparent;
  /* ensure the canvas element scales responsively in layout; the backing store will be adjusted in JS */
  width:100%;
  height:100%;
  display:block;
}
#wheel-wrapper #pointer{
  position:absolute;
  top:18px;
  left:50%;
  transform:translateX(-50%);
  font-size:40px;
  color:var(--accent);
  text-shadow:0 2px 4px rgba(0,0,0,0.2);
  pointer-events:none;
}
footer{ text-align:center; margin-top:16px; color:var(--text); opacity:0.7; }
/* Responsive */
@media (max-width:960px){
  .main-grid{ grid-template-columns:1fr; }
  .wheel-wrapper{ width:420px; height:420px; }
  #wheel-canvas{ width:420px; height:420px; }
}
```

wheel.js
```javascript
'''
DOCSTRING:
wheel.js
Contains a Wheel class that draws the wheel on a canvas and animates spins.
Key methods:
- constructor(canvas, options)
- setNames(names)
- setTheme(theme)
- draw()
- resize() -> handle high-DPI displays
- spinToIndex(index) -> Promise resolves with index after animation
- getRandomIndex()
'''
/* A small utility to requestAnimationFrame safely (browser-provided) */
class Wheel {
  constructor(canvas, options = {}) {
    this.canvas = canvas;
    this.ctx = canvas.getContext('2d');
    this.names = options.names || [];
    this.colors = options.colors || ['#ffb3b3', '#ffd9b3', '#fff3b3', '#d9ffb3', '#b3ffd9', '#b3e6ff'];
    this.textColor = options.textColor || '#222';
    this.rotation = 0; // degrees
    this.font = options.font || '16px Inter, Arial';
    this.onDraw = options.onDraw || function(){};
    this._animating = false;

    // Set up high-DPI friendly canvas and metrics
    this.resize();

    // Redraw once created
    this.draw();

    // Optional: handle container resize via ResizeObserver if available
    if (window.ResizeObserver) {
      try {
        const ro = new ResizeObserver(() => this.resize());
        ro.observe(this.canvas.parentElement || this.canvas);
        this._resizeObserver = ro;
      } catch (e) {
        // ignore
      }
    } else {
      window.addEventListener('resize', () => this.resize());
    }
  }

  resize() {
    // Make the canvas crisp on high-DPI screens.
    const dpr = window.devicePixelRatio || 1;
    const rect = this.canvas.getBoundingClientRect();
    // Fallback to element width/height attributes if bounding rect is 0
    const cssWidth = rect.width || this.canvas.clientWidth || this.canvas.width / (dpr || 1);
    const cssHeight = rect.height || this.canvas.clientHeight || this.canvas.height / (dpr || 1);

    // Set backing store size
    this.canvas.width = Math.max(1, Math.round(cssWidth * dpr));
    this.canvas.height = Math.max(1, Math.round(cssHeight * dpr));
    // Keep CSS size consistent
    this.canvas.style.width = cssWidth + 'px';
    this.canvas.style.height = cssHeight + 'px';
    // Reset transform so we can set a scale for dpr
    this.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

    // Use CSS pixel coordinates for drawing from now on
    this.centerX = cssWidth / 2;
    this.centerY = cssHeight / 2;
    this.radius = Math.min(cssWidth, cssHeight) / 2 - 10;

    // Recompute font size based on canvas size to keep labels legible
    // If user supplied a font (with px), keep it; otherwise set a sensible value.
    if (!this.font || typeof this.font !== 'string') {
      this.font = Math.max(12, Math.round(this.radius * 0.06)) + 'px Inter, Arial';
    } else {
      // keep user's font but ensure text scale reasonable
      // (we don't attempt to parse px here; leaving as provided)
    }

    this.draw();
  }

  setNames(names) {
    this.names = names.slice();
    this.draw();
  }

  setTheme(theme) {
    if (!theme) return;
    if (theme.colors && theme.colors.length) this.colors = theme.colors.slice();
    if (theme.text) this.textColor = theme.text;
    this.draw();
  }

  clearCanvas() {
    // Clear the visible canvas area (CSS pixels)
    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
  }

  draw() {
    this.clearCanvas();
    const ctx = this.ctx;
    const n = Math.max(1, this.names.length);
    const seg = 360 / n;

    ctx.save();
    // Translate to center using CSS pixel coordinates
    ctx.translate(this.centerX, this.centerY);
    ctx.rotate(this.degToRad(this.rotation));

    // Draw segments
    for (let i = 0; i < n; i++) {
      const start = this.degToRad(i * seg);
      const end = this.degToRad((i + 1) * seg);
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.arc(0, 0, this.radius, start, end);
      ctx.closePath();
      ctx.fillStyle = this.colors[i % this.colors.length];
      ctx.fill();

      // stroke
      ctx.lineWidth = Math.max(1, this.radius * 0.008);
      ctx.strokeStyle = 'rgba(0,0,0,0.08)';
      ctx.stroke();

      // Draw label
      ctx.save();
      const angle = start + (end - start) / 2;
      ctx.rotate(angle);
      ctx.translate(this.radius * 0.55, 0);
      ctx.rotate(Math.PI / 2);
      ctx.fillStyle = this.textColor;
      // Set font size relative to radius if not provided precisely
      ctx.font = this.font;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      const name = this.names[i] || '';
      this.wrapText(ctx, name, 0, 0, this.radius * 0.35, parseInt(Math.max(12, this.radius * 0.06), 10));
      ctx.restore();
    }

    ctx.restore();

    // center circle
    ctx.beginPath();
    ctx.arc(this.centerX, this.centerY, this.radius * 0.12, 0, Math.PI * 2);
    // Fill with background-like color; allow theme override by drawing over it in CSS if necessary
    ctx.fillStyle = '#ffffff';
    ctx.fill();
    ctx.lineWidth = Math.max(1, this.radius * 0.008);
    ctx.strokeStyle = 'rgba(0,0,0,0.06)';
    ctx.stroke();

    this.onDraw();
  }

  wrapText(ctx, text, x, y, maxWidth, lineHeight) {
    // A simple wrap for canvas text
    const words = String(text).split(' ');
    let line = '';
    let yOffset = y;
    for (let n = 0; n < words.length; n++) {
      const testLine = line + words[n] + ' ';
      const metrics = ctx.measureText(testLine);
      const testWidth = metrics.width;
      if (testWidth > maxWidth && n > 0) {
        ctx.fillText(line.trim(), x, yOffset);
        line = words[n] + ' ';
        yOffset += lineHeight;
      } else {
        line = testLine;
      }
    }
    ctx.fillText(line.trim(), x, yOffset);
  }

  degToRad(d) {
    return d * Math.PI / 180;
  }

  radToDeg(r) {
    return r * 180 / Math.PI;
  }

  getRandomIndex() {
    if (!this.names.length) return 0;
    return Math.floor(Math.random() * this.names.length);
  }

  // Spin such that the segment at `index` lands on the pointer at top.
  spinToIndex(index, opts = {}) {
    if (this._animating) return Promise.reject('Already animating');
    if (!this.names.length) return Promise.reject('No names');
    const n = this.names.length;
    const segAngle = 360 / n;

    // Normalize current rotation to [0, 360)
    const normalized = ((this.rotation % 360) + 360) % 360;

    // Center of segment i is at angle: (i * segAngle + segAngle/2)
    const centerAngle = index * segAngle + segAngle / 2;

    // We want (centerAngle + rotation) mod 360 = 270 (pointing upward if pointer is at top)
    let targetRotation = 270 - centerAngle;
    targetRotation = ((targetRotation % 360) + 360) % 360;

    const fullSpins = opts.fullSpins !== undefined ? opts.fullSpins : (3 + Math.floor(Math.random() * 3)); // 3-5 spins
    const endRotation = targetRotation + fullSpins * 360 + (opts.randomOffset || 0);

    const startRotation = normalized;
    const delta = endRotation - startRotation;
    const duration = opts.duration || 5000; // ms
    const startTime = performance.now();
    this._animating = true;

    return new Promise((resolve) => {
      const animate = (now) => {
        const elapsed = now - startTime;
        const t = Math.min(1, elapsed / duration);
        // ease out cubic
        const eased = 1 - Math.pow(1 - t, 3);
        const current = startRotation + delta * eased;
        this.rotation = current;
        this.draw();
        if (t < 1) {
          requestAnimationFrame(animate);
        } else {
          this._animating = false;
          // Normalize rotation to endRotation mod 360
          this.rotation = ((endRotation % 360) + 360) % 360;
          this.draw();
          resolve(index);
        }
      };
      requestAnimationFrame(animate);
    });
  }
}
```

main.js
```javascript
'''
DOCSTRING:
main.js
Wires UI to the Wheel class:
- loads themes.json (URL injected by Flask)
- populates theme selector
- reads names and updates wheel
- handles spin logic and result display
Includes robust fallback if fetching themes.json fails.
'''
/* DOM wiring and app logic */
document.addEventListener('DOMContentLoaded', async () => {
  const canvas = document.getElementById('wheel-canvas');
  const nameInput = document.getElementById('name-input');
  const addBtn = document.getElementById('add-name');
  const namesTextarea = document.getElementById('names-textarea');
  const spinBtn = document.getElementById('spin-btn');
  const resultDiv = document.getElementById('result');
  const themeSelect = document.getElementById('theme-select');
  const loadSampleBtn = document.getElementById('load-sample');
  const clearBtn = document.getElementById('clear-names');
  const importBtn = document.getElementById('import-names');
  const exportBtn = document.getElementById('export-names');

  const wheel = new Wheel(canvas, { names: [], colors: ['#ffb3b3','#ffd9b3','#fff3b3','#d9ffb3'] });

  let themes = [];

  // A small fallback theme set in case fetching themes.json fails.
  const defaultThemes = [
    {
      id: 'fallback',
      name: 'Default',
      bg: '#ffffff',
      text: '#222222',
      accent: '#007bff',
      colors: ['#ffb3b3','#ffd9b3','#fff3b3','#d9ffb3']
    }
  ];

  // Helper to populate theme selector
  function populateThemeSelector(list) {
    themeSelect.innerHTML = '';
    list.forEach(t => {
      const opt = document.createElement('option');
      opt.value = t.id;
      opt.textContent = t.name;
      themeSelect.appendChild(opt);
    });
  }

  // Load themes.json (URL injected by Flask)
  try {
    const themesUrl = window.THEMES_JSON_URL || '/static/themes.json';
    const resp = await fetch(themesUrl, {cache: 'no-cache'});
    if (!resp.ok) throw new Error('HTTP ' + resp.status);
    themes = await resp.json();
    if (!Array.isArray(themes) || themes.length === 0) throw new Error('No themes found');
    populateThemeSelector(themes);
    // apply first theme
    applyTheme(themes[0]);
    themeSelect.value = themes[0].id;
  } catch (err) {
    console.error('Failed to load themes:', err);
    // fallback
    themes = defaultThemes;
    populateThemeSelector(themes);
    applyTheme(themes[0]);
    themeSelect.value = themes[0].id;
  }

  function applyTheme(theme) {
    if (!theme) return;
    document.documentElement.style.setProperty('--bg', theme.bg || '#fff');
    document.documentElement.style.setProperty('--text', theme.text || '#222');
    document.documentElement.style.setProperty('--accent', theme.accent || '#007bff');
    // set panel bg slightly adjusted
    let panelBg = theme.bg;
    try {
      panelBg = lightenOrDarkenColor(theme.bg || '#fff', 18);
    } catch(e) {
      panelBg = '#f6f8fa';
    }
    document.documentElement.style.setProperty('--panel-bg', panelBg);
    wheel.setTheme({ colors: theme.colors || [], text: theme.text || '#222' });

    // recolor pointer (DOM element)
    const pointer = document.getElementById('pointer');
    if (pointer) pointer.style.color = theme.accent || '';
    // recolor spin button
    const spin = document.getElementById('spin-btn');
    if (spin) spin.style.background = theme.accent || '';
  }

  function lightenOrDarkenColor(col, amt) {
    // accepts #rgb or #rrggbb. amt can be negative to darken.
    if (typeof col !== 'string') throw new Error('Invalid color');
    let colStr = col.trim();
    if (colStr[0] === '#') colStr = colStr.slice(1);
    if (colStr.length === 3) {
      colStr = colStr.split('').map(c => c + c).join('');
    }
    if (colStr.length !== 6) throw new Error('Invalid hex color');
    const num = parseInt(colStr, 16);
    let r = (num >> 16) & 0xFF;
    let g = (num >> 8) & 0xFF;
    let b = num & 0xFF;
    r = Math.max(0, Math.min(255, r + amt));
    g = Math.max(0, Math.min(255, g + amt));
    b = Math.max(0, Math.min(255, b + amt));
    const newHex = '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
    return newHex;
  }

  themeSelect.addEventListener('change', () => {
    const id = themeSelect.value;
    const t = themes.find(x => x.id === id);
    if (t) applyTheme(t);
  });

  function parseNamesFromTextarea() {
    const lines = namesTextarea.value.split('\n').map(s => s.trim()).filter(s => s.length);
    return lines;
  }

  function updateWheelFromTextarea() {
    const names = parseNamesFromTextarea();
    wheel.setNames(names);
  }

  addBtn.addEventListener('click', () => {
    const v = nameInput.value.trim();
    if (!v) return;
    const cur = parseNamesFromTextarea();
    cur.push(v);
    namesTextarea.value = cur.join('\n');
    nameInput.value = '';
    updateWheelFromTextarea();
  });

  nameInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
      addBtn.click();
      e.preventDefault();
    }
  });

  namesTextarea.addEventListener('input', () => {
    updateWheelFromTextarea();
  });

  loadSampleBtn.addEventListener('click', () => {
    const sample = ['Alice','Bob','Charlie','Diana','Eva','Frank','George','Helen','Ivy','Jack'];
    namesTextarea.value = sample.join('\n');
    updateWheelFromTextarea();
  });

  clearBtn.addEventListener('click', () => {
    namesTextarea.value = '';
    updateWheelFromTextarea();
    resultDiv.classList.add('hidden');
  });

  importBtn.addEventListener('click', async () => {
    // prompt user for a newline separated list (simple)
    const data = prompt('Paste names (one per line):');
    if (data === null) return;
    namesTextarea.value = data.split('\n').map(s => s.trim()).filter(s => s).join('\n');
    updateWheelFromTextarea();
  });

  exportBtn.addEventListener('click', () => {
    const names = parseNamesFromTextarea();
    const blob = new Blob([names.join('\n')], {type: 'text/plain'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'names.txt';
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  });

  spinBtn.addEventListener('click', async () => {
    const names = parseNamesFromTextarea();
    if (names.length === 0) {
      alert('Please add at least one name.');
      return;
    }
    resultDiv.classList.add('hidden');
    spinBtn.disabled = true;
    spinBtn.textContent = 'Spinning...';

    // Ensure wheel has latest names before selecting index
    wheel.setNames(names);

    // pick random index
    const idx = wheel.getRandomIndex();
    try {
      const winnerIndex = await wheel.spinToIndex(idx, { duration: 4500 });
      const winner = names[winnerIndex];
      resultDiv.textContent = `Winner: ${winner}`;
      resultDiv.classList.remove('hidden');
      spinBtn.textContent = 'SPIN';
      spinBtn.disabled = false;
    } catch (err) {
      console.error(err);
      spinBtn.textContent = 'SPIN';
      spinBtn.disabled = false;
    }
  });

  // initial sample and initial canvas sizing
  namesTextarea.value = 'Alice\nBob\nCharlie\nDiana\nEva';
  updateWheelFromTextarea();

  // Ensure wheel draws crisply at startup and on resize
  function handleResize() {
    if (typeof wheel.resize === 'function') {
      wheel.resize();
    } else {
      // fallback: redraw
      wheel.draw();
    }
  }
  window.addEventListener('resize', handleResize);
  // Run a resize after a short delay to ensure layout settled
  setTimeout(handleResize, 50);
});
```

[2025-17-09 14:06:42 INFO] **[Update Codes]**

main.py updated.


```
'''

'''
--- Old
+++ New
@@ -9,6 +9,7 @@
 def create_app():
     """
     Create and configure the Flask application.
+    Serves templates from 'templates' and static files from 'static'.
     """
     app = Flask(__name__, static_folder='static', template_folder='templates')
     @app.route('/')
@@ -21,4 +22,5 @@
 if __name__ == '__main__':
     app = create_app()
     port = int(os.environ.get('PORT', 5000))
+    # debug=True for development; set to False in production
     app.run(debug=True, host='0.0.0.0', port=port)
```

[2025-17-09 14:06:42 INFO] **[Update Codes]**

index.html updated.


```
'''

'''
--- Old
+++ New
@@ -15,6 +15,7 @@
   <meta charset="utf-8">
   <meta name="viewport" content="width=device-width, initial-scale=1">
   <title>Wheel of Names</title>
+  <!-- Main stylesheet -->
   <link rel="stylesheet" href="{{ url_for('static', filename='css/styles.css') }}">
 </head>
 <body>
@@ -29,28 +30,29 @@
           <label for="name-input">Add a name</label>
           <div class="input-row">
             <input id="name-input" type="text" placeholder="Enter name and press Add" autocomplete="off">
-            <button id="add-name">Add</button>
+            <button id="add-name" type="button">Add</button>
           </div>
           <label for="names-textarea">Names (one per line)</label>
           <textarea id="names-textarea" placeholder="Alice\nBob\nCharlie"></textarea>
           <div class="buttons-row">
-            <button id="load-sample">Load Sample</button>
-            <button id="clear-names">Clear</button>
-            <button id="import-names">Import</button>
-            <button id="export-names">Export</button>
+            <button id="load-sample" type="button">Load Sample</button>
+            <button id="clear-names" type="button">Clear</button>
+            <button id="import-names" type="button">Import</button>
+            <button id="export-names" type="button">Export</button>
           </div>
           <label for="theme-select">Theme</label>
-          <select id="theme-select"></select>
+          <select id="theme-select" aria-label="Theme selector"></select>
           <div class="spin-controls">
-            <button id="spin-btn" class="spin">SPIN</button>
-            <div id="result" class="result hidden"></div>
+            <button id="spin-btn" class="spin" type="button">SPIN</button>
+            <div id="result" class="result hidden" aria-live="polite"></div>
           </div>
         </div>
       </section>
       <section class="right-panel">
         <div class="wheel-wrapper" id="wheel-wrapper">
-          <canvas id="wheel-canvas" width="600" height="600"></canvas>
-          <div id="pointer">â–¼</div>
+          <!-- Canvas will be scaled for high-DPI via JS -->
+          <canvas id="wheel-canvas" width="600" height="600" aria-label="Wheel of names"></canvas>
+          <div id="pointer" aria-hidden="true">â–¼</div>
         </div>
       </section>
     </main>
```

[2025-17-09 14:06:42 INFO] **[Update Codes]**

themes.json updated.


```
'''

'''
--- Old
+++ New
@@ -2,6 +2,7 @@
 DOCSTRING:
 List of themes available for the wheel.
 Each theme contains:
+- id: machine id
 - name: display name
 - bg: page background color
 - text: primary text color
```

[2025-17-09 14:06:42 INFO] **[Update Codes]**

styles.css updated.


```
'''

'''
--- Old
+++ New
@@ -3,6 +3,7 @@
 Base CSS for the Wheel of Names app.
 Defines layout, basic theme variables, and responsive styles.
 '''
+/* Base CSS and theme variables */
 :root{
   --bg: #ffffff;
   --text: #222222;
@@ -45,6 +46,8 @@
   padding:8px 10px;
   border-radius:6px;
   border:1px solid #ddd;
+  background:white;
+  color:inherit;
 }
 .input-row button{
   padding:8px 12px;
@@ -61,6 +64,8 @@
   border-radius:8px;
   border:1px solid #ddd;
   resize:vertical;
+  background:white;
+  color:inherit;
 }
 .buttons-row{
   display:flex;
@@ -116,6 +121,10 @@
   border-radius:50%;
   box-shadow: 0 12px 30px rgba(0,0,0,0.12);
   background:transparent;
+  /* ensure the canvas element scales responsively in layout; the backing store will be adjusted in JS */
+  width:100%;
+  height:100%;
+  display:block;
 }
 #wheel-wrapper #pointer{
   position:absolute;
```

[2025-17-09 14:06:42 INFO] **[Update Codes]**

wheel.js updated.


```
'''

'''
--- Old
+++ New
@@ -1,4 +1,3 @@
-/*
 '''
 DOCSTRING:
 wheel.js
@@ -8,10 +7,11 @@
 - setNames(names)
 - setTheme(theme)
 - draw()
+- resize() -> handle high-DPI displays
 - spinToIndex(index) -> Promise resolves with index after animation
 - getRandomIndex()
 '''
-*/
+/* A small utility to requestAnimationFrame safely (browser-provided) */
 class Wheel {
   constructor(canvas, options = {}) {
     this.canvas = canvas;
@@ -19,13 +19,54 @@
     this.names = options.names || [];
     this.colors = options.colors || ['#ffb3b3', '#ffd9b3', '#fff3b3', '#d9ffb3', '#b3ffd9', '#b3e6ff'];
     this.textColor = options.textColor || '#222';
-    this.centerX = canvas.width / 2;
-    this.centerY = canvas.height / 2;
-    this.radius = Math.min(this.centerX, this.centerY) - 10;
     this.rotation = 0; // degrees
     this.font = options.font || '16px Inter, Arial';
     this.onDraw = options.onDraw || function(){};
     this._animating = false;
+    // Set up high-DPI friendly canvas and metrics
+    this.resize();
+    // Redraw once created
+    this.draw();
+    // Optional: handle container resize via ResizeObserver if available
+    if (window.ResizeObserver) {
+      try {
+        const ro = new ResizeObserver(() => this.resize());
+        ro.observe(this.canvas.parentElement || this.canvas);
+        this._resizeObserver = ro;
+      } catch (e) {
+        // ignore
+      }
+    } else {
+      window.addEventListener('resize', () => this.resize());
+    }
+  }
+  resize() {
+    // Make the canvas crisp on high-DPI screens.
+    const dpr = window.devicePixelRatio || 1;
+    const rect = this.canvas.getBoundingClientRect();
+    // Fallback to element width/height attributes if bounding rect is 0
+    const cssWidth = rect.width || this.canvas.clientWidth || this.canvas.width / (dpr || 1);
+    const cssHeight = rect.height || this.canvas.clientHeight || this.canvas.height / (dpr || 1);
+    // Set backing store size
+    this.canvas.width = Math.max(1, Math.round(cssWidth * dpr));
+    this.canvas.height = Math.max(1, Math.round(cssHeight * dpr));
+    // Keep CSS size consistent
+    this.canvas.style.width = cssWidth + 'px';
+    this.canvas.style.height = cssHeight + 'px';
+    // Reset transform so we can set a scale for dpr
+    this.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
+    // Use CSS pixel coordinates for drawing from now on
+    this.centerX = cssWidth / 2;
+    this.centerY = cssHeight / 2;
+    this.radius = Math.min(cssWidth, cssHeight) / 2 - 10;
+    // Recompute font size based on canvas size to keep labels legible
+    // If user supplied a font (with px), keep it; otherwise set a sensible value.
+    if (!this.font || typeof this.font !== 'string') {
+      this.font = Math.max(12, Math.round(this.radius * 0.06)) + 'px Inter, Arial';
+    } else {
+      // keep user's font but ensure text scale reasonable
+      // (we don't attempt to parse px here; leaving as provided)
+    }
     this.draw();
   }
   setNames(names) {
@@ -39,7 +80,8 @@
     this.draw();
   }
   clearCanvas() {
-    this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height);
+    // Clear the visible canvas area (CSS pixels)
+    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
   }
   draw() {
     this.clearCanvas();
@@ -47,6 +89,7 @@
     const n = Math.max(1, this.names.length);
     const seg = 360 / n;
     ctx.save();
+    // Translate to center using CSS pixel coordinates
     ctx.translate(this.centerX, this.centerY);
     ctx.rotate(this.degToRad(this.rotation));
     // Draw segments
@@ -54,13 +97,13 @@
       const start = this.degToRad(i * seg);
       const end = this.degToRad((i + 1) * seg);
       ctx.beginPath();
-      ctx.moveTo(0,0);
-      ctx.arc(0,0,this.radius,start,end);
+      ctx.moveTo(0, 0);
+      ctx.arc(0, 0, this.radius, start, end);
       ctx.closePath();
       ctx.fillStyle = this.colors[i % this.colors.length];
       ctx.fill();
       // stroke
-      ctx.lineWidth = 2;
+      ctx.lineWidth = Math.max(1, this.radius * 0.008);
       ctx.strokeStyle = 'rgba(0,0,0,0.08)';
       ctx.stroke();
       // Draw label
@@ -70,27 +113,29 @@
       ctx.translate(this.radius * 0.55, 0);
       ctx.rotate(Math.PI / 2);
       ctx.fillStyle = this.textColor;
+      // Set font size relative to radius if not provided precisely
       ctx.font = this.font;
       ctx.textAlign = 'center';
       ctx.textBaseline = 'middle';
       const name = this.names[i] || '';
-      this.wrapText(ctx, name, 0, 0, this.radius * 0.35, 18);
+      this.wrapText(ctx, name, 0, 0, this.radius * 0.35, parseInt(Math.max(12, this.radius * 0.06), 10));
       ctx.restore();
     }
     ctx.restore();
     // center circle
     ctx.beginPath();
-    ctx.arc(this.centerX, this.centerY, this.radius * 0.12, 0, Math.PI*2);
+    ctx.arc(this.centerX, this.centerY, this.radius * 0.12, 0, Math.PI * 2);
+    // Fill with background-like color; allow theme override by drawing over it in CSS if necessary
     ctx.fillStyle = '#ffffff';
     ctx.fill();
-    ctx.lineWidth = 2;
+    ctx.lineWidth = Math.max(1, this.radius * 0.008);
     ctx.strokeStyle = 'rgba(0,0,0,0.06)';
     ctx.stroke();
     this.onDraw();
   }
   wrapText(ctx, text, x, y, maxWidth, lineHeight) {
     // A simple wrap for canvas text
-    const words = text.split(' ');
+    const words = String(text).split(' ');
     let line = '';
     let yOffset = y;
     for (let n = 0; n < words.length; n++) {
@@ -123,22 +168,15 @@
     if (!this.names.length) return Promise.reject('No names');
     const n = this.names.length;
     const segAngle = 360 / n;
-    // We want the center of target segment to be at angle 270deg (top of canvas - adjust if pointer is at top)
-    // Our rotation variable rotates the whole wheel clockwise in degrees.
-    // Compute the current rotation normalized
+    // Normalize current rotation to [0, 360)
     const normalized = ((this.rotation % 360) + 360) % 360;
-    // Calculate angle to place the segment center at top (270deg)
     // Center of segment i is at angle: (i * segAngle + segAngle/2)
-    // We need rotation such that (centerAngle + rotation) mod 360 = 270
     const centerAngle = index * segAngle + segAngle / 2;
-    // Solve for rotation target:
+    // We want (centerAngle + rotation) mod 360 = 270 (pointing upward if pointer is at top)
     let targetRotation = 270 - centerAngle;
-    // Normalize to 0..360
     targetRotation = ((targetRotation % 360) + 360) % 360;
-    // To produce multiple spins, add several full rotations:
-    const fullSpins = opts.fullSpins !== undefined ? opts.fullSpins : (3 + Math.floor(Math.random()*3)); // 3-5 spins
+    const fullSpins = opts.fullSpins !== undefined ? opts.fullSpins : (3 + Math.floor(Math.random() * 3)); // 3-5 spins
     const endRotation = targetRotation + fullSpins * 360 + (opts.randomOffset || 0);
-    // We'll animate from current normalized to endRotation, taking into account wrap
     const startRotation = normalized;
     const delta = endRotation - startRotation;
     const duration = opts.duration || 5000; // ms
```

[2025-17-09 14:06:42 INFO] **[Update Codes]**

main.js updated.


```
'''

'''
--- Old
+++ New
@@ -1,4 +1,3 @@
-/*
 '''
 DOCSTRING:
 main.js
@@ -9,7 +8,7 @@
 - handles spin logic and result display
 Includes robust fallback if fetching themes.json fails.
 '''
-*/
+/* DOM wiring and app logic */
 document.addEventListener('DOMContentLoaded', async () => {
   const canvas = document.getElementById('wheel-canvas');
   const nameInput = document.getElementById('name-input');
@@ -48,7 +47,7 @@
   // Load themes.json (URL injected by Flask)
   try {
     const themesUrl = window.THEMES_JSON_URL || '/static/themes.json';
-    const resp = await fetch(themesUrl);
+    const resp = await fetch(themesUrl, {cache: 'no-cache'});
     if (!resp.ok) throw new Error('HTTP ' + resp.status);
     themes = await resp.json();
     if (!Array.isArray(themes) || themes.length === 0) throw new Error('No themes found');
@@ -71,7 +70,6 @@
     document.documentElement.style.setProperty('--accent', theme.accent || '#007bff');
     // set panel bg slightly adjusted
     let panelBg = theme.bg;
-    // robust luminance tweak (supports 3/6 digit hex)
     try {
       panelBg = lightenOrDarkenColor(theme.bg || '#fff', 18);
     } catch(e) {
@@ -79,6 +77,12 @@
     }
     document.documentElement.style.setProperty('--panel-bg', panelBg);
     wheel.setTheme({ colors: theme.colors || [], text: theme.text || '#222' });
+    // recolor pointer (DOM element)
+    const pointer = document.getElementById('pointer');
+    if (pointer) pointer.style.color = theme.accent || '';
+    // recolor spin button
+    const spin = document.getElementById('spin-btn');
+    if (spin) spin.style.background = theme.accent || '';
   }
   function lightenOrDarkenColor(col, amt) {
     // accepts #rgb or #rrggbb. amt can be negative to darken.
@@ -168,6 +172,8 @@
     resultDiv.classList.add('hidden');
     spinBtn.disabled = true;
     spinBtn.textContent = 'Spinning...';
+    // Ensure wheel has latest names before selecting index
+    wheel.setNames(names);
     // pick random index
     const idx = wheel.getRandomIndex();
     try {
@@ -183,7 +189,19 @@
       spinBtn.disabled = false;
     }
   });
-  // initial sample
+  // initial sample and initial canvas sizing
   namesTextarea.value = 'Alice\nBob\nCharlie\nDiana\nEva';
   updateWheelFromTextarea();
+  // Ensure wheel draws crisply at startup and on resize
+  function handleResize() {
+    if (typeof wheel.resize === 'function') {
+      wheel.resize();
+    } else {
+      // fallback: redraw
+      wheel.draw();
+    }
+  }
+  window.addEventListener('resize', handleResize);
+  // Run a resize after a short delay to ensure layout settled
+  setTimeout(handleResize, 50);
 });
```

[2025-17-09 14:06:43 INFO] **[Software Info]**:

 

ðŸ’°**cost**=$0.056212

ðŸ”¨**version_updates**=-1

ðŸ“ƒ**num_code_files**=1

ðŸž**num_png_files**=0

ðŸ“š**num_doc_files**=9

ðŸ“ƒ**code_lines**=26

ðŸ“‹**env_lines**=-1

ðŸ“’**manual_lines**=-1

ðŸ—£**num_utterances**=15

ðŸ¤”**num_self_reflections**=0

â“**num_prompt_tokens**=26969

â—**num_completion_tokens**=28485

ðŸŒŸ**num_total_tokens**=55454

[2025-17-09 14:06:43 INFO] **[Execute Detail]**

execute SimplePhase:[CodeReviewComment] in ComposedPhase:[CodeReview], cycle 3

[2025-17-09 14:06:43 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | [Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes.] |
| **need_reflect** | False |
| **assistant_role_name** | Code Reviewer |
| **user_role_name** | Programmer |
| **phase_prompt** | According to the new user's task and our software designs:  Task: "{task}". Modality: "{modality}". Programming Language: "{language}" Ideas: "{ideas}" Codes: "{codes}" As the {assistant_role}, to make the software directly operable without further coding, ChatDev have formulated the following regulations: 1) all referenced classes should be imported; 2) all methods should be implemented; 3) all methods need to have the necessary comments; 4) no potential bugs; 5) The entire project conforms to the tasks proposed by the user; 6) most importantly, do not only check the errors in the code, but also the logic of code. Make sure that user can interact with generated software without losing any feature in the requirement; Now, you should check the above regulations one by one and review the codes in detail, propose one comment with the highest priority about the codes, and give me instructions on how to fix. Tell me your comment with the highest priority and corresponding suggestions on revision. If the codes are perfect and you have no comment on them, return only one line like " Finished". |
| **phase_name** | CodeReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Code Reviewer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. You can help programmers to assess source codes for software troubleshooting, fix bugs to increase code quality and robustness, and offer proposals to improve the source codes. Here is a new customer's task: {task}. To complete the task, you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Programmer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. You can write/create computer software or applications by providing a specific programming language to the computer. You have extensive computing and coding experience in many varieties of programming languages and platforms, such as Python, Java, C, C++, HTML, CSS, JavaScript, XML, SQL, PHP, etc,. Here is a new customer's task: {task}. To complete the task, you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': 'main.py\npython\n\'\'\'\nFlask application that serves the wheel-of-names web app.\nRun: pip install flask\nThen: python main.py\nAccess: http://127.0.0.1:5000/\n\'\'\'\nfrom flask import Flask, render_template\nimport os\n\ndef create_app():\n    """\n    Create and configure the Flask application.\n    Serves templates from \'templates\' and static files from \'static\'.\n    """\n    app = Flask(__name__, static_folder=\'static\', template_folder=\'templates\')\n\n    @app.route(\'/\')\n    def index():\n        """\n        Serve the main page.\n        """\n        return render_template(\'index.html\')\n\n    return app\n\nif __name__ == \'__main__\':\n    app = create_app()\n    port = int(os.environ.get(\'PORT\', 5000))\n    # debug=True for development; set to False in production\n    app.run(debug=True, host=\'0.0.0.0\', port=port)\n\n\nindex.html\nhtml\n\'\'\'\nDOCSTRING:\nMain HTML page for the Wheel of Names app.\nContains UI elements:\n- name input and list\n- canvas for wheel\n- theme selector\n- spin / clear / add buttons\nIncludes JS files wheel.js and main.js for behavior.\nAlso injects a dynamically generated URL for themes.json using Flask\'s url_for so the client can reliably fetch the resource even when the app is mounted under a subpath.\n\'\'\'\n&lt;!doctype html&gt;\n&lt;html lang="en"&gt;\n&lt;head&gt;\n  &lt;meta charset="utf-8"&gt;\n  &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;\n  &lt;title&gt;Wheel of Names&lt;/title&gt;\n  &lt;!-- Main stylesheet --&gt;\n  &lt;link rel="stylesheet" href="{{ url_for(\'static\', filename=\'css/styles.css\') }}"&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div class="container"&gt;\n    &lt;header&gt;\n      &lt;h1&gt;Wheel of Names&lt;/h1&gt;\n      &lt;p&gt;Enter names, choose a theme, and spin to pick a random winner.&lt;/p&gt;\n    &lt;/header&gt;\n    &lt;main class="main-grid"&gt;\n      &lt;section class="left-panel"&gt;\n        &lt;div class="controls"&gt;\n          &lt;label for="name-input"&gt;Add a name&lt;/label&gt;\n          &lt;div class="input-row"&gt;\n            &lt;input id="name-input" type="text" placeholder="Enter name and press Add" autocomplete="off"&gt;\n            &lt;button id="add-name" type="button"&gt;Add&lt;/button&gt;\n          &lt;/div&gt;\n\n          &lt;label for="names-textarea"&gt;Names (one per line)&lt;/label&gt;\n          &lt;textarea id="names-textarea" placeholder="Alice\\nBob\\nCharlie"&gt;&lt;/textarea&gt;\n\n          &lt;div class="buttons-row"&gt;\n            &lt;button id="load-sample" type="button"&gt;Load Sample&lt;/button&gt;\n            &lt;button id="clear-names" type="button"&gt;Clear&lt;/button&gt;\n            &lt;button id="import-names" type="button"&gt;Import&lt;/button&gt;\n            &lt;button id="export-names" type="button"&gt;Export&lt;/button&gt;\n          &lt;/div&gt;\n\n          &lt;label for="theme-select"&gt;Theme&lt;/label&gt;\n          &lt;select id="theme-select" aria-label="Theme selector"&gt;&lt;/select&gt;\n\n          &lt;div class="spin-controls"&gt;\n            &lt;button id="spin-btn" class="spin" type="button"&gt;SPIN&lt;/button&gt;\n            &lt;div id="result" class="result hidden" aria-live="polite"&gt;&lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      &lt;/section&gt;\n\n      &lt;section class="right-panel"&gt;\n        &lt;div class="wheel-wrapper" id="wheel-wrapper"&gt;\n          &lt;!-- Canvas will be scaled for high-DPI via JS --&gt;\n          &lt;canvas id="wheel-canvas" width="600" height="600" aria-label="Wheel of names"&gt;&lt;/canvas&gt;\n          &lt;div id="pointer" aria-hidden="true"&gt;â–¼&lt;/div&gt;\n        &lt;/div&gt;\n      &lt;/section&gt;\n    &lt;/main&gt;\n\n    &lt;footer&gt;\n      &lt;small&gt;Built with Flask + Canvas. Themes available.&lt;/small&gt;\n    &lt;/footer&gt;\n  &lt;/div&gt;\n\n  &lt;!-- Provide the correct URL for themes.json (generated by Flask).\n       This ensures the client can fetch themes.json even when the app is mounted under a prefix. --&gt;\n  &lt;script&gt;\n    window.THEMES_JSON_URL = "{{ url_for(\'static\', filename=\'themes.json\') }}";\n  &lt;/script&gt;\n\n  &lt;script src="{{ url_for(\'static\', filename=\'js/wheel.js\') }}"&gt;&lt;/script&gt;\n  &lt;script src="{{ url_for(\'static\', filename=\'js/main.js\') }}"&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\n\nthemes.json\njson\n\'\'\'\nDOCSTRING:\nList of themes available for the wheel.\nEach theme contains:\n- id: machine id\n- name: display name\n- bg: page background color\n- text: primary text color\n- accent: accent color used for pointer/button\n- colors: array of segment colors (will be cycled for segments)\n\'\'\'\n[\n  {\n    "id": "classic",\n    "name": "Classic",\n    "bg": "#ffffff",\n    "text": "#222222",\n    "accent": "#007bff",\n    "colors": ["#ffb3b3", "#ffd9b3", "#fff3b3", "#d9ffb3", "#b3ffd9", "#b3e6ff", "#c7b3ff", "#ffb3f2"]\n  },\n  {\n    "id": "dark",\n    "name": "Dark",\n    "bg": "#121212",\n    "text": "#f5f5f5",\n    "accent": "#ff6b6b",\n    "colors": ["#2e2e34", "#3a3a44", "#4a4a56", "#5a5a68", "#6a6a78", "#7a7a88"]\n  },\n  {\n    "id": "pastel",\n    "name": "Pastel",\n    "bg": "#f7f7ff",\n    "text": "#333333",\n    "accent": "#ff8c94",\n    "colors": ["#ffd1dc", "#fce1b4", "#e8ffd1", "#d1fff0", "#d1e7ff", "#e6d1ff"]\n  },\n  {\n    "id": "neon",\n    "name": "Neon",\n    "bg": "#0f0f13",\n    "text": "#eaff00",\n    "accent": "#00fff5",\n    "colors": ["#ff00ff", "#ff8c00", "#00ff00", "#00ffff", "#8c00ff", "#ff0066"]\n  }\n]\n\n\nstyles.css\ncss\n\'\'\'\nDOCSTRING:\nBase CSS for the Wheel of Names app.\nDefines layout, basic theme variables, and responsive styles.\n\'\'\'\n/* Base CSS and theme variables */\n:root{\n  --bg: #ffffff;\n  --text: #222222;\n  --accent: #007bff;\n  --panel-bg: #f6f8fa;\n}\n*{box-sizing:border-box}\nhtml,body{\n  height:100%;\n  margin:0;\n  font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;\n  background: var(--bg);\n  color: var(--text);\n}\n.container{\n  max-width:1100px;\n  margin:24px auto;\n  padding:16px;\n}\nheader{ text-align:center; margin-bottom:8px }\nh1{ margin:6px 0; font-size:28px }\np{ margin:0; color:var(--text); opacity:0.8 }\n.main-grid{\n  display:grid;\n  grid-template-columns: 360px 1fr;\n  gap:20px;\n  align-items:start;\n  margin-top:18px;\n}\n.left-panel{\n  background:var(--panel-bg);\n  padding:14px;\n  border-radius:8px;\n  box-shadow:0 4px 8px rgba(0,0,0,0.04);\n}\n.left-panel label{ display:block; margin-top:8px; font-weight:600; margin-bottom:6px }\n.input-row{ display:flex; gap:8px }\n.input-row input[type="text"]{\n  flex:1;\n  padding:8px 10px;\n  border-radius:6px;\n  border:1px solid #ddd;\n  background:white;\n  color:inherit;\n}\n.input-row button{\n  padding:8px 12px;\n  border-radius:6px;\n  background:var(--accent);\n  color:white;\n  border:none;\n  cursor:pointer;\n}\ntextarea{\n  width:100%;\n  min-height:160px;\n  padding:10px;\n  border-radius:8px;\n  border:1px solid #ddd;\n  resize:vertical;\n  background:white;\n  color:inherit;\n}\n.buttons-row{\n  display:flex;\n  gap:8px;\n  margin-top:8px;\n  flex-wrap:wrap;\n}\n.buttons-row button{\n  padding:8px 10px;\n  border-radius:6px;\n  border:1px solid #ccc;\n  background:transparent;\n  cursor:pointer;\n}\n.spin-controls{\n  display:flex;\n  gap:12px;\n  margin-top:16px;\n  align-items:center;\n}\n.spin{\n  padding:14px 24px;\n  background:var(--accent);\n  color:white;\n  font-weight:700;\n  border:none;\n  border-radius:10px;\n  cursor:pointer;\n  font-size:18px;\n}\n.result{\n  padding:10px 12px;\n  background:rgba(0,0,0,0.06);\n  border-radius:8px;\n}\n.hidden{ display:none }\n.right-panel{\n  display:flex;\n  align-items:center;\n  justify-content:center;\n  min-height:420px;\n}\n.wheel-wrapper{\n  position:relative;\n  width:600px;\n  height:600px;\n  display:flex;\n  align-items:center;\n  justify-content:center;\n  margin:auto;\n}\n#wheel-canvas{\n  border-radius:50%;\n  box-shadow: 0 12px 30px rgba(0,0,0,0.12);\n  background:transparent;\n  /* ensure the canvas element scales responsively in layout; the backing store will be adjusted in JS */\n  width:100%;\n  height:100%;\n  display:block;\n}\n#wheel-wrapper #pointer{\n  position:absolute;\n  top:18px;\n  left:50%;\n  transform:translateX(-50%);\n  font-size:40px;\n  color:var(--accent);\n  text-shadow:0 2px 4px rgba(0,0,0,0.2);\n  pointer-events:none;\n}\nfooter{ text-align:center; margin-top:16px; color:var(--text); opacity:0.7; }\n/* Responsive */\n@media (max-width:960px){\n  .main-grid{ grid-template-columns:1fr; }\n  .wheel-wrapper{ width:420px; height:420px; }\n  #wheel-canvas{ width:420px; height:420px; }\n}\n\n\nwheel.js\njavascript\n\'\'\'\nDOCSTRING:\nwheel.js\nContains a Wheel class that draws the wheel on a canvas and animates spins.\nKey methods:\n- constructor(canvas, options)\n- setNames(names)\n- setTheme(theme)\n- draw()\n- resize() -&gt; handle high-DPI displays\n- spinToIndex(index) -&gt; Promise resolves with index after animation\n- getRandomIndex()\n\'\'\'\n/* A small utility to requestAnimationFrame safely (browser-provided) */\nclass Wheel {\n  constructor(canvas, options = {}) {\n    this.canvas = canvas;\n    this.ctx = canvas.getContext(\'2d\');\n    this.names = options.names || [];\n    this.colors = options.colors || [\'#ffb3b3\', \'#ffd9b3\', \'#fff3b3\', \'#d9ffb3\', \'#b3ffd9\', \'#b3e6ff\'];\n    this.textColor = options.textColor || \'#222\';\n    this.rotation = 0; // degrees\n    this.font = options.font || \'16px Inter, Arial\';\n    this.onDraw = options.onDraw || function(){};\n    this._animating = false;\n\n    // Set up high-DPI friendly canvas and metrics\n    this.resize();\n\n    // Redraw once created\n    this.draw();\n\n    // Optional: handle container resize via ResizeObserver if available\n    if (window.ResizeObserver) {\n      try {\n        const ro = new ResizeObserver(() =&gt; this.resize());\n        ro.observe(this.canvas.parentElement || this.canvas);\n        this._resizeObserver = ro;\n      } catch (e) {\n        // ignore\n      }\n    } else {\n      window.addEventListener(\'resize\', () =&gt; this.resize());\n    }\n  }\n\n  resize() {\n    // Make the canvas crisp on high-DPI screens.\n    const dpr = window.devicePixelRatio || 1;\n    const rect = this.canvas.getBoundingClientRect();\n    // Fallback to element width/height attributes if bounding rect is 0\n    const cssWidth = rect.width || this.canvas.clientWidth || this.canvas.width / (dpr || 1);\n    const cssHeight = rect.height || this.canvas.clientHeight || this.canvas.height / (dpr || 1);\n\n    // Set backing store size\n    this.canvas.width = Math.max(1, Math.round(cssWidth * dpr));\n    this.canvas.height = Math.max(1, Math.round(cssHeight * dpr));\n    // Keep CSS size consistent\n    this.canvas.style.width = cssWidth + \'px\';\n    this.canvas.style.height = cssHeight + \'px\';\n    // Reset transform so we can set a scale for dpr\n    this.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n\n    // Use CSS pixel coordinates for drawing from now on\n    this.centerX = cssWidth / 2;\n    this.centerY = cssHeight / 2;\n    this.radius = Math.min(cssWidth, cssHeight) / 2 - 10;\n\n    // Recompute font size based on canvas size to keep labels legible\n    // If user supplied a font (with px), keep it; otherwise set a sensible value.\n    if (!this.font || typeof this.font !== \'string\') {\n      this.font = Math.max(12, Math.round(this.radius * 0.06)) + \'px Inter, Arial\';\n    } else {\n      // keep user\'s font but ensure text scale reasonable\n      // (we don\'t attempt to parse px here; leaving as provided)\n    }\n\n    this.draw();\n  }\n\n  setNames(names) {\n    this.names = names.slice();\n    this.draw();\n  }\n\n  setTheme(theme) {\n    if (!theme) return;\n    if (theme.colors &amp;&amp; theme.colors.length) this.colors = theme.colors.slice();\n    if (theme.text) this.textColor = theme.text;\n    this.draw();\n  }\n\n  clearCanvas() {\n    // Clear the visible canvas area (CSS pixels)\n    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n  }\n\n  draw() {\n    this.clearCanvas();\n    const ctx = this.ctx;\n    const n = Math.max(1, this.names.length);\n    const seg = 360 / n;\n\n    ctx.save();\n    // Translate to center using CSS pixel coordinates\n    ctx.translate(this.centerX, this.centerY);\n    ctx.rotate(this.degToRad(this.rotation));\n\n    // Draw segments\n    for (let i = 0; i &lt; n; i++) {\n      const start = this.degToRad(i * seg);\n      const end = this.degToRad((i + 1) * seg);\n      ctx.beginPath();\n      ctx.moveTo(0, 0);\n      ctx.arc(0, 0, this.radius, start, end);\n      ctx.closePath();\n      ctx.fillStyle = this.colors[i % this.colors.length];\n      ctx.fill();\n\n      // stroke\n      ctx.lineWidth = Math.max(1, this.radius * 0.008);\n      ctx.strokeStyle = \'rgba(0,0,0,0.08)\';\n      ctx.stroke();\n\n      // Draw label\n      ctx.save();\n      const angle = start + (end - start) / 2;\n      ctx.rotate(angle);\n      ctx.translate(this.radius * 0.55, 0);\n      ctx.rotate(Math.PI / 2);\n      ctx.fillStyle = this.textColor;\n      // Set font size relative to radius if not provided precisely\n      ctx.font = this.font;\n      ctx.textAlign = \'center\';\n      ctx.textBaseline = \'middle\';\n      const name = this.names[i] || \'\';\n      this.wrapText(ctx, name, 0, 0, this.radius * 0.35, parseInt(Math.max(12, this.radius * 0.06), 10));\n      ctx.restore();\n    }\n\n    ctx.restore();\n\n    // center circle\n    ctx.beginPath();\n    ctx.arc(this.centerX, this.centerY, this.radius * 0.12, 0, Math.PI * 2);\n    // Fill with background-like color; allow theme override by drawing over it in CSS if necessary\n    ctx.fillStyle = \'#ffffff\';\n    ctx.fill();\n    ctx.lineWidth = Math.max(1, this.radius * 0.008);\n    ctx.strokeStyle = \'rgba(0,0,0,0.06)\';\n    ctx.stroke();\n\n    this.onDraw();\n  }\n\n  wrapText(ctx, text, x, y, maxWidth, lineHeight) {\n    // A simple wrap for canvas text\n    const words = String(text).split(\' \');\n    let line = \'\';\n    let yOffset = y;\n    for (let n = 0; n &lt; words.length; n++) {\n      const testLine = line + words[n] + \' \';\n      const metrics = ctx.measureText(testLine);\n      const testWidth = metrics.width;\n      if (testWidth &gt; maxWidth &amp;&amp; n &gt; 0) {\n        ctx.fillText(line.trim(), x, yOffset);\n        line = words[n] + \' \';\n        yOffset += lineHeight;\n      } else {\n        line = testLine;\n      }\n    }\n    ctx.fillText(line.trim(), x, yOffset);\n  }\n\n  degToRad(d) {\n    return d * Math.PI / 180;\n  }\n\n  radToDeg(r) {\n    return r * 180 / Math.PI;\n  }\n\n  getRandomIndex() {\n    if (!this.names.length) return 0;\n    return Math.floor(Math.random() * this.names.length);\n  }\n\n  // Spin such that the segment at `index` lands on the pointer at top.\n  spinToIndex(index, opts = {}) {\n    if (this._animating) return Promise.reject(\'Already animating\');\n    if (!this.names.length) return Promise.reject(\'No names\');\n    const n = this.names.length;\n    const segAngle = 360 / n;\n\n    // Normalize current rotation to [0, 360)\n    const normalized = ((this.rotation % 360) + 360) % 360;\n\n    // Center of segment i is at angle: (i * segAngle + segAngle/2)\n    const centerAngle = index * segAngle + segAngle / 2;\n\n    // We want (centerAngle + rotation) mod 360 = 270 (pointing upward if pointer is at top)\n    let targetRotation = 270 - centerAngle;\n    targetRotation = ((targetRotation % 360) + 360) % 360;\n\n    const fullSpins = opts.fullSpins !== undefined ? opts.fullSpins : (3 + Math.floor(Math.random() * 3)); // 3-5 spins\n    const endRotation = targetRotation + fullSpins * 360 + (opts.randomOffset || 0);\n\n    const startRotation = normalized;\n    const delta = endRotation - startRotation;\n    const duration = opts.duration || 5000; // ms\n    const startTime = performance.now();\n    this._animating = true;\n\n    return new Promise((resolve) =&gt; {\n      const animate = (now) =&gt; {\n        const elapsed = now - startTime;\n        const t = Math.min(1, elapsed / duration);\n        // ease out cubic\n        const eased = 1 - Math.pow(1 - t, 3);\n        const current = startRotation + delta * eased;\n        this.rotation = current;\n        this.draw();\n        if (t &lt; 1) {\n          requestAnimationFrame(animate);\n        } else {\n          this._animating = false;\n          // Normalize rotation to endRotation mod 360\n          this.rotation = ((endRotation % 360) + 360) % 360;\n          this.draw();\n          resolve(index);\n        }\n      };\n      requestAnimationFrame(animate);\n    });\n  }\n}\n\n\nmain.js\njavascript\n\'\'\'\nDOCSTRING:\nmain.js\nWires UI to the Wheel class:\n- loads themes.json (URL injected by Flask)\n- populates theme selector\n- reads names and updates wheel\n- handles spin logic and result display\nIncludes robust fallback if fetching themes.json fails.\n\'\'\'\n/* DOM wiring and app logic */\ndocument.addEventListener(\'DOMContentLoaded\', async () =&gt; {\n  const canvas = document.getElementById(\'wheel-canvas\');\n  const nameInput = document.getElementById(\'name-input\');\n  const addBtn = document.getElementById(\'add-name\');\n  const namesTextarea = document.getElementById(\'names-textarea\');\n  const spinBtn = document.getElementById(\'spin-btn\');\n  const resultDiv = document.getElementById(\'result\');\n  const themeSelect = document.getElementById(\'theme-select\');\n  const loadSampleBtn = document.getElementById(\'load-sample\');\n  const clearBtn = document.getElementById(\'clear-names\');\n  const importBtn = document.getElementById(\'import-names\');\n  const exportBtn = document.getElementById(\'export-names\');\n\n  const wheel = new Wheel(canvas, { names: [], colors: [\'#ffb3b3\',\'#ffd9b3\',\'#fff3b3\',\'#d9ffb3\'] });\n\n  let themes = [];\n\n  // A small fallback theme set in case fetching themes.json fails.\n  const defaultThemes = [\n    {\n      id: \'fallback\',\n      name: \'Default\',\n      bg: \'#ffffff\',\n      text: \'#222222\',\n      accent: \'#007bff\',\n      colors: [\'#ffb3b3\',\'#ffd9b3\',\'#fff3b3\',\'#d9ffb3\']\n    }\n  ];\n\n  // Helper to populate theme selector\n  function populateThemeSelector(list) {\n    themeSelect.innerHTML = \'\';\n    list.forEach(t =&gt; {\n      const opt = document.createElement(\'option\');\n      opt.value = t.id;\n      opt.textContent = t.name;\n      themeSelect.appendChild(opt);\n    });\n  }\n\n  // Load themes.json (URL injected by Flask)\n  try {\n    const themesUrl = window.THEMES_JSON_URL || \'/static/themes.json\';\n    const resp = await fetch(themesUrl, {cache: \'no-cache\'});\n    if (!resp.ok) throw new Error(\'HTTP \' + resp.status);\n    themes = await resp.json();\n    if (!Array.isArray(themes) || themes.length === 0) throw new Error(\'No themes found\');\n    populateThemeSelector(themes);\n    // apply first theme\n    applyTheme(themes[0]);\n    themeSelect.value = themes[0].id;\n  } catch (err) {\n    console.error(\'Failed to load themes:\', err);\n    // fallback\n    themes = defaultThemes;\n    populateThemeSelector(themes);\n    applyTheme(themes[0]);\n    themeSelect.value = themes[0].id;\n  }\n\n  function applyTheme(theme) {\n    if (!theme) return;\n    document.documentElement.style.setProperty(\'--bg\', theme.bg || \'#fff\');\n    document.documentElement.style.setProperty(\'--text\', theme.text || \'#222\');\n    document.documentElement.style.setProperty(\'--accent\', theme.accent || \'#007bff\');\n    // set panel bg slightly adjusted\n    let panelBg = theme.bg;\n    try {\n      panelBg = lightenOrDarkenColor(theme.bg || \'#fff\', 18);\n    } catch(e) {\n      panelBg = \'#f6f8fa\';\n    }\n    document.documentElement.style.setProperty(\'--panel-bg\', panelBg);\n    wheel.setTheme({ colors: theme.colors || [], text: theme.text || \'#222\' });\n\n    // recolor pointer (DOM element)\n    const pointer = document.getElementById(\'pointer\');\n    if (pointer) pointer.style.color = theme.accent || \'\';\n    // recolor spin button\n    const spin = document.getElementById(\'spin-btn\');\n    if (spin) spin.style.background = theme.accent || \'\';\n  }\n\n  function lightenOrDarkenColor(col, amt) {\n    // accepts #rgb or #rrggbb. amt can be negative to darken.\n    if (typeof col !== \'string\') throw new Error(\'Invalid color\');\n    let colStr = col.trim();\n    if (colStr[0] === \'#\') colStr = colStr.slice(1);\n    if (colStr.length === 3) {\n      colStr = colStr.split(\'\').map(c =&gt; c + c).join(\'\');\n    }\n    if (colStr.length !== 6) throw new Error(\'Invalid hex color\');\n    const num = parseInt(colStr, 16);\n    let r = (num &gt;&gt; 16) &amp; 0xFF;\n    let g = (num &gt;&gt; 8) &amp; 0xFF;\n    let b = num &amp; 0xFF;\n    r = Math.max(0, Math.min(255, r + amt));\n    g = Math.max(0, Math.min(255, g + amt));\n    b = Math.max(0, Math.min(255, b + amt));\n    const newHex = \'#\' + ((1 &lt;&lt; 24) + (r &lt;&lt; 16) + (g &lt;&lt; 8) + b).toString(16).slice(1);\n    return newHex;\n  }\n\n  themeSelect.addEventListener(\'change\', () =&gt; {\n    const id = themeSelect.value;\n    const t = themes.find(x =&gt; x.id === id);\n    if (t) applyTheme(t);\n  });\n\n  function parseNamesFromTextarea() {\n    const lines = namesTextarea.value.split(\'\\n\').map(s =&gt; s.trim()).filter(s =&gt; s.length);\n    return lines;\n  }\n\n  function updateWheelFromTextarea() {\n    const names = parseNamesFromTextarea();\n    wheel.setNames(names);\n  }\n\n  addBtn.addEventListener(\'click\', () =&gt; {\n    const v = nameInput.value.trim();\n    if (!v) return;\n    const cur = parseNamesFromTextarea();\n    cur.push(v);\n    namesTextarea.value = cur.join(\'\\n\');\n    nameInput.value = \'\';\n    updateWheelFromTextarea();\n  });\n\n  nameInput.addEventListener(\'keydown\', (e) =&gt; {\n    if (e.key === \'Enter\') {\n      addBtn.click();\n      e.preventDefault();\n    }\n  });\n\n  namesTextarea.addEventListener(\'input\', () =&gt; {\n    updateWheelFromTextarea();\n  });\n\n  loadSampleBtn.addEventListener(\'click\', () =&gt; {\n    const sample = [\'Alice\',\'Bob\',\'Charlie\',\'Diana\',\'Eva\',\'Frank\',\'George\',\'Helen\',\'Ivy\',\'Jack\'];\n    namesTextarea.value = sample.join(\'\\n\');\n    updateWheelFromTextarea();\n  });\n\n  clearBtn.addEventListener(\'click\', () =&gt; {\n    namesTextarea.value = \'\';\n    updateWheelFromTextarea();\n    resultDiv.classList.add(\'hidden\');\n  });\n\n  importBtn.addEventListener(\'click\', async () =&gt; {\n    // prompt user for a newline separated list (simple)\n    const data = prompt(\'Paste names (one per line):\');\n    if (data === null) return;\n    namesTextarea.value = data.split(\'\\n\').map(s =&gt; s.trim()).filter(s =&gt; s).join(\'\\n\');\n    updateWheelFromTextarea();\n  });\n\n  exportBtn.addEventListener(\'click\', () =&gt; {\n    const names = parseNamesFromTextarea();\n    const blob = new Blob([names.join(\'\\n\')], {type: \'text/plain\'});\n    const url = URL.createObjectURL(blob);\n    const a = document.createElement(\'a\');\n    a.href = url;\n    a.download = \'names.txt\';\n    document.body.appendChild(a);\n    a.click();\n    a.remove();\n    URL.revokeObjectURL(url);\n  });\n\n  spinBtn.addEventListener(\'click\', async () =&gt; {\n    const names = parseNamesFromTextarea();\n    if (names.length === 0) {\n      alert(\'Please add at least one name.\');\n      return;\n    }\n    resultDiv.classList.add(\'hidden\');\n    spinBtn.disabled = true;\n    spinBtn.textContent = \'Spinning...\';\n\n    // Ensure wheel has latest names before selecting index\n    wheel.setNames(names);\n\n    // pick random index\n    const idx = wheel.getRandomIndex();\n    try {\n      const winnerIndex = await wheel.spinToIndex(idx, { duration: 4500 });\n      const winner = names[winnerIndex];\n      resultDiv.textContent = `Winner: ${winner}`;\n      resultDiv.classList.remove(\'hidden\');\n      spinBtn.textContent = \'SPIN\';\n      spinBtn.disabled = false;\n    } catch (err) {\n      console.error(err);\n      spinBtn.textContent = \'SPIN\';\n      spinBtn.disabled = false;\n    }\n  });\n\n  // initial sample and initial canvas sizing\n  namesTextarea.value = \'Alice\\nBob\\nCharlie\\nDiana\\nEva\';\n  updateWheelFromTextarea();\n\n  // Ensure wheel draws crisply at startup and on resize\n  function handleResize() {\n    if (typeof wheel.resize === \'function\') {\n      wheel.resize();\n    } else {\n      // fallback: redraw\n      wheel.draw();\n    }\n  }\n  window.addEventListener(\'resize\', handleResize);\n  // Run a resize after a short delay to ensure layout settled\n  setTimeout(handleResize, 50);\n});\n', 'cycle_index': 3, 'task': '[Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes.]', 'modality': 'website', 'ideas': '', 'language': ' Python', 'codes': 'main.py\npython\n\'\'\'\nFlask application that serves the wheel-of-names web app.\nRun: pip install flask\nThen: python main.py\nAccess: http://127.0.0.1:5000/\n\'\'\'\nfrom flask import Flask, render_template\nimport os\ndef create_app():\n    """\n    Create and configure the Flask application.\n    Serves templates from \'templates\' and static files from \'static\'.\n    """\n    app = Flask(__name__, static_folder=\'static\', template_folder=\'templates\')\n    @app.route(\'/\')\n    def index():\n        """\n        Serve the main page.\n        """\n        return render_template(\'index.html\')\n    return app\nif __name__ == \'__main__\':\n    app = create_app()\n    port = int(os.environ.get(\'PORT\', 5000))\n    # debug=True for development; set to False in production\n    app.run(debug=True, host=\'0.0.0.0\', port=port)\n\n\nindex.html\nhtml\n\'\'\'\nDOCSTRING:\nMain HTML page for the Wheel of Names app.\nContains UI elements:\n- name input and list\n- canvas for wheel\n- theme selector\n- spin / clear / add buttons\nIncludes JS files wheel.js and main.js for behavior.\nAlso injects a dynamically generated URL for themes.json using Flask\'s url_for so the client can reliably fetch the resource even when the app is mounted under a subpath.\n\'\'\'\n&lt;!doctype html&gt;\n&lt;html lang="en"&gt;\n&lt;head&gt;\n  &lt;meta charset="utf-8"&gt;\n  &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;\n  &lt;title&gt;Wheel of Names&lt;/title&gt;\n  &lt;!-- Main stylesheet --&gt;\n  &lt;link rel="stylesheet" href="{{ url_for(\'static\', filename=\'css/styles.css\') }}"&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div class="container"&gt;\n    &lt;header&gt;\n      &lt;h1&gt;Wheel of Names&lt;/h1&gt;\n      &lt;p&gt;Enter names, choose a theme, and spin to pick a random winner.&lt;/p&gt;\n    &lt;/header&gt;\n    &lt;main class="main-grid"&gt;\n      &lt;section class="left-panel"&gt;\n        &lt;div class="controls"&gt;\n          &lt;label for="name-input"&gt;Add a name&lt;/label&gt;\n          &lt;div class="input-row"&gt;\n            &lt;input id="name-input" type="text" placeholder="Enter name and press Add" autocomplete="off"&gt;\n            &lt;button id="add-name" type="button"&gt;Add&lt;/button&gt;\n          &lt;/div&gt;\n          &lt;label for="names-textarea"&gt;Names (one per line)&lt;/label&gt;\n          &lt;textarea id="names-textarea" placeholder="Alice\\nBob\\nCharlie"&gt;&lt;/textarea&gt;\n          &lt;div class="buttons-row"&gt;\n            &lt;button id="load-sample" type="button"&gt;Load Sample&lt;/button&gt;\n            &lt;button id="clear-names" type="button"&gt;Clear&lt;/button&gt;\n            &lt;button id="import-names" type="button"&gt;Import&lt;/button&gt;\n            &lt;button id="export-names" type="button"&gt;Export&lt;/button&gt;\n          &lt;/div&gt;\n          &lt;label for="theme-select"&gt;Theme&lt;/label&gt;\n          &lt;select id="theme-select" aria-label="Theme selector"&gt;&lt;/select&gt;\n          &lt;div class="spin-controls"&gt;\n            &lt;button id="spin-btn" class="spin" type="button"&gt;SPIN&lt;/button&gt;\n            &lt;div id="result" class="result hidden" aria-live="polite"&gt;&lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      &lt;/section&gt;\n      &lt;section class="right-panel"&gt;\n        &lt;div class="wheel-wrapper" id="wheel-wrapper"&gt;\n          &lt;!-- Canvas will be scaled for high-DPI via JS --&gt;\n          &lt;canvas id="wheel-canvas" width="600" height="600" aria-label="Wheel of names"&gt;&lt;/canvas&gt;\n          &lt;div id="pointer" aria-hidden="true"&gt;â–¼&lt;/div&gt;\n        &lt;/div&gt;\n      &lt;/section&gt;\n    &lt;/main&gt;\n    &lt;footer&gt;\n      &lt;small&gt;Built with Flask + Canvas. Themes available.&lt;/small&gt;\n    &lt;/footer&gt;\n  &lt;/div&gt;\n  &lt;!-- Provide the correct URL for themes.json (generated by Flask).\n       This ensures the client can fetch themes.json even when the app is mounted under a prefix. --&gt;\n  &lt;script&gt;\n    window.THEMES_JSON_URL = "{{ url_for(\'static\', filename=\'themes.json\') }}";\n  &lt;/script&gt;\n  &lt;script src="{{ url_for(\'static\', filename=\'js/wheel.js\') }}"&gt;&lt;/script&gt;\n  &lt;script src="{{ url_for(\'static\', filename=\'js/main.js\') }}"&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\n\nthemes.json\njson\n\'\'\'\nDOCSTRING:\nList of themes available for the wheel.\nEach theme contains:\n- id: machine id\n- name: display name\n- bg: page background color\n- text: primary text color\n- accent: accent color used for pointer/button\n- colors: array of segment colors (will be cycled for segments)\n\'\'\'\n[\n  {\n    "id": "classic",\n    "name": "Classic",\n    "bg": "#ffffff",\n    "text": "#222222",\n    "accent": "#007bff",\n    "colors": ["#ffb3b3", "#ffd9b3", "#fff3b3", "#d9ffb3", "#b3ffd9", "#b3e6ff", "#c7b3ff", "#ffb3f2"]\n  },\n  {\n    "id": "dark",\n    "name": "Dark",\n    "bg": "#121212",\n    "text": "#f5f5f5",\n    "accent": "#ff6b6b",\n    "colors": ["#2e2e34", "#3a3a44", "#4a4a56", "#5a5a68", "#6a6a78", "#7a7a88"]\n  },\n  {\n    "id": "pastel",\n    "name": "Pastel",\n    "bg": "#f7f7ff",\n    "text": "#333333",\n    "accent": "#ff8c94",\n    "colors": ["#ffd1dc", "#fce1b4", "#e8ffd1", "#d1fff0", "#d1e7ff", "#e6d1ff"]\n  },\n  {\n    "id": "neon",\n    "name": "Neon",\n    "bg": "#0f0f13",\n    "text": "#eaff00",\n    "accent": "#00fff5",\n    "colors": ["#ff00ff", "#ff8c00", "#00ff00", "#00ffff", "#8c00ff", "#ff0066"]\n  }\n]\n\n\nstyles.css\ncss\n\'\'\'\nDOCSTRING:\nBase CSS for the Wheel of Names app.\nDefines layout, basic theme variables, and responsive styles.\n\'\'\'\n/* Base CSS and theme variables */\n:root{\n  --bg: #ffffff;\n  --text: #222222;\n  --accent: #007bff;\n  --panel-bg: #f6f8fa;\n}\n*{box-sizing:border-box}\nhtml,body{\n  height:100%;\n  margin:0;\n  font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;\n  background: var(--bg);\n  color: var(--text);\n}\n.container{\n  max-width:1100px;\n  margin:24px auto;\n  padding:16px;\n}\nheader{ text-align:center; margin-bottom:8px }\nh1{ margin:6px 0; font-size:28px }\np{ margin:0; color:var(--text); opacity:0.8 }\n.main-grid{\n  display:grid;\n  grid-template-columns: 360px 1fr;\n  gap:20px;\n  align-items:start;\n  margin-top:18px;\n}\n.left-panel{\n  background:var(--panel-bg);\n  padding:14px;\n  border-radius:8px;\n  box-shadow:0 4px 8px rgba(0,0,0,0.04);\n}\n.left-panel label{ display:block; margin-top:8px; font-weight:600; margin-bottom:6px }\n.input-row{ display:flex; gap:8px }\n.input-row input[type="text"]{\n  flex:1;\n  padding:8px 10px;\n  border-radius:6px;\n  border:1px solid #ddd;\n  background:white;\n  color:inherit;\n}\n.input-row button{\n  padding:8px 12px;\n  border-radius:6px;\n  background:var(--accent);\n  color:white;\n  border:none;\n  cursor:pointer;\n}\ntextarea{\n  width:100%;\n  min-height:160px;\n  padding:10px;\n  border-radius:8px;\n  border:1px solid #ddd;\n  resize:vertical;\n  background:white;\n  color:inherit;\n}\n.buttons-row{\n  display:flex;\n  gap:8px;\n  margin-top:8px;\n  flex-wrap:wrap;\n}\n.buttons-row button{\n  padding:8px 10px;\n  border-radius:6px;\n  border:1px solid #ccc;\n  background:transparent;\n  cursor:pointer;\n}\n.spin-controls{\n  display:flex;\n  gap:12px;\n  margin-top:16px;\n  align-items:center;\n}\n.spin{\n  padding:14px 24px;\n  background:var(--accent);\n  color:white;\n  font-weight:700;\n  border:none;\n  border-radius:10px;\n  cursor:pointer;\n  font-size:18px;\n}\n.result{\n  padding:10px 12px;\n  background:rgba(0,0,0,0.06);\n  border-radius:8px;\n}\n.hidden{ display:none }\n.right-panel{\n  display:flex;\n  align-items:center;\n  justify-content:center;\n  min-height:420px;\n}\n.wheel-wrapper{\n  position:relative;\n  width:600px;\n  height:600px;\n  display:flex;\n  align-items:center;\n  justify-content:center;\n  margin:auto;\n}\n#wheel-canvas{\n  border-radius:50%;\n  box-shadow: 0 12px 30px rgba(0,0,0,0.12);\n  background:transparent;\n  /* ensure the canvas element scales responsively in layout; the backing store will be adjusted in JS */\n  width:100%;\n  height:100%;\n  display:block;\n}\n#wheel-wrapper #pointer{\n  position:absolute;\n  top:18px;\n  left:50%;\n  transform:translateX(-50%);\n  font-size:40px;\n  color:var(--accent);\n  text-shadow:0 2px 4px rgba(0,0,0,0.2);\n  pointer-events:none;\n}\nfooter{ text-align:center; margin-top:16px; color:var(--text); opacity:0.7; }\n/* Responsive */\n@media (max-width:960px){\n  .main-grid{ grid-template-columns:1fr; }\n  .wheel-wrapper{ width:420px; height:420px; }\n  #wheel-canvas{ width:420px; height:420px; }\n}\n\n\nwheel.js\njs\n\'\'\'\nDOCSTRING:\nwheel.js\nContains a Wheel class that draws the wheel on a canvas and animates spins.\nKey methods:\n- constructor(canvas, options)\n- setNames(names)\n- setTheme(theme)\n- draw()\n- resize() -&gt; handle high-DPI displays\n- spinToIndex(index) -&gt; Promise resolves with index after animation\n- getRandomIndex()\n\'\'\'\n/* A small utility to requestAnimationFrame safely (browser-provided) */\nclass Wheel {\n  constructor(canvas, options = {}) {\n    this.canvas = canvas;\n    this.ctx = canvas.getContext(\'2d\');\n    this.names = options.names || [];\n    this.colors = options.colors || [\'#ffb3b3\', \'#ffd9b3\', \'#fff3b3\', \'#d9ffb3\', \'#b3ffd9\', \'#b3e6ff\'];\n    this.textColor = options.textColor || \'#222\';\n    this.rotation = 0; // degrees\n    this.font = options.font || \'16px Inter, Arial\';\n    this.onDraw = options.onDraw || function(){};\n    this._animating = false;\n    // Set up high-DPI friendly canvas and metrics\n    this.resize();\n    // Redraw once created\n    this.draw();\n    // Optional: handle container resize via ResizeObserver if available\n    if (window.ResizeObserver) {\n      try {\n        const ro = new ResizeObserver(() =&gt; this.resize());\n        ro.observe(this.canvas.parentElement || this.canvas);\n        this._resizeObserver = ro;\n      } catch (e) {\n        // ignore\n      }\n    } else {\n      window.addEventListener(\'resize\', () =&gt; this.resize());\n    }\n  }\n  resize() {\n    // Make the canvas crisp on high-DPI screens.\n    const dpr = window.devicePixelRatio || 1;\n    const rect = this.canvas.getBoundingClientRect();\n    // Fallback to element width/height attributes if bounding rect is 0\n    const cssWidth = rect.width || this.canvas.clientWidth || this.canvas.width / (dpr || 1);\n    const cssHeight = rect.height || this.canvas.clientHeight || this.canvas.height / (dpr || 1);\n    // Set backing store size\n    this.canvas.width = Math.max(1, Math.round(cssWidth * dpr));\n    this.canvas.height = Math.max(1, Math.round(cssHeight * dpr));\n    // Keep CSS size consistent\n    this.canvas.style.width = cssWidth + \'px\';\n    this.canvas.style.height = cssHeight + \'px\';\n    // Reset transform so we can set a scale for dpr\n    this.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n    // Use CSS pixel coordinates for drawing from now on\n    this.centerX = cssWidth / 2;\n    this.centerY = cssHeight / 2;\n    this.radius = Math.min(cssWidth, cssHeight) / 2 - 10;\n    // Recompute font size based on canvas size to keep labels legible\n    // If user supplied a font (with px), keep it; otherwise set a sensible value.\n    if (!this.font || typeof this.font !== \'string\') {\n      this.font = Math.max(12, Math.round(this.radius * 0.06)) + \'px Inter, Arial\';\n    } else {\n      // keep user\'s font but ensure text scale reasonable\n      // (we don\'t attempt to parse px here; leaving as provided)\n    }\n    this.draw();\n  }\n  setNames(names) {\n    this.names = names.slice();\n    this.draw();\n  }\n  setTheme(theme) {\n    if (!theme) return;\n    if (theme.colors &amp;&amp; theme.colors.length) this.colors = theme.colors.slice();\n    if (theme.text) this.textColor = theme.text;\n    this.draw();\n  }\n  clearCanvas() {\n    // Clear the visible canvas area (CSS pixels)\n    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n  }\n  draw() {\n    this.clearCanvas();\n    const ctx = this.ctx;\n    const n = Math.max(1, this.names.length);\n    const seg = 360 / n;\n    ctx.save();\n    // Translate to center using CSS pixel coordinates\n    ctx.translate(this.centerX, this.centerY);\n    ctx.rotate(this.degToRad(this.rotation));\n    // Draw segments\n    for (let i = 0; i &lt; n; i++) {\n      const start = this.degToRad(i * seg);\n      const end = this.degToRad((i + 1) * seg);\n      ctx.beginPath();\n      ctx.moveTo(0, 0);\n      ctx.arc(0, 0, this.radius, start, end);\n      ctx.closePath();\n      ctx.fillStyle = this.colors[i % this.colors.length];\n      ctx.fill();\n      // stroke\n      ctx.lineWidth = Math.max(1, this.radius * 0.008);\n      ctx.strokeStyle = \'rgba(0,0,0,0.08)\';\n      ctx.stroke();\n      // Draw label\n      ctx.save();\n      const angle = start + (end - start) / 2;\n      ctx.rotate(angle);\n      ctx.translate(this.radius * 0.55, 0);\n      ctx.rotate(Math.PI / 2);\n      ctx.fillStyle = this.textColor;\n      // Set font size relative to radius if not provided precisely\n      ctx.font = this.font;\n      ctx.textAlign = \'center\';\n      ctx.textBaseline = \'middle\';\n      const name = this.names[i] || \'\';\n      this.wrapText(ctx, name, 0, 0, this.radius * 0.35, parseInt(Math.max(12, this.radius * 0.06), 10));\n      ctx.restore();\n    }\n    ctx.restore();\n    // center circle\n    ctx.beginPath();\n    ctx.arc(this.centerX, this.centerY, this.radius * 0.12, 0, Math.PI * 2);\n    // Fill with background-like color; allow theme override by drawing over it in CSS if necessary\n    ctx.fillStyle = \'#ffffff\';\n    ctx.fill();\n    ctx.lineWidth = Math.max(1, this.radius * 0.008);\n    ctx.strokeStyle = \'rgba(0,0,0,0.06)\';\n    ctx.stroke();\n    this.onDraw();\n  }\n  wrapText(ctx, text, x, y, maxWidth, lineHeight) {\n    // A simple wrap for canvas text\n    const words = String(text).split(\' \');\n    let line = \'\';\n    let yOffset = y;\n    for (let n = 0; n &lt; words.length; n++) {\n      const testLine = line + words[n] + \' \';\n      const metrics = ctx.measureText(testLine);\n      const testWidth = metrics.width;\n      if (testWidth &gt; maxWidth &amp;&amp; n &gt; 0) {\n        ctx.fillText(line.trim(), x, yOffset);\n        line = words[n] + \' \';\n        yOffset += lineHeight;\n      } else {\n        line = testLine;\n      }\n    }\n    ctx.fillText(line.trim(), x, yOffset);\n  }\n  degToRad(d) {\n    return d * Math.PI / 180;\n  }\n  radToDeg(r) {\n    return r * 180 / Math.PI;\n  }\n  getRandomIndex() {\n    if (!this.names.length) return 0;\n    return Math.floor(Math.random() * this.names.length);\n  }\n  // Spin such that the segment at `index` lands on the pointer at top.\n  spinToIndex(index, opts = {}) {\n    if (this._animating) return Promise.reject(\'Already animating\');\n    if (!this.names.length) return Promise.reject(\'No names\');\n    const n = this.names.length;\n    const segAngle = 360 / n;\n    // Normalize current rotation to [0, 360)\n    const normalized = ((this.rotation % 360) + 360) % 360;\n    // Center of segment i is at angle: (i * segAngle + segAngle/2)\n    const centerAngle = index * segAngle + segAngle / 2;\n    // We want (centerAngle + rotation) mod 360 = 270 (pointing upward if pointer is at top)\n    let targetRotation = 270 - centerAngle;\n    targetRotation = ((targetRotation % 360) + 360) % 360;\n    const fullSpins = opts.fullSpins !== undefined ? opts.fullSpins : (3 + Math.floor(Math.random() * 3)); // 3-5 spins\n    const endRotation = targetRotation + fullSpins * 360 + (opts.randomOffset || 0);\n    const startRotation = normalized;\n    const delta = endRotation - startRotation;\n    const duration = opts.duration || 5000; // ms\n    const startTime = performance.now();\n    this._animating = true;\n    return new Promise((resolve) =&gt; {\n      const animate = (now) =&gt; {\n        const elapsed = now - startTime;\n        const t = Math.min(1, elapsed / duration);\n        // ease out cubic\n        const eased = 1 - Math.pow(1 - t, 3);\n        const current = startRotation + delta * eased;\n        this.rotation = current;\n        this.draw();\n        if (t &lt; 1) {\n          requestAnimationFrame(animate);\n        } else {\n          this._animating = false;\n          // Normalize rotation to endRotation mod 360\n          this.rotation = ((endRotation % 360) + 360) % 360;\n          this.draw();\n          resolve(index);\n        }\n      };\n      requestAnimationFrame(animate);\n    });\n  }\n}\n\n\nmain.js\njs\n\'\'\'\nDOCSTRING:\nmain.js\nWires UI to the Wheel class:\n- loads themes.json (URL injected by Flask)\n- populates theme selector\n- reads names and updates wheel\n- handles spin logic and result display\nIncludes robust fallback if fetching themes.json fails.\n\'\'\'\n/* DOM wiring and app logic */\ndocument.addEventListener(\'DOMContentLoaded\', async () =&gt; {\n  const canvas = document.getElementById(\'wheel-canvas\');\n  const nameInput = document.getElementById(\'name-input\');\n  const addBtn = document.getElementById(\'add-name\');\n  const namesTextarea = document.getElementById(\'names-textarea\');\n  const spinBtn = document.getElementById(\'spin-btn\');\n  const resultDiv = document.getElementById(\'result\');\n  const themeSelect = document.getElementById(\'theme-select\');\n  const loadSampleBtn = document.getElementById(\'load-sample\');\n  const clearBtn = document.getElementById(\'clear-names\');\n  const importBtn = document.getElementById(\'import-names\');\n  const exportBtn = document.getElementById(\'export-names\');\n  const wheel = new Wheel(canvas, { names: [], colors: [\'#ffb3b3\',\'#ffd9b3\',\'#fff3b3\',\'#d9ffb3\'] });\n  let themes = [];\n  // A small fallback theme set in case fetching themes.json fails.\n  const defaultThemes = [\n    {\n      id: \'fallback\',\n      name: \'Default\',\n      bg: \'#ffffff\',\n      text: \'#222222\',\n      accent: \'#007bff\',\n      colors: [\'#ffb3b3\',\'#ffd9b3\',\'#fff3b3\',\'#d9ffb3\']\n    }\n  ];\n  // Helper to populate theme selector\n  function populateThemeSelector(list) {\n    themeSelect.innerHTML = \'\';\n    list.forEach(t =&gt; {\n      const opt = document.createElement(\'option\');\n      opt.value = t.id;\n      opt.textContent = t.name;\n      themeSelect.appendChild(opt);\n    });\n  }\n  // Load themes.json (URL injected by Flask)\n  try {\n    const themesUrl = window.THEMES_JSON_URL || \'/static/themes.json\';\n    const resp = await fetch(themesUrl, {cache: \'no-cache\'});\n    if (!resp.ok) throw new Error(\'HTTP \' + resp.status);\n    themes = await resp.json();\n    if (!Array.isArray(themes) || themes.length === 0) throw new Error(\'No themes found\');\n    populateThemeSelector(themes);\n    // apply first theme\n    applyTheme(themes[0]);\n    themeSelect.value = themes[0].id;\n  } catch (err) {\n    console.error(\'Failed to load themes:\', err);\n    // fallback\n    themes = defaultThemes;\n    populateThemeSelector(themes);\n    applyTheme(themes[0]);\n    themeSelect.value = themes[0].id;\n  }\n  function applyTheme(theme) {\n    if (!theme) return;\n    document.documentElement.style.setProperty(\'--bg\', theme.bg || \'#fff\');\n    document.documentElement.style.setProperty(\'--text\', theme.text || \'#222\');\n    document.documentElement.style.setProperty(\'--accent\', theme.accent || \'#007bff\');\n    // set panel bg slightly adjusted\n    let panelBg = theme.bg;\n    try {\n      panelBg = lightenOrDarkenColor(theme.bg || \'#fff\', 18);\n    } catch(e) {\n      panelBg = \'#f6f8fa\';\n    }\n    document.documentElement.style.setProperty(\'--panel-bg\', panelBg);\n    wheel.setTheme({ colors: theme.colors || [], text: theme.text || \'#222\' });\n    // recolor pointer (DOM element)\n    const pointer = document.getElementById(\'pointer\');\n    if (pointer) pointer.style.color = theme.accent || \'\';\n    // recolor spin button\n    const spin = document.getElementById(\'spin-btn\');\n    if (spin) spin.style.background = theme.accent || \'\';\n  }\n  function lightenOrDarkenColor(col, amt) {\n    // accepts #rgb or #rrggbb. amt can be negative to darken.\n    if (typeof col !== \'string\') throw new Error(\'Invalid color\');\n    let colStr = col.trim();\n    if (colStr[0] === \'#\') colStr = colStr.slice(1);\n    if (colStr.length === 3) {\n      colStr = colStr.split(\'\').map(c =&gt; c + c).join(\'\');\n    }\n    if (colStr.length !== 6) throw new Error(\'Invalid hex color\');\n    const num = parseInt(colStr, 16);\n    let r = (num &gt;&gt; 16) &amp; 0xFF;\n    let g = (num &gt;&gt; 8) &amp; 0xFF;\n    let b = num &amp; 0xFF;\n    r = Math.max(0, Math.min(255, r + amt));\n    g = Math.max(0, Math.min(255, g + amt));\n    b = Math.max(0, Math.min(255, b + amt));\n    const newHex = \'#\' + ((1 &lt;&lt; 24) + (r &lt;&lt; 16) + (g &lt;&lt; 8) + b).toString(16).slice(1);\n    return newHex;\n  }\n  themeSelect.addEventListener(\'change\', () =&gt; {\n    const id = themeSelect.value;\n    const t = themes.find(x =&gt; x.id === id);\n    if (t) applyTheme(t);\n  });\n  function parseNamesFromTextarea() {\n    const lines = namesTextarea.value.split(\'\\n\').map(s =&gt; s.trim()).filter(s =&gt; s.length);\n    return lines;\n  }\n  function updateWheelFromTextarea() {\n    const names = parseNamesFromTextarea();\n    wheel.setNames(names);\n  }\n  addBtn.addEventListener(\'click\', () =&gt; {\n    const v = nameInput.value.trim();\n    if (!v) return;\n    const cur = parseNamesFromTextarea();\n    cur.push(v);\n    namesTextarea.value = cur.join(\'\\n\');\n    nameInput.value = \'\';\n    updateWheelFromTextarea();\n  });\n  nameInput.addEventListener(\'keydown\', (e) =&gt; {\n    if (e.key === \'Enter\') {\n      addBtn.click();\n      e.preventDefault();\n    }\n  });\n  namesTextarea.addEventListener(\'input\', () =&gt; {\n    updateWheelFromTextarea();\n  });\n  loadSampleBtn.addEventListener(\'click\', () =&gt; {\n    const sample = [\'Alice\',\'Bob\',\'Charlie\',\'Diana\',\'Eva\',\'Frank\',\'George\',\'Helen\',\'Ivy\',\'Jack\'];\n    namesTextarea.value = sample.join(\'\\n\');\n    updateWheelFromTextarea();\n  });\n  clearBtn.addEventListener(\'click\', () =&gt; {\n    namesTextarea.value = \'\';\n    updateWheelFromTextarea();\n    resultDiv.classList.add(\'hidden\');\n  });\n  importBtn.addEventListener(\'click\', async () =&gt; {\n    // prompt user for a newline separated list (simple)\n    const data = prompt(\'Paste names (one per line):\');\n    if (data === null) return;\n    namesTextarea.value = data.split(\'\\n\').map(s =&gt; s.trim()).filter(s =&gt; s).join(\'\\n\');\n    updateWheelFromTextarea();\n  });\n  exportBtn.addEventListener(\'click\', () =&gt; {\n    const names = parseNamesFromTextarea();\n    const blob = new Blob([names.join(\'\\n\')], {type: \'text/plain\'});\n    const url = URL.createObjectURL(blob);\n    const a = document.createElement(\'a\');\n    a.href = url;\n    a.download = \'names.txt\';\n    document.body.appendChild(a);\n    a.click();\n    a.remove();\n    URL.revokeObjectURL(url);\n  });\n  spinBtn.addEventListener(\'click\', async () =&gt; {\n    const names = parseNamesFromTextarea();\n    if (names.length === 0) {\n      alert(\'Please add at least one name.\');\n      return;\n    }\n    resultDiv.classList.add(\'hidden\');\n    spinBtn.disabled = true;\n    spinBtn.textContent = \'Spinning...\';\n    // Ensure wheel has latest names before selecting index\n    wheel.setNames(names);\n    // pick random index\n    const idx = wheel.getRandomIndex();\n    try {\n      const winnerIndex = await wheel.spinToIndex(idx, { duration: 4500 });\n      const winner = names[winnerIndex];\n      resultDiv.textContent = `Winner: ${winner}`;\n      resultDiv.classList.remove(\'hidden\');\n      spinBtn.textContent = \'SPIN\';\n      spinBtn.disabled = false;\n    } catch (err) {\n      console.error(err);\n      spinBtn.textContent = \'SPIN\';\n      spinBtn.disabled = false;\n    }\n  });\n  // initial sample and initial canvas sizing\n  namesTextarea.value = \'Alice\\nBob\\nCharlie\\nDiana\\nEva\';\n  updateWheelFromTextarea();\n  // Ensure wheel draws crisply at startup and on resize\n  function handleResize() {\n    if (typeof wheel.resize === \'function\') {\n      wheel.resize();\n    } else {\n      // fallback: redraw\n      wheel.draw();\n    }\n  }\n  window.addEventListener(\'resize\', handleResize);\n  // Run a resize after a short delay to ensure layout settled\n  setTimeout(handleResize, 50);\n});\n\n\n', 'images': '', 'comments': ' Highest-priority problem: invalid "triple-quote" docstrings present in static asset files (index.html, styles.css, themes.json). These stray triple single-quote blocks will make HTML/CSS/JSON invalid at runtime â€” causing the page/CSS to break and the client-side fetch of themes.json to fail (so themes won\'t load and the wheel won\'t style correctly).\n\nWhy it\'s critical\n- index.html begins with Python-style/triple-quote docstring text â€” HTML will contain unexpected literal \'\'\' and the browser may treat it as text content before the DOCTYPE/HTML, breaking layout and script execution.\n- styles.css begins with triple quotes instead of a CSS comment â€” the CSS parser will choke or ignore rules, breaking all styling.\n- themes.json contains triple-quote docstrings and therefore is not valid JSON â€” fetch() will fail or JSON.parse will throw, falling back to your default theme but also causing confusing console errors.\nBecause themes drive colors, themes.json failure will degrade core functionality (themes cannot be chosen/applied) and the UI may be unusable.\n\nHow to fix (step-by-step)\n1) index.html\n- Remove the Python-style triple-quoted docstring block at the very top.\n- If you want an in-file comment, use an HTML comment: .\nExample: replace the first lines (the \'\'\'DOCSTRING...\'\'\') with either nothing or an HTML comment. At minimum the file should begin with:\n&lt;!doctype html&gt;\n\n  ...\n(Do NOT leave any \'\'\' markers outside of proper HTML comments.)\n\n2) styles.css\n- Remove the leading triple single quotes and wrap any explanatory text in a CSS comment (/ ... /) or remove it entirely.\nExample: change the top from:\n\'\'\'\nDOCSTRING:\nBase CSS ...\n\'\'\'\nto either:\n/ DOCSTRING:\n   Base CSS for the Wheel of Names app.\n/\nor simply remove those lines so the file starts with :root{...}\n\n3) themes.json\n- Remove the triple-quoted docstring wrappers and all non-JSON comment text. JSON must be pure data â€” no comments or stray strings.\nReplace the file exactly with valid JSON, e.g.:\n[\n  {\n    "id": "classic",\n    "name": "Classic",\n    "bg": "#ffffff",\n    "text": "#222222",\n    "accent": "#007bff",\n    "colors": ["#ffb3b3", "#ffd9b3", "#fff3b3", "#d9ffb3", "#b3ffd9", "#b3e6ff", "#c7b3ff", "#ffb3f2"]\n  },\n  {\n    "id": "dark",\n    "name": "Dark",\n    "bg": "#121212",\n    "text": "#f5f5f5",\n    "accent": "#ff6b6b",\n    "colors": ["#2e2e34", "#3a3a44", "#4a4a56", "#5a5a68", "#6a6a78", "#7a7a88"]\n  },\n  {\n    "id": "pastel",\n    "name": "Pastel",\n    "bg": "#f7f7ff",\n    "text": "#333333",\n    "accent": "#ff8c94",\n    "colors": ["#ffd1dc", "#fce1b4", "#e8ffd1", "#d1fff0", "#d1e7ff", "#e6d1ff"]\n  },\n  {\n    "id": "neon",\n    "name": "Neon",\n    "bg": "#0f0f13",\n    "text": "#eaff00",\n    "accent": "#00fff5",\n    "colors": ["#ff00ff", "#ff8c00", "#00ff00", "#00ffff", "#8c00ff", "#ff0066"]\n  }\n]\n\n4) Validate and test\n- Put corrected files in your Flask project:\n  - templates/index.html\n  - static/css/styles.css\n  - static/js/wheel.js and static/js/main.js\n  - static/themes.json\n- Run the app: python main.py\n- Open browser console (F12) and Network tab:\n  - Confirm themes.json returns 200 and is valid JSON.\n  - Confirm no CSS parse errors and that styles apply.\n  - Try selecting themes and spinning the wheel.\n\nOptional further improvements (not blocking)\n- Make canvas drawing crisp on high-DPI screens by handling window.devicePixelRatio (resize canvas drawing buffer accordingly). This improves rendering quality but is not required to make the app operable.\n- Add a small check in main.js to log a clear error if themes.json parsing fails, to help debugging.\n\nSummary\nRemove all Python-style triple-quoted docstrings from static files and replace with appropriate comment styles (HTML/CSS) or remove for JSON. Fixing this will make your frontend valid and allow themes.json to be fetched and parsed, restoring the theme selection and visual behavior required by the user.'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_3_5_TURBO |

[2025-17-09 14:06:43 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Code Reviewer |
| **user_role_name** | Programmer |
| **assistant_role_prompt** | {chatdev_prompt} You are Code Reviewer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. You can help programmers to assess source codes for software troubleshooting, fix bugs to increase code quality and robustness, and offer proposals to improve the source codes. Here is a new customer's task: {task}. To complete the task, you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Programmer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. You can write/create computer software or applications by providing a specific programming language to the computer. You have extensive computing and coding experience in many varieties of programming languages and platforms, such as Python, Java, C, C++, HTML, CSS, JavaScript, XML, SQL, PHP, etc,. Here is a new customer's task: {task}. To complete the task, you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **task_prompt** | [Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes.] |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_3_5_TURBO |
| **background_prompt** | ChatDev is a software company powered by multiple intelligent agents, such as chief executive officer, chief human resources officer, chief product officer, chief technology officer, etc, with a multi-agent organizational structure and the mission of 'changing the digital world through programming'. |

[2025-17-09 14:06:43 INFO] Programmer: **[Start Chat]**

[ChatDev is a software company powered by multiple intelligent agents, such as chief executive officer, chief human resources officer, chief product officer, chief technology officer, etc, with a multi-agent organizational structure and the mission of 'changing the digital world through programming'.
You are Code Reviewer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer.
You can help programmers to assess source codes for software troubleshooting, fix bugs to increase code quality and robustness, and offer proposals to improve the source codes.
Here is a new customer's task: [Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes.].
To complete the task, you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]

According to the new user's task and our software designs: 
Task: "[Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes.]".
Modality: "website".
Programming Language: " Python"
Ideas: ""
Codes:
"main.py
```python
'''
Flask application that serves the wheel-of-names web app.
Run: pip install flask
Then: python main.py
Access: http://127.0.0.1:5000/
'''
from flask import Flask, render_template
import os
def create_app():
    """
    Create and configure the Flask application.
    Serves templates from 'templates' and static files from 'static'.
    """
    app = Flask(__name__, static_folder='static', template_folder='templates')
    @app.route('/')
    def index():
        """
        Serve the main page.
        """
        return render_template('index.html')
    return app
if __name__ == '__main__':
    app = create_app()
    port = int(os.environ.get('PORT', 5000))
    # debug=True for development; set to False in production
    app.run(debug=True, host='0.0.0.0', port=port)
```

index.html
```html
'''
DOCSTRING:
Main HTML page for the Wheel of Names app.
Contains UI elements:
- name input and list
- canvas for wheel
- theme selector
- spin / clear / add buttons
Includes JS files wheel.js and main.js for behavior.
Also injects a dynamically generated URL for themes.json using Flask's url_for so the client can reliably fetch the resource even when the app is mounted under a subpath.
'''
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Wheel of Names</title>
  <!-- Main stylesheet -->
  <link rel="stylesheet" href="{{ url_for('static', filename='css/styles.css') }}">
</head>
<body>
  <div class="container">
    <header>
      <h1>Wheel of Names</h1>
      <p>Enter names, choose a theme, and spin to pick a random winner.</p>
    </header>
    <main class="main-grid">
      <section class="left-panel">
        <div class="controls">
          <label for="name-input">Add a name</label>
          <div class="input-row">
            <input id="name-input" type="text" placeholder="Enter name and press Add" autocomplete="off">
            <button id="add-name" type="button">Add</button>
          </div>
          <label for="names-textarea">Names (one per line)</label>
          <textarea id="names-textarea" placeholder="Alice\nBob\nCharlie"></textarea>
          <div class="buttons-row">
            <button id="load-sample" type="button">Load Sample</button>
            <button id="clear-names" type="button">Clear</button>
            <button id="import-names" type="button">Import</button>
            <button id="export-names" type="button">Export</button>
          </div>
          <label for="theme-select">Theme</label>
          <select id="theme-select" aria-label="Theme selector"></select>
          <div class="spin-controls">
            <button id="spin-btn" class="spin" type="button">SPIN</button>
            <div id="result" class="result hidden" aria-live="polite"></div>
          </div>
        </div>
      </section>
      <section class="right-panel">
        <div class="wheel-wrapper" id="wheel-wrapper">
          <!-- Canvas will be scaled for high-DPI via JS -->
          <canvas id="wheel-canvas" width="600" height="600" aria-label="Wheel of names"></canvas>
          <div id="pointer" aria-hidden="true">â–¼</div>
        </div>
      </section>
    </main>
    <footer>
      <small>Built with Flask + Canvas. Themes available.</small>
    </footer>
  </div>
  <!-- Provide the correct URL for themes.json (generated by Flask).
       This ensures the client can fetch themes.json even when the app is mounted under a prefix. -->
  <script>
    window.THEMES_JSON_URL = "{{ url_for('static', filename='themes.json') }}";
  </script>
  <script src="{{ url_for('static', filename='js/wheel.js') }}"></script>
  <script src="{{ url_for('static', filename='js/main.js') }}"></script>
</body>
</html>
```

themes.json
```json
'''
DOCSTRING:
List of themes available for the wheel.
Each theme contains:
- id: machine id
- name: display name
- bg: page background color
- text: primary text color
- accent: accent color used for pointer/button
- colors: array of segment colors (will be cycled for segments)
'''
[
  {
    "id": "classic",
    "name": "Classic",
    "bg": "#ffffff",
    "text": "#222222",
    "accent": "#007bff",
    "colors": ["#ffb3b3", "#ffd9b3", "#fff3b3", "#d9ffb3", "#b3ffd9", "#b3e6ff", "#c7b3ff", "#ffb3f2"]
  },
  {
    "id": "dark",
    "name": "Dark",
    "bg": "#121212",
    "text": "#f5f5f5",
    "accent": "#ff6b6b",
    "colors": ["#2e2e34", "#3a3a44", "#4a4a56", "#5a5a68", "#6a6a78", "#7a7a88"]
  },
  {
    "id": "pastel",
    "name": "Pastel",
    "bg": "#f7f7ff",
    "text": "#333333",
    "accent": "#ff8c94",
    "colors": ["#ffd1dc", "#fce1b4", "#e8ffd1", "#d1fff0", "#d1e7ff", "#e6d1ff"]
  },
  {
    "id": "neon",
    "name": "Neon",
    "bg": "#0f0f13",
    "text": "#eaff00",
    "accent": "#00fff5",
    "colors": ["#ff00ff", "#ff8c00", "#00ff00", "#00ffff", "#8c00ff", "#ff0066"]
  }
]
```

styles.css
```css
'''
DOCSTRING:
Base CSS for the Wheel of Names app.
Defines layout, basic theme variables, and responsive styles.
'''
/* Base CSS and theme variables */
:root{
  --bg: #ffffff;
  --text: #222222;
  --accent: #007bff;
  --panel-bg: #f6f8fa;
}
*{box-sizing:border-box}
html,body{
  height:100%;
  margin:0;
  font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
  background: var(--bg);
  color: var(--text);
}
.container{
  max-width:1100px;
  margin:24px auto;
  padding:16px;
}
header{ text-align:center; margin-bottom:8px }
h1{ margin:6px 0; font-size:28px }
p{ margin:0; color:var(--text); opacity:0.8 }
.main-grid{
  display:grid;
  grid-template-columns: 360px 1fr;
  gap:20px;
  align-items:start;
  margin-top:18px;
}
.left-panel{
  background:var(--panel-bg);
  padding:14px;
  border-radius:8px;
  box-shadow:0 4px 8px rgba(0,0,0,0.04);
}
.left-panel label{ display:block; margin-top:8px; font-weight:600; margin-bottom:6px }
.input-row{ display:flex; gap:8px }
.input-row input[type="text"]{
  flex:1;
  padding:8px 10px;
  border-radius:6px;
  border:1px solid #ddd;
  background:white;
  color:inherit;
}
.input-row button{
  padding:8px 12px;
  border-radius:6px;
  background:var(--accent);
  color:white;
  border:none;
  cursor:pointer;
}
textarea{
  width:100%;
  min-height:160px;
  padding:10px;
  border-radius:8px;
  border:1px solid #ddd;
  resize:vertical;
  background:white;
  color:inherit;
}
.buttons-row{
  display:flex;
  gap:8px;
  margin-top:8px;
  flex-wrap:wrap;
}
.buttons-row button{
  padding:8px 10px;
  border-radius:6px;
  border:1px solid #ccc;
  background:transparent;
  cursor:pointer;
}
.spin-controls{
  display:flex;
  gap:12px;
  margin-top:16px;
  align-items:center;
}
.spin{
  padding:14px 24px;
  background:var(--accent);
  color:white;
  font-weight:700;
  border:none;
  border-radius:10px;
  cursor:pointer;
  font-size:18px;
}
.result{
  padding:10px 12px;
  background:rgba(0,0,0,0.06);
  border-radius:8px;
}
.hidden{ display:none }
.right-panel{
  display:flex;
  align-items:center;
  justify-content:center;
  min-height:420px;
}
.wheel-wrapper{
  position:relative;
  width:600px;
  height:600px;
  display:flex;
  align-items:center;
  justify-content:center;
  margin:auto;
}
#wheel-canvas{
  border-radius:50%;
  box-shadow: 0 12px 30px rgba(0,0,0,0.12);
  background:transparent;
  /* ensure the canvas element scales responsively in layout; the backing store will be adjusted in JS */
  width:100%;
  height:100%;
  display:block;
}
#wheel-wrapper #pointer{
  position:absolute;
  top:18px;
  left:50%;
  transform:translateX(-50%);
  font-size:40px;
  color:var(--accent);
  text-shadow:0 2px 4px rgba(0,0,0,0.2);
  pointer-events:none;
}
footer{ text-align:center; margin-top:16px; color:var(--text); opacity:0.7; }
/* Responsive */
@media (max-width:960px){
  .main-grid{ grid-template-columns:1fr; }
  .wheel-wrapper{ width:420px; height:420px; }
  #wheel-canvas{ width:420px; height:420px; }
}
```

wheel.js
```js
'''
DOCSTRING:
wheel.js
Contains a Wheel class that draws the wheel on a canvas and animates spins.
Key methods:
- constructor(canvas, options)
- setNames(names)
- setTheme(theme)
- draw()
- resize() -> handle high-DPI displays
- spinToIndex(index) -> Promise resolves with index after animation
- getRandomIndex()
'''
/* A small utility to requestAnimationFrame safely (browser-provided) */
class Wheel {
  constructor(canvas, options = {}) {
    this.canvas = canvas;
    this.ctx = canvas.getContext('2d');
    this.names = options.names || [];
    this.colors = options.colors || ['#ffb3b3', '#ffd9b3', '#fff3b3', '#d9ffb3', '#b3ffd9', '#b3e6ff'];
    this.textColor = options.textColor || '#222';
    this.rotation = 0; // degrees
    this.font = options.font || '16px Inter, Arial';
    this.onDraw = options.onDraw || function(){};
    this._animating = false;
    // Set up high-DPI friendly canvas and metrics
    this.resize();
    // Redraw once created
    this.draw();
    // Optional: handle container resize via ResizeObserver if available
    if (window.ResizeObserver) {
      try {
        const ro = new ResizeObserver(() => this.resize());
        ro.observe(this.canvas.parentElement || this.canvas);
        this._resizeObserver = ro;
      } catch (e) {
        // ignore
      }
    } else {
      window.addEventListener('resize', () => this.resize());
    }
  }
  resize() {
    // Make the canvas crisp on high-DPI screens.
    const dpr = window.devicePixelRatio || 1;
    const rect = this.canvas.getBoundingClientRect();
    // Fallback to element width/height attributes if bounding rect is 0
    const cssWidth = rect.width || this.canvas.clientWidth || this.canvas.width / (dpr || 1);
    const cssHeight = rect.height || this.canvas.clientHeight || this.canvas.height / (dpr || 1);
    // Set backing store size
    this.canvas.width = Math.max(1, Math.round(cssWidth * dpr));
    this.canvas.height = Math.max(1, Math.round(cssHeight * dpr));
    // Keep CSS size consistent
    this.canvas.style.width = cssWidth + 'px';
    this.canvas.style.height = cssHeight + 'px';
    // Reset transform so we can set a scale for dpr
    this.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    // Use CSS pixel coordinates for drawing from now on
    this.centerX = cssWidth / 2;
    this.centerY = cssHeight / 2;
    this.radius = Math.min(cssWidth, cssHeight) / 2 - 10;
    // Recompute font size based on canvas size to keep labels legible
    // If user supplied a font (with px), keep it; otherwise set a sensible value.
    if (!this.font || typeof this.font !== 'string') {
      this.font = Math.max(12, Math.round(this.radius * 0.06)) + 'px Inter, Arial';
    } else {
      // keep user's font but ensure text scale reasonable
      // (we don't attempt to parse px here; leaving as provided)
    }
    this.draw();
  }
  setNames(names) {
    this.names = names.slice();
    this.draw();
  }
  setTheme(theme) {
    if (!theme) return;
    if (theme.colors && theme.colors.length) this.colors = theme.colors.slice();
    if (theme.text) this.textColor = theme.text;
    this.draw();
  }
  clearCanvas() {
    // Clear the visible canvas area (CSS pixels)
    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
  }
  draw() {
    this.clearCanvas();
    const ctx = this.ctx;
    const n = Math.max(1, this.names.length);
    const seg = 360 / n;
    ctx.save();
    // Translate to center using CSS pixel coordinates
    ctx.translate(this.centerX, this.centerY);
    ctx.rotate(this.degToRad(this.rotation));
    // Draw segments
    for (let i = 0; i < n; i++) {
      const start = this.degToRad(i * seg);
      const end = this.degToRad((i + 1) * seg);
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.arc(0, 0, this.radius, start, end);
      ctx.closePath();
      ctx.fillStyle = this.colors[i % this.colors.length];
      ctx.fill();
      // stroke
      ctx.lineWidth = Math.max(1, this.radius * 0.008);
      ctx.strokeStyle = 'rgba(0,0,0,0.08)';
      ctx.stroke();
      // Draw label
      ctx.save();
      const angle = start + (end - start) / 2;
      ctx.rotate(angle);
      ctx.translate(this.radius * 0.55, 0);
      ctx.rotate(Math.PI / 2);
      ctx.fillStyle = this.textColor;
      // Set font size relative to radius if not provided precisely
      ctx.font = this.font;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      const name = this.names[i] || '';
      this.wrapText(ctx, name, 0, 0, this.radius * 0.35, parseInt(Math.max(12, this.radius * 0.06), 10));
      ctx.restore();
    }
    ctx.restore();
    // center circle
    ctx.beginPath();
    ctx.arc(this.centerX, this.centerY, this.radius * 0.12, 0, Math.PI * 2);
    // Fill with background-like color; allow theme override by drawing over it in CSS if necessary
    ctx.fillStyle = '#ffffff';
    ctx.fill();
    ctx.lineWidth = Math.max(1, this.radius * 0.008);
    ctx.strokeStyle = 'rgba(0,0,0,0.06)';
    ctx.stroke();
    this.onDraw();
  }
  wrapText(ctx, text, x, y, maxWidth, lineHeight) {
    // A simple wrap for canvas text
    const words = String(text).split(' ');
    let line = '';
    let yOffset = y;
    for (let n = 0; n < words.length; n++) {
      const testLine = line + words[n] + ' ';
      const metrics = ctx.measureText(testLine);
      const testWidth = metrics.width;
      if (testWidth > maxWidth && n > 0) {
        ctx.fillText(line.trim(), x, yOffset);
        line = words[n] + ' ';
        yOffset += lineHeight;
      } else {
        line = testLine;
      }
    }
    ctx.fillText(line.trim(), x, yOffset);
  }
  degToRad(d) {
    return d * Math.PI / 180;
  }
  radToDeg(r) {
    return r * 180 / Math.PI;
  }
  getRandomIndex() {
    if (!this.names.length) return 0;
    return Math.floor(Math.random() * this.names.length);
  }
  // Spin such that the segment at `index` lands on the pointer at top.
  spinToIndex(index, opts = {}) {
    if (this._animating) return Promise.reject('Already animating');
    if (!this.names.length) return Promise.reject('No names');
    const n = this.names.length;
    const segAngle = 360 / n;
    // Normalize current rotation to [0, 360)
    const normalized = ((this.rotation % 360) + 360) % 360;
    // Center of segment i is at angle: (i * segAngle + segAngle/2)
    const centerAngle = index * segAngle + segAngle / 2;
    // We want (centerAngle + rotation) mod 360 = 270 (pointing upward if pointer is at top)
    let targetRotation = 270 - centerAngle;
    targetRotation = ((targetRotation % 360) + 360) % 360;
    const fullSpins = opts.fullSpins !== undefined ? opts.fullSpins : (3 + Math.floor(Math.random() * 3)); // 3-5 spins
    const endRotation = targetRotation + fullSpins * 360 + (opts.randomOffset || 0);
    const startRotation = normalized;
    const delta = endRotation - startRotation;
    const duration = opts.duration || 5000; // ms
    const startTime = performance.now();
    this._animating = true;
    return new Promise((resolve) => {
      const animate = (now) => {
        const elapsed = now - startTime;
        const t = Math.min(1, elapsed / duration);
        // ease out cubic
        const eased = 1 - Math.pow(1 - t, 3);
        const current = startRotation + delta * eased;
        this.rotation = current;
        this.draw();
        if (t < 1) {
          requestAnimationFrame(animate);
        } else {
          this._animating = false;
          // Normalize rotation to endRotation mod 360
          this.rotation = ((endRotation % 360) + 360) % 360;
          this.draw();
          resolve(index);
        }
      };
      requestAnimationFrame(animate);
    });
  }
}
```

main.js
```js
'''
DOCSTRING:
main.js
Wires UI to the Wheel class:
- loads themes.json (URL injected by Flask)
- populates theme selector
- reads names and updates wheel
- handles spin logic and result display
Includes robust fallback if fetching themes.json fails.
'''
/* DOM wiring and app logic */
document.addEventListener('DOMContentLoaded', async () => {
  const canvas = document.getElementById('wheel-canvas');
  const nameInput = document.getElementById('name-input');
  const addBtn = document.getElementById('add-name');
  const namesTextarea = document.getElementById('names-textarea');
  const spinBtn = document.getElementById('spin-btn');
  const resultDiv = document.getElementById('result');
  const themeSelect = document.getElementById('theme-select');
  const loadSampleBtn = document.getElementById('load-sample');
  const clearBtn = document.getElementById('clear-names');
  const importBtn = document.getElementById('import-names');
  const exportBtn = document.getElementById('export-names');
  const wheel = new Wheel(canvas, { names: [], colors: ['#ffb3b3','#ffd9b3','#fff3b3','#d9ffb3'] });
  let themes = [];
  // A small fallback theme set in case fetching themes.json fails.
  const defaultThemes = [
    {
      id: 'fallback',
      name: 'Default',
      bg: '#ffffff',
      text: '#222222',
      accent: '#007bff',
      colors: ['#ffb3b3','#ffd9b3','#fff3b3','#d9ffb3']
    }
  ];
  // Helper to populate theme selector
  function populateThemeSelector(list) {
    themeSelect.innerHTML = '';
    list.forEach(t => {
      const opt = document.createElement('option');
      opt.value = t.id;
      opt.textContent = t.name;
      themeSelect.appendChild(opt);
    });
  }
  // Load themes.json (URL injected by Flask)
  try {
    const themesUrl = window.THEMES_JSON_URL || '/static/themes.json';
    const resp = await fetch(themesUrl, {cache: 'no-cache'});
    if (!resp.ok) throw new Error('HTTP ' + resp.status);
    themes = await resp.json();
    if (!Array.isArray(themes) || themes.length === 0) throw new Error('No themes found');
    populateThemeSelector(themes);
    // apply first theme
    applyTheme(themes[0]);
    themeSelect.value = themes[0].id;
  } catch (err) {
    console.error('Failed to load themes:', err);
    // fallback
    themes = defaultThemes;
    populateThemeSelector(themes);
    applyTheme(themes[0]);
    themeSelect.value = themes[0].id;
  }
  function applyTheme(theme) {
    if (!theme) return;
    document.documentElement.style.setProperty('--bg', theme.bg || '#fff');
    document.documentElement.style.setProperty('--text', theme.text || '#222');
    document.documentElement.style.setProperty('--accent', theme.accent || '#007bff');
    // set panel bg slightly adjusted
    let panelBg = theme.bg;
    try {
      panelBg = lightenOrDarkenColor(theme.bg || '#fff', 18);
    } catch(e) {
      panelBg = '#f6f8fa';
    }
    document.documentElement.style.setProperty('--panel-bg', panelBg);
    wheel.setTheme({ colors: theme.colors || [], text: theme.text || '#222' });
    // recolor pointer (DOM element)
    const pointer = document.getElementById('pointer');
    if (pointer) pointer.style.color = theme.accent || '';
    // recolor spin button
    const spin = document.getElementById('spin-btn');
    if (spin) spin.style.background = theme.accent || '';
  }
  function lightenOrDarkenColor(col, amt) {
    // accepts #rgb or #rrggbb. amt can be negative to darken.
    if (typeof col !== 'string') throw new Error('Invalid color');
    let colStr = col.trim();
    if (colStr[0] === '#') colStr = colStr.slice(1);
    if (colStr.length === 3) {
      colStr = colStr.split('').map(c => c + c).join('');
    }
    if (colStr.length !== 6) throw new Error('Invalid hex color');
    const num = parseInt(colStr, 16);
    let r = (num >> 16) & 0xFF;
    let g = (num >> 8) & 0xFF;
    let b = num & 0xFF;
    r = Math.max(0, Math.min(255, r + amt));
    g = Math.max(0, Math.min(255, g + amt));
    b = Math.max(0, Math.min(255, b + amt));
    const newHex = '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
    return newHex;
  }
  themeSelect.addEventListener('change', () => {
    const id = themeSelect.value;
    const t = themes.find(x => x.id === id);
    if (t) applyTheme(t);
  });
  function parseNamesFromTextarea() {
    const lines = namesTextarea.value.split('\n').map(s => s.trim()).filter(s => s.length);
    return lines;
  }
  function updateWheelFromTextarea() {
    const names = parseNamesFromTextarea();
    wheel.setNames(names);
  }
  addBtn.addEventListener('click', () => {
    const v = nameInput.value.trim();
    if (!v) return;
    const cur = parseNamesFromTextarea();
    cur.push(v);
    namesTextarea.value = cur.join('\n');
    nameInput.value = '';
    updateWheelFromTextarea();
  });
  nameInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
      addBtn.click();
      e.preventDefault();
    }
  });
  namesTextarea.addEventListener('input', () => {
    updateWheelFromTextarea();
  });
  loadSampleBtn.addEventListener('click', () => {
    const sample = ['Alice','Bob','Charlie','Diana','Eva','Frank','George','Helen','Ivy','Jack'];
    namesTextarea.value = sample.join('\n');
    updateWheelFromTextarea();
  });
  clearBtn.addEventListener('click', () => {
    namesTextarea.value = '';
    updateWheelFromTextarea();
    resultDiv.classList.add('hidden');
  });
  importBtn.addEventListener('click', async () => {
    // prompt user for a newline separated list (simple)
    const data = prompt('Paste names (one per line):');
    if (data === null) return;
    namesTextarea.value = data.split('\n').map(s => s.trim()).filter(s => s).join('\n');
    updateWheelFromTextarea();
  });
  exportBtn.addEventListener('click', () => {
    const names = parseNamesFromTextarea();
    const blob = new Blob([names.join('\n')], {type: 'text/plain'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'names.txt';
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  });
  spinBtn.addEventListener('click', async () => {
    const names = parseNamesFromTextarea();
    if (names.length === 0) {
      alert('Please add at least one name.');
      return;
    }
    resultDiv.classList.add('hidden');
    spinBtn.disabled = true;
    spinBtn.textContent = 'Spinning...';
    // Ensure wheel has latest names before selecting index
    wheel.setNames(names);
    // pick random index
    const idx = wheel.getRandomIndex();
    try {
      const winnerIndex = await wheel.spinToIndex(idx, { duration: 4500 });
      const winner = names[winnerIndex];
      resultDiv.textContent = `Winner: ${winner}`;
      resultDiv.classList.remove('hidden');
      spinBtn.textContent = 'SPIN';
      spinBtn.disabled = false;
    } catch (err) {
      console.error(err);
      spinBtn.textContent = 'SPIN';
      spinBtn.disabled = false;
    }
  });
  // initial sample and initial canvas sizing
  namesTextarea.value = 'Alice\nBob\nCharlie\nDiana\nEva';
  updateWheelFromTextarea();
  // Ensure wheel draws crisply at startup and on resize
  function handleResize() {
    if (typeof wheel.resize === 'function') {
      wheel.resize();
    } else {
      // fallback: redraw
      wheel.draw();
    }
  }
  window.addEventListener('resize', handleResize);
  // Run a resize after a short delay to ensure layout settled
  setTimeout(handleResize, 50);
});
```

"
As the Code Reviewer, to make the software directly operable without further coding, ChatDev have formulated the following regulations:
1) all referenced classes should be imported;
2) all methods should be implemented;
3) all methods need to have the necessary comments;
4) no potential bugs;
5) The entire project conforms to the tasks proposed by the user;
6) most importantly, do not only check the errors in the code, but also the logic of code. Make sure that user can interact with generated software without losing any feature in the requirement;
Now, you should check the above regulations one by one and review the codes in detail, propose one comment with the highest priority about the codes, and give me instructions on how to fix. Tell me your comment with the highest priority and corresponding suggestions on revision. If the codes are perfect and you have no comment on them, return only one line like "<INFO> Finished".

[2025-17-09 14:07:31 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2025-17-09 14:07:31 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 6785
completion_tokens: 2262
total_tokens: 9047
cost: $-1.000000


[2025-17-09 14:07:31 INFO] Code Reviewer: **Code Reviewer<->Programmer on : CodeReviewComment, turn 0**

[ChatDev is a software company powered by multiple intelligent agents, such as chief executive officer, chief human resources officer, chief product officer, chief technology officer, etc, with a multi-agent organizational structure and the mission of 'changing the digital world through programming'.
You are Programmer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer.
You can write/create computer software or applications by providing a specific programming language to the computer. You have extensive computing and coding experience in many varieties of programming languages and platforms, such as Python, Java, C, C++, HTML, CSS, JavaScript, XML, SQL, PHP, etc,.
Here is a new customer's task: [Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes.].
To complete the task, you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]

<PRIORITY> Critical: Remove invalid Python-style triple-quoted "docstrings" from non-Python static files (themes.json, JS, CSS, HTML). These triple-quote blocks break JSON/JS/CSS/HTML parsing and will prevent the site from running.

Why this is highest priority
- themes.json begins with ''' which makes it invalid JSON â€” the client will fail when fetching themes.json and fall back to the default theme (or crash if fetch handling changes).
- wheel.js / main.js / styles.css / index.html each start with Python-style triple-quoted docstrings (''' ... ''') â€” those are not valid JS/CSS/HTML comments and will cause parse errors in browsers. If wheel.js or main.js fail to parse, the wheel UI and spin logic will not work at all.
- Fixing these stray docstrings is required before anything else (logic/UX improvements) can be relied upon.

How to fix (step-by-step)
1) themes.json
- Remove the leading and trailing ''' docstring lines entirely. JSON must contain only valid JSON.
- Ensure the file starts with [ and the JSON objects exactly as shown below.

Replace the current themes.json contents with (no comments, only JSON):
[
  {
    "id": "classic",
    "name": "Classic",
    "bg": "#ffffff",
    "text": "#222222",
    "accent": "#007bff",
    "colors": ["#ffb3b3", "#ffd9b3", "#fff3b3", "#d9ffb3", "#b3ffd9", "#b3e6ff", "#c7b3ff", "#ffb3f2"]
  },
  {
    "id": "dark",
    "name": "Dark",
    "bg": "#121212",
    "text": "#f5f5f5",
    "accent": "#ff6b6b",
    "colors": ["#2e2e34", "#3a3a44", "#4a4a56", "#5a5a68", "#6a6a78", "#7a7a88"]
  },
  {
    "id": "pastel",
    "name": "Pastel",
    "bg": "#f7f7ff",
    "text": "#333333",
    "accent": "#ff8c94",
    "colors": ["#ffd1dc", "#fce1b4", "#e8ffd1", "#d1fff0", "#d1e7ff", "#e6d1ff"]
  },
  {
    "id": "neon",
    "name": "Neon",
    "bg": "#0f0f13",
    "text": "#eaff00",
    "accent": "#00fff5",
    "colors": ["#ff00ff", "#ff8c00", "#00ff00", "#00ffff", "#8c00ff", "#ff0066"]
  }
]

2) wheel.js and main.js (JavaScript files)
- Replace the leading Python-style docstring with a JS comment block (/* ... */) or line comments (// ...).
- Example: change
  '''
  DOCSTRING:
  wheel.js
  ...
  '''
  to
  /* DOCSTRING:
     wheel.js
     Contains a Wheel class that draws the wheel on a canvas and animates spins.
     Key methods: ...
  */

- Make sure there are no stray leading apostrophes nor trailing ones. The rest of the JS code is fine as JS once the invalid string markers are removed.

3) styles.css (CSS file)
- Replace the triple-quoted docstring with a proper CSS comment block:
  /* DOCSTRING: Base CSS for the Wheel of Names app... */
- Remove any leading/trailing ''' lines.

4) index.html (HTML file)
- Remove the top triple-quoted docstring block. If you want inline documentation, use HTML comments:
  <!--
    DOCSTRING:
    Main HTML page for the Wheel of Names app...
  -->
- Make sure the HTML starts with <!doctype html> at the very top (no characters before it).

Why the above exact fixes are necessary
- Browsers will reject/parsing-fail on invalid JS/CSS/JSON; fixing comment syntax ensures files parse and the app can load scripts and themes.
- JSON does not support comments â€” for themes.json there must be no comment tokens at all.

Optional additional suggestions (not blocking but recommended)
- In wheel.js, consider using theme.bg for the center circle fill instead of hard-coded '#ffffff' so the center matches dark themes.
- Add small server-side safety: serve themes.json with correct MIME type (Flask static does this automatically).
- Consider adding simple unit/linters to catch non-JS/CSS/JSON tokens in future.

Verification after fixes
- Start app: pip install flask; python main.py
- Open http://127.0.0.1:5000/ â€” scripts should load without console parse errors, themes load from themes.json, the wheel should draw and spinning should work.

If you want, I can provide the cleaned top-of-file snippets for each file (index.html, wheel.js, main.js, styles.css, themes.json) so you can paste them in directly.

[2025-17-09 14:07:31 INFO] **[Seminar Conclusion]**:

 <PRIORITY> Critical: Remove invalid Python-style triple-quoted "docstrings" from non-Python static files (themes.json, JS, CSS, HTML). These triple-quote blocks break JSON/JS/CSS/HTML parsing and will prevent the site from running.

Why this is highest priority
- themes.json begins with ''' which makes it invalid JSON â€” the client will fail when fetching themes.json and fall back to the default theme (or crash if fetch handling changes).
- wheel.js / main.js / styles.css / index.html each start with Python-style triple-quoted docstrings (''' ... ''') â€” those are not valid JS/CSS/HTML comments and will cause parse errors in browsers. If wheel.js or main.js fail to parse, the wheel UI and spin logic will not work at all.
- Fixing these stray docstrings is required before anything else (logic/UX improvements) can be relied upon.

How to fix (step-by-step)
1) themes.json
- Remove the leading and trailing ''' docstring lines entirely. JSON must contain only valid JSON.
- Ensure the file starts with [ and the JSON objects exactly as shown below.

Replace the current themes.json contents with (no comments, only JSON):
[
  {
    "id": "classic",
    "name": "Classic",
    "bg": "#ffffff",
    "text": "#222222",
    "accent": "#007bff",
    "colors": ["#ffb3b3", "#ffd9b3", "#fff3b3", "#d9ffb3", "#b3ffd9", "#b3e6ff", "#c7b3ff", "#ffb3f2"]
  },
  {
    "id": "dark",
    "name": "Dark",
    "bg": "#121212",
    "text": "#f5f5f5",
    "accent": "#ff6b6b",
    "colors": ["#2e2e34", "#3a3a44", "#4a4a56", "#5a5a68", "#6a6a78", "#7a7a88"]
  },
  {
    "id": "pastel",
    "name": "Pastel",
    "bg": "#f7f7ff",
    "text": "#333333",
    "accent": "#ff8c94",
    "colors": ["#ffd1dc", "#fce1b4", "#e8ffd1", "#d1fff0", "#d1e7ff", "#e6d1ff"]
  },
  {
    "id": "neon",
    "name": "Neon",
    "bg": "#0f0f13",
    "text": "#eaff00",
    "accent": "#00fff5",
    "colors": ["#ff00ff", "#ff8c00", "#00ff00", "#00ffff", "#8c00ff", "#ff0066"]
  }
]

2) wheel.js and main.js (JavaScript files)
- Replace the leading Python-style docstring with a JS comment block (/* ... */) or line comments (// ...).
- Example: change
  '''
  DOCSTRING:
  wheel.js
  ...
  '''
  to
  /* DOCSTRING:
     wheel.js
     Contains a Wheel class that draws the wheel on a canvas and animates spins.
     Key methods: ...
  */

- Make sure there are no stray leading apostrophes nor trailing ones. The rest of the JS code is fine as JS once the invalid string markers are removed.

3) styles.css (CSS file)
- Replace the triple-quoted docstring with a proper CSS comment block:
  /* DOCSTRING: Base CSS for the Wheel of Names app... */
- Remove any leading/trailing ''' lines.

4) index.html (HTML file)
- Remove the top triple-quoted docstring block. If you want inline documentation, use HTML comments:
  <!--
    DOCSTRING:
    Main HTML page for the Wheel of Names app...
  -->
- Make sure the HTML starts with <!doctype html> at the very top (no characters before it).

Why the above exact fixes are necessary
- Browsers will reject/parsing-fail on invalid JS/CSS/JSON; fixing comment syntax ensures files parse and the app can load scripts and themes.
- JSON does not support comments â€” for themes.json there must be no comment tokens at all.

Optional additional suggestions (not blocking but recommended)
- In wheel.js, consider using theme.bg for the center circle fill instead of hard-coded '#ffffff' so the center matches dark themes.
- Add small server-side safety: serve themes.json with correct MIME type (Flask static does this automatically).
- Consider adding simple unit/linters to catch non-JS/CSS/JSON tokens in future.

Verification after fixes
- Start app: pip install flask; python main.py
- Open http://127.0.0.1:5000/ â€” scripts should load without console parse errors, themes load from themes.json, the wheel should draw and spinning should work.

If you want, I can provide the cleaned top-of-file snippets for each file (index.html, wheel.js, main.js, styles.css, themes.json) so you can paste them in directly.

[2025-17-09 14:07:31 INFO] **[Execute Detail]**

execute SimplePhase:[CodeReviewModification] in ComposedPhase:[CodeReview], cycle 3

[2025-17-09 14:07:31 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | [Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes.] |
| **need_reflect** | False |
| **assistant_role_name** | Programmer |
| **user_role_name** | Code Reviewer |
| **phase_prompt** | According to the new user's task, our designed product modality, languages and ideas, our developed first-edition source codes are listed below:  Task: "{task}". Modality: "{modality}". Programming Language: "{language}" Ideas: "{ideas}" Codes:  "{codes}" Comments on Codes: "{comments}" In the software, each file must strictly follow a markdown code block format, where the following tokens must be replaced such that "FILENAME" is the lowercase file name including the file extension, "LANGUAGE" in the programming language, "DOCSTRING" is a string literal specified in source code that is used to document a specific segment of code, and "CODE" is the original code. Format: FILENAME LANGUAGE ''' DOCSTRING ''' CODE As the {assistant_role}, to satisfy the new user's demand and make the software creative, executive and robust, you should modify corresponding codes according to the comments. Then, output the full and complete codes with all bugs fixed based on the comments. Return all codes strictly following the required format. |
| **phase_name** | CodeReviewModification |
| **assistant_role_prompt** | {chatdev_prompt} You are Programmer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. You can write/create computer software or applications by providing a specific programming language to the computer. You have extensive computing and coding experience in many varieties of programming languages and platforms, such as Python, Java, C, C++, HTML, CSS, JavaScript, XML, SQL, PHP, etc,. Here is a new customer's task: {task}. To complete the task, you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Code Reviewer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. You can help programmers to assess source codes for software troubleshooting, fix bugs to increase code quality and robustness, and offer proposals to improve the source codes. Here is a new customer's task: {task}. To complete the task, you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': 'main.py\npython\n\'\'\'\nFlask application that serves the wheel-of-names web app.\nRun: pip install flask\nThen: python main.py\nAccess: http://127.0.0.1:5000/\n\'\'\'\nfrom flask import Flask, render_template\nimport os\n\ndef create_app():\n    """\n    Create and configure the Flask application.\n    Serves templates from \'templates\' and static files from \'static\'.\n    """\n    app = Flask(__name__, static_folder=\'static\', template_folder=\'templates\')\n\n    @app.route(\'/\')\n    def index():\n        """\n        Serve the main page.\n        """\n        return render_template(\'index.html\')\n\n    return app\n\nif __name__ == \'__main__\':\n    app = create_app()\n    port = int(os.environ.get(\'PORT\', 5000))\n    # debug=True for development; set to False in production\n    app.run(debug=True, host=\'0.0.0.0\', port=port)\n\n\nindex.html\nhtml\n\'\'\'\nDOCSTRING:\nMain HTML page for the Wheel of Names app.\nContains UI elements:\n- name input and list\n- canvas for wheel\n- theme selector\n- spin / clear / add buttons\nIncludes JS files wheel.js and main.js for behavior.\nAlso injects a dynamically generated URL for themes.json using Flask\'s url_for so the client can reliably fetch the resource even when the app is mounted under a subpath.\n\'\'\'\n&lt;!doctype html&gt;\n&lt;html lang="en"&gt;\n&lt;head&gt;\n  &lt;meta charset="utf-8"&gt;\n  &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;\n  &lt;title&gt;Wheel of Names&lt;/title&gt;\n  &lt;!-- Main stylesheet --&gt;\n  &lt;link rel="stylesheet" href="{{ url_for(\'static\', filename=\'css/styles.css\') }}"&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div class="container"&gt;\n    &lt;header&gt;\n      &lt;h1&gt;Wheel of Names&lt;/h1&gt;\n      &lt;p&gt;Enter names, choose a theme, and spin to pick a random winner.&lt;/p&gt;\n    &lt;/header&gt;\n    &lt;main class="main-grid"&gt;\n      &lt;section class="left-panel"&gt;\n        &lt;div class="controls"&gt;\n          &lt;label for="name-input"&gt;Add a name&lt;/label&gt;\n          &lt;div class="input-row"&gt;\n            &lt;input id="name-input" type="text" placeholder="Enter name and press Add" autocomplete="off"&gt;\n            &lt;button id="add-name" type="button"&gt;Add&lt;/button&gt;\n          &lt;/div&gt;\n\n          &lt;label for="names-textarea"&gt;Names (one per line)&lt;/label&gt;\n          &lt;textarea id="names-textarea" placeholder="Alice\\nBob\\nCharlie"&gt;&lt;/textarea&gt;\n\n          &lt;div class="buttons-row"&gt;\n            &lt;button id="load-sample" type="button"&gt;Load Sample&lt;/button&gt;\n            &lt;button id="clear-names" type="button"&gt;Clear&lt;/button&gt;\n            &lt;button id="import-names" type="button"&gt;Import&lt;/button&gt;\n            &lt;button id="export-names" type="button"&gt;Export&lt;/button&gt;\n          &lt;/div&gt;\n\n          &lt;label for="theme-select"&gt;Theme&lt;/label&gt;\n          &lt;select id="theme-select" aria-label="Theme selector"&gt;&lt;/select&gt;\n\n          &lt;div class="spin-controls"&gt;\n            &lt;button id="spin-btn" class="spin" type="button"&gt;SPIN&lt;/button&gt;\n            &lt;div id="result" class="result hidden" aria-live="polite"&gt;&lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      &lt;/section&gt;\n\n      &lt;section class="right-panel"&gt;\n        &lt;div class="wheel-wrapper" id="wheel-wrapper"&gt;\n          &lt;!-- Canvas will be scaled for high-DPI via JS --&gt;\n          &lt;canvas id="wheel-canvas" width="600" height="600" aria-label="Wheel of names"&gt;&lt;/canvas&gt;\n          &lt;div id="pointer" aria-hidden="true"&gt;â–¼&lt;/div&gt;\n        &lt;/div&gt;\n      &lt;/section&gt;\n    &lt;/main&gt;\n\n    &lt;footer&gt;\n      &lt;small&gt;Built with Flask + Canvas. Themes available.&lt;/small&gt;\n    &lt;/footer&gt;\n  &lt;/div&gt;\n\n  &lt;!-- Provide the correct URL for themes.json (generated by Flask).\n       This ensures the client can fetch themes.json even when the app is mounted under a prefix. --&gt;\n  &lt;script&gt;\n    window.THEMES_JSON_URL = "{{ url_for(\'static\', filename=\'themes.json\') }}";\n  &lt;/script&gt;\n\n  &lt;script src="{{ url_for(\'static\', filename=\'js/wheel.js\') }}"&gt;&lt;/script&gt;\n  &lt;script src="{{ url_for(\'static\', filename=\'js/main.js\') }}"&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\n\nthemes.json\njson\n\'\'\'\nDOCSTRING:\nList of themes available for the wheel.\nEach theme contains:\n- id: machine id\n- name: display name\n- bg: page background color\n- text: primary text color\n- accent: accent color used for pointer/button\n- colors: array of segment colors (will be cycled for segments)\n\'\'\'\n[\n  {\n    "id": "classic",\n    "name": "Classic",\n    "bg": "#ffffff",\n    "text": "#222222",\n    "accent": "#007bff",\n    "colors": ["#ffb3b3", "#ffd9b3", "#fff3b3", "#d9ffb3", "#b3ffd9", "#b3e6ff", "#c7b3ff", "#ffb3f2"]\n  },\n  {\n    "id": "dark",\n    "name": "Dark",\n    "bg": "#121212",\n    "text": "#f5f5f5",\n    "accent": "#ff6b6b",\n    "colors": ["#2e2e34", "#3a3a44", "#4a4a56", "#5a5a68", "#6a6a78", "#7a7a88"]\n  },\n  {\n    "id": "pastel",\n    "name": "Pastel",\n    "bg": "#f7f7ff",\n    "text": "#333333",\n    "accent": "#ff8c94",\n    "colors": ["#ffd1dc", "#fce1b4", "#e8ffd1", "#d1fff0", "#d1e7ff", "#e6d1ff"]\n  },\n  {\n    "id": "neon",\n    "name": "Neon",\n    "bg": "#0f0f13",\n    "text": "#eaff00",\n    "accent": "#00fff5",\n    "colors": ["#ff00ff", "#ff8c00", "#00ff00", "#00ffff", "#8c00ff", "#ff0066"]\n  }\n]\n\n\nstyles.css\ncss\n\'\'\'\nDOCSTRING:\nBase CSS for the Wheel of Names app.\nDefines layout, basic theme variables, and responsive styles.\n\'\'\'\n/* Base CSS and theme variables */\n:root{\n  --bg: #ffffff;\n  --text: #222222;\n  --accent: #007bff;\n  --panel-bg: #f6f8fa;\n}\n*{box-sizing:border-box}\nhtml,body{\n  height:100%;\n  margin:0;\n  font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;\n  background: var(--bg);\n  color: var(--text);\n}\n.container{\n  max-width:1100px;\n  margin:24px auto;\n  padding:16px;\n}\nheader{ text-align:center; margin-bottom:8px }\nh1{ margin:6px 0; font-size:28px }\np{ margin:0; color:var(--text); opacity:0.8 }\n.main-grid{\n  display:grid;\n  grid-template-columns: 360px 1fr;\n  gap:20px;\n  align-items:start;\n  margin-top:18px;\n}\n.left-panel{\n  background:var(--panel-bg);\n  padding:14px;\n  border-radius:8px;\n  box-shadow:0 4px 8px rgba(0,0,0,0.04);\n}\n.left-panel label{ display:block; margin-top:8px; font-weight:600; margin-bottom:6px }\n.input-row{ display:flex; gap:8px }\n.input-row input[type="text"]{\n  flex:1;\n  padding:8px 10px;\n  border-radius:6px;\n  border:1px solid #ddd;\n  background:white;\n  color:inherit;\n}\n.input-row button{\n  padding:8px 12px;\n  border-radius:6px;\n  background:var(--accent);\n  color:white;\n  border:none;\n  cursor:pointer;\n}\ntextarea{\n  width:100%;\n  min-height:160px;\n  padding:10px;\n  border-radius:8px;\n  border:1px solid #ddd;\n  resize:vertical;\n  background:white;\n  color:inherit;\n}\n.buttons-row{\n  display:flex;\n  gap:8px;\n  margin-top:8px;\n  flex-wrap:wrap;\n}\n.buttons-row button{\n  padding:8px 10px;\n  border-radius:6px;\n  border:1px solid #ccc;\n  background:transparent;\n  cursor:pointer;\n}\n.spin-controls{\n  display:flex;\n  gap:12px;\n  margin-top:16px;\n  align-items:center;\n}\n.spin{\n  padding:14px 24px;\n  background:var(--accent);\n  color:white;\n  font-weight:700;\n  border:none;\n  border-radius:10px;\n  cursor:pointer;\n  font-size:18px;\n}\n.result{\n  padding:10px 12px;\n  background:rgba(0,0,0,0.06);\n  border-radius:8px;\n}\n.hidden{ display:none }\n.right-panel{\n  display:flex;\n  align-items:center;\n  justify-content:center;\n  min-height:420px;\n}\n.wheel-wrapper{\n  position:relative;\n  width:600px;\n  height:600px;\n  display:flex;\n  align-items:center;\n  justify-content:center;\n  margin:auto;\n}\n#wheel-canvas{\n  border-radius:50%;\n  box-shadow: 0 12px 30px rgba(0,0,0,0.12);\n  background:transparent;\n  /* ensure the canvas element scales responsively in layout; the backing store will be adjusted in JS */\n  width:100%;\n  height:100%;\n  display:block;\n}\n#wheel-wrapper #pointer{\n  position:absolute;\n  top:18px;\n  left:50%;\n  transform:translateX(-50%);\n  font-size:40px;\n  color:var(--accent);\n  text-shadow:0 2px 4px rgba(0,0,0,0.2);\n  pointer-events:none;\n}\nfooter{ text-align:center; margin-top:16px; color:var(--text); opacity:0.7; }\n/* Responsive */\n@media (max-width:960px){\n  .main-grid{ grid-template-columns:1fr; }\n  .wheel-wrapper{ width:420px; height:420px; }\n  #wheel-canvas{ width:420px; height:420px; }\n}\n\n\nwheel.js\njavascript\n\'\'\'\nDOCSTRING:\nwheel.js\nContains a Wheel class that draws the wheel on a canvas and animates spins.\nKey methods:\n- constructor(canvas, options)\n- setNames(names)\n- setTheme(theme)\n- draw()\n- resize() -&gt; handle high-DPI displays\n- spinToIndex(index) -&gt; Promise resolves with index after animation\n- getRandomIndex()\n\'\'\'\n/* A small utility to requestAnimationFrame safely (browser-provided) */\nclass Wheel {\n  constructor(canvas, options = {}) {\n    this.canvas = canvas;\n    this.ctx = canvas.getContext(\'2d\');\n    this.names = options.names || [];\n    this.colors = options.colors || [\'#ffb3b3\', \'#ffd9b3\', \'#fff3b3\', \'#d9ffb3\', \'#b3ffd9\', \'#b3e6ff\'];\n    this.textColor = options.textColor || \'#222\';\n    this.rotation = 0; // degrees\n    this.font = options.font || \'16px Inter, Arial\';\n    this.onDraw = options.onDraw || function(){};\n    this._animating = false;\n\n    // Set up high-DPI friendly canvas and metrics\n    this.resize();\n\n    // Redraw once created\n    this.draw();\n\n    // Optional: handle container resize via ResizeObserver if available\n    if (window.ResizeObserver) {\n      try {\n        const ro = new ResizeObserver(() =&gt; this.resize());\n        ro.observe(this.canvas.parentElement || this.canvas);\n        this._resizeObserver = ro;\n      } catch (e) {\n        // ignore\n      }\n    } else {\n      window.addEventListener(\'resize\', () =&gt; this.resize());\n    }\n  }\n\n  resize() {\n    // Make the canvas crisp on high-DPI screens.\n    const dpr = window.devicePixelRatio || 1;\n    const rect = this.canvas.getBoundingClientRect();\n    // Fallback to element width/height attributes if bounding rect is 0\n    const cssWidth = rect.width || this.canvas.clientWidth || this.canvas.width / (dpr || 1);\n    const cssHeight = rect.height || this.canvas.clientHeight || this.canvas.height / (dpr || 1);\n\n    // Set backing store size\n    this.canvas.width = Math.max(1, Math.round(cssWidth * dpr));\n    this.canvas.height = Math.max(1, Math.round(cssHeight * dpr));\n    // Keep CSS size consistent\n    this.canvas.style.width = cssWidth + \'px\';\n    this.canvas.style.height = cssHeight + \'px\';\n    // Reset transform so we can set a scale for dpr\n    this.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n\n    // Use CSS pixel coordinates for drawing from now on\n    this.centerX = cssWidth / 2;\n    this.centerY = cssHeight / 2;\n    this.radius = Math.min(cssWidth, cssHeight) / 2 - 10;\n\n    // Recompute font size based on canvas size to keep labels legible\n    // If user supplied a font (with px), keep it; otherwise set a sensible value.\n    if (!this.font || typeof this.font !== \'string\') {\n      this.font = Math.max(12, Math.round(this.radius * 0.06)) + \'px Inter, Arial\';\n    } else {\n      // keep user\'s font but ensure text scale reasonable\n      // (we don\'t attempt to parse px here; leaving as provided)\n    }\n\n    this.draw();\n  }\n\n  setNames(names) {\n    this.names = names.slice();\n    this.draw();\n  }\n\n  setTheme(theme) {\n    if (!theme) return;\n    if (theme.colors &amp;&amp; theme.colors.length) this.colors = theme.colors.slice();\n    if (theme.text) this.textColor = theme.text;\n    this.draw();\n  }\n\n  clearCanvas() {\n    // Clear the visible canvas area (CSS pixels)\n    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n  }\n\n  draw() {\n    this.clearCanvas();\n    const ctx = this.ctx;\n    const n = Math.max(1, this.names.length);\n    const seg = 360 / n;\n\n    ctx.save();\n    // Translate to center using CSS pixel coordinates\n    ctx.translate(this.centerX, this.centerY);\n    ctx.rotate(this.degToRad(this.rotation));\n\n    // Draw segments\n    for (let i = 0; i &lt; n; i++) {\n      const start = this.degToRad(i * seg);\n      const end = this.degToRad((i + 1) * seg);\n      ctx.beginPath();\n      ctx.moveTo(0, 0);\n      ctx.arc(0, 0, this.radius, start, end);\n      ctx.closePath();\n      ctx.fillStyle = this.colors[i % this.colors.length];\n      ctx.fill();\n\n      // stroke\n      ctx.lineWidth = Math.max(1, this.radius * 0.008);\n      ctx.strokeStyle = \'rgba(0,0,0,0.08)\';\n      ctx.stroke();\n\n      // Draw label\n      ctx.save();\n      const angle = start + (end - start) / 2;\n      ctx.rotate(angle);\n      ctx.translate(this.radius * 0.55, 0);\n      ctx.rotate(Math.PI / 2);\n      ctx.fillStyle = this.textColor;\n      // Set font size relative to radius if not provided precisely\n      ctx.font = this.font;\n      ctx.textAlign = \'center\';\n      ctx.textBaseline = \'middle\';\n      const name = this.names[i] || \'\';\n      this.wrapText(ctx, name, 0, 0, this.radius * 0.35, parseInt(Math.max(12, this.radius * 0.06), 10));\n      ctx.restore();\n    }\n\n    ctx.restore();\n\n    // center circle\n    ctx.beginPath();\n    ctx.arc(this.centerX, this.centerY, this.radius * 0.12, 0, Math.PI * 2);\n    // Fill with background-like color; allow theme override by drawing over it in CSS if necessary\n    ctx.fillStyle = \'#ffffff\';\n    ctx.fill();\n    ctx.lineWidth = Math.max(1, this.radius * 0.008);\n    ctx.strokeStyle = \'rgba(0,0,0,0.06)\';\n    ctx.stroke();\n\n    this.onDraw();\n  }\n\n  wrapText(ctx, text, x, y, maxWidth, lineHeight) {\n    // A simple wrap for canvas text\n    const words = String(text).split(\' \');\n    let line = \'\';\n    let yOffset = y;\n    for (let n = 0; n &lt; words.length; n++) {\n      const testLine = line + words[n] + \' \';\n      const metrics = ctx.measureText(testLine);\n      const testWidth = metrics.width;\n      if (testWidth &gt; maxWidth &amp;&amp; n &gt; 0) {\n        ctx.fillText(line.trim(), x, yOffset);\n        line = words[n] + \' \';\n        yOffset += lineHeight;\n      } else {\n        line = testLine;\n      }\n    }\n    ctx.fillText(line.trim(), x, yOffset);\n  }\n\n  degToRad(d) {\n    return d * Math.PI / 180;\n  }\n\n  radToDeg(r) {\n    return r * 180 / Math.PI;\n  }\n\n  getRandomIndex() {\n    if (!this.names.length) return 0;\n    return Math.floor(Math.random() * this.names.length);\n  }\n\n  // Spin such that the segment at `index` lands on the pointer at top.\n  spinToIndex(index, opts = {}) {\n    if (this._animating) return Promise.reject(\'Already animating\');\n    if (!this.names.length) return Promise.reject(\'No names\');\n    const n = this.names.length;\n    const segAngle = 360 / n;\n\n    // Normalize current rotation to [0, 360)\n    const normalized = ((this.rotation % 360) + 360) % 360;\n\n    // Center of segment i is at angle: (i * segAngle + segAngle/2)\n    const centerAngle = index * segAngle + segAngle / 2;\n\n    // We want (centerAngle + rotation) mod 360 = 270 (pointing upward if pointer is at top)\n    let targetRotation = 270 - centerAngle;\n    targetRotation = ((targetRotation % 360) + 360) % 360;\n\n    const fullSpins = opts.fullSpins !== undefined ? opts.fullSpins : (3 + Math.floor(Math.random() * 3)); // 3-5 spins\n    const endRotation = targetRotation + fullSpins * 360 + (opts.randomOffset || 0);\n\n    const startRotation = normalized;\n    const delta = endRotation - startRotation;\n    const duration = opts.duration || 5000; // ms\n    const startTime = performance.now();\n    this._animating = true;\n\n    return new Promise((resolve) =&gt; {\n      const animate = (now) =&gt; {\n        const elapsed = now - startTime;\n        const t = Math.min(1, elapsed / duration);\n        // ease out cubic\n        const eased = 1 - Math.pow(1 - t, 3);\n        const current = startRotation + delta * eased;\n        this.rotation = current;\n        this.draw();\n        if (t &lt; 1) {\n          requestAnimationFrame(animate);\n        } else {\n          this._animating = false;\n          // Normalize rotation to endRotation mod 360\n          this.rotation = ((endRotation % 360) + 360) % 360;\n          this.draw();\n          resolve(index);\n        }\n      };\n      requestAnimationFrame(animate);\n    });\n  }\n}\n\n\nmain.js\njavascript\n\'\'\'\nDOCSTRING:\nmain.js\nWires UI to the Wheel class:\n- loads themes.json (URL injected by Flask)\n- populates theme selector\n- reads names and updates wheel\n- handles spin logic and result display\nIncludes robust fallback if fetching themes.json fails.\n\'\'\'\n/* DOM wiring and app logic */\ndocument.addEventListener(\'DOMContentLoaded\', async () =&gt; {\n  const canvas = document.getElementById(\'wheel-canvas\');\n  const nameInput = document.getElementById(\'name-input\');\n  const addBtn = document.getElementById(\'add-name\');\n  const namesTextarea = document.getElementById(\'names-textarea\');\n  const spinBtn = document.getElementById(\'spin-btn\');\n  const resultDiv = document.getElementById(\'result\');\n  const themeSelect = document.getElementById(\'theme-select\');\n  const loadSampleBtn = document.getElementById(\'load-sample\');\n  const clearBtn = document.getElementById(\'clear-names\');\n  const importBtn = document.getElementById(\'import-names\');\n  const exportBtn = document.getElementById(\'export-names\');\n\n  const wheel = new Wheel(canvas, { names: [], colors: [\'#ffb3b3\',\'#ffd9b3\',\'#fff3b3\',\'#d9ffb3\'] });\n\n  let themes = [];\n\n  // A small fallback theme set in case fetching themes.json fails.\n  const defaultThemes = [\n    {\n      id: \'fallback\',\n      name: \'Default\',\n      bg: \'#ffffff\',\n      text: \'#222222\',\n      accent: \'#007bff\',\n      colors: [\'#ffb3b3\',\'#ffd9b3\',\'#fff3b3\',\'#d9ffb3\']\n    }\n  ];\n\n  // Helper to populate theme selector\n  function populateThemeSelector(list) {\n    themeSelect.innerHTML = \'\';\n    list.forEach(t =&gt; {\n      const opt = document.createElement(\'option\');\n      opt.value = t.id;\n      opt.textContent = t.name;\n      themeSelect.appendChild(opt);\n    });\n  }\n\n  // Load themes.json (URL injected by Flask)\n  try {\n    const themesUrl = window.THEMES_JSON_URL || \'/static/themes.json\';\n    const resp = await fetch(themesUrl, {cache: \'no-cache\'});\n    if (!resp.ok) throw new Error(\'HTTP \' + resp.status);\n    themes = await resp.json();\n    if (!Array.isArray(themes) || themes.length === 0) throw new Error(\'No themes found\');\n    populateThemeSelector(themes);\n    // apply first theme\n    applyTheme(themes[0]);\n    themeSelect.value = themes[0].id;\n  } catch (err) {\n    console.error(\'Failed to load themes:\', err);\n    // fallback\n    themes = defaultThemes;\n    populateThemeSelector(themes);\n    applyTheme(themes[0]);\n    themeSelect.value = themes[0].id;\n  }\n\n  function applyTheme(theme) {\n    if (!theme) return;\n    document.documentElement.style.setProperty(\'--bg\', theme.bg || \'#fff\');\n    document.documentElement.style.setProperty(\'--text\', theme.text || \'#222\');\n    document.documentElement.style.setProperty(\'--accent\', theme.accent || \'#007bff\');\n    // set panel bg slightly adjusted\n    let panelBg = theme.bg;\n    try {\n      panelBg = lightenOrDarkenColor(theme.bg || \'#fff\', 18);\n    } catch(e) {\n      panelBg = \'#f6f8fa\';\n    }\n    document.documentElement.style.setProperty(\'--panel-bg\', panelBg);\n    wheel.setTheme({ colors: theme.colors || [], text: theme.text || \'#222\' });\n\n    // recolor pointer (DOM element)\n    const pointer = document.getElementById(\'pointer\');\n    if (pointer) pointer.style.color = theme.accent || \'\';\n    // recolor spin button\n    const spin = document.getElementById(\'spin-btn\');\n    if (spin) spin.style.background = theme.accent || \'\';\n  }\n\n  function lightenOrDarkenColor(col, amt) {\n    // accepts #rgb or #rrggbb. amt can be negative to darken.\n    if (typeof col !== \'string\') throw new Error(\'Invalid color\');\n    let colStr = col.trim();\n    if (colStr[0] === \'#\') colStr = colStr.slice(1);\n    if (colStr.length === 3) {\n      colStr = colStr.split(\'\').map(c =&gt; c + c).join(\'\');\n    }\n    if (colStr.length !== 6) throw new Error(\'Invalid hex color\');\n    const num = parseInt(colStr, 16);\n    let r = (num &gt;&gt; 16) &amp; 0xFF;\n    let g = (num &gt;&gt; 8) &amp; 0xFF;\n    let b = num &amp; 0xFF;\n    r = Math.max(0, Math.min(255, r + amt));\n    g = Math.max(0, Math.min(255, g + amt));\n    b = Math.max(0, Math.min(255, b + amt));\n    const newHex = \'#\' + ((1 &lt;&lt; 24) + (r &lt;&lt; 16) + (g &lt;&lt; 8) + b).toString(16).slice(1);\n    return newHex;\n  }\n\n  themeSelect.addEventListener(\'change\', () =&gt; {\n    const id = themeSelect.value;\n    const t = themes.find(x =&gt; x.id === id);\n    if (t) applyTheme(t);\n  });\n\n  function parseNamesFromTextarea() {\n    const lines = namesTextarea.value.split(\'\\n\').map(s =&gt; s.trim()).filter(s =&gt; s.length);\n    return lines;\n  }\n\n  function updateWheelFromTextarea() {\n    const names = parseNamesFromTextarea();\n    wheel.setNames(names);\n  }\n\n  addBtn.addEventListener(\'click\', () =&gt; {\n    const v = nameInput.value.trim();\n    if (!v) return;\n    const cur = parseNamesFromTextarea();\n    cur.push(v);\n    namesTextarea.value = cur.join(\'\\n\');\n    nameInput.value = \'\';\n    updateWheelFromTextarea();\n  });\n\n  nameInput.addEventListener(\'keydown\', (e) =&gt; {\n    if (e.key === \'Enter\') {\n      addBtn.click();\n      e.preventDefault();\n    }\n  });\n\n  namesTextarea.addEventListener(\'input\', () =&gt; {\n    updateWheelFromTextarea();\n  });\n\n  loadSampleBtn.addEventListener(\'click\', () =&gt; {\n    const sample = [\'Alice\',\'Bob\',\'Charlie\',\'Diana\',\'Eva\',\'Frank\',\'George\',\'Helen\',\'Ivy\',\'Jack\'];\n    namesTextarea.value = sample.join(\'\\n\');\n    updateWheelFromTextarea();\n  });\n\n  clearBtn.addEventListener(\'click\', () =&gt; {\n    namesTextarea.value = \'\';\n    updateWheelFromTextarea();\n    resultDiv.classList.add(\'hidden\');\n  });\n\n  importBtn.addEventListener(\'click\', async () =&gt; {\n    // prompt user for a newline separated list (simple)\n    const data = prompt(\'Paste names (one per line):\');\n    if (data === null) return;\n    namesTextarea.value = data.split(\'\\n\').map(s =&gt; s.trim()).filter(s =&gt; s).join(\'\\n\');\n    updateWheelFromTextarea();\n  });\n\n  exportBtn.addEventListener(\'click\', () =&gt; {\n    const names = parseNamesFromTextarea();\n    const blob = new Blob([names.join(\'\\n\')], {type: \'text/plain\'});\n    const url = URL.createObjectURL(blob);\n    const a = document.createElement(\'a\');\n    a.href = url;\n    a.download = \'names.txt\';\n    document.body.appendChild(a);\n    a.click();\n    a.remove();\n    URL.revokeObjectURL(url);\n  });\n\n  spinBtn.addEventListener(\'click\', async () =&gt; {\n    const names = parseNamesFromTextarea();\n    if (names.length === 0) {\n      alert(\'Please add at least one name.\');\n      return;\n    }\n    resultDiv.classList.add(\'hidden\');\n    spinBtn.disabled = true;\n    spinBtn.textContent = \'Spinning...\';\n\n    // Ensure wheel has latest names before selecting index\n    wheel.setNames(names);\n\n    // pick random index\n    const idx = wheel.getRandomIndex();\n    try {\n      const winnerIndex = await wheel.spinToIndex(idx, { duration: 4500 });\n      const winner = names[winnerIndex];\n      resultDiv.textContent = `Winner: ${winner}`;\n      resultDiv.classList.remove(\'hidden\');\n      spinBtn.textContent = \'SPIN\';\n      spinBtn.disabled = false;\n    } catch (err) {\n      console.error(err);\n      spinBtn.textContent = \'SPIN\';\n      spinBtn.disabled = false;\n    }\n  });\n\n  // initial sample and initial canvas sizing\n  namesTextarea.value = \'Alice\\nBob\\nCharlie\\nDiana\\nEva\';\n  updateWheelFromTextarea();\n\n  // Ensure wheel draws crisply at startup and on resize\n  function handleResize() {\n    if (typeof wheel.resize === \'function\') {\n      wheel.resize();\n    } else {\n      // fallback: redraw\n      wheel.draw();\n    }\n  }\n  window.addEventListener(\'resize\', handleResize);\n  // Run a resize after a short delay to ensure layout settled\n  setTimeout(handleResize, 50);\n});\n', 'cycle_index': 3, 'task': '[Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes.]', 'modality': 'website', 'ideas': '', 'language': ' Python', 'codes': 'main.py\npython\n\'\'\'\nFlask application that serves the wheel-of-names web app.\nRun: pip install flask\nThen: python main.py\nAccess: http://127.0.0.1:5000/\n\'\'\'\nfrom flask import Flask, render_template\nimport os\ndef create_app():\n    """\n    Create and configure the Flask application.\n    Serves templates from \'templates\' and static files from \'static\'.\n    """\n    app = Flask(__name__, static_folder=\'static\', template_folder=\'templates\')\n    @app.route(\'/\')\n    def index():\n        """\n        Serve the main page.\n        """\n        return render_template(\'index.html\')\n    return app\nif __name__ == \'__main__\':\n    app = create_app()\n    port = int(os.environ.get(\'PORT\', 5000))\n    # debug=True for development; set to False in production\n    app.run(debug=True, host=\'0.0.0.0\', port=port)\n\n\nindex.html\nhtml\n\'\'\'\nDOCSTRING:\nMain HTML page for the Wheel of Names app.\nContains UI elements:\n- name input and list\n- canvas for wheel\n- theme selector\n- spin / clear / add buttons\nIncludes JS files wheel.js and main.js for behavior.\nAlso injects a dynamically generated URL for themes.json using Flask\'s url_for so the client can reliably fetch the resource even when the app is mounted under a subpath.\n\'\'\'\n&lt;!doctype html&gt;\n&lt;html lang="en"&gt;\n&lt;head&gt;\n  &lt;meta charset="utf-8"&gt;\n  &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;\n  &lt;title&gt;Wheel of Names&lt;/title&gt;\n  &lt;!-- Main stylesheet --&gt;\n  &lt;link rel="stylesheet" href="{{ url_for(\'static\', filename=\'css/styles.css\') }}"&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div class="container"&gt;\n    &lt;header&gt;\n      &lt;h1&gt;Wheel of Names&lt;/h1&gt;\n      &lt;p&gt;Enter names, choose a theme, and spin to pick a random winner.&lt;/p&gt;\n    &lt;/header&gt;\n    &lt;main class="main-grid"&gt;\n      &lt;section class="left-panel"&gt;\n        &lt;div class="controls"&gt;\n          &lt;label for="name-input"&gt;Add a name&lt;/label&gt;\n          &lt;div class="input-row"&gt;\n            &lt;input id="name-input" type="text" placeholder="Enter name and press Add" autocomplete="off"&gt;\n            &lt;button id="add-name" type="button"&gt;Add&lt;/button&gt;\n          &lt;/div&gt;\n          &lt;label for="names-textarea"&gt;Names (one per line)&lt;/label&gt;\n          &lt;textarea id="names-textarea" placeholder="Alice\\nBob\\nCharlie"&gt;&lt;/textarea&gt;\n          &lt;div class="buttons-row"&gt;\n            &lt;button id="load-sample" type="button"&gt;Load Sample&lt;/button&gt;\n            &lt;button id="clear-names" type="button"&gt;Clear&lt;/button&gt;\n            &lt;button id="import-names" type="button"&gt;Import&lt;/button&gt;\n            &lt;button id="export-names" type="button"&gt;Export&lt;/button&gt;\n          &lt;/div&gt;\n          &lt;label for="theme-select"&gt;Theme&lt;/label&gt;\n          &lt;select id="theme-select" aria-label="Theme selector"&gt;&lt;/select&gt;\n          &lt;div class="spin-controls"&gt;\n            &lt;button id="spin-btn" class="spin" type="button"&gt;SPIN&lt;/button&gt;\n            &lt;div id="result" class="result hidden" aria-live="polite"&gt;&lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      &lt;/section&gt;\n      &lt;section class="right-panel"&gt;\n        &lt;div class="wheel-wrapper" id="wheel-wrapper"&gt;\n          &lt;!-- Canvas will be scaled for high-DPI via JS --&gt;\n          &lt;canvas id="wheel-canvas" width="600" height="600" aria-label="Wheel of names"&gt;&lt;/canvas&gt;\n          &lt;div id="pointer" aria-hidden="true"&gt;â–¼&lt;/div&gt;\n        &lt;/div&gt;\n      &lt;/section&gt;\n    &lt;/main&gt;\n    &lt;footer&gt;\n      &lt;small&gt;Built with Flask + Canvas. Themes available.&lt;/small&gt;\n    &lt;/footer&gt;\n  &lt;/div&gt;\n  &lt;!-- Provide the correct URL for themes.json (generated by Flask).\n       This ensures the client can fetch themes.json even when the app is mounted under a prefix. --&gt;\n  &lt;script&gt;\n    window.THEMES_JSON_URL = "{{ url_for(\'static\', filename=\'themes.json\') }}";\n  &lt;/script&gt;\n  &lt;script src="{{ url_for(\'static\', filename=\'js/wheel.js\') }}"&gt;&lt;/script&gt;\n  &lt;script src="{{ url_for(\'static\', filename=\'js/main.js\') }}"&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\n\nthemes.json\njson\n\'\'\'\nDOCSTRING:\nList of themes available for the wheel.\nEach theme contains:\n- id: machine id\n- name: display name\n- bg: page background color\n- text: primary text color\n- accent: accent color used for pointer/button\n- colors: array of segment colors (will be cycled for segments)\n\'\'\'\n[\n  {\n    "id": "classic",\n    "name": "Classic",\n    "bg": "#ffffff",\n    "text": "#222222",\n    "accent": "#007bff",\n    "colors": ["#ffb3b3", "#ffd9b3", "#fff3b3", "#d9ffb3", "#b3ffd9", "#b3e6ff", "#c7b3ff", "#ffb3f2"]\n  },\n  {\n    "id": "dark",\n    "name": "Dark",\n    "bg": "#121212",\n    "text": "#f5f5f5",\n    "accent": "#ff6b6b",\n    "colors": ["#2e2e34", "#3a3a44", "#4a4a56", "#5a5a68", "#6a6a78", "#7a7a88"]\n  },\n  {\n    "id": "pastel",\n    "name": "Pastel",\n    "bg": "#f7f7ff",\n    "text": "#333333",\n    "accent": "#ff8c94",\n    "colors": ["#ffd1dc", "#fce1b4", "#e8ffd1", "#d1fff0", "#d1e7ff", "#e6d1ff"]\n  },\n  {\n    "id": "neon",\n    "name": "Neon",\n    "bg": "#0f0f13",\n    "text": "#eaff00",\n    "accent": "#00fff5",\n    "colors": ["#ff00ff", "#ff8c00", "#00ff00", "#00ffff", "#8c00ff", "#ff0066"]\n  }\n]\n\n\nstyles.css\ncss\n\'\'\'\nDOCSTRING:\nBase CSS for the Wheel of Names app.\nDefines layout, basic theme variables, and responsive styles.\n\'\'\'\n/* Base CSS and theme variables */\n:root{\n  --bg: #ffffff;\n  --text: #222222;\n  --accent: #007bff;\n  --panel-bg: #f6f8fa;\n}\n*{box-sizing:border-box}\nhtml,body{\n  height:100%;\n  margin:0;\n  font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;\n  background: var(--bg);\n  color: var(--text);\n}\n.container{\n  max-width:1100px;\n  margin:24px auto;\n  padding:16px;\n}\nheader{ text-align:center; margin-bottom:8px }\nh1{ margin:6px 0; font-size:28px }\np{ margin:0; color:var(--text); opacity:0.8 }\n.main-grid{\n  display:grid;\n  grid-template-columns: 360px 1fr;\n  gap:20px;\n  align-items:start;\n  margin-top:18px;\n}\n.left-panel{\n  background:var(--panel-bg);\n  padding:14px;\n  border-radius:8px;\n  box-shadow:0 4px 8px rgba(0,0,0,0.04);\n}\n.left-panel label{ display:block; margin-top:8px; font-weight:600; margin-bottom:6px }\n.input-row{ display:flex; gap:8px }\n.input-row input[type="text"]{\n  flex:1;\n  padding:8px 10px;\n  border-radius:6px;\n  border:1px solid #ddd;\n  background:white;\n  color:inherit;\n}\n.input-row button{\n  padding:8px 12px;\n  border-radius:6px;\n  background:var(--accent);\n  color:white;\n  border:none;\n  cursor:pointer;\n}\ntextarea{\n  width:100%;\n  min-height:160px;\n  padding:10px;\n  border-radius:8px;\n  border:1px solid #ddd;\n  resize:vertical;\n  background:white;\n  color:inherit;\n}\n.buttons-row{\n  display:flex;\n  gap:8px;\n  margin-top:8px;\n  flex-wrap:wrap;\n}\n.buttons-row button{\n  padding:8px 10px;\n  border-radius:6px;\n  border:1px solid #ccc;\n  background:transparent;\n  cursor:pointer;\n}\n.spin-controls{\n  display:flex;\n  gap:12px;\n  margin-top:16px;\n  align-items:center;\n}\n.spin{\n  padding:14px 24px;\n  background:var(--accent);\n  color:white;\n  font-weight:700;\n  border:none;\n  border-radius:10px;\n  cursor:pointer;\n  font-size:18px;\n}\n.result{\n  padding:10px 12px;\n  background:rgba(0,0,0,0.06);\n  border-radius:8px;\n}\n.hidden{ display:none }\n.right-panel{\n  display:flex;\n  align-items:center;\n  justify-content:center;\n  min-height:420px;\n}\n.wheel-wrapper{\n  position:relative;\n  width:600px;\n  height:600px;\n  display:flex;\n  align-items:center;\n  justify-content:center;\n  margin:auto;\n}\n#wheel-canvas{\n  border-radius:50%;\n  box-shadow: 0 12px 30px rgba(0,0,0,0.12);\n  background:transparent;\n  /* ensure the canvas element scales responsively in layout; the backing store will be adjusted in JS */\n  width:100%;\n  height:100%;\n  display:block;\n}\n#wheel-wrapper #pointer{\n  position:absolute;\n  top:18px;\n  left:50%;\n  transform:translateX(-50%);\n  font-size:40px;\n  color:var(--accent);\n  text-shadow:0 2px 4px rgba(0,0,0,0.2);\n  pointer-events:none;\n}\nfooter{ text-align:center; margin-top:16px; color:var(--text); opacity:0.7; }\n/* Responsive */\n@media (max-width:960px){\n  .main-grid{ grid-template-columns:1fr; }\n  .wheel-wrapper{ width:420px; height:420px; }\n  #wheel-canvas{ width:420px; height:420px; }\n}\n\n\nwheel.js\njs\n\'\'\'\nDOCSTRING:\nwheel.js\nContains a Wheel class that draws the wheel on a canvas and animates spins.\nKey methods:\n- constructor(canvas, options)\n- setNames(names)\n- setTheme(theme)\n- draw()\n- resize() -&gt; handle high-DPI displays\n- spinToIndex(index) -&gt; Promise resolves with index after animation\n- getRandomIndex()\n\'\'\'\n/* A small utility to requestAnimationFrame safely (browser-provided) */\nclass Wheel {\n  constructor(canvas, options = {}) {\n    this.canvas = canvas;\n    this.ctx = canvas.getContext(\'2d\');\n    this.names = options.names || [];\n    this.colors = options.colors || [\'#ffb3b3\', \'#ffd9b3\', \'#fff3b3\', \'#d9ffb3\', \'#b3ffd9\', \'#b3e6ff\'];\n    this.textColor = options.textColor || \'#222\';\n    this.rotation = 0; // degrees\n    this.font = options.font || \'16px Inter, Arial\';\n    this.onDraw = options.onDraw || function(){};\n    this._animating = false;\n    // Set up high-DPI friendly canvas and metrics\n    this.resize();\n    // Redraw once created\n    this.draw();\n    // Optional: handle container resize via ResizeObserver if available\n    if (window.ResizeObserver) {\n      try {\n        const ro = new ResizeObserver(() =&gt; this.resize());\n        ro.observe(this.canvas.parentElement || this.canvas);\n        this._resizeObserver = ro;\n      } catch (e) {\n        // ignore\n      }\n    } else {\n      window.addEventListener(\'resize\', () =&gt; this.resize());\n    }\n  }\n  resize() {\n    // Make the canvas crisp on high-DPI screens.\n    const dpr = window.devicePixelRatio || 1;\n    const rect = this.canvas.getBoundingClientRect();\n    // Fallback to element width/height attributes if bounding rect is 0\n    const cssWidth = rect.width || this.canvas.clientWidth || this.canvas.width / (dpr || 1);\n    const cssHeight = rect.height || this.canvas.clientHeight || this.canvas.height / (dpr || 1);\n    // Set backing store size\n    this.canvas.width = Math.max(1, Math.round(cssWidth * dpr));\n    this.canvas.height = Math.max(1, Math.round(cssHeight * dpr));\n    // Keep CSS size consistent\n    this.canvas.style.width = cssWidth + \'px\';\n    this.canvas.style.height = cssHeight + \'px\';\n    // Reset transform so we can set a scale for dpr\n    this.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n    // Use CSS pixel coordinates for drawing from now on\n    this.centerX = cssWidth / 2;\n    this.centerY = cssHeight / 2;\n    this.radius = Math.min(cssWidth, cssHeight) / 2 - 10;\n    // Recompute font size based on canvas size to keep labels legible\n    // If user supplied a font (with px), keep it; otherwise set a sensible value.\n    if (!this.font || typeof this.font !== \'string\') {\n      this.font = Math.max(12, Math.round(this.radius * 0.06)) + \'px Inter, Arial\';\n    } else {\n      // keep user\'s font but ensure text scale reasonable\n      // (we don\'t attempt to parse px here; leaving as provided)\n    }\n    this.draw();\n  }\n  setNames(names) {\n    this.names = names.slice();\n    this.draw();\n  }\n  setTheme(theme) {\n    if (!theme) return;\n    if (theme.colors &amp;&amp; theme.colors.length) this.colors = theme.colors.slice();\n    if (theme.text) this.textColor = theme.text;\n    this.draw();\n  }\n  clearCanvas() {\n    // Clear the visible canvas area (CSS pixels)\n    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n  }\n  draw() {\n    this.clearCanvas();\n    const ctx = this.ctx;\n    const n = Math.max(1, this.names.length);\n    const seg = 360 / n;\n    ctx.save();\n    // Translate to center using CSS pixel coordinates\n    ctx.translate(this.centerX, this.centerY);\n    ctx.rotate(this.degToRad(this.rotation));\n    // Draw segments\n    for (let i = 0; i &lt; n; i++) {\n      const start = this.degToRad(i * seg);\n      const end = this.degToRad((i + 1) * seg);\n      ctx.beginPath();\n      ctx.moveTo(0, 0);\n      ctx.arc(0, 0, this.radius, start, end);\n      ctx.closePath();\n      ctx.fillStyle = this.colors[i % this.colors.length];\n      ctx.fill();\n      // stroke\n      ctx.lineWidth = Math.max(1, this.radius * 0.008);\n      ctx.strokeStyle = \'rgba(0,0,0,0.08)\';\n      ctx.stroke();\n      // Draw label\n      ctx.save();\n      const angle = start + (end - start) / 2;\n      ctx.rotate(angle);\n      ctx.translate(this.radius * 0.55, 0);\n      ctx.rotate(Math.PI / 2);\n      ctx.fillStyle = this.textColor;\n      // Set font size relative to radius if not provided precisely\n      ctx.font = this.font;\n      ctx.textAlign = \'center\';\n      ctx.textBaseline = \'middle\';\n      const name = this.names[i] || \'\';\n      this.wrapText(ctx, name, 0, 0, this.radius * 0.35, parseInt(Math.max(12, this.radius * 0.06), 10));\n      ctx.restore();\n    }\n    ctx.restore();\n    // center circle\n    ctx.beginPath();\n    ctx.arc(this.centerX, this.centerY, this.radius * 0.12, 0, Math.PI * 2);\n    // Fill with background-like color; allow theme override by drawing over it in CSS if necessary\n    ctx.fillStyle = \'#ffffff\';\n    ctx.fill();\n    ctx.lineWidth = Math.max(1, this.radius * 0.008);\n    ctx.strokeStyle = \'rgba(0,0,0,0.06)\';\n    ctx.stroke();\n    this.onDraw();\n  }\n  wrapText(ctx, text, x, y, maxWidth, lineHeight) {\n    // A simple wrap for canvas text\n    const words = String(text).split(\' \');\n    let line = \'\';\n    let yOffset = y;\n    for (let n = 0; n &lt; words.length; n++) {\n      const testLine = line + words[n] + \' \';\n      const metrics = ctx.measureText(testLine);\n      const testWidth = metrics.width;\n      if (testWidth &gt; maxWidth &amp;&amp; n &gt; 0) {\n        ctx.fillText(line.trim(), x, yOffset);\n        line = words[n] + \' \';\n        yOffset += lineHeight;\n      } else {\n        line = testLine;\n      }\n    }\n    ctx.fillText(line.trim(), x, yOffset);\n  }\n  degToRad(d) {\n    return d * Math.PI / 180;\n  }\n  radToDeg(r) {\n    return r * 180 / Math.PI;\n  }\n  getRandomIndex() {\n    if (!this.names.length) return 0;\n    return Math.floor(Math.random() * this.names.length);\n  }\n  // Spin such that the segment at `index` lands on the pointer at top.\n  spinToIndex(index, opts = {}) {\n    if (this._animating) return Promise.reject(\'Already animating\');\n    if (!this.names.length) return Promise.reject(\'No names\');\n    const n = this.names.length;\n    const segAngle = 360 / n;\n    // Normalize current rotation to [0, 360)\n    const normalized = ((this.rotation % 360) + 360) % 360;\n    // Center of segment i is at angle: (i * segAngle + segAngle/2)\n    const centerAngle = index * segAngle + segAngle / 2;\n    // We want (centerAngle + rotation) mod 360 = 270 (pointing upward if pointer is at top)\n    let targetRotation = 270 - centerAngle;\n    targetRotation = ((targetRotation % 360) + 360) % 360;\n    const fullSpins = opts.fullSpins !== undefined ? opts.fullSpins : (3 + Math.floor(Math.random() * 3)); // 3-5 spins\n    const endRotation = targetRotation + fullSpins * 360 + (opts.randomOffset || 0);\n    const startRotation = normalized;\n    const delta = endRotation - startRotation;\n    const duration = opts.duration || 5000; // ms\n    const startTime = performance.now();\n    this._animating = true;\n    return new Promise((resolve) =&gt; {\n      const animate = (now) =&gt; {\n        const elapsed = now - startTime;\n        const t = Math.min(1, elapsed / duration);\n        // ease out cubic\n        const eased = 1 - Math.pow(1 - t, 3);\n        const current = startRotation + delta * eased;\n        this.rotation = current;\n        this.draw();\n        if (t &lt; 1) {\n          requestAnimationFrame(animate);\n        } else {\n          this._animating = false;\n          // Normalize rotation to endRotation mod 360\n          this.rotation = ((endRotation % 360) + 360) % 360;\n          this.draw();\n          resolve(index);\n        }\n      };\n      requestAnimationFrame(animate);\n    });\n  }\n}\n\n\nmain.js\njs\n\'\'\'\nDOCSTRING:\nmain.js\nWires UI to the Wheel class:\n- loads themes.json (URL injected by Flask)\n- populates theme selector\n- reads names and updates wheel\n- handles spin logic and result display\nIncludes robust fallback if fetching themes.json fails.\n\'\'\'\n/* DOM wiring and app logic */\ndocument.addEventListener(\'DOMContentLoaded\', async () =&gt; {\n  const canvas = document.getElementById(\'wheel-canvas\');\n  const nameInput = document.getElementById(\'name-input\');\n  const addBtn = document.getElementById(\'add-name\');\n  const namesTextarea = document.getElementById(\'names-textarea\');\n  const spinBtn = document.getElementById(\'spin-btn\');\n  const resultDiv = document.getElementById(\'result\');\n  const themeSelect = document.getElementById(\'theme-select\');\n  const loadSampleBtn = document.getElementById(\'load-sample\');\n  const clearBtn = document.getElementById(\'clear-names\');\n  const importBtn = document.getElementById(\'import-names\');\n  const exportBtn = document.getElementById(\'export-names\');\n  const wheel = new Wheel(canvas, { names: [], colors: [\'#ffb3b3\',\'#ffd9b3\',\'#fff3b3\',\'#d9ffb3\'] });\n  let themes = [];\n  // A small fallback theme set in case fetching themes.json fails.\n  const defaultThemes = [\n    {\n      id: \'fallback\',\n      name: \'Default\',\n      bg: \'#ffffff\',\n      text: \'#222222\',\n      accent: \'#007bff\',\n      colors: [\'#ffb3b3\',\'#ffd9b3\',\'#fff3b3\',\'#d9ffb3\']\n    }\n  ];\n  // Helper to populate theme selector\n  function populateThemeSelector(list) {\n    themeSelect.innerHTML = \'\';\n    list.forEach(t =&gt; {\n      const opt = document.createElement(\'option\');\n      opt.value = t.id;\n      opt.textContent = t.name;\n      themeSelect.appendChild(opt);\n    });\n  }\n  // Load themes.json (URL injected by Flask)\n  try {\n    const themesUrl = window.THEMES_JSON_URL || \'/static/themes.json\';\n    const resp = await fetch(themesUrl, {cache: \'no-cache\'});\n    if (!resp.ok) throw new Error(\'HTTP \' + resp.status);\n    themes = await resp.json();\n    if (!Array.isArray(themes) || themes.length === 0) throw new Error(\'No themes found\');\n    populateThemeSelector(themes);\n    // apply first theme\n    applyTheme(themes[0]);\n    themeSelect.value = themes[0].id;\n  } catch (err) {\n    console.error(\'Failed to load themes:\', err);\n    // fallback\n    themes = defaultThemes;\n    populateThemeSelector(themes);\n    applyTheme(themes[0]);\n    themeSelect.value = themes[0].id;\n  }\n  function applyTheme(theme) {\n    if (!theme) return;\n    document.documentElement.style.setProperty(\'--bg\', theme.bg || \'#fff\');\n    document.documentElement.style.setProperty(\'--text\', theme.text || \'#222\');\n    document.documentElement.style.setProperty(\'--accent\', theme.accent || \'#007bff\');\n    // set panel bg slightly adjusted\n    let panelBg = theme.bg;\n    try {\n      panelBg = lightenOrDarkenColor(theme.bg || \'#fff\', 18);\n    } catch(e) {\n      panelBg = \'#f6f8fa\';\n    }\n    document.documentElement.style.setProperty(\'--panel-bg\', panelBg);\n    wheel.setTheme({ colors: theme.colors || [], text: theme.text || \'#222\' });\n    // recolor pointer (DOM element)\n    const pointer = document.getElementById(\'pointer\');\n    if (pointer) pointer.style.color = theme.accent || \'\';\n    // recolor spin button\n    const spin = document.getElementById(\'spin-btn\');\n    if (spin) spin.style.background = theme.accent || \'\';\n  }\n  function lightenOrDarkenColor(col, amt) {\n    // accepts #rgb or #rrggbb. amt can be negative to darken.\n    if (typeof col !== \'string\') throw new Error(\'Invalid color\');\n    let colStr = col.trim();\n    if (colStr[0] === \'#\') colStr = colStr.slice(1);\n    if (colStr.length === 3) {\n      colStr = colStr.split(\'\').map(c =&gt; c + c).join(\'\');\n    }\n    if (colStr.length !== 6) throw new Error(\'Invalid hex color\');\n    const num = parseInt(colStr, 16);\n    let r = (num &gt;&gt; 16) &amp; 0xFF;\n    let g = (num &gt;&gt; 8) &amp; 0xFF;\n    let b = num &amp; 0xFF;\n    r = Math.max(0, Math.min(255, r + amt));\n    g = Math.max(0, Math.min(255, g + amt));\n    b = Math.max(0, Math.min(255, b + amt));\n    const newHex = \'#\' + ((1 &lt;&lt; 24) + (r &lt;&lt; 16) + (g &lt;&lt; 8) + b).toString(16).slice(1);\n    return newHex;\n  }\n  themeSelect.addEventListener(\'change\', () =&gt; {\n    const id = themeSelect.value;\n    const t = themes.find(x =&gt; x.id === id);\n    if (t) applyTheme(t);\n  });\n  function parseNamesFromTextarea() {\n    const lines = namesTextarea.value.split(\'\\n\').map(s =&gt; s.trim()).filter(s =&gt; s.length);\n    return lines;\n  }\n  function updateWheelFromTextarea() {\n    const names = parseNamesFromTextarea();\n    wheel.setNames(names);\n  }\n  addBtn.addEventListener(\'click\', () =&gt; {\n    const v = nameInput.value.trim();\n    if (!v) return;\n    const cur = parseNamesFromTextarea();\n    cur.push(v);\n    namesTextarea.value = cur.join(\'\\n\');\n    nameInput.value = \'\';\n    updateWheelFromTextarea();\n  });\n  nameInput.addEventListener(\'keydown\', (e) =&gt; {\n    if (e.key === \'Enter\') {\n      addBtn.click();\n      e.preventDefault();\n    }\n  });\n  namesTextarea.addEventListener(\'input\', () =&gt; {\n    updateWheelFromTextarea();\n  });\n  loadSampleBtn.addEventListener(\'click\', () =&gt; {\n    const sample = [\'Alice\',\'Bob\',\'Charlie\',\'Diana\',\'Eva\',\'Frank\',\'George\',\'Helen\',\'Ivy\',\'Jack\'];\n    namesTextarea.value = sample.join(\'\\n\');\n    updateWheelFromTextarea();\n  });\n  clearBtn.addEventListener(\'click\', () =&gt; {\n    namesTextarea.value = \'\';\n    updateWheelFromTextarea();\n    resultDiv.classList.add(\'hidden\');\n  });\n  importBtn.addEventListener(\'click\', async () =&gt; {\n    // prompt user for a newline separated list (simple)\n    const data = prompt(\'Paste names (one per line):\');\n    if (data === null) return;\n    namesTextarea.value = data.split(\'\\n\').map(s =&gt; s.trim()).filter(s =&gt; s).join(\'\\n\');\n    updateWheelFromTextarea();\n  });\n  exportBtn.addEventListener(\'click\', () =&gt; {\n    const names = parseNamesFromTextarea();\n    const blob = new Blob([names.join(\'\\n\')], {type: \'text/plain\'});\n    const url = URL.createObjectURL(blob);\n    const a = document.createElement(\'a\');\n    a.href = url;\n    a.download = \'names.txt\';\n    document.body.appendChild(a);\n    a.click();\n    a.remove();\n    URL.revokeObjectURL(url);\n  });\n  spinBtn.addEventListener(\'click\', async () =&gt; {\n    const names = parseNamesFromTextarea();\n    if (names.length === 0) {\n      alert(\'Please add at least one name.\');\n      return;\n    }\n    resultDiv.classList.add(\'hidden\');\n    spinBtn.disabled = true;\n    spinBtn.textContent = \'Spinning...\';\n    // Ensure wheel has latest names before selecting index\n    wheel.setNames(names);\n    // pick random index\n    const idx = wheel.getRandomIndex();\n    try {\n      const winnerIndex = await wheel.spinToIndex(idx, { duration: 4500 });\n      const winner = names[winnerIndex];\n      resultDiv.textContent = `Winner: ${winner}`;\n      resultDiv.classList.remove(\'hidden\');\n      spinBtn.textContent = \'SPIN\';\n      spinBtn.disabled = false;\n    } catch (err) {\n      console.error(err);\n      spinBtn.textContent = \'SPIN\';\n      spinBtn.disabled = false;\n    }\n  });\n  // initial sample and initial canvas sizing\n  namesTextarea.value = \'Alice\\nBob\\nCharlie\\nDiana\\nEva\';\n  updateWheelFromTextarea();\n  // Ensure wheel draws crisply at startup and on resize\n  function handleResize() {\n    if (typeof wheel.resize === \'function\') {\n      wheel.resize();\n    } else {\n      // fallback: redraw\n      wheel.draw();\n    }\n  }\n  window.addEventListener(\'resize\', handleResize);\n  // Run a resize after a short delay to ensure layout settled\n  setTimeout(handleResize, 50);\n});\n\n\n', 'images': '', 'comments': ' Critical: Remove invalid Python-style triple-quoted "docstrings" from non-Python static files (themes.json, JS, CSS, HTML). These triple-quote blocks break JSON/JS/CSS/HTML parsing and will prevent the site from running.\n\nWhy this is highest priority\n- themes.json begins with \'\'\' which makes it invalid JSON â€” the client will fail when fetching themes.json and fall back to the default theme (or crash if fetch handling changes).\n- wheel.js / main.js / styles.css / index.html each start with Python-style triple-quoted docstrings (\'\'\' ... \'\'\') â€” those are not valid JS/CSS/HTML comments and will cause parse errors in browsers. If wheel.js or main.js fail to parse, the wheel UI and spin logic will not work at all.\n- Fixing these stray docstrings is required before anything else (logic/UX improvements) can be relied upon.\n\nHow to fix (step-by-step)\n1) themes.json\n- Remove the leading and trailing \'\'\' docstring lines entirely. JSON must contain only valid JSON.\n- Ensure the file starts with [ and the JSON objects exactly as shown below.\n\nReplace the current themes.json contents with (no comments, only JSON):\n[\n  {\n    "id": "classic",\n    "name": "Classic",\n    "bg": "#ffffff",\n    "text": "#222222",\n    "accent": "#007bff",\n    "colors": ["#ffb3b3", "#ffd9b3", "#fff3b3", "#d9ffb3", "#b3ffd9", "#b3e6ff", "#c7b3ff", "#ffb3f2"]\n  },\n  {\n    "id": "dark",\n    "name": "Dark",\n    "bg": "#121212",\n    "text": "#f5f5f5",\n    "accent": "#ff6b6b",\n    "colors": ["#2e2e34", "#3a3a44", "#4a4a56", "#5a5a68", "#6a6a78", "#7a7a88"]\n  },\n  {\n    "id": "pastel",\n    "name": "Pastel",\n    "bg": "#f7f7ff",\n    "text": "#333333",\n    "accent": "#ff8c94",\n    "colors": ["#ffd1dc", "#fce1b4", "#e8ffd1", "#d1fff0", "#d1e7ff", "#e6d1ff"]\n  },\n  {\n    "id": "neon",\n    "name": "Neon",\n    "bg": "#0f0f13",\n    "text": "#eaff00",\n    "accent": "#00fff5",\n    "colors": ["#ff00ff", "#ff8c00", "#00ff00", "#00ffff", "#8c00ff", "#ff0066"]\n  }\n]\n\n2) wheel.js and main.js (JavaScript files)\n- Replace the leading Python-style docstring with a JS comment block (/ ... /) or line comments (// ...).\n- Example: change\n  \'\'\'\n  DOCSTRING:\n  wheel.js\n  ...\n  \'\'\'\n  to\n  / DOCSTRING:\n     wheel.js\n     Contains a Wheel class that draws the wheel on a canvas and animates spins.\n     Key methods: ...\n  /\n\n- Make sure there are no stray leading apostrophes nor trailing ones. The rest of the JS code is fine as JS once the invalid string markers are removed.\n\n3) styles.css (CSS file)\n- Replace the triple-quoted docstring with a proper CSS comment block:\n  / DOCSTRING: Base CSS for the Wheel of Names app... /\n- Remove any leading/trailing \'\'\' lines.\n\n4) index.html (HTML file)\n- Remove the top triple-quoted docstring block. If you want inline documentation, use HTML comments:\n  \n- Make sure the HTML starts with &lt;!doctype html&gt; at the very top (no characters before it).\n\nWhy the above exact fixes are necessary\n- Browsers will reject/parsing-fail on invalid JS/CSS/JSON; fixing comment syntax ensures files parse and the app can load scripts and themes.\n- JSON does not support comments â€” for themes.json there must be no comment tokens at all.\n\nOptional additional suggestions (not blocking but recommended)\n- In wheel.js, consider using theme.bg for the center circle fill instead of hard-coded \'#ffffff\' so the center matches dark themes.\n- Add small server-side safety: serve themes.json with correct MIME type (Flask static does this automatically).\n- Consider adding simple unit/linters to catch non-JS/CSS/JSON tokens in future.\n\nVerification after fixes\n- Start app: pip install flask; python main.py\n- Open http://127.0.0.1:5000/ â€” scripts should load without console parse errors, themes load from themes.json, the wheel should draw and spinning should work.\n\nIf you want, I can provide the cleaned top-of-file snippets for each file (index.html, wheel.js, main.js, styles.css, themes.json) so you can paste them in directly.'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_3_5_TURBO |

[2025-17-09 14:07:31 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Programmer |
| **user_role_name** | Code Reviewer |
| **assistant_role_prompt** | {chatdev_prompt} You are Programmer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. You can write/create computer software or applications by providing a specific programming language to the computer. You have extensive computing and coding experience in many varieties of programming languages and platforms, such as Python, Java, C, C++, HTML, CSS, JavaScript, XML, SQL, PHP, etc,. Here is a new customer's task: {task}. To complete the task, you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Code Reviewer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. You can help programmers to assess source codes for software troubleshooting, fix bugs to increase code quality and robustness, and offer proposals to improve the source codes. Here is a new customer's task: {task}. To complete the task, you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **task_prompt** | [Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes.] |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_3_5_TURBO |
| **background_prompt** | ChatDev is a software company powered by multiple intelligent agents, such as chief executive officer, chief human resources officer, chief product officer, chief technology officer, etc, with a multi-agent organizational structure and the mission of 'changing the digital world through programming'. |

[2025-17-09 14:07:31 INFO] Code Reviewer: **[Start Chat]**

[ChatDev is a software company powered by multiple intelligent agents, such as chief executive officer, chief human resources officer, chief product officer, chief technology officer, etc, with a multi-agent organizational structure and the mission of 'changing the digital world through programming'.
You are Programmer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer.
You can write/create computer software or applications by providing a specific programming language to the computer. You have extensive computing and coding experience in many varieties of programming languages and platforms, such as Python, Java, C, C++, HTML, CSS, JavaScript, XML, SQL, PHP, etc,.
Here is a new customer's task: [Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes.].
To complete the task, you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]

According to the new user's task, our designed product modality, languages and ideas, our developed first-edition source codes are listed below: 
Task: "[Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes.]".
Modality: "website".
Programming Language: " Python"
Ideas: ""
Codes: 
"main.py
```python
'''
Flask application that serves the wheel-of-names web app.
Run: pip install flask
Then: python main.py
Access: http://127.0.0.1:5000/
'''
from flask import Flask, render_template
import os
def create_app():
    """
    Create and configure the Flask application.
    Serves templates from 'templates' and static files from 'static'.
    """
    app = Flask(__name__, static_folder='static', template_folder='templates')
    @app.route('/')
    def index():
        """
        Serve the main page.
        """
        return render_template('index.html')
    return app
if __name__ == '__main__':
    app = create_app()
    port = int(os.environ.get('PORT', 5000))
    # debug=True for development; set to False in production
    app.run(debug=True, host='0.0.0.0', port=port)
```

index.html
```html
'''
DOCSTRING:
Main HTML page for the Wheel of Names app.
Contains UI elements:
- name input and list
- canvas for wheel
- theme selector
- spin / clear / add buttons
Includes JS files wheel.js and main.js for behavior.
Also injects a dynamically generated URL for themes.json using Flask's url_for so the client can reliably fetch the resource even when the app is mounted under a subpath.
'''
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Wheel of Names</title>
  <!-- Main stylesheet -->
  <link rel="stylesheet" href="{{ url_for('static', filename='css/styles.css') }}">
</head>
<body>
  <div class="container">
    <header>
      <h1>Wheel of Names</h1>
      <p>Enter names, choose a theme, and spin to pick a random winner.</p>
    </header>
    <main class="main-grid">
      <section class="left-panel">
        <div class="controls">
          <label for="name-input">Add a name</label>
          <div class="input-row">
            <input id="name-input" type="text" placeholder="Enter name and press Add" autocomplete="off">
            <button id="add-name" type="button">Add</button>
          </div>
          <label for="names-textarea">Names (one per line)</label>
          <textarea id="names-textarea" placeholder="Alice\nBob\nCharlie"></textarea>
          <div class="buttons-row">
            <button id="load-sample" type="button">Load Sample</button>
            <button id="clear-names" type="button">Clear</button>
            <button id="import-names" type="button">Import</button>
            <button id="export-names" type="button">Export</button>
          </div>
          <label for="theme-select">Theme</label>
          <select id="theme-select" aria-label="Theme selector"></select>
          <div class="spin-controls">
            <button id="spin-btn" class="spin" type="button">SPIN</button>
            <div id="result" class="result hidden" aria-live="polite"></div>
          </div>
        </div>
      </section>
      <section class="right-panel">
        <div class="wheel-wrapper" id="wheel-wrapper">
          <!-- Canvas will be scaled for high-DPI via JS -->
          <canvas id="wheel-canvas" width="600" height="600" aria-label="Wheel of names"></canvas>
          <div id="pointer" aria-hidden="true">â–¼</div>
        </div>
      </section>
    </main>
    <footer>
      <small>Built with Flask + Canvas. Themes available.</small>
    </footer>
  </div>
  <!-- Provide the correct URL for themes.json (generated by Flask).
       This ensures the client can fetch themes.json even when the app is mounted under a prefix. -->
  <script>
    window.THEMES_JSON_URL = "{{ url_for('static', filename='themes.json') }}";
  </script>
  <script src="{{ url_for('static', filename='js/wheel.js') }}"></script>
  <script src="{{ url_for('static', filename='js/main.js') }}"></script>
</body>
</html>
```

themes.json
```json
'''
DOCSTRING:
List of themes available for the wheel.
Each theme contains:
- id: machine id
- name: display name
- bg: page background color
- text: primary text color
- accent: accent color used for pointer/button
- colors: array of segment colors (will be cycled for segments)
'''
[
  {
    "id": "classic",
    "name": "Classic",
    "bg": "#ffffff",
    "text": "#222222",
    "accent": "#007bff",
    "colors": ["#ffb3b3", "#ffd9b3", "#fff3b3", "#d9ffb3", "#b3ffd9", "#b3e6ff", "#c7b3ff", "#ffb3f2"]
  },
  {
    "id": "dark",
    "name": "Dark",
    "bg": "#121212",
    "text": "#f5f5f5",
    "accent": "#ff6b6b",
    "colors": ["#2e2e34", "#3a3a44", "#4a4a56", "#5a5a68", "#6a6a78", "#7a7a88"]
  },
  {
    "id": "pastel",
    "name": "Pastel",
    "bg": "#f7f7ff",
    "text": "#333333",
    "accent": "#ff8c94",
    "colors": ["#ffd1dc", "#fce1b4", "#e8ffd1", "#d1fff0", "#d1e7ff", "#e6d1ff"]
  },
  {
    "id": "neon",
    "name": "Neon",
    "bg": "#0f0f13",
    "text": "#eaff00",
    "accent": "#00fff5",
    "colors": ["#ff00ff", "#ff8c00", "#00ff00", "#00ffff", "#8c00ff", "#ff0066"]
  }
]
```

styles.css
```css
'''
DOCSTRING:
Base CSS for the Wheel of Names app.
Defines layout, basic theme variables, and responsive styles.
'''
/* Base CSS and theme variables */
:root{
  --bg: #ffffff;
  --text: #222222;
  --accent: #007bff;
  --panel-bg: #f6f8fa;
}
*{box-sizing:border-box}
html,body{
  height:100%;
  margin:0;
  font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
  background: var(--bg);
  color: var(--text);
}
.container{
  max-width:1100px;
  margin:24px auto;
  padding:16px;
}
header{ text-align:center; margin-bottom:8px }
h1{ margin:6px 0; font-size:28px }
p{ margin:0; color:var(--text); opacity:0.8 }
.main-grid{
  display:grid;
  grid-template-columns: 360px 1fr;
  gap:20px;
  align-items:start;
  margin-top:18px;
}
.left-panel{
  background:var(--panel-bg);
  padding:14px;
  border-radius:8px;
  box-shadow:0 4px 8px rgba(0,0,0,0.04);
}
.left-panel label{ display:block; margin-top:8px; font-weight:600; margin-bottom:6px }
.input-row{ display:flex; gap:8px }
.input-row input[type="text"]{
  flex:1;
  padding:8px 10px;
  border-radius:6px;
  border:1px solid #ddd;
  background:white;
  color:inherit;
}
.input-row button{
  padding:8px 12px;
  border-radius:6px;
  background:var(--accent);
  color:white;
  border:none;
  cursor:pointer;
}
textarea{
  width:100%;
  min-height:160px;
  padding:10px;
  border-radius:8px;
  border:1px solid #ddd;
  resize:vertical;
  background:white;
  color:inherit;
}
.buttons-row{
  display:flex;
  gap:8px;
  margin-top:8px;
  flex-wrap:wrap;
}
.buttons-row button{
  padding:8px 10px;
  border-radius:6px;
  border:1px solid #ccc;
  background:transparent;
  cursor:pointer;
}
.spin-controls{
  display:flex;
  gap:12px;
  margin-top:16px;
  align-items:center;
}
.spin{
  padding:14px 24px;
  background:var(--accent);
  color:white;
  font-weight:700;
  border:none;
  border-radius:10px;
  cursor:pointer;
  font-size:18px;
}
.result{
  padding:10px 12px;
  background:rgba(0,0,0,0.06);
  border-radius:8px;
}
.hidden{ display:none }
.right-panel{
  display:flex;
  align-items:center;
  justify-content:center;
  min-height:420px;
}
.wheel-wrapper{
  position:relative;
  width:600px;
  height:600px;
  display:flex;
  align-items:center;
  justify-content:center;
  margin:auto;
}
#wheel-canvas{
  border-radius:50%;
  box-shadow: 0 12px 30px rgba(0,0,0,0.12);
  background:transparent;
  /* ensure the canvas element scales responsively in layout; the backing store will be adjusted in JS */
  width:100%;
  height:100%;
  display:block;
}
#wheel-wrapper #pointer{
  position:absolute;
  top:18px;
  left:50%;
  transform:translateX(-50%);
  font-size:40px;
  color:var(--accent);
  text-shadow:0 2px 4px rgba(0,0,0,0.2);
  pointer-events:none;
}
footer{ text-align:center; margin-top:16px; color:var(--text); opacity:0.7; }
/* Responsive */
@media (max-width:960px){
  .main-grid{ grid-template-columns:1fr; }
  .wheel-wrapper{ width:420px; height:420px; }
  #wheel-canvas{ width:420px; height:420px; }
}
```

wheel.js
```js
'''
DOCSTRING:
wheel.js
Contains a Wheel class that draws the wheel on a canvas and animates spins.
Key methods:
- constructor(canvas, options)
- setNames(names)
- setTheme(theme)
- draw()
- resize() -> handle high-DPI displays
- spinToIndex(index) -> Promise resolves with index after animation
- getRandomIndex()
'''
/* A small utility to requestAnimationFrame safely (browser-provided) */
class Wheel {
  constructor(canvas, options = {}) {
    this.canvas = canvas;
    this.ctx = canvas.getContext('2d');
    this.names = options.names || [];
    this.colors = options.colors || ['#ffb3b3', '#ffd9b3', '#fff3b3', '#d9ffb3', '#b3ffd9', '#b3e6ff'];
    this.textColor = options.textColor || '#222';
    this.rotation = 0; // degrees
    this.font = options.font || '16px Inter, Arial';
    this.onDraw = options.onDraw || function(){};
    this._animating = false;
    // Set up high-DPI friendly canvas and metrics
    this.resize();
    // Redraw once created
    this.draw();
    // Optional: handle container resize via ResizeObserver if available
    if (window.ResizeObserver) {
      try {
        const ro = new ResizeObserver(() => this.resize());
        ro.observe(this.canvas.parentElement || this.canvas);
        this._resizeObserver = ro;
      } catch (e) {
        // ignore
      }
    } else {
      window.addEventListener('resize', () => this.resize());
    }
  }
  resize() {
    // Make the canvas crisp on high-DPI screens.
    const dpr = window.devicePixelRatio || 1;
    const rect = this.canvas.getBoundingClientRect();
    // Fallback to element width/height attributes if bounding rect is 0
    const cssWidth = rect.width || this.canvas.clientWidth || this.canvas.width / (dpr || 1);
    const cssHeight = rect.height || this.canvas.clientHeight || this.canvas.height / (dpr || 1);
    // Set backing store size
    this.canvas.width = Math.max(1, Math.round(cssWidth * dpr));
    this.canvas.height = Math.max(1, Math.round(cssHeight * dpr));
    // Keep CSS size consistent
    this.canvas.style.width = cssWidth + 'px';
    this.canvas.style.height = cssHeight + 'px';
    // Reset transform so we can set a scale for dpr
    this.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    // Use CSS pixel coordinates for drawing from now on
    this.centerX = cssWidth / 2;
    this.centerY = cssHeight / 2;
    this.radius = Math.min(cssWidth, cssHeight) / 2 - 10;
    // Recompute font size based on canvas size to keep labels legible
    // If user supplied a font (with px), keep it; otherwise set a sensible value.
    if (!this.font || typeof this.font !== 'string') {
      this.font = Math.max(12, Math.round(this.radius * 0.06)) + 'px Inter, Arial';
    } else {
      // keep user's font but ensure text scale reasonable
      // (we don't attempt to parse px here; leaving as provided)
    }
    this.draw();
  }
  setNames(names) {
    this.names = names.slice();
    this.draw();
  }
  setTheme(theme) {
    if (!theme) return;
    if (theme.colors && theme.colors.length) this.colors = theme.colors.slice();
    if (theme.text) this.textColor = theme.text;
    this.draw();
  }
  clearCanvas() {
    // Clear the visible canvas area (CSS pixels)
    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
  }
  draw() {
    this.clearCanvas();
    const ctx = this.ctx;
    const n = Math.max(1, this.names.length);
    const seg = 360 / n;
    ctx.save();
    // Translate to center using CSS pixel coordinates
    ctx.translate(this.centerX, this.centerY);
    ctx.rotate(this.degToRad(this.rotation));
    // Draw segments
    for (let i = 0; i < n; i++) {
      const start = this.degToRad(i * seg);
      const end = this.degToRad((i + 1) * seg);
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.arc(0, 0, this.radius, start, end);
      ctx.closePath();
      ctx.fillStyle = this.colors[i % this.colors.length];
      ctx.fill();
      // stroke
      ctx.lineWidth = Math.max(1, this.radius * 0.008);
      ctx.strokeStyle = 'rgba(0,0,0,0.08)';
      ctx.stroke();
      // Draw label
      ctx.save();
      const angle = start + (end - start) / 2;
      ctx.rotate(angle);
      ctx.translate(this.radius * 0.55, 0);
      ctx.rotate(Math.PI / 2);
      ctx.fillStyle = this.textColor;
      // Set font size relative to radius if not provided precisely
      ctx.font = this.font;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      const name = this.names[i] || '';
      this.wrapText(ctx, name, 0, 0, this.radius * 0.35, parseInt(Math.max(12, this.radius * 0.06), 10));
      ctx.restore();
    }
    ctx.restore();
    // center circle
    ctx.beginPath();
    ctx.arc(this.centerX, this.centerY, this.radius * 0.12, 0, Math.PI * 2);
    // Fill with background-like color; allow theme override by drawing over it in CSS if necessary
    ctx.fillStyle = '#ffffff';
    ctx.fill();
    ctx.lineWidth = Math.max(1, this.radius * 0.008);
    ctx.strokeStyle = 'rgba(0,0,0,0.06)';
    ctx.stroke();
    this.onDraw();
  }
  wrapText(ctx, text, x, y, maxWidth, lineHeight) {
    // A simple wrap for canvas text
    const words = String(text).split(' ');
    let line = '';
    let yOffset = y;
    for (let n = 0; n < words.length; n++) {
      const testLine = line + words[n] + ' ';
      const metrics = ctx.measureText(testLine);
      const testWidth = metrics.width;
      if (testWidth > maxWidth && n > 0) {
        ctx.fillText(line.trim(), x, yOffset);
        line = words[n] + ' ';
        yOffset += lineHeight;
      } else {
        line = testLine;
      }
    }
    ctx.fillText(line.trim(), x, yOffset);
  }
  degToRad(d) {
    return d * Math.PI / 180;
  }
  radToDeg(r) {
    return r * 180 / Math.PI;
  }
  getRandomIndex() {
    if (!this.names.length) return 0;
    return Math.floor(Math.random() * this.names.length);
  }
  // Spin such that the segment at `index` lands on the pointer at top.
  spinToIndex(index, opts = {}) {
    if (this._animating) return Promise.reject('Already animating');
    if (!this.names.length) return Promise.reject('No names');
    const n = this.names.length;
    const segAngle = 360 / n;
    // Normalize current rotation to [0, 360)
    const normalized = ((this.rotation % 360) + 360) % 360;
    // Center of segment i is at angle: (i * segAngle + segAngle/2)
    const centerAngle = index * segAngle + segAngle / 2;
    // We want (centerAngle + rotation) mod 360 = 270 (pointing upward if pointer is at top)
    let targetRotation = 270 - centerAngle;
    targetRotation = ((targetRotation % 360) + 360) % 360;
    const fullSpins = opts.fullSpins !== undefined ? opts.fullSpins : (3 + Math.floor(Math.random() * 3)); // 3-5 spins
    const endRotation = targetRotation + fullSpins * 360 + (opts.randomOffset || 0);
    const startRotation = normalized;
    const delta = endRotation - startRotation;
    const duration = opts.duration || 5000; // ms
    const startTime = performance.now();
    this._animating = true;
    return new Promise((resolve) => {
      const animate = (now) => {
        const elapsed = now - startTime;
        const t = Math.min(1, elapsed / duration);
        // ease out cubic
        const eased = 1 - Math.pow(1 - t, 3);
        const current = startRotation + delta * eased;
        this.rotation = current;
        this.draw();
        if (t < 1) {
          requestAnimationFrame(animate);
        } else {
          this._animating = false;
          // Normalize rotation to endRotation mod 360
          this.rotation = ((endRotation % 360) + 360) % 360;
          this.draw();
          resolve(index);
        }
      };
      requestAnimationFrame(animate);
    });
  }
}
```

main.js
```js
'''
DOCSTRING:
main.js
Wires UI to the Wheel class:
- loads themes.json (URL injected by Flask)
- populates theme selector
- reads names and updates wheel
- handles spin logic and result display
Includes robust fallback if fetching themes.json fails.
'''
/* DOM wiring and app logic */
document.addEventListener('DOMContentLoaded', async () => {
  const canvas = document.getElementById('wheel-canvas');
  const nameInput = document.getElementById('name-input');
  const addBtn = document.getElementById('add-name');
  const namesTextarea = document.getElementById('names-textarea');
  const spinBtn = document.getElementById('spin-btn');
  const resultDiv = document.getElementById('result');
  const themeSelect = document.getElementById('theme-select');
  const loadSampleBtn = document.getElementById('load-sample');
  const clearBtn = document.getElementById('clear-names');
  const importBtn = document.getElementById('import-names');
  const exportBtn = document.getElementById('export-names');
  const wheel = new Wheel(canvas, { names: [], colors: ['#ffb3b3','#ffd9b3','#fff3b3','#d9ffb3'] });
  let themes = [];
  // A small fallback theme set in case fetching themes.json fails.
  const defaultThemes = [
    {
      id: 'fallback',
      name: 'Default',
      bg: '#ffffff',
      text: '#222222',
      accent: '#007bff',
      colors: ['#ffb3b3','#ffd9b3','#fff3b3','#d9ffb3']
    }
  ];
  // Helper to populate theme selector
  function populateThemeSelector(list) {
    themeSelect.innerHTML = '';
    list.forEach(t => {
      const opt = document.createElement('option');
      opt.value = t.id;
      opt.textContent = t.name;
      themeSelect.appendChild(opt);
    });
  }
  // Load themes.json (URL injected by Flask)
  try {
    const themesUrl = window.THEMES_JSON_URL || '/static/themes.json';
    const resp = await fetch(themesUrl, {cache: 'no-cache'});
    if (!resp.ok) throw new Error('HTTP ' + resp.status);
    themes = await resp.json();
    if (!Array.isArray(themes) || themes.length === 0) throw new Error('No themes found');
    populateThemeSelector(themes);
    // apply first theme
    applyTheme(themes[0]);
    themeSelect.value = themes[0].id;
  } catch (err) {
    console.error('Failed to load themes:', err);
    // fallback
    themes = defaultThemes;
    populateThemeSelector(themes);
    applyTheme(themes[0]);
    themeSelect.value = themes[0].id;
  }
  function applyTheme(theme) {
    if (!theme) return;
    document.documentElement.style.setProperty('--bg', theme.bg || '#fff');
    document.documentElement.style.setProperty('--text', theme.text || '#222');
    document.documentElement.style.setProperty('--accent', theme.accent || '#007bff');
    // set panel bg slightly adjusted
    let panelBg = theme.bg;
    try {
      panelBg = lightenOrDarkenColor(theme.bg || '#fff', 18);
    } catch(e) {
      panelBg = '#f6f8fa';
    }
    document.documentElement.style.setProperty('--panel-bg', panelBg);
    wheel.setTheme({ colors: theme.colors || [], text: theme.text || '#222' });
    // recolor pointer (DOM element)
    const pointer = document.getElementById('pointer');
    if (pointer) pointer.style.color = theme.accent || '';
    // recolor spin button
    const spin = document.getElementById('spin-btn');
    if (spin) spin.style.background = theme.accent || '';
  }
  function lightenOrDarkenColor(col, amt) {
    // accepts #rgb or #rrggbb. amt can be negative to darken.
    if (typeof col !== 'string') throw new Error('Invalid color');
    let colStr = col.trim();
    if (colStr[0] === '#') colStr = colStr.slice(1);
    if (colStr.length === 3) {
      colStr = colStr.split('').map(c => c + c).join('');
    }
    if (colStr.length !== 6) throw new Error('Invalid hex color');
    const num = parseInt(colStr, 16);
    let r = (num >> 16) & 0xFF;
    let g = (num >> 8) & 0xFF;
    let b = num & 0xFF;
    r = Math.max(0, Math.min(255, r + amt));
    g = Math.max(0, Math.min(255, g + amt));
    b = Math.max(0, Math.min(255, b + amt));
    const newHex = '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
    return newHex;
  }
  themeSelect.addEventListener('change', () => {
    const id = themeSelect.value;
    const t = themes.find(x => x.id === id);
    if (t) applyTheme(t);
  });
  function parseNamesFromTextarea() {
    const lines = namesTextarea.value.split('\n').map(s => s.trim()).filter(s => s.length);
    return lines;
  }
  function updateWheelFromTextarea() {
    const names = parseNamesFromTextarea();
    wheel.setNames(names);
  }
  addBtn.addEventListener('click', () => {
    const v = nameInput.value.trim();
    if (!v) return;
    const cur = parseNamesFromTextarea();
    cur.push(v);
    namesTextarea.value = cur.join('\n');
    nameInput.value = '';
    updateWheelFromTextarea();
  });
  nameInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
      addBtn.click();
      e.preventDefault();
    }
  });
  namesTextarea.addEventListener('input', () => {
    updateWheelFromTextarea();
  });
  loadSampleBtn.addEventListener('click', () => {
    const sample = ['Alice','Bob','Charlie','Diana','Eva','Frank','George','Helen','Ivy','Jack'];
    namesTextarea.value = sample.join('\n');
    updateWheelFromTextarea();
  });
  clearBtn.addEventListener('click', () => {
    namesTextarea.value = '';
    updateWheelFromTextarea();
    resultDiv.classList.add('hidden');
  });
  importBtn.addEventListener('click', async () => {
    // prompt user for a newline separated list (simple)
    const data = prompt('Paste names (one per line):');
    if (data === null) return;
    namesTextarea.value = data.split('\n').map(s => s.trim()).filter(s => s).join('\n');
    updateWheelFromTextarea();
  });
  exportBtn.addEventListener('click', () => {
    const names = parseNamesFromTextarea();
    const blob = new Blob([names.join('\n')], {type: 'text/plain'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'names.txt';
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  });
  spinBtn.addEventListener('click', async () => {
    const names = parseNamesFromTextarea();
    if (names.length === 0) {
      alert('Please add at least one name.');
      return;
    }
    resultDiv.classList.add('hidden');
    spinBtn.disabled = true;
    spinBtn.textContent = 'Spinning...';
    // Ensure wheel has latest names before selecting index
    wheel.setNames(names);
    // pick random index
    const idx = wheel.getRandomIndex();
    try {
      const winnerIndex = await wheel.spinToIndex(idx, { duration: 4500 });
      const winner = names[winnerIndex];
      resultDiv.textContent = `Winner: ${winner}`;
      resultDiv.classList.remove('hidden');
      spinBtn.textContent = 'SPIN';
      spinBtn.disabled = false;
    } catch (err) {
      console.error(err);
      spinBtn.textContent = 'SPIN';
      spinBtn.disabled = false;
    }
  });
  // initial sample and initial canvas sizing
  namesTextarea.value = 'Alice\nBob\nCharlie\nDiana\nEva';
  updateWheelFromTextarea();
  // Ensure wheel draws crisply at startup and on resize
  function handleResize() {
    if (typeof wheel.resize === 'function') {
      wheel.resize();
    } else {
      // fallback: redraw
      wheel.draw();
    }
  }
  window.addEventListener('resize', handleResize);
  // Run a resize after a short delay to ensure layout settled
  setTimeout(handleResize, 50);
});
```

"
Comments on Codes:
"<PRIORITY> Critical: Remove invalid Python-style triple-quoted "docstrings" from non-Python static files (themes.json, JS, CSS, HTML). These triple-quote blocks break JSON/JS/CSS/HTML parsing and will prevent the site from running.

Why this is highest priority
- themes.json begins with ''' which makes it invalid JSON â€” the client will fail when fetching themes.json and fall back to the default theme (or crash if fetch handling changes).
- wheel.js / main.js / styles.css / index.html each start with Python-style triple-quoted docstrings (''' ... ''') â€” those are not valid JS/CSS/HTML comments and will cause parse errors in browsers. If wheel.js or main.js fail to parse, the wheel UI and spin logic will not work at all.
- Fixing these stray docstrings is required before anything else (logic/UX improvements) can be relied upon.

How to fix (step-by-step)
1) themes.json
- Remove the leading and trailing ''' docstring lines entirely. JSON must contain only valid JSON.
- Ensure the file starts with [ and the JSON objects exactly as shown below.

Replace the current themes.json contents with (no comments, only JSON):
[
  {
    "id": "classic",
    "name": "Classic",
    "bg": "#ffffff",
    "text": "#222222",
    "accent": "#007bff",
    "colors": ["#ffb3b3", "#ffd9b3", "#fff3b3", "#d9ffb3", "#b3ffd9", "#b3e6ff", "#c7b3ff", "#ffb3f2"]
  },
  {
    "id": "dark",
    "name": "Dark",
    "bg": "#121212",
    "text": "#f5f5f5",
    "accent": "#ff6b6b",
    "colors": ["#2e2e34", "#3a3a44", "#4a4a56", "#5a5a68", "#6a6a78", "#7a7a88"]
  },
  {
    "id": "pastel",
    "name": "Pastel",
    "bg": "#f7f7ff",
    "text": "#333333",
    "accent": "#ff8c94",
    "colors": ["#ffd1dc", "#fce1b4", "#e8ffd1", "#d1fff0", "#d1e7ff", "#e6d1ff"]
  },
  {
    "id": "neon",
    "name": "Neon",
    "bg": "#0f0f13",
    "text": "#eaff00",
    "accent": "#00fff5",
    "colors": ["#ff00ff", "#ff8c00", "#00ff00", "#00ffff", "#8c00ff", "#ff0066"]
  }
]

2) wheel.js and main.js (JavaScript files)
- Replace the leading Python-style docstring with a JS comment block (/* ... */) or line comments (// ...).
- Example: change
  '''
  DOCSTRING:
  wheel.js
  ...
  '''
  to
  /* DOCSTRING:
     wheel.js
     Contains a Wheel class that draws the wheel on a canvas and animates spins.
     Key methods: ...
  */

- Make sure there are no stray leading apostrophes nor trailing ones. The rest of the JS code is fine as JS once the invalid string markers are removed.

3) styles.css (CSS file)
- Replace the triple-quoted docstring with a proper CSS comment block:
  /* DOCSTRING: Base CSS for the Wheel of Names app... */
- Remove any leading/trailing ''' lines.

4) index.html (HTML file)
- Remove the top triple-quoted docstring block. If you want inline documentation, use HTML comments:
  <!--
    DOCSTRING:
    Main HTML page for the Wheel of Names app...
  -->
- Make sure the HTML starts with <!doctype html> at the very top (no characters before it).

Why the above exact fixes are necessary
- Browsers will reject/parsing-fail on invalid JS/CSS/JSON; fixing comment syntax ensures files parse and the app can load scripts and themes.
- JSON does not support comments â€” for themes.json there must be no comment tokens at all.

Optional additional suggestions (not blocking but recommended)
- In wheel.js, consider using theme.bg for the center circle fill instead of hard-coded '#ffffff' so the center matches dark themes.
- Add small server-side safety: serve themes.json with correct MIME type (Flask static does this automatically).
- Consider adding simple unit/linters to catch non-JS/CSS/JSON tokens in future.

Verification after fixes
- Start app: pip install flask; python main.py
- Open http://127.0.0.1:5000/ â€” scripts should load without console parse errors, themes load from themes.json, the wheel should draw and spinning should work.

If you want, I can provide the cleaned top-of-file snippets for each file (index.html, wheel.js, main.js, styles.css, themes.json) so you can paste them in directly."
In the software, each file must strictly follow a markdown code block format, where the following tokens must be replaced such that "FILENAME" is the lowercase file name including the file extension, "LANGUAGE" in the programming language, "DOCSTRING" is a string literal specified in source code that is used to document a specific segment of code, and "CODE" is the original code. Format:
FILENAME
```LANGUAGE
'''
DOCSTRING
'''
CODE
```
As the Programmer, to satisfy the new user's demand and make the software creative, executive and robust, you should modify corresponding codes according to the comments. Then, output the full and complete codes with all bugs fixed based on the comments. Return all codes strictly following the required format.

[2025-17-09 14:10:24 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2025-17-09 14:10:24 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 7903
completion_tokens: 8638
total_tokens: 16541
cost: $-1.000000


[2025-17-09 14:10:24 INFO] Programmer: **Programmer<->Code Reviewer on : CodeReviewModification, turn 0**

[ChatDev is a software company powered by multiple intelligent agents, such as chief executive officer, chief human resources officer, chief product officer, chief technology officer, etc, with a multi-agent organizational structure and the mission of 'changing the digital world through programming'.
You are Code Reviewer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer.
You can help programmers to assess source codes for software troubleshooting, fix bugs to increase code quality and robustness, and offer proposals to improve the source codes.
Here is a new customer's task: [Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes.].
To complete the task, you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]



[2025-17-09 14:10:24 INFO] **[Seminar Conclusion]**:

 

[2025-17-09 14:10:24 INFO] **[Execute Detail]**

execute SimplePhase:[TestErrorSummary] in ComposedPhase:[Test], cycle 1

[2025-17-09 14:10:27 INFO] **[Test Reports]**:

The software run successfully without errors.

[2025-17-09 14:10:27 INFO] **[Test Info]**

AI User (Software Test Engineer):
Test Pass!


[2025-17-09 14:10:27 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | [Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes.] |
| **need_reflect** | True |
| **assistant_role_name** | Programmer |
| **user_role_name** | Chief Technology Officer |
| **phase_prompt** | The new user's task and our developed codes are listed:  Task: "{task}". Modality: "{modality}". Programming Language: "{language}" Ideas: "{ideas}" Codes:  "{codes}" As the {assistant_role}, you should write a requirements.txt file, which is commonly used in Python projects to specify the dependencies or packages required for the project to run properly. It serves as a way to document and manage the project's dependencies in a standardized format. For example: requirements.txt ``` numpy==1.19.2 pandas&gt;=1.1.4 ``` According to the codes and file format listed above, write a requirements.txt file to specify the dependencies or packages required for the project to run properly. |
| **phase_name** | EnvironmentDoc |
| **assistant_role_prompt** | {chatdev_prompt} You are Programmer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. You can write/create computer software or applications by providing a specific programming language to the computer. You have extensive computing and coding experience in many varieties of programming languages and platforms, such as Python, Java, C, C++, HTML, CSS, JavaScript, XML, SQL, PHP, etc,. Here is a new customer's task: {task}. To complete the task, you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Chief Technology Officer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. You are very familiar to information technology. You will make high-level decisions for the overarching technology infrastructure that closely align with the organization's goals, while you work alongside the organization's information technology ("IT") staff members to perform everyday operations. Here is a new customer's task: {task}. To complete the task, You must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'task': '[Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes.]', 'modality': 'website', 'ideas': '', 'language': ' Python', 'codes': 'main.py\npython\n\'\'\'\nFlask application that serves the wheel-of-names web app.\nRun: pip install flask\nThen: python main.py\nAccess: http://127.0.0.1:5000/\n\'\'\'\nfrom flask import Flask, render_template\nimport os\ndef create_app():\n    """\n    Create and configure the Flask application.\n    Serves templates from \'templates\' and static files from \'static\'.\n    """\n    app = Flask(__name__, static_folder=\'static\', template_folder=\'templates\')\n    @app.route(\'/\')\n    def index():\n        """\n        Serve the main page.\n        """\n        return render_template(\'index.html\')\n    return app\nif __name__ == \'__main__\':\n    app = create_app()\n    port = int(os.environ.get(\'PORT\', 5000))\n    # debug=True for development; set to False in production\n    app.run(debug=True, host=\'0.0.0.0\', port=port)\n\n\nindex.html\nhtml\n\'\'\'\nDOCSTRING:\nMain HTML page for the Wheel of Names app.\nContains UI elements:\n- name input and list\n- canvas for wheel\n- theme selector\n- spin / clear / add buttons\nIncludes JS files wheel.js and main.js for behavior.\nAlso injects a dynamically generated URL for themes.json using Flask\'s url_for so the client can reliably fetch the resource even when the app is mounted under a subpath.\n\'\'\'\n&lt;!doctype html&gt;\n&lt;html lang="en"&gt;\n&lt;head&gt;\n  &lt;meta charset="utf-8"&gt;\n  &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;\n  &lt;title&gt;Wheel of Names&lt;/title&gt;\n  &lt;!-- Main stylesheet --&gt;\n  &lt;link rel="stylesheet" href="{{ url_for(\'static\', filename=\'css/styles.css\') }}"&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div class="container"&gt;\n    &lt;header&gt;\n      &lt;h1&gt;Wheel of Names&lt;/h1&gt;\n      &lt;p&gt;Enter names, choose a theme, and spin to pick a random winner.&lt;/p&gt;\n    &lt;/header&gt;\n    &lt;main class="main-grid"&gt;\n      &lt;section class="left-panel"&gt;\n        &lt;div class="controls"&gt;\n          &lt;label for="name-input"&gt;Add a name&lt;/label&gt;\n          &lt;div class="input-row"&gt;\n            &lt;input id="name-input" type="text" placeholder="Enter name and press Add" autocomplete="off"&gt;\n            &lt;button id="add-name" type="button"&gt;Add&lt;/button&gt;\n          &lt;/div&gt;\n          &lt;label for="names-textarea"&gt;Names (one per line)&lt;/label&gt;\n          &lt;textarea id="names-textarea" placeholder="Alice\\nBob\\nCharlie"&gt;&lt;/textarea&gt;\n          &lt;div class="buttons-row"&gt;\n            &lt;button id="load-sample" type="button"&gt;Load Sample&lt;/button&gt;\n            &lt;button id="clear-names" type="button"&gt;Clear&lt;/button&gt;\n            &lt;button id="import-names" type="button"&gt;Import&lt;/button&gt;\n            &lt;button id="export-names" type="button"&gt;Export&lt;/button&gt;\n          &lt;/div&gt;\n          &lt;label for="theme-select"&gt;Theme&lt;/label&gt;\n          &lt;select id="theme-select" aria-label="Theme selector"&gt;&lt;/select&gt;\n          &lt;div class="spin-controls"&gt;\n            &lt;button id="spin-btn" class="spin" type="button"&gt;SPIN&lt;/button&gt;\n            &lt;div id="result" class="result hidden" aria-live="polite"&gt;&lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      &lt;/section&gt;\n      &lt;section class="right-panel"&gt;\n        &lt;div class="wheel-wrapper" id="wheel-wrapper"&gt;\n          &lt;!-- Canvas will be scaled for high-DPI via JS --&gt;\n          &lt;canvas id="wheel-canvas" width="600" height="600" aria-label="Wheel of names"&gt;&lt;/canvas&gt;\n          &lt;div id="pointer" aria-hidden="true"&gt;â–¼&lt;/div&gt;\n        &lt;/div&gt;\n      &lt;/section&gt;\n    &lt;/main&gt;\n    &lt;footer&gt;\n      &lt;small&gt;Built with Flask + Canvas. Themes available.&lt;/small&gt;\n    &lt;/footer&gt;\n  &lt;/div&gt;\n  &lt;!-- Provide the correct URL for themes.json (generated by Flask).\n       This ensures the client can fetch themes.json even when the app is mounted under a prefix. --&gt;\n  &lt;script&gt;\n    window.THEMES_JSON_URL = "{{ url_for(\'static\', filename=\'themes.json\') }}";\n  &lt;/script&gt;\n  &lt;script src="{{ url_for(\'static\', filename=\'js/wheel.js\') }}"&gt;&lt;/script&gt;\n  &lt;script src="{{ url_for(\'static\', filename=\'js/main.js\') }}"&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\n\nthemes.json\njson\n\'\'\'\nDOCSTRING:\nList of themes available for the wheel.\nEach theme contains:\n- id: machine id\n- name: display name\n- bg: page background color\n- text: primary text color\n- accent: accent color used for pointer/button\n- colors: array of segment colors (will be cycled for segments)\n\'\'\'\n[\n  {\n    "id": "classic",\n    "name": "Classic",\n    "bg": "#ffffff",\n    "text": "#222222",\n    "accent": "#007bff",\n    "colors": ["#ffb3b3", "#ffd9b3", "#fff3b3", "#d9ffb3", "#b3ffd9", "#b3e6ff", "#c7b3ff", "#ffb3f2"]\n  },\n  {\n    "id": "dark",\n    "name": "Dark",\n    "bg": "#121212",\n    "text": "#f5f5f5",\n    "accent": "#ff6b6b",\n    "colors": ["#2e2e34", "#3a3a44", "#4a4a56", "#5a5a68", "#6a6a78", "#7a7a88"]\n  },\n  {\n    "id": "pastel",\n    "name": "Pastel",\n    "bg": "#f7f7ff",\n    "text": "#333333",\n    "accent": "#ff8c94",\n    "colors": ["#ffd1dc", "#fce1b4", "#e8ffd1", "#d1fff0", "#d1e7ff", "#e6d1ff"]\n  },\n  {\n    "id": "neon",\n    "name": "Neon",\n    "bg": "#0f0f13",\n    "text": "#eaff00",\n    "accent": "#00fff5",\n    "colors": ["#ff00ff", "#ff8c00", "#00ff00", "#00ffff", "#8c00ff", "#ff0066"]\n  }\n]\n\n\nstyles.css\ncss\n\'\'\'\nDOCSTRING:\nBase CSS for the Wheel of Names app.\nDefines layout, basic theme variables, and responsive styles.\n\'\'\'\n/* Base CSS and theme variables */\n:root{\n  --bg: #ffffff;\n  --text: #222222;\n  --accent: #007bff;\n  --panel-bg: #f6f8fa;\n}\n*{box-sizing:border-box}\nhtml,body{\n  height:100%;\n  margin:0;\n  font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;\n  background: var(--bg);\n  color: var(--text);\n}\n.container{\n  max-width:1100px;\n  margin:24px auto;\n  padding:16px;\n}\nheader{ text-align:center; margin-bottom:8px }\nh1{ margin:6px 0; font-size:28px }\np{ margin:0; color:var(--text); opacity:0.8 }\n.main-grid{\n  display:grid;\n  grid-template-columns: 360px 1fr;\n  gap:20px;\n  align-items:start;\n  margin-top:18px;\n}\n.left-panel{\n  background:var(--panel-bg);\n  padding:14px;\n  border-radius:8px;\n  box-shadow:0 4px 8px rgba(0,0,0,0.04);\n}\n.left-panel label{ display:block; margin-top:8px; font-weight:600; margin-bottom:6px }\n.input-row{ display:flex; gap:8px }\n.input-row input[type="text"]{\n  flex:1;\n  padding:8px 10px;\n  border-radius:6px;\n  border:1px solid #ddd;\n  background:white;\n  color:inherit;\n}\n.input-row button{\n  padding:8px 12px;\n  border-radius:6px;\n  background:var(--accent);\n  color:white;\n  border:none;\n  cursor:pointer;\n}\ntextarea{\n  width:100%;\n  min-height:160px;\n  padding:10px;\n  border-radius:8px;\n  border:1px solid #ddd;\n  resize:vertical;\n  background:white;\n  color:inherit;\n}\n.buttons-row{\n  display:flex;\n  gap:8px;\n  margin-top:8px;\n  flex-wrap:wrap;\n}\n.buttons-row button{\n  padding:8px 10px;\n  border-radius:6px;\n  border:1px solid #ccc;\n  background:transparent;\n  cursor:pointer;\n}\n.spin-controls{\n  display:flex;\n  gap:12px;\n  margin-top:16px;\n  align-items:center;\n}\n.spin{\n  padding:14px 24px;\n  background:var(--accent);\n  color:white;\n  font-weight:700;\n  border:none;\n  border-radius:10px;\n  cursor:pointer;\n  font-size:18px;\n}\n.result{\n  padding:10px 12px;\n  background:rgba(0,0,0,0.06);\n  border-radius:8px;\n}\n.hidden{ display:none }\n.right-panel{\n  display:flex;\n  align-items:center;\n  justify-content:center;\n  min-height:420px;\n}\n.wheel-wrapper{\n  position:relative;\n  width:600px;\n  height:600px;\n  display:flex;\n  align-items:center;\n  justify-content:center;\n  margin:auto;\n}\n#wheel-canvas{\n  border-radius:50%;\n  box-shadow: 0 12px 30px rgba(0,0,0,0.12);\n  background:transparent;\n  /* ensure the canvas element scales responsively in layout; the backing store will be adjusted in JS */\n  width:100%;\n  height:100%;\n  display:block;\n}\n#wheel-wrapper #pointer{\n  position:absolute;\n  top:18px;\n  left:50%;\n  transform:translateX(-50%);\n  font-size:40px;\n  color:var(--accent);\n  text-shadow:0 2px 4px rgba(0,0,0,0.2);\n  pointer-events:none;\n}\nfooter{ text-align:center; margin-top:16px; color:var(--text); opacity:0.7; }\n/* Responsive */\n@media (max-width:960px){\n  .main-grid{ grid-template-columns:1fr; }\n  .wheel-wrapper{ width:420px; height:420px; }\n  #wheel-canvas{ width:420px; height:420px; }\n}\n\n\nwheel.js\njs\n\'\'\'\nDOCSTRING:\nwheel.js\nContains a Wheel class that draws the wheel on a canvas and animates spins.\nKey methods:\n- constructor(canvas, options)\n- setNames(names)\n- setTheme(theme)\n- draw()\n- resize() -&gt; handle high-DPI displays\n- spinToIndex(index) -&gt; Promise resolves with index after animation\n- getRandomIndex()\n\'\'\'\n/* A small utility to requestAnimationFrame safely (browser-provided) */\nclass Wheel {\n  constructor(canvas, options = {}) {\n    this.canvas = canvas;\n    this.ctx = canvas.getContext(\'2d\');\n    this.names = options.names || [];\n    this.colors = options.colors || [\'#ffb3b3\', \'#ffd9b3\', \'#fff3b3\', \'#d9ffb3\', \'#b3ffd9\', \'#b3e6ff\'];\n    this.textColor = options.textColor || \'#222\';\n    this.rotation = 0; // degrees\n    this.font = options.font || \'16px Inter, Arial\';\n    this.onDraw = options.onDraw || function(){};\n    this._animating = false;\n    // Set up high-DPI friendly canvas and metrics\n    this.resize();\n    // Redraw once created\n    this.draw();\n    // Optional: handle container resize via ResizeObserver if available\n    if (window.ResizeObserver) {\n      try {\n        const ro = new ResizeObserver(() =&gt; this.resize());\n        ro.observe(this.canvas.parentElement || this.canvas);\n        this._resizeObserver = ro;\n      } catch (e) {\n        // ignore\n      }\n    } else {\n      window.addEventListener(\'resize\', () =&gt; this.resize());\n    }\n  }\n  resize() {\n    // Make the canvas crisp on high-DPI screens.\n    const dpr = window.devicePixelRatio || 1;\n    const rect = this.canvas.getBoundingClientRect();\n    // Fallback to element width/height attributes if bounding rect is 0\n    const cssWidth = rect.width || this.canvas.clientWidth || this.canvas.width / (dpr || 1);\n    const cssHeight = rect.height || this.canvas.clientHeight || this.canvas.height / (dpr || 1);\n    // Set backing store size\n    this.canvas.width = Math.max(1, Math.round(cssWidth * dpr));\n    this.canvas.height = Math.max(1, Math.round(cssHeight * dpr));\n    // Keep CSS size consistent\n    this.canvas.style.width = cssWidth + \'px\';\n    this.canvas.style.height = cssHeight + \'px\';\n    // Reset transform so we can set a scale for dpr\n    this.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n    // Use CSS pixel coordinates for drawing from now on\n    this.centerX = cssWidth / 2;\n    this.centerY = cssHeight / 2;\n    this.radius = Math.min(cssWidth, cssHeight) / 2 - 10;\n    // Recompute font size based on canvas size to keep labels legible\n    // If user supplied a font (with px), keep it; otherwise set a sensible value.\n    if (!this.font || typeof this.font !== \'string\') {\n      this.font = Math.max(12, Math.round(this.radius * 0.06)) + \'px Inter, Arial\';\n    } else {\n      // keep user\'s font but ensure text scale reasonable\n      // (we don\'t attempt to parse px here; leaving as provided)\n    }\n    this.draw();\n  }\n  setNames(names) {\n    this.names = names.slice();\n    this.draw();\n  }\n  setTheme(theme) {\n    if (!theme) return;\n    if (theme.colors &amp;&amp; theme.colors.length) this.colors = theme.colors.slice();\n    if (theme.text) this.textColor = theme.text;\n    this.draw();\n  }\n  clearCanvas() {\n    // Clear the visible canvas area (CSS pixels)\n    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n  }\n  draw() {\n    this.clearCanvas();\n    const ctx = this.ctx;\n    const n = Math.max(1, this.names.length);\n    const seg = 360 / n;\n    ctx.save();\n    // Translate to center using CSS pixel coordinates\n    ctx.translate(this.centerX, this.centerY);\n    ctx.rotate(this.degToRad(this.rotation));\n    // Draw segments\n    for (let i = 0; i &lt; n; i++) {\n      const start = this.degToRad(i * seg);\n      const end = this.degToRad((i + 1) * seg);\n      ctx.beginPath();\n      ctx.moveTo(0, 0);\n      ctx.arc(0, 0, this.radius, start, end);\n      ctx.closePath();\n      ctx.fillStyle = this.colors[i % this.colors.length];\n      ctx.fill();\n      // stroke\n      ctx.lineWidth = Math.max(1, this.radius * 0.008);\n      ctx.strokeStyle = \'rgba(0,0,0,0.08)\';\n      ctx.stroke();\n      // Draw label\n      ctx.save();\n      const angle = start + (end - start) / 2;\n      ctx.rotate(angle);\n      ctx.translate(this.radius * 0.55, 0);\n      ctx.rotate(Math.PI / 2);\n      ctx.fillStyle = this.textColor;\n      // Set font size relative to radius if not provided precisely\n      ctx.font = this.font;\n      ctx.textAlign = \'center\';\n      ctx.textBaseline = \'middle\';\n      const name = this.names[i] || \'\';\n      this.wrapText(ctx, name, 0, 0, this.radius * 0.35, parseInt(Math.max(12, this.radius * 0.06), 10));\n      ctx.restore();\n    }\n    ctx.restore();\n    // center circle\n    ctx.beginPath();\n    ctx.arc(this.centerX, this.centerY, this.radius * 0.12, 0, Math.PI * 2);\n    // Fill with background-like color; allow theme override by drawing over it in CSS if necessary\n    ctx.fillStyle = \'#ffffff\';\n    ctx.fill();\n    ctx.lineWidth = Math.max(1, this.radius * 0.008);\n    ctx.strokeStyle = \'rgba(0,0,0,0.06)\';\n    ctx.stroke();\n    this.onDraw();\n  }\n  wrapText(ctx, text, x, y, maxWidth, lineHeight) {\n    // A simple wrap for canvas text\n    const words = String(text).split(\' \');\n    let line = \'\';\n    let yOffset = y;\n    for (let n = 0; n &lt; words.length; n++) {\n      const testLine = line + words[n] + \' \';\n      const metrics = ctx.measureText(testLine);\n      const testWidth = metrics.width;\n      if (testWidth &gt; maxWidth &amp;&amp; n &gt; 0) {\n        ctx.fillText(line.trim(), x, yOffset);\n        line = words[n] + \' \';\n        yOffset += lineHeight;\n      } else {\n        line = testLine;\n      }\n    }\n    ctx.fillText(line.trim(), x, yOffset);\n  }\n  degToRad(d) {\n    return d * Math.PI / 180;\n  }\n  radToDeg(r) {\n    return r * 180 / Math.PI;\n  }\n  getRandomIndex() {\n    if (!this.names.length) return 0;\n    return Math.floor(Math.random() * this.names.length);\n  }\n  // Spin such that the segment at `index` lands on the pointer at top.\n  spinToIndex(index, opts = {}) {\n    if (this._animating) return Promise.reject(\'Already animating\');\n    if (!this.names.length) return Promise.reject(\'No names\');\n    const n = this.names.length;\n    const segAngle = 360 / n;\n    // Normalize current rotation to [0, 360)\n    const normalized = ((this.rotation % 360) + 360) % 360;\n    // Center of segment i is at angle: (i * segAngle + segAngle/2)\n    const centerAngle = index * segAngle + segAngle / 2;\n    // We want (centerAngle + rotation) mod 360 = 270 (pointing upward if pointer is at top)\n    let targetRotation = 270 - centerAngle;\n    targetRotation = ((targetRotation % 360) + 360) % 360;\n    const fullSpins = opts.fullSpins !== undefined ? opts.fullSpins : (3 + Math.floor(Math.random() * 3)); // 3-5 spins\n    const endRotation = targetRotation + fullSpins * 360 + (opts.randomOffset || 0);\n    const startRotation = normalized;\n    const delta = endRotation - startRotation;\n    const duration = opts.duration || 5000; // ms\n    const startTime = performance.now();\n    this._animating = true;\n    return new Promise((resolve) =&gt; {\n      const animate = (now) =&gt; {\n        const elapsed = now - startTime;\n        const t = Math.min(1, elapsed / duration);\n        // ease out cubic\n        const eased = 1 - Math.pow(1 - t, 3);\n        const current = startRotation + delta * eased;\n        this.rotation = current;\n        this.draw();\n        if (t &lt; 1) {\n          requestAnimationFrame(animate);\n        } else {\n          this._animating = false;\n          // Normalize rotation to endRotation mod 360\n          this.rotation = ((endRotation % 360) + 360) % 360;\n          this.draw();\n          resolve(index);\n        }\n      };\n      requestAnimationFrame(animate);\n    });\n  }\n}\n\n\nmain.js\njs\n\'\'\'\nDOCSTRING:\nmain.js\nWires UI to the Wheel class:\n- loads themes.json (URL injected by Flask)\n- populates theme selector\n- reads names and updates wheel\n- handles spin logic and result display\nIncludes robust fallback if fetching themes.json fails.\n\'\'\'\n/* DOM wiring and app logic */\ndocument.addEventListener(\'DOMContentLoaded\', async () =&gt; {\n  const canvas = document.getElementById(\'wheel-canvas\');\n  const nameInput = document.getElementById(\'name-input\');\n  const addBtn = document.getElementById(\'add-name\');\n  const namesTextarea = document.getElementById(\'names-textarea\');\n  const spinBtn = document.getElementById(\'spin-btn\');\n  const resultDiv = document.getElementById(\'result\');\n  const themeSelect = document.getElementById(\'theme-select\');\n  const loadSampleBtn = document.getElementById(\'load-sample\');\n  const clearBtn = document.getElementById(\'clear-names\');\n  const importBtn = document.getElementById(\'import-names\');\n  const exportBtn = document.getElementById(\'export-names\');\n  const wheel = new Wheel(canvas, { names: [], colors: [\'#ffb3b3\',\'#ffd9b3\',\'#fff3b3\',\'#d9ffb3\'] });\n  let themes = [];\n  // A small fallback theme set in case fetching themes.json fails.\n  const defaultThemes = [\n    {\n      id: \'fallback\',\n      name: \'Default\',\n      bg: \'#ffffff\',\n      text: \'#222222\',\n      accent: \'#007bff\',\n      colors: [\'#ffb3b3\',\'#ffd9b3\',\'#fff3b3\',\'#d9ffb3\']\n    }\n  ];\n  // Helper to populate theme selector\n  function populateThemeSelector(list) {\n    themeSelect.innerHTML = \'\';\n    list.forEach(t =&gt; {\n      const opt = document.createElement(\'option\');\n      opt.value = t.id;\n      opt.textContent = t.name;\n      themeSelect.appendChild(opt);\n    });\n  }\n  // Load themes.json (URL injected by Flask)\n  try {\n    const themesUrl = window.THEMES_JSON_URL || \'/static/themes.json\';\n    const resp = await fetch(themesUrl, {cache: \'no-cache\'});\n    if (!resp.ok) throw new Error(\'HTTP \' + resp.status);\n    themes = await resp.json();\n    if (!Array.isArray(themes) || themes.length === 0) throw new Error(\'No themes found\');\n    populateThemeSelector(themes);\n    // apply first theme\n    applyTheme(themes[0]);\n    themeSelect.value = themes[0].id;\n  } catch (err) {\n    console.error(\'Failed to load themes:\', err);\n    // fallback\n    themes = defaultThemes;\n    populateThemeSelector(themes);\n    applyTheme(themes[0]);\n    themeSelect.value = themes[0].id;\n  }\n  function applyTheme(theme) {\n    if (!theme) return;\n    document.documentElement.style.setProperty(\'--bg\', theme.bg || \'#fff\');\n    document.documentElement.style.setProperty(\'--text\', theme.text || \'#222\');\n    document.documentElement.style.setProperty(\'--accent\', theme.accent || \'#007bff\');\n    // set panel bg slightly adjusted\n    let panelBg = theme.bg;\n    try {\n      panelBg = lightenOrDarkenColor(theme.bg || \'#fff\', 18);\n    } catch(e) {\n      panelBg = \'#f6f8fa\';\n    }\n    document.documentElement.style.setProperty(\'--panel-bg\', panelBg);\n    wheel.setTheme({ colors: theme.colors || [], text: theme.text || \'#222\' });\n    // recolor pointer (DOM element)\n    const pointer = document.getElementById(\'pointer\');\n    if (pointer) pointer.style.color = theme.accent || \'\';\n    // recolor spin button\n    const spin = document.getElementById(\'spin-btn\');\n    if (spin) spin.style.background = theme.accent || \'\';\n  }\n  function lightenOrDarkenColor(col, amt) {\n    // accepts #rgb or #rrggbb. amt can be negative to darken.\n    if (typeof col !== \'string\') throw new Error(\'Invalid color\');\n    let colStr = col.trim();\n    if (colStr[0] === \'#\') colStr = colStr.slice(1);\n    if (colStr.length === 3) {\n      colStr = colStr.split(\'\').map(c =&gt; c + c).join(\'\');\n    }\n    if (colStr.length !== 6) throw new Error(\'Invalid hex color\');\n    const num = parseInt(colStr, 16);\n    let r = (num &gt;&gt; 16) &amp; 0xFF;\n    let g = (num &gt;&gt; 8) &amp; 0xFF;\n    let b = num &amp; 0xFF;\n    r = Math.max(0, Math.min(255, r + amt));\n    g = Math.max(0, Math.min(255, g + amt));\n    b = Math.max(0, Math.min(255, b + amt));\n    const newHex = \'#\' + ((1 &lt;&lt; 24) + (r &lt;&lt; 16) + (g &lt;&lt; 8) + b).toString(16).slice(1);\n    return newHex;\n  }\n  themeSelect.addEventListener(\'change\', () =&gt; {\n    const id = themeSelect.value;\n    const t = themes.find(x =&gt; x.id === id);\n    if (t) applyTheme(t);\n  });\n  function parseNamesFromTextarea() {\n    const lines = namesTextarea.value.split(\'\\n\').map(s =&gt; s.trim()).filter(s =&gt; s.length);\n    return lines;\n  }\n  function updateWheelFromTextarea() {\n    const names = parseNamesFromTextarea();\n    wheel.setNames(names);\n  }\n  addBtn.addEventListener(\'click\', () =&gt; {\n    const v = nameInput.value.trim();\n    if (!v) return;\n    const cur = parseNamesFromTextarea();\n    cur.push(v);\n    namesTextarea.value = cur.join(\'\\n\');\n    nameInput.value = \'\';\n    updateWheelFromTextarea();\n  });\n  nameInput.addEventListener(\'keydown\', (e) =&gt; {\n    if (e.key === \'Enter\') {\n      addBtn.click();\n      e.preventDefault();\n    }\n  });\n  namesTextarea.addEventListener(\'input\', () =&gt; {\n    updateWheelFromTextarea();\n  });\n  loadSampleBtn.addEventListener(\'click\', () =&gt; {\n    const sample = [\'Alice\',\'Bob\',\'Charlie\',\'Diana\',\'Eva\',\'Frank\',\'George\',\'Helen\',\'Ivy\',\'Jack\'];\n    namesTextarea.value = sample.join(\'\\n\');\n    updateWheelFromTextarea();\n  });\n  clearBtn.addEventListener(\'click\', () =&gt; {\n    namesTextarea.value = \'\';\n    updateWheelFromTextarea();\n    resultDiv.classList.add(\'hidden\');\n  });\n  importBtn.addEventListener(\'click\', async () =&gt; {\n    // prompt user for a newline separated list (simple)\n    const data = prompt(\'Paste names (one per line):\');\n    if (data === null) return;\n    namesTextarea.value = data.split(\'\\n\').map(s =&gt; s.trim()).filter(s =&gt; s).join(\'\\n\');\n    updateWheelFromTextarea();\n  });\n  exportBtn.addEventListener(\'click\', () =&gt; {\n    const names = parseNamesFromTextarea();\n    const blob = new Blob([names.join(\'\\n\')], {type: \'text/plain\'});\n    const url = URL.createObjectURL(blob);\n    const a = document.createElement(\'a\');\n    a.href = url;\n    a.download = \'names.txt\';\n    document.body.appendChild(a);\n    a.click();\n    a.remove();\n    URL.revokeObjectURL(url);\n  });\n  spinBtn.addEventListener(\'click\', async () =&gt; {\n    const names = parseNamesFromTextarea();\n    if (names.length === 0) {\n      alert(\'Please add at least one name.\');\n      return;\n    }\n    resultDiv.classList.add(\'hidden\');\n    spinBtn.disabled = true;\n    spinBtn.textContent = \'Spinning...\';\n    // Ensure wheel has latest names before selecting index\n    wheel.setNames(names);\n    // pick random index\n    const idx = wheel.getRandomIndex();\n    try {\n      const winnerIndex = await wheel.spinToIndex(idx, { duration: 4500 });\n      const winner = names[winnerIndex];\n      resultDiv.textContent = `Winner: ${winner}`;\n      resultDiv.classList.remove(\'hidden\');\n      spinBtn.textContent = \'SPIN\';\n      spinBtn.disabled = false;\n    } catch (err) {\n      console.error(err);\n      spinBtn.textContent = \'SPIN\';\n      spinBtn.disabled = false;\n    }\n  });\n  // initial sample and initial canvas sizing\n  namesTextarea.value = \'Alice\\nBob\\nCharlie\\nDiana\\nEva\';\n  updateWheelFromTextarea();\n  // Ensure wheel draws crisply at startup and on resize\n  function handleResize() {\n    if (typeof wheel.resize === \'function\') {\n      wheel.resize();\n    } else {\n      // fallback: redraw\n      wheel.draw();\n    }\n  }\n  window.addEventListener(\'resize\', handleResize);\n  // Run a resize after a short delay to ensure layout settled\n  setTimeout(handleResize, 50);\n});\n\n\n'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_3_5_TURBO |

[2025-17-09 14:10:27 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Programmer |
| **user_role_name** | Chief Technology Officer |
| **assistant_role_prompt** | {chatdev_prompt} You are Programmer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. You can write/create computer software or applications by providing a specific programming language to the computer. You have extensive computing and coding experience in many varieties of programming languages and platforms, such as Python, Java, C, C++, HTML, CSS, JavaScript, XML, SQL, PHP, etc,. Here is a new customer's task: {task}. To complete the task, you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Chief Technology Officer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. You are very familiar to information technology. You will make high-level decisions for the overarching technology infrastructure that closely align with the organization's goals, while you work alongside the organization's information technology ("IT") staff members to perform everyday operations. Here is a new customer's task: {task}. To complete the task, You must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **task_prompt** | [Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes.] |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_3_5_TURBO |
| **background_prompt** | ChatDev is a software company powered by multiple intelligent agents, such as chief executive officer, chief human resources officer, chief product officer, chief technology officer, etc, with a multi-agent organizational structure and the mission of 'changing the digital world through programming'. |

[2025-17-09 14:10:27 INFO] Chief Technology Officer: **[Start Chat]**

[ChatDev is a software company powered by multiple intelligent agents, such as chief executive officer, chief human resources officer, chief product officer, chief technology officer, etc, with a multi-agent organizational structure and the mission of 'changing the digital world through programming'.
You are Programmer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer.
You can write/create computer software or applications by providing a specific programming language to the computer. You have extensive computing and coding experience in many varieties of programming languages and platforms, such as Python, Java, C, C++, HTML, CSS, JavaScript, XML, SQL, PHP, etc,.
Here is a new customer's task: [Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes.].
To complete the task, you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]

The new user's task and our developed codes are listed: 

Task: "[Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes.]".

Modality: "website".

Programming Language: " Python"

Ideas: ""

Codes: 

"main.py
```python
'''
Flask application that serves the wheel-of-names web app.
Run: pip install flask
Then: python main.py
Access: http://127.0.0.1:5000/
'''
from flask import Flask, render_template
import os
def create_app():
    """
    Create and configure the Flask application.
    Serves templates from 'templates' and static files from 'static'.
    """
    app = Flask(__name__, static_folder='static', template_folder='templates')
    @app.route('/')
    def index():
        """
        Serve the main page.
        """
        return render_template('index.html')
    return app
if __name__ == '__main__':
    app = create_app()
    port = int(os.environ.get('PORT', 5000))
    # debug=True for development; set to False in production
    app.run(debug=True, host='0.0.0.0', port=port)
```

index.html
```html
'''
DOCSTRING:
Main HTML page for the Wheel of Names app.
Contains UI elements:
- name input and list
- canvas for wheel
- theme selector
- spin / clear / add buttons
Includes JS files wheel.js and main.js for behavior.
Also injects a dynamically generated URL for themes.json using Flask's url_for so the client can reliably fetch the resource even when the app is mounted under a subpath.
'''
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Wheel of Names</title>
  <!-- Main stylesheet -->
  <link rel="stylesheet" href="{{ url_for('static', filename='css/styles.css') }}">
</head>
<body>
  <div class="container">
    <header>
      <h1>Wheel of Names</h1>
      <p>Enter names, choose a theme, and spin to pick a random winner.</p>
    </header>
    <main class="main-grid">
      <section class="left-panel">
        <div class="controls">
          <label for="name-input">Add a name</label>
          <div class="input-row">
            <input id="name-input" type="text" placeholder="Enter name and press Add" autocomplete="off">
            <button id="add-name" type="button">Add</button>
          </div>
          <label for="names-textarea">Names (one per line)</label>
          <textarea id="names-textarea" placeholder="Alice\nBob\nCharlie"></textarea>
          <div class="buttons-row">
            <button id="load-sample" type="button">Load Sample</button>
            <button id="clear-names" type="button">Clear</button>
            <button id="import-names" type="button">Import</button>
            <button id="export-names" type="button">Export</button>
          </div>
          <label for="theme-select">Theme</label>
          <select id="theme-select" aria-label="Theme selector"></select>
          <div class="spin-controls">
            <button id="spin-btn" class="spin" type="button">SPIN</button>
            <div id="result" class="result hidden" aria-live="polite"></div>
          </div>
        </div>
      </section>
      <section class="right-panel">
        <div class="wheel-wrapper" id="wheel-wrapper">
          <!-- Canvas will be scaled for high-DPI via JS -->
          <canvas id="wheel-canvas" width="600" height="600" aria-label="Wheel of names"></canvas>
          <div id="pointer" aria-hidden="true">â–¼</div>
        </div>
      </section>
    </main>
    <footer>
      <small>Built with Flask + Canvas. Themes available.</small>
    </footer>
  </div>
  <!-- Provide the correct URL for themes.json (generated by Flask).
       This ensures the client can fetch themes.json even when the app is mounted under a prefix. -->
  <script>
    window.THEMES_JSON_URL = "{{ url_for('static', filename='themes.json') }}";
  </script>
  <script src="{{ url_for('static', filename='js/wheel.js') }}"></script>
  <script src="{{ url_for('static', filename='js/main.js') }}"></script>
</body>
</html>
```

themes.json
```json
'''
DOCSTRING:
List of themes available for the wheel.
Each theme contains:
- id: machine id
- name: display name
- bg: page background color
- text: primary text color
- accent: accent color used for pointer/button
- colors: array of segment colors (will be cycled for segments)
'''
[
  {
    "id": "classic",
    "name": "Classic",
    "bg": "#ffffff",
    "text": "#222222",
    "accent": "#007bff",
    "colors": ["#ffb3b3", "#ffd9b3", "#fff3b3", "#d9ffb3", "#b3ffd9", "#b3e6ff", "#c7b3ff", "#ffb3f2"]
  },
  {
    "id": "dark",
    "name": "Dark",
    "bg": "#121212",
    "text": "#f5f5f5",
    "accent": "#ff6b6b",
    "colors": ["#2e2e34", "#3a3a44", "#4a4a56", "#5a5a68", "#6a6a78", "#7a7a88"]
  },
  {
    "id": "pastel",
    "name": "Pastel",
    "bg": "#f7f7ff",
    "text": "#333333",
    "accent": "#ff8c94",
    "colors": ["#ffd1dc", "#fce1b4", "#e8ffd1", "#d1fff0", "#d1e7ff", "#e6d1ff"]
  },
  {
    "id": "neon",
    "name": "Neon",
    "bg": "#0f0f13",
    "text": "#eaff00",
    "accent": "#00fff5",
    "colors": ["#ff00ff", "#ff8c00", "#00ff00", "#00ffff", "#8c00ff", "#ff0066"]
  }
]
```

styles.css
```css
'''
DOCSTRING:
Base CSS for the Wheel of Names app.
Defines layout, basic theme variables, and responsive styles.
'''
/* Base CSS and theme variables */
:root{
  --bg: #ffffff;
  --text: #222222;
  --accent: #007bff;
  --panel-bg: #f6f8fa;
}
*{box-sizing:border-box}
html,body{
  height:100%;
  margin:0;
  font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
  background: var(--bg);
  color: var(--text);
}
.container{
  max-width:1100px;
  margin:24px auto;
  padding:16px;
}
header{ text-align:center; margin-bottom:8px }
h1{ margin:6px 0; font-size:28px }
p{ margin:0; color:var(--text); opacity:0.8 }
.main-grid{
  display:grid;
  grid-template-columns: 360px 1fr;
  gap:20px;
  align-items:start;
  margin-top:18px;
}
.left-panel{
  background:var(--panel-bg);
  padding:14px;
  border-radius:8px;
  box-shadow:0 4px 8px rgba(0,0,0,0.04);
}
.left-panel label{ display:block; margin-top:8px; font-weight:600; margin-bottom:6px }
.input-row{ display:flex; gap:8px }
.input-row input[type="text"]{
  flex:1;
  padding:8px 10px;
  border-radius:6px;
  border:1px solid #ddd;
  background:white;
  color:inherit;
}
.input-row button{
  padding:8px 12px;
  border-radius:6px;
  background:var(--accent);
  color:white;
  border:none;
  cursor:pointer;
}
textarea{
  width:100%;
  min-height:160px;
  padding:10px;
  border-radius:8px;
  border:1px solid #ddd;
  resize:vertical;
  background:white;
  color:inherit;
}
.buttons-row{
  display:flex;
  gap:8px;
  margin-top:8px;
  flex-wrap:wrap;
}
.buttons-row button{
  padding:8px 10px;
  border-radius:6px;
  border:1px solid #ccc;
  background:transparent;
  cursor:pointer;
}
.spin-controls{
  display:flex;
  gap:12px;
  margin-top:16px;
  align-items:center;
}
.spin{
  padding:14px 24px;
  background:var(--accent);
  color:white;
  font-weight:700;
  border:none;
  border-radius:10px;
  cursor:pointer;
  font-size:18px;
}
.result{
  padding:10px 12px;
  background:rgba(0,0,0,0.06);
  border-radius:8px;
}
.hidden{ display:none }
.right-panel{
  display:flex;
  align-items:center;
  justify-content:center;
  min-height:420px;
}
.wheel-wrapper{
  position:relative;
  width:600px;
  height:600px;
  display:flex;
  align-items:center;
  justify-content:center;
  margin:auto;
}
#wheel-canvas{
  border-radius:50%;
  box-shadow: 0 12px 30px rgba(0,0,0,0.12);
  background:transparent;
  /* ensure the canvas element scales responsively in layout; the backing store will be adjusted in JS */
  width:100%;
  height:100%;
  display:block;
}
#wheel-wrapper #pointer{
  position:absolute;
  top:18px;
  left:50%;
  transform:translateX(-50%);
  font-size:40px;
  color:var(--accent);
  text-shadow:0 2px 4px rgba(0,0,0,0.2);
  pointer-events:none;
}
footer{ text-align:center; margin-top:16px; color:var(--text); opacity:0.7; }
/* Responsive */
@media (max-width:960px){
  .main-grid{ grid-template-columns:1fr; }
  .wheel-wrapper{ width:420px; height:420px; }
  #wheel-canvas{ width:420px; height:420px; }
}
```

wheel.js
```js
'''
DOCSTRING:
wheel.js
Contains a Wheel class that draws the wheel on a canvas and animates spins.
Key methods:
- constructor(canvas, options)
- setNames(names)
- setTheme(theme)
- draw()
- resize() -> handle high-DPI displays
- spinToIndex(index) -> Promise resolves with index after animation
- getRandomIndex()
'''
/* A small utility to requestAnimationFrame safely (browser-provided) */
class Wheel {
  constructor(canvas, options = {}) {
    this.canvas = canvas;
    this.ctx = canvas.getContext('2d');
    this.names = options.names || [];
    this.colors = options.colors || ['#ffb3b3', '#ffd9b3', '#fff3b3', '#d9ffb3', '#b3ffd9', '#b3e6ff'];
    this.textColor = options.textColor || '#222';
    this.rotation = 0; // degrees
    this.font = options.font || '16px Inter, Arial';
    this.onDraw = options.onDraw || function(){};
    this._animating = false;
    // Set up high-DPI friendly canvas and metrics
    this.resize();
    // Redraw once created
    this.draw();
    // Optional: handle container resize via ResizeObserver if available
    if (window.ResizeObserver) {
      try {
        const ro = new ResizeObserver(() => this.resize());
        ro.observe(this.canvas.parentElement || this.canvas);
        this._resizeObserver = ro;
      } catch (e) {
        // ignore
      }
    } else {
      window.addEventListener('resize', () => this.resize());
    }
  }
  resize() {
    // Make the canvas crisp on high-DPI screens.
    const dpr = window.devicePixelRatio || 1;
    const rect = this.canvas.getBoundingClientRect();
    // Fallback to element width/height attributes if bounding rect is 0
    const cssWidth = rect.width || this.canvas.clientWidth || this.canvas.width / (dpr || 1);
    const cssHeight = rect.height || this.canvas.clientHeight || this.canvas.height / (dpr || 1);
    // Set backing store size
    this.canvas.width = Math.max(1, Math.round(cssWidth * dpr));
    this.canvas.height = Math.max(1, Math.round(cssHeight * dpr));
    // Keep CSS size consistent
    this.canvas.style.width = cssWidth + 'px';
    this.canvas.style.height = cssHeight + 'px';
    // Reset transform so we can set a scale for dpr
    this.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    // Use CSS pixel coordinates for drawing from now on
    this.centerX = cssWidth / 2;
    this.centerY = cssHeight / 2;
    this.radius = Math.min(cssWidth, cssHeight) / 2 - 10;
    // Recompute font size based on canvas size to keep labels legible
    // If user supplied a font (with px), keep it; otherwise set a sensible value.
    if (!this.font || typeof this.font !== 'string') {
      this.font = Math.max(12, Math.round(this.radius * 0.06)) + 'px Inter, Arial';
    } else {
      // keep user's font but ensure text scale reasonable
      // (we don't attempt to parse px here; leaving as provided)
    }
    this.draw();
  }
  setNames(names) {
    this.names = names.slice();
    this.draw();
  }
  setTheme(theme) {
    if (!theme) return;
    if (theme.colors && theme.colors.length) this.colors = theme.colors.slice();
    if (theme.text) this.textColor = theme.text;
    this.draw();
  }
  clearCanvas() {
    // Clear the visible canvas area (CSS pixels)
    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
  }
  draw() {
    this.clearCanvas();
    const ctx = this.ctx;
    const n = Math.max(1, this.names.length);
    const seg = 360 / n;
    ctx.save();
    // Translate to center using CSS pixel coordinates
    ctx.translate(this.centerX, this.centerY);
    ctx.rotate(this.degToRad(this.rotation));
    // Draw segments
    for (let i = 0; i < n; i++) {
      const start = this.degToRad(i * seg);
      const end = this.degToRad((i + 1) * seg);
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.arc(0, 0, this.radius, start, end);
      ctx.closePath();
      ctx.fillStyle = this.colors[i % this.colors.length];
      ctx.fill();
      // stroke
      ctx.lineWidth = Math.max(1, this.radius * 0.008);
      ctx.strokeStyle = 'rgba(0,0,0,0.08)';
      ctx.stroke();
      // Draw label
      ctx.save();
      const angle = start + (end - start) / 2;
      ctx.rotate(angle);
      ctx.translate(this.radius * 0.55, 0);
      ctx.rotate(Math.PI / 2);
      ctx.fillStyle = this.textColor;
      // Set font size relative to radius if not provided precisely
      ctx.font = this.font;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      const name = this.names[i] || '';
      this.wrapText(ctx, name, 0, 0, this.radius * 0.35, parseInt(Math.max(12, this.radius * 0.06), 10));
      ctx.restore();
    }
    ctx.restore();
    // center circle
    ctx.beginPath();
    ctx.arc(this.centerX, this.centerY, this.radius * 0.12, 0, Math.PI * 2);
    // Fill with background-like color; allow theme override by drawing over it in CSS if necessary
    ctx.fillStyle = '#ffffff';
    ctx.fill();
    ctx.lineWidth = Math.max(1, this.radius * 0.008);
    ctx.strokeStyle = 'rgba(0,0,0,0.06)';
    ctx.stroke();
    this.onDraw();
  }
  wrapText(ctx, text, x, y, maxWidth, lineHeight) {
    // A simple wrap for canvas text
    const words = String(text).split(' ');
    let line = '';
    let yOffset = y;
    for (let n = 0; n < words.length; n++) {
      const testLine = line + words[n] + ' ';
      const metrics = ctx.measureText(testLine);
      const testWidth = metrics.width;
      if (testWidth > maxWidth && n > 0) {
        ctx.fillText(line.trim(), x, yOffset);
        line = words[n] + ' ';
        yOffset += lineHeight;
      } else {
        line = testLine;
      }
    }
    ctx.fillText(line.trim(), x, yOffset);
  }
  degToRad(d) {
    return d * Math.PI / 180;
  }
  radToDeg(r) {
    return r * 180 / Math.PI;
  }
  getRandomIndex() {
    if (!this.names.length) return 0;
    return Math.floor(Math.random() * this.names.length);
  }
  // Spin such that the segment at `index` lands on the pointer at top.
  spinToIndex(index, opts = {}) {
    if (this._animating) return Promise.reject('Already animating');
    if (!this.names.length) return Promise.reject('No names');
    const n = this.names.length;
    const segAngle = 360 / n;
    // Normalize current rotation to [0, 360)
    const normalized = ((this.rotation % 360) + 360) % 360;
    // Center of segment i is at angle: (i * segAngle + segAngle/2)
    const centerAngle = index * segAngle + segAngle / 2;
    // We want (centerAngle + rotation) mod 360 = 270 (pointing upward if pointer is at top)
    let targetRotation = 270 - centerAngle;
    targetRotation = ((targetRotation % 360) + 360) % 360;
    const fullSpins = opts.fullSpins !== undefined ? opts.fullSpins : (3 + Math.floor(Math.random() * 3)); // 3-5 spins
    const endRotation = targetRotation + fullSpins * 360 + (opts.randomOffset || 0);
    const startRotation = normalized;
    const delta = endRotation - startRotation;
    const duration = opts.duration || 5000; // ms
    const startTime = performance.now();
    this._animating = true;
    return new Promise((resolve) => {
      const animate = (now) => {
        const elapsed = now - startTime;
        const t = Math.min(1, elapsed / duration);
        // ease out cubic
        const eased = 1 - Math.pow(1 - t, 3);
        const current = startRotation + delta * eased;
        this.rotation = current;
        this.draw();
        if (t < 1) {
          requestAnimationFrame(animate);
        } else {
          this._animating = false;
          // Normalize rotation to endRotation mod 360
          this.rotation = ((endRotation % 360) + 360) % 360;
          this.draw();
          resolve(index);
        }
      };
      requestAnimationFrame(animate);
    });
  }
}
```

main.js
```js
'''
DOCSTRING:
main.js
Wires UI to the Wheel class:
- loads themes.json (URL injected by Flask)
- populates theme selector
- reads names and updates wheel
- handles spin logic and result display
Includes robust fallback if fetching themes.json fails.
'''
/* DOM wiring and app logic */
document.addEventListener('DOMContentLoaded', async () => {
  const canvas = document.getElementById('wheel-canvas');
  const nameInput = document.getElementById('name-input');
  const addBtn = document.getElementById('add-name');
  const namesTextarea = document.getElementById('names-textarea');
  const spinBtn = document.getElementById('spin-btn');
  const resultDiv = document.getElementById('result');
  const themeSelect = document.getElementById('theme-select');
  const loadSampleBtn = document.getElementById('load-sample');
  const clearBtn = document.getElementById('clear-names');
  const importBtn = document.getElementById('import-names');
  const exportBtn = document.getElementById('export-names');
  const wheel = new Wheel(canvas, { names: [], colors: ['#ffb3b3','#ffd9b3','#fff3b3','#d9ffb3'] });
  let themes = [];
  // A small fallback theme set in case fetching themes.json fails.
  const defaultThemes = [
    {
      id: 'fallback',
      name: 'Default',
      bg: '#ffffff',
      text: '#222222',
      accent: '#007bff',
      colors: ['#ffb3b3','#ffd9b3','#fff3b3','#d9ffb3']
    }
  ];
  // Helper to populate theme selector
  function populateThemeSelector(list) {
    themeSelect.innerHTML = '';
    list.forEach(t => {
      const opt = document.createElement('option');
      opt.value = t.id;
      opt.textContent = t.name;
      themeSelect.appendChild(opt);
    });
  }
  // Load themes.json (URL injected by Flask)
  try {
    const themesUrl = window.THEMES_JSON_URL || '/static/themes.json';
    const resp = await fetch(themesUrl, {cache: 'no-cache'});
    if (!resp.ok) throw new Error('HTTP ' + resp.status);
    themes = await resp.json();
    if (!Array.isArray(themes) || themes.length === 0) throw new Error('No themes found');
    populateThemeSelector(themes);
    // apply first theme
    applyTheme(themes[0]);
    themeSelect.value = themes[0].id;
  } catch (err) {
    console.error('Failed to load themes:', err);
    // fallback
    themes = defaultThemes;
    populateThemeSelector(themes);
    applyTheme(themes[0]);
    themeSelect.value = themes[0].id;
  }
  function applyTheme(theme) {
    if (!theme) return;
    document.documentElement.style.setProperty('--bg', theme.bg || '#fff');
    document.documentElement.style.setProperty('--text', theme.text || '#222');
    document.documentElement.style.setProperty('--accent', theme.accent || '#007bff');
    // set panel bg slightly adjusted
    let panelBg = theme.bg;
    try {
      panelBg = lightenOrDarkenColor(theme.bg || '#fff', 18);
    } catch(e) {
      panelBg = '#f6f8fa';
    }
    document.documentElement.style.setProperty('--panel-bg', panelBg);
    wheel.setTheme({ colors: theme.colors || [], text: theme.text || '#222' });
    // recolor pointer (DOM element)
    const pointer = document.getElementById('pointer');
    if (pointer) pointer.style.color = theme.accent || '';
    // recolor spin button
    const spin = document.getElementById('spin-btn');
    if (spin) spin.style.background = theme.accent || '';
  }
  function lightenOrDarkenColor(col, amt) {
    // accepts #rgb or #rrggbb. amt can be negative to darken.
    if (typeof col !== 'string') throw new Error('Invalid color');
    let colStr = col.trim();
    if (colStr[0] === '#') colStr = colStr.slice(1);
    if (colStr.length === 3) {
      colStr = colStr.split('').map(c => c + c).join('');
    }
    if (colStr.length !== 6) throw new Error('Invalid hex color');
    const num = parseInt(colStr, 16);
    let r = (num >> 16) & 0xFF;
    let g = (num >> 8) & 0xFF;
    let b = num & 0xFF;
    r = Math.max(0, Math.min(255, r + amt));
    g = Math.max(0, Math.min(255, g + amt));
    b = Math.max(0, Math.min(255, b + amt));
    const newHex = '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
    return newHex;
  }
  themeSelect.addEventListener('change', () => {
    const id = themeSelect.value;
    const t = themes.find(x => x.id === id);
    if (t) applyTheme(t);
  });
  function parseNamesFromTextarea() {
    const lines = namesTextarea.value.split('\n').map(s => s.trim()).filter(s => s.length);
    return lines;
  }
  function updateWheelFromTextarea() {
    const names = parseNamesFromTextarea();
    wheel.setNames(names);
  }
  addBtn.addEventListener('click', () => {
    const v = nameInput.value.trim();
    if (!v) return;
    const cur = parseNamesFromTextarea();
    cur.push(v);
    namesTextarea.value = cur.join('\n');
    nameInput.value = '';
    updateWheelFromTextarea();
  });
  nameInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
      addBtn.click();
      e.preventDefault();
    }
  });
  namesTextarea.addEventListener('input', () => {
    updateWheelFromTextarea();
  });
  loadSampleBtn.addEventListener('click', () => {
    const sample = ['Alice','Bob','Charlie','Diana','Eva','Frank','George','Helen','Ivy','Jack'];
    namesTextarea.value = sample.join('\n');
    updateWheelFromTextarea();
  });
  clearBtn.addEventListener('click', () => {
    namesTextarea.value = '';
    updateWheelFromTextarea();
    resultDiv.classList.add('hidden');
  });
  importBtn.addEventListener('click', async () => {
    // prompt user for a newline separated list (simple)
    const data = prompt('Paste names (one per line):');
    if (data === null) return;
    namesTextarea.value = data.split('\n').map(s => s.trim()).filter(s => s).join('\n');
    updateWheelFromTextarea();
  });
  exportBtn.addEventListener('click', () => {
    const names = parseNamesFromTextarea();
    const blob = new Blob([names.join('\n')], {type: 'text/plain'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'names.txt';
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  });
  spinBtn.addEventListener('click', async () => {
    const names = parseNamesFromTextarea();
    if (names.length === 0) {
      alert('Please add at least one name.');
      return;
    }
    resultDiv.classList.add('hidden');
    spinBtn.disabled = true;
    spinBtn.textContent = 'Spinning...';
    // Ensure wheel has latest names before selecting index
    wheel.setNames(names);
    // pick random index
    const idx = wheel.getRandomIndex();
    try {
      const winnerIndex = await wheel.spinToIndex(idx, { duration: 4500 });
      const winner = names[winnerIndex];
      resultDiv.textContent = `Winner: ${winner}`;
      resultDiv.classList.remove('hidden');
      spinBtn.textContent = 'SPIN';
      spinBtn.disabled = false;
    } catch (err) {
      console.error(err);
      spinBtn.textContent = 'SPIN';
      spinBtn.disabled = false;
    }
  });
  // initial sample and initial canvas sizing
  namesTextarea.value = 'Alice\nBob\nCharlie\nDiana\nEva';
  updateWheelFromTextarea();
  // Ensure wheel draws crisply at startup and on resize
  function handleResize() {
    if (typeof wheel.resize === 'function') {
      wheel.resize();
    } else {
      // fallback: redraw
      wheel.draw();
    }
  }
  window.addEventListener('resize', handleResize);
  // Run a resize after a short delay to ensure layout settled
  setTimeout(handleResize, 50);
});
```

"

As the Programmer, you should write a requirements.txt file, which is commonly used in Python projects to specify the dependencies or packages required for the project to run properly. It serves as a way to document and manage the project's dependencies in a standardized format. For example:

requirements.txt

```

numpy==1.19.2

pandas>=1.1.4

```

According to the codes and file format listed above, write a requirements.txt file to specify the dependencies or packages required for the project to run properly.

[2025-17-09 14:10:44 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2025-17-09 14:10:44 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 6735
completion_tokens: 604
total_tokens: 7339
cost: $-1.000000


[2025-17-09 14:10:44 INFO] Programmer: **Programmer<->Chief Technology Officer on : EnvironmentDoc, turn 0**

[ChatDev is a software company powered by multiple intelligent agents, such as chief executive officer, chief human resources officer, chief product officer, chief technology officer, etc, with a multi-agent organizational structure and the mission of 'changing the digital world through programming'.
You are Chief Technology Officer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer.
You are very familiar to information technology. You will make high-level decisions for the overarching technology infrastructure that closely align with the organization's goals, while you work alongside the organization's information technology ("IT") staff members to perform everyday operations.
Here is a new customer's task: [Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes.].
To complete the task, You must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]

Flask>=2.0,<3.0
gunicorn>=20.1.0

[2025-17-09 14:10:44 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | [Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes.] |
| **assistant_role_name** | Chief Executive Officer |
| **user_role_name** | Counselor |
| **phase_prompt** | Here is a conversation between two roles: {conversations} {question} |
| **phase_name** | Reflection |
| **assistant_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully complete a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. To complete the task, I will give you one or more instructions, and you must help me to write a specific solution that appropriately solves the requested instruction based on your expertise and my needs. |
| **user_role_prompt** | {chatdev_prompt} You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer. Your main responsibilities include asking what user and customer think and provide your valuable suggestions.  Here is a new customer's task: {task}. To complete the task, I will give you one or more instructions, and you must help me to write a specific solution that appropriately solves the requested instruction based on your expertise and my needs. |
| **placeholders** | {'conversations': 'Programmer: ChatDev is a software company powered by multiple intelligent agents, such as chief executive officer, chief human resources officer, chief product officer, chief technology officer, etc, with a multi-agent organizational structure and the mission of \'changing the digital world through programming\'.\nYou are Programmer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer.\nYou can write/create computer software or applications by providing a specific programming language to the computer. You have extensive computing and coding experience in many varieties of programming languages and platforms, such as Python, Java, C, C++, HTML, CSS, JavaScript, XML, SQL, PHP, etc,.\nHere is a new customer\'s task: [Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes.].\nTo complete the task, you must write a response that appropriately solves the requested instruction based on your expertise and customer\'s needs.\n\nChief Technology Officer: The new user\'s task and our developed codes are listed: \nTask: "[Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes.]".\nModality: "website".\nProgramming Language: " Python"\nIdeas: ""\nCodes: \n"main.py\npython\n\'\'\'\nFlask application that serves the wheel-of-names web app.\nRun: pip install flask\nThen: python main.py\nAccess: http://127.0.0.1:5000/\n\'\'\'\nfrom flask import Flask, render_template\nimport os\ndef create_app():\n    """\n    Create and configure the Flask application.\n    Serves templates from \'templates\' and static files from \'static\'.\n    """\n    app = Flask(__name__, static_folder=\'static\', template_folder=\'templates\')\n    @app.route(\'/\')\n    def index():\n        """\n        Serve the main page.\n        """\n        return render_template(\'index.html\')\n    return app\nif __name__ == \'__main__\':\n    app = create_app()\n    port = int(os.environ.get(\'PORT\', 5000))\n    # debug=True for development; set to False in production\n    app.run(debug=True, host=\'0.0.0.0\', port=port)\n\nindex.html\nhtml\n\'\'\'\nDOCSTRING:\nMain HTML page for the Wheel of Names app.\nContains UI elements:\n- name input and list\n- canvas for wheel\n- theme selector\n- spin / clear / add buttons\nIncludes JS files wheel.js and main.js for behavior.\nAlso injects a dynamically generated URL for themes.json using Flask\'s url_for so the client can reliably fetch the resource even when the app is mounted under a subpath.\n\'\'\'\n&lt;!doctype html&gt;\n&lt;html lang="en"&gt;\n&lt;head&gt;\n  &lt;meta charset="utf-8"&gt;\n  &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;\n  &lt;title&gt;Wheel of Names&lt;/title&gt;\n  &lt;!-- Main stylesheet --&gt;\n  &lt;link rel="stylesheet" href="{{ url_for(\'static\', filename=\'css/styles.css\') }}"&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div class="container"&gt;\n    &lt;header&gt;\n      &lt;h1&gt;Wheel of Names&lt;/h1&gt;\n      &lt;p&gt;Enter names, choose a theme, and spin to pick a random winner.&lt;/p&gt;\n    &lt;/header&gt;\n    &lt;main class="main-grid"&gt;\n      &lt;section class="left-panel"&gt;\n        &lt;div class="controls"&gt;\n          &lt;label for="name-input"&gt;Add a name&lt;/label&gt;\n          &lt;div class="input-row"&gt;\n            &lt;input id="name-input" type="text" placeholder="Enter name and press Add" autocomplete="off"&gt;\n            &lt;button id="add-name" type="button"&gt;Add&lt;/button&gt;\n          &lt;/div&gt;\n          &lt;label for="names-textarea"&gt;Names (one per line)&lt;/label&gt;\n          &lt;textarea id="names-textarea" placeholder="Alice\\nBob\\nCharlie"&gt;&lt;/textarea&gt;\n          &lt;div class="buttons-row"&gt;\n            &lt;button id="load-sample" type="button"&gt;Load Sample&lt;/button&gt;\n            &lt;button id="clear-names" type="button"&gt;Clear&lt;/button&gt;\n            &lt;button id="import-names" type="button"&gt;Import&lt;/button&gt;\n            &lt;button id="export-names" type="button"&gt;Export&lt;/button&gt;\n          &lt;/div&gt;\n          &lt;label for="theme-select"&gt;Theme&lt;/label&gt;\n          &lt;select id="theme-select" aria-label="Theme selector"&gt;&lt;/select&gt;\n          &lt;div class="spin-controls"&gt;\n            &lt;button id="spin-btn" class="spin" type="button"&gt;SPIN&lt;/button&gt;\n            &lt;div id="result" class="result hidden" aria-live="polite"&gt;&lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      &lt;/section&gt;\n      &lt;section class="right-panel"&gt;\n        &lt;div class="wheel-wrapper" id="wheel-wrapper"&gt;\n          &lt;!-- Canvas will be scaled for high-DPI via JS --&gt;\n          &lt;canvas id="wheel-canvas" width="600" height="600" aria-label="Wheel of names"&gt;&lt;/canvas&gt;\n          &lt;div id="pointer" aria-hidden="true"&gt;â–¼&lt;/div&gt;\n        &lt;/div&gt;\n      &lt;/section&gt;\n    &lt;/main&gt;\n    &lt;footer&gt;\n      &lt;small&gt;Built with Flask + Canvas. Themes available.&lt;/small&gt;\n    &lt;/footer&gt;\n  &lt;/div&gt;\n  &lt;!-- Provide the correct URL for themes.json (generated by Flask).\n       This ensures the client can fetch themes.json even when the app is mounted under a prefix. --&gt;\n  &lt;script&gt;\n    window.THEMES_JSON_URL = "{{ url_for(\'static\', filename=\'themes.json\') }}";\n  &lt;/script&gt;\n  &lt;script src="{{ url_for(\'static\', filename=\'js/wheel.js\') }}"&gt;&lt;/script&gt;\n  &lt;script src="{{ url_for(\'static\', filename=\'js/main.js\') }}"&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\nthemes.json\njson\n\'\'\'\nDOCSTRING:\nList of themes available for the wheel.\nEach theme contains:\n- id: machine id\n- name: display name\n- bg: page background color\n- text: primary text color\n- accent: accent color used for pointer/button\n- colors: array of segment colors (will be cycled for segments)\n\'\'\'\n[\n  {\n    "id": "classic",\n    "name": "Classic",\n    "bg": "#ffffff",\n    "text": "#222222",\n    "accent": "#007bff",\n    "colors": ["#ffb3b3", "#ffd9b3", "#fff3b3", "#d9ffb3", "#b3ffd9", "#b3e6ff", "#c7b3ff", "#ffb3f2"]\n  },\n  {\n    "id": "dark",\n    "name": "Dark",\n    "bg": "#121212",\n    "text": "#f5f5f5",\n    "accent": "#ff6b6b",\n    "colors": ["#2e2e34", "#3a3a44", "#4a4a56", "#5a5a68", "#6a6a78", "#7a7a88"]\n  },\n  {\n    "id": "pastel",\n    "name": "Pastel",\n    "bg": "#f7f7ff",\n    "text": "#333333",\n    "accent": "#ff8c94",\n    "colors": ["#ffd1dc", "#fce1b4", "#e8ffd1", "#d1fff0", "#d1e7ff", "#e6d1ff"]\n  },\n  {\n    "id": "neon",\n    "name": "Neon",\n    "bg": "#0f0f13",\n    "text": "#eaff00",\n    "accent": "#00fff5",\n    "colors": ["#ff00ff", "#ff8c00", "#00ff00", "#00ffff", "#8c00ff", "#ff0066"]\n  }\n]\n\nstyles.css\ncss\n\'\'\'\nDOCSTRING:\nBase CSS for the Wheel of Names app.\nDefines layout, basic theme variables, and responsive styles.\n\'\'\'\n/* Base CSS and theme variables */\n:root{\n  --bg: #ffffff;\n  --text: #222222;\n  --accent: #007bff;\n  --panel-bg: #f6f8fa;\n}\n*{box-sizing:border-box}\nhtml,body{\n  height:100%;\n  margin:0;\n  font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;\n  background: var(--bg);\n  color: var(--text);\n}\n.container{\n  max-width:1100px;\n  margin:24px auto;\n  padding:16px;\n}\nheader{ text-align:center; margin-bottom:8px }\nh1{ margin:6px 0; font-size:28px }\np{ margin:0; color:var(--text); opacity:0.8 }\n.main-grid{\n  display:grid;\n  grid-template-columns: 360px 1fr;\n  gap:20px;\n  align-items:start;\n  margin-top:18px;\n}\n.left-panel{\n  background:var(--panel-bg);\n  padding:14px;\n  border-radius:8px;\n  box-shadow:0 4px 8px rgba(0,0,0,0.04);\n}\n.left-panel label{ display:block; margin-top:8px; font-weight:600; margin-bottom:6px }\n.input-row{ display:flex; gap:8px }\n.input-row input[type="text"]{\n  flex:1;\n  padding:8px 10px;\n  border-radius:6px;\n  border:1px solid #ddd;\n  background:white;\n  color:inherit;\n}\n.input-row button{\n  padding:8px 12px;\n  border-radius:6px;\n  background:var(--accent);\n  color:white;\n  border:none;\n  cursor:pointer;\n}\ntextarea{\n  width:100%;\n  min-height:160px;\n  padding:10px;\n  border-radius:8px;\n  border:1px solid #ddd;\n  resize:vertical;\n  background:white;\n  color:inherit;\n}\n.buttons-row{\n  display:flex;\n  gap:8px;\n  margin-top:8px;\n  flex-wrap:wrap;\n}\n.buttons-row button{\n  padding:8px 10px;\n  border-radius:6px;\n  border:1px solid #ccc;\n  background:transparent;\n  cursor:pointer;\n}\n.spin-controls{\n  display:flex;\n  gap:12px;\n  margin-top:16px;\n  align-items:center;\n}\n.spin{\n  padding:14px 24px;\n  background:var(--accent);\n  color:white;\n  font-weight:700;\n  border:none;\n  border-radius:10px;\n  cursor:pointer;\n  font-size:18px;\n}\n.result{\n  padding:10px 12px;\n  background:rgba(0,0,0,0.06);\n  border-radius:8px;\n}\n.hidden{ display:none }\n.right-panel{\n  display:flex;\n  align-items:center;\n  justify-content:center;\n  min-height:420px;\n}\n.wheel-wrapper{\n  position:relative;\n  width:600px;\n  height:600px;\n  display:flex;\n  align-items:center;\n  justify-content:center;\n  margin:auto;\n}\n#wheel-canvas{\n  border-radius:50%;\n  box-shadow: 0 12px 30px rgba(0,0,0,0.12);\n  background:transparent;\n  /* ensure the canvas element scales responsively in layout; the backing store will be adjusted in JS */\n  width:100%;\n  height:100%;\n  display:block;\n}\n#wheel-wrapper #pointer{\n  position:absolute;\n  top:18px;\n  left:50%;\n  transform:translateX(-50%);\n  font-size:40px;\n  color:var(--accent);\n  text-shadow:0 2px 4px rgba(0,0,0,0.2);\n  pointer-events:none;\n}\nfooter{ text-align:center; margin-top:16px; color:var(--text); opacity:0.7; }\n/* Responsive */\n@media (max-width:960px){\n  .main-grid{ grid-template-columns:1fr; }\n  .wheel-wrapper{ width:420px; height:420px; }\n  #wheel-canvas{ width:420px; height:420px; }\n}\n\nwheel.js\njs\n\'\'\'\nDOCSTRING:\nwheel.js\nContains a Wheel class that draws the wheel on a canvas and animates spins.\nKey methods:\n- constructor(canvas, options)\n- setNames(names)\n- setTheme(theme)\n- draw()\n- resize() -&gt; handle high-DPI displays\n- spinToIndex(index) -&gt; Promise resolves with index after animation\n- getRandomIndex()\n\'\'\'\n/* A small utility to requestAnimationFrame safely (browser-provided) */\nclass Wheel {\n  constructor(canvas, options = {}) {\n    this.canvas = canvas;\n    this.ctx = canvas.getContext(\'2d\');\n    this.names = options.names || [];\n    this.colors = options.colors || [\'#ffb3b3\', \'#ffd9b3\', \'#fff3b3\', \'#d9ffb3\', \'#b3ffd9\', \'#b3e6ff\'];\n    this.textColor = options.textColor || \'#222\';\n    this.rotation = 0; // degrees\n    this.font = options.font || \'16px Inter, Arial\';\n    this.onDraw = options.onDraw || function(){};\n    this._animating = false;\n    // Set up high-DPI friendly canvas and metrics\n    this.resize();\n    // Redraw once created\n    this.draw();\n    // Optional: handle container resize via ResizeObserver if available\n    if (window.ResizeObserver) {\n      try {\n        const ro = new ResizeObserver(() =&gt; this.resize());\n        ro.observe(this.canvas.parentElement || this.canvas);\n        this._resizeObserver = ro;\n      } catch (e) {\n        // ignore\n      }\n    } else {\n      window.addEventListener(\'resize\', () =&gt; this.resize());\n    }\n  }\n  resize() {\n    // Make the canvas crisp on high-DPI screens.\n    const dpr = window.devicePixelRatio || 1;\n    const rect = this.canvas.getBoundingClientRect();\n    // Fallback to element width/height attributes if bounding rect is 0\n    const cssWidth = rect.width || this.canvas.clientWidth || this.canvas.width / (dpr || 1);\n    const cssHeight = rect.height || this.canvas.clientHeight || this.canvas.height / (dpr || 1);\n    // Set backing store size\n    this.canvas.width = Math.max(1, Math.round(cssWidth * dpr));\n    this.canvas.height = Math.max(1, Math.round(cssHeight * dpr));\n    // Keep CSS size consistent\n    this.canvas.style.width = cssWidth + \'px\';\n    this.canvas.style.height = cssHeight + \'px\';\n    // Reset transform so we can set a scale for dpr\n    this.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n    // Use CSS pixel coordinates for drawing from now on\n    this.centerX = cssWidth / 2;\n    this.centerY = cssHeight / 2;\n    this.radius = Math.min(cssWidth, cssHeight) / 2 - 10;\n    // Recompute font size based on canvas size to keep labels legible\n    // If user supplied a font (with px), keep it; otherwise set a sensible value.\n    if (!this.font || typeof this.font !== \'string\') {\n      this.font = Math.max(12, Math.round(this.radius * 0.06)) + \'px Inter, Arial\';\n    } else {\n      // keep user\'s font but ensure text scale reasonable\n      // (we don\'t attempt to parse px here; leaving as provided)\n    }\n    this.draw();\n  }\n  setNames(names) {\n    this.names = names.slice();\n    this.draw();\n  }\n  setTheme(theme) {\n    if (!theme) return;\n    if (theme.colors &amp;&amp; theme.colors.length) this.colors = theme.colors.slice();\n    if (theme.text) this.textColor = theme.text;\n    this.draw();\n  }\n  clearCanvas() {\n    // Clear the visible canvas area (CSS pixels)\n    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n  }\n  draw() {\n    this.clearCanvas();\n    const ctx = this.ctx;\n    const n = Math.max(1, this.names.length);\n    const seg = 360 / n;\n    ctx.save();\n    // Translate to center using CSS pixel coordinates\n    ctx.translate(this.centerX, this.centerY);\n    ctx.rotate(this.degToRad(this.rotation));\n    // Draw segments\n    for (let i = 0; i &lt; n; i++) {\n      const start = this.degToRad(i * seg);\n      const end = this.degToRad((i + 1) * seg);\n      ctx.beginPath();\n      ctx.moveTo(0, 0);\n      ctx.arc(0, 0, this.radius, start, end);\n      ctx.closePath();\n      ctx.fillStyle = this.colors[i % this.colors.length];\n      ctx.fill();\n      // stroke\n      ctx.lineWidth = Math.max(1, this.radius * 0.008);\n      ctx.strokeStyle = \'rgba(0,0,0,0.08)\';\n      ctx.stroke();\n      // Draw label\n      ctx.save();\n      const angle = start + (end - start) / 2;\n      ctx.rotate(angle);\n      ctx.translate(this.radius * 0.55, 0);\n      ctx.rotate(Math.PI / 2);\n      ctx.fillStyle = this.textColor;\n      // Set font size relative to radius if not provided precisely\n      ctx.font = this.font;\n      ctx.textAlign = \'center\';\n      ctx.textBaseline = \'middle\';\n      const name = this.names[i] || \'\';\n      this.wrapText(ctx, name, 0, 0, this.radius * 0.35, parseInt(Math.max(12, this.radius * 0.06), 10));\n      ctx.restore();\n    }\n    ctx.restore();\n    // center circle\n    ctx.beginPath();\n    ctx.arc(this.centerX, this.centerY, this.radius * 0.12, 0, Math.PI * 2);\n    // Fill with background-like color; allow theme override by drawing over it in CSS if necessary\n    ctx.fillStyle = \'#ffffff\';\n    ctx.fill();\n    ctx.lineWidth = Math.max(1, this.radius * 0.008);\n    ctx.strokeStyle = \'rgba(0,0,0,0.06)\';\n    ctx.stroke();\n    this.onDraw();\n  }\n  wrapText(ctx, text, x, y, maxWidth, lineHeight) {\n    // A simple wrap for canvas text\n    const words = String(text).split(\' \');\n    let line = \'\';\n    let yOffset = y;\n    for (let n = 0; n &lt; words.length; n++) {\n      const testLine = line + words[n] + \' \';\n      const metrics = ctx.measureText(testLine);\n      const testWidth = metrics.width;\n      if (testWidth &gt; maxWidth &amp;&amp; n &gt; 0) {\n        ctx.fillText(line.trim(), x, yOffset);\n        line = words[n] + \' \';\n        yOffset += lineHeight;\n      } else {\n        line = testLine;\n      }\n    }\n    ctx.fillText(line.trim(), x, yOffset);\n  }\n  degToRad(d) {\n    return d * Math.PI / 180;\n  }\n  radToDeg(r) {\n    return r * 180 / Math.PI;\n  }\n  getRandomIndex() {\n    if (!this.names.length) return 0;\n    return Math.floor(Math.random() * this.names.length);\n  }\n  // Spin such that the segment at `index` lands on the pointer at top.\n  spinToIndex(index, opts = {}) {\n    if (this._animating) return Promise.reject(\'Already animating\');\n    if (!this.names.length) return Promise.reject(\'No names\');\n    const n = this.names.length;\n    const segAngle = 360 / n;\n    // Normalize current rotation to [0, 360)\n    const normalized = ((this.rotation % 360) + 360) % 360;\n    // Center of segment i is at angle: (i * segAngle + segAngle/2)\n    const centerAngle = index * segAngle + segAngle / 2;\n    // We want (centerAngle + rotation) mod 360 = 270 (pointing upward if pointer is at top)\n    let targetRotation = 270 - centerAngle;\n    targetRotation = ((targetRotation % 360) + 360) % 360;\n    const fullSpins = opts.fullSpins !== undefined ? opts.fullSpins : (3 + Math.floor(Math.random() * 3)); // 3-5 spins\n    const endRotation = targetRotation + fullSpins * 360 + (opts.randomOffset || 0);\n    const startRotation = normalized;\n    const delta = endRotation - startRotation;\n    const duration = opts.duration || 5000; // ms\n    const startTime = performance.now();\n    this._animating = true;\n    return new Promise((resolve) =&gt; {\n      const animate = (now) =&gt; {\n        const elapsed = now - startTime;\n        const t = Math.min(1, elapsed / duration);\n        // ease out cubic\n        const eased = 1 - Math.pow(1 - t, 3);\n        const current = startRotation + delta * eased;\n        this.rotation = current;\n        this.draw();\n        if (t &lt; 1) {\n          requestAnimationFrame(animate);\n        } else {\n          this._animating = false;\n          // Normalize rotation to endRotation mod 360\n          this.rotation = ((endRotation % 360) + 360) % 360;\n          this.draw();\n          resolve(index);\n        }\n      };\n      requestAnimationFrame(animate);\n    });\n  }\n}\n\nmain.js\njs\n\'\'\'\nDOCSTRING:\nmain.js\nWires UI to the Wheel class:\n- loads themes.json (URL injected by Flask)\n- populates theme selector\n- reads names and updates wheel\n- handles spin logic and result display\nIncludes robust fallback if fetching themes.json fails.\n\'\'\'\n/* DOM wiring and app logic */\ndocument.addEventListener(\'DOMContentLoaded\', async () =&gt; {\n  const canvas = document.getElementById(\'wheel-canvas\');\n  const nameInput = document.getElementById(\'name-input\');\n  const addBtn = document.getElementById(\'add-name\');\n  const namesTextarea = document.getElementById(\'names-textarea\');\n  const spinBtn = document.getElementById(\'spin-btn\');\n  const resultDiv = document.getElementById(\'result\');\n  const themeSelect = document.getElementById(\'theme-select\');\n  const loadSampleBtn = document.getElementById(\'load-sample\');\n  const clearBtn = document.getElementById(\'clear-names\');\n  const importBtn = document.getElementById(\'import-names\');\n  const exportBtn = document.getElementById(\'export-names\');\n  const wheel = new Wheel(canvas, { names: [], colors: [\'#ffb3b3\',\'#ffd9b3\',\'#fff3b3\',\'#d9ffb3\'] });\n  let themes = [];\n  // A small fallback theme set in case fetching themes.json fails.\n  const defaultThemes = [\n    {\n      id: \'fallback\',\n      name: \'Default\',\n      bg: \'#ffffff\',\n      text: \'#222222\',\n      accent: \'#007bff\',\n      colors: [\'#ffb3b3\',\'#ffd9b3\',\'#fff3b3\',\'#d9ffb3\']\n    }\n  ];\n  // Helper to populate theme selector\n  function populateThemeSelector(list) {\n    themeSelect.innerHTML = \'\';\n    list.forEach(t =&gt; {\n      const opt = document.createElement(\'option\');\n      opt.value = t.id;\n      opt.textContent = t.name;\n      themeSelect.appendChild(opt);\n    });\n  }\n  // Load themes.json (URL injected by Flask)\n  try {\n    const themesUrl = window.THEMES_JSON_URL || \'/static/themes.json\';\n    const resp = await fetch(themesUrl, {cache: \'no-cache\'});\n    if (!resp.ok) throw new Error(\'HTTP \' + resp.status);\n    themes = await resp.json();\n    if (!Array.isArray(themes) || themes.length === 0) throw new Error(\'No themes found\');\n    populateThemeSelector(themes);\n    // apply first theme\n    applyTheme(themes[0]);\n    themeSelect.value = themes[0].id;\n  } catch (err) {\n    console.error(\'Failed to load themes:\', err);\n    // fallback\n    themes = defaultThemes;\n    populateThemeSelector(themes);\n    applyTheme(themes[0]);\n    themeSelect.value = themes[0].id;\n  }\n  function applyTheme(theme) {\n    if (!theme) return;\n    document.documentElement.style.setProperty(\'--bg\', theme.bg || \'#fff\');\n    document.documentElement.style.setProperty(\'--text\', theme.text || \'#222\');\n    document.documentElement.style.setProperty(\'--accent\', theme.accent || \'#007bff\');\n    // set panel bg slightly adjusted\n    let panelBg = theme.bg;\n    try {\n      panelBg = lightenOrDarkenColor(theme.bg || \'#fff\', 18);\n    } catch(e) {\n      panelBg = \'#f6f8fa\';\n    }\n    document.documentElement.style.setProperty(\'--panel-bg\', panelBg);\n    wheel.setTheme({ colors: theme.colors || [], text: theme.text || \'#222\' });\n    // recolor pointer (DOM element)\n    const pointer = document.getElementById(\'pointer\');\n    if (pointer) pointer.style.color = theme.accent || \'\';\n    // recolor spin button\n    const spin = document.getElementById(\'spin-btn\');\n    if (spin) spin.style.background = theme.accent || \'\';\n  }\n  function lightenOrDarkenColor(col, amt) {\n    // accepts #rgb or #rrggbb. amt can be negative to darken.\n    if (typeof col !== \'string\') throw new Error(\'Invalid color\');\n    let colStr = col.trim();\n    if (colStr[0] === \'#\') colStr = colStr.slice(1);\n    if (colStr.length === 3) {\n      colStr = colStr.split(\'\').map(c =&gt; c + c).join(\'\');\n    }\n    if (colStr.length !== 6) throw new Error(\'Invalid hex color\');\n    const num = parseInt(colStr, 16);\n    let r = (num &gt;&gt; 16) &amp; 0xFF;\n    let g = (num &gt;&gt; 8) &amp; 0xFF;\n    let b = num &amp; 0xFF;\n    r = Math.max(0, Math.min(255, r + amt));\n    g = Math.max(0, Math.min(255, g + amt));\n    b = Math.max(0, Math.min(255, b + amt));\n    const newHex = \'#\' + ((1 &lt;&lt; 24) + (r &lt;&lt; 16) + (g &lt;&lt; 8) + b).toString(16).slice(1);\n    return newHex;\n  }\n  themeSelect.addEventListener(\'change\', () =&gt; {\n    const id = themeSelect.value;\n    const t = themes.find(x =&gt; x.id === id);\n    if (t) applyTheme(t);\n  });\n  function parseNamesFromTextarea() {\n    const lines = namesTextarea.value.split(\'\\n\').map(s =&gt; s.trim()).filter(s =&gt; s.length);\n    return lines;\n  }\n  function updateWheelFromTextarea() {\n    const names = parseNamesFromTextarea();\n    wheel.setNames(names);\n  }\n  addBtn.addEventListener(\'click\', () =&gt; {\n    const v = nameInput.value.trim();\n    if (!v) return;\n    const cur = parseNamesFromTextarea();\n    cur.push(v);\n    namesTextarea.value = cur.join(\'\\n\');\n    nameInput.value = \'\';\n    updateWheelFromTextarea();\n  });\n  nameInput.addEventListener(\'keydown\', (e) =&gt; {\n    if (e.key === \'Enter\') {\n      addBtn.click();\n      e.preventDefault();\n    }\n  });\n  namesTextarea.addEventListener(\'input\', () =&gt; {\n    updateWheelFromTextarea();\n  });\n  loadSampleBtn.addEventListener(\'click\', () =&gt; {\n    const sample = [\'Alice\',\'Bob\',\'Charlie\',\'Diana\',\'Eva\',\'Frank\',\'George\',\'Helen\',\'Ivy\',\'Jack\'];\n    namesTextarea.value = sample.join(\'\\n\');\n    updateWheelFromTextarea();\n  });\n  clearBtn.addEventListener(\'click\', () =&gt; {\n    namesTextarea.value = \'\';\n    updateWheelFromTextarea();\n    resultDiv.classList.add(\'hidden\');\n  });\n  importBtn.addEventListener(\'click\', async () =&gt; {\n    // prompt user for a newline separated list (simple)\n    const data = prompt(\'Paste names (one per line):\');\n    if (data === null) return;\n    namesTextarea.value = data.split(\'\\n\').map(s =&gt; s.trim()).filter(s =&gt; s).join(\'\\n\');\n    updateWheelFromTextarea();\n  });\n  exportBtn.addEventListener(\'click\', () =&gt; {\n    const names = parseNamesFromTextarea();\n    const blob = new Blob([names.join(\'\\n\')], {type: \'text/plain\'});\n    const url = URL.createObjectURL(blob);\n    const a = document.createElement(\'a\');\n    a.href = url;\n    a.download = \'names.txt\';\n    document.body.appendChild(a);\n    a.click();\n    a.remove();\n    URL.revokeObjectURL(url);\n  });\n  spinBtn.addEventListener(\'click\', async () =&gt; {\n    const names = parseNamesFromTextarea();\n    if (names.length === 0) {\n      alert(\'Please add at least one name.\');\n      return;\n    }\n    resultDiv.classList.add(\'hidden\');\n    spinBtn.disabled = true;\n    spinBtn.textContent = \'Spinning...\';\n    // Ensure wheel has latest names before selecting index\n    wheel.setNames(names);\n    // pick random index\n    const idx = wheel.getRandomIndex();\n    try {\n      const winnerIndex = await wheel.spinToIndex(idx, { duration: 4500 });\n      const winner = names[winnerIndex];\n      resultDiv.textContent = `Winner: ${winner}`;\n      resultDiv.classList.remove(\'hidden\');\n      spinBtn.textContent = \'SPIN\';\n      spinBtn.disabled = false;\n    } catch (err) {\n      console.error(err);\n      spinBtn.textContent = \'SPIN\';\n      spinBtn.disabled = false;\n    }\n  });\n  // initial sample and initial canvas sizing\n  namesTextarea.value = \'Alice\\nBob\\nCharlie\\nDiana\\nEva\';\n  updateWheelFromTextarea();\n  // Ensure wheel draws crisply at startup and on resize\n  function handleResize() {\n    if (typeof wheel.resize === \'function\') {\n      wheel.resize();\n    } else {\n      // fallback: redraw\n      wheel.draw();\n    }\n  }\n  window.addEventListener(\'resize\', handleResize);\n  // Run a resize after a short delay to ensure layout settled\n  setTimeout(handleResize, 50);\n});\n\n"\nAs the Programmer, you should write a requirements.txt file, which is commonly used in Python projects to specify the dependencies or packages required for the project to run properly. It serves as a way to document and manage the project\'s dependencies in a standardized format. For example:\nrequirements.txt\n\nnumpy==1.19.2\npandas&gt;=1.1.4\n\nAccording to the codes and file format listed above, write a requirements.txt file to specify the dependencies or packages required for the project to run properly.\n\nProgrammer: Flask&gt;=2.0,&lt;3.0\ngunicorn&gt;=20.1.0', 'question': 'According to the codes and file format listed above, write a requirements.txt file to specify the dependencies or packages required for the project to run properly." '} |
| **need_reflect** | False |
| **memory** | No existed memory |
| **chat_turn_limit** | 1 |
| **model_type** | ModelType.GPT_3_5_TURBO |

[2025-17-09 14:10:44 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Chief Executive Officer |
| **user_role_name** | Counselor |
| **assistant_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully complete a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. To complete the task, I will give you one or more instructions, and you must help me to write a specific solution that appropriately solves the requested instruction based on your expertise and my needs. |
| **user_role_prompt** | {chatdev_prompt} You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer. Your main responsibilities include asking what user and customer think and provide your valuable suggestions.  Here is a new customer's task: {task}. To complete the task, I will give you one or more instructions, and you must help me to write a specific solution that appropriately solves the requested instruction based on your expertise and my needs. |
| **task_prompt** | [Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes.] |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_3_5_TURBO |
| **background_prompt** | ChatDev is a software company powered by multiple intelligent agents, such as chief executive officer, chief human resources officer, chief product officer, chief technology officer, etc, with a multi-agent organizational structure and the mission of 'changing the digital world through programming'. |

[2025-17-09 14:10:44 INFO] Counselor: **[Start Chat]**

[ChatDev is a software company powered by multiple intelligent agents, such as chief executive officer, chief human resources officer, chief product officer, chief technology officer, etc, with a multi-agent organizational structure and the mission of 'changing the digital world through programming'.
You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully complete a task assigned by a new customer.
Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees.
Here is a new customer's task: [Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes.].
To complete the task, I will give you one or more instructions, and you must help me to write a specific solution that appropriately solves the requested instruction based on your expertise and my needs.]

Here is a conversation between two roles: Programmer: ChatDev is a software company powered by multiple intelligent agents, such as chief executive officer, chief human resources officer, chief product officer, chief technology officer, etc, with a multi-agent organizational structure and the mission of 'changing the digital world through programming'.
You are Programmer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer.
You can write/create computer software or applications by providing a specific programming language to the computer. You have extensive computing and coding experience in many varieties of programming languages and platforms, such as Python, Java, C, C++, HTML, CSS, JavaScript, XML, SQL, PHP, etc,.
Here is a new customer's task: [Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes.].
To complete the task, you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.

Chief Technology Officer: The new user's task and our developed codes are listed: 
Task: "[Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes.]".
Modality: "website".
Programming Language: " Python"
Ideas: ""
Codes: 
"main.py
```python
'''
Flask application that serves the wheel-of-names web app.
Run: pip install flask
Then: python main.py
Access: http://127.0.0.1:5000/
'''
from flask import Flask, render_template
import os
def create_app():
    """
    Create and configure the Flask application.
    Serves templates from 'templates' and static files from 'static'.
    """
    app = Flask(__name__, static_folder='static', template_folder='templates')
    @app.route('/')
    def index():
        """
        Serve the main page.
        """
        return render_template('index.html')
    return app
if __name__ == '__main__':
    app = create_app()
    port = int(os.environ.get('PORT', 5000))
    # debug=True for development; set to False in production
    app.run(debug=True, host='0.0.0.0', port=port)
```
index.html
```html
'''
DOCSTRING:
Main HTML page for the Wheel of Names app.
Contains UI elements:
- name input and list
- canvas for wheel
- theme selector
- spin / clear / add buttons
Includes JS files wheel.js and main.js for behavior.
Also injects a dynamically generated URL for themes.json using Flask's url_for so the client can reliably fetch the resource even when the app is mounted under a subpath.
'''
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Wheel of Names</title>
  <!-- Main stylesheet -->
  <link rel="stylesheet" href="{{ url_for('static', filename='css/styles.css') }}">
</head>
<body>
  <div class="container">
    <header>
      <h1>Wheel of Names</h1>
      <p>Enter names, choose a theme, and spin to pick a random winner.</p>
    </header>
    <main class="main-grid">
      <section class="left-panel">
        <div class="controls">
          <label for="name-input">Add a name</label>
          <div class="input-row">
            <input id="name-input" type="text" placeholder="Enter name and press Add" autocomplete="off">
            <button id="add-name" type="button">Add</button>
          </div>
          <label for="names-textarea">Names (one per line)</label>
          <textarea id="names-textarea" placeholder="Alice\nBob\nCharlie"></textarea>
          <div class="buttons-row">
            <button id="load-sample" type="button">Load Sample</button>
            <button id="clear-names" type="button">Clear</button>
            <button id="import-names" type="button">Import</button>
            <button id="export-names" type="button">Export</button>
          </div>
          <label for="theme-select">Theme</label>
          <select id="theme-select" aria-label="Theme selector"></select>
          <div class="spin-controls">
            <button id="spin-btn" class="spin" type="button">SPIN</button>
            <div id="result" class="result hidden" aria-live="polite"></div>
          </div>
        </div>
      </section>
      <section class="right-panel">
        <div class="wheel-wrapper" id="wheel-wrapper">
          <!-- Canvas will be scaled for high-DPI via JS -->
          <canvas id="wheel-canvas" width="600" height="600" aria-label="Wheel of names"></canvas>
          <div id="pointer" aria-hidden="true">â–¼</div>
        </div>
      </section>
    </main>
    <footer>
      <small>Built with Flask + Canvas. Themes available.</small>
    </footer>
  </div>
  <!-- Provide the correct URL for themes.json (generated by Flask).
       This ensures the client can fetch themes.json even when the app is mounted under a prefix. -->
  <script>
    window.THEMES_JSON_URL = "{{ url_for('static', filename='themes.json') }}";
  </script>
  <script src="{{ url_for('static', filename='js/wheel.js') }}"></script>
  <script src="{{ url_for('static', filename='js/main.js') }}"></script>
</body>
</html>
```
themes.json
```json
'''
DOCSTRING:
List of themes available for the wheel.
Each theme contains:
- id: machine id
- name: display name
- bg: page background color
- text: primary text color
- accent: accent color used for pointer/button
- colors: array of segment colors (will be cycled for segments)
'''
[
  {
    "id": "classic",
    "name": "Classic",
    "bg": "#ffffff",
    "text": "#222222",
    "accent": "#007bff",
    "colors": ["#ffb3b3", "#ffd9b3", "#fff3b3", "#d9ffb3", "#b3ffd9", "#b3e6ff", "#c7b3ff", "#ffb3f2"]
  },
  {
    "id": "dark",
    "name": "Dark",
    "bg": "#121212",
    "text": "#f5f5f5",
    "accent": "#ff6b6b",
    "colors": ["#2e2e34", "#3a3a44", "#4a4a56", "#5a5a68", "#6a6a78", "#7a7a88"]
  },
  {
    "id": "pastel",
    "name": "Pastel",
    "bg": "#f7f7ff",
    "text": "#333333",
    "accent": "#ff8c94",
    "colors": ["#ffd1dc", "#fce1b4", "#e8ffd1", "#d1fff0", "#d1e7ff", "#e6d1ff"]
  },
  {
    "id": "neon",
    "name": "Neon",
    "bg": "#0f0f13",
    "text": "#eaff00",
    "accent": "#00fff5",
    "colors": ["#ff00ff", "#ff8c00", "#00ff00", "#00ffff", "#8c00ff", "#ff0066"]
  }
]
```
styles.css
```css
'''
DOCSTRING:
Base CSS for the Wheel of Names app.
Defines layout, basic theme variables, and responsive styles.
'''
/* Base CSS and theme variables */
:root{
  --bg: #ffffff;
  --text: #222222;
  --accent: #007bff;
  --panel-bg: #f6f8fa;
}
*{box-sizing:border-box}
html,body{
  height:100%;
  margin:0;
  font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
  background: var(--bg);
  color: var(--text);
}
.container{
  max-width:1100px;
  margin:24px auto;
  padding:16px;
}
header{ text-align:center; margin-bottom:8px }
h1{ margin:6px 0; font-size:28px }
p{ margin:0; color:var(--text); opacity:0.8 }
.main-grid{
  display:grid;
  grid-template-columns: 360px 1fr;
  gap:20px;
  align-items:start;
  margin-top:18px;
}
.left-panel{
  background:var(--panel-bg);
  padding:14px;
  border-radius:8px;
  box-shadow:0 4px 8px rgba(0,0,0,0.04);
}
.left-panel label{ display:block; margin-top:8px; font-weight:600; margin-bottom:6px }
.input-row{ display:flex; gap:8px }
.input-row input[type="text"]{
  flex:1;
  padding:8px 10px;
  border-radius:6px;
  border:1px solid #ddd;
  background:white;
  color:inherit;
}
.input-row button{
  padding:8px 12px;
  border-radius:6px;
  background:var(--accent);
  color:white;
  border:none;
  cursor:pointer;
}
textarea{
  width:100%;
  min-height:160px;
  padding:10px;
  border-radius:8px;
  border:1px solid #ddd;
  resize:vertical;
  background:white;
  color:inherit;
}
.buttons-row{
  display:flex;
  gap:8px;
  margin-top:8px;
  flex-wrap:wrap;
}
.buttons-row button{
  padding:8px 10px;
  border-radius:6px;
  border:1px solid #ccc;
  background:transparent;
  cursor:pointer;
}
.spin-controls{
  display:flex;
  gap:12px;
  margin-top:16px;
  align-items:center;
}
.spin{
  padding:14px 24px;
  background:var(--accent);
  color:white;
  font-weight:700;
  border:none;
  border-radius:10px;
  cursor:pointer;
  font-size:18px;
}
.result{
  padding:10px 12px;
  background:rgba(0,0,0,0.06);
  border-radius:8px;
}
.hidden{ display:none }
.right-panel{
  display:flex;
  align-items:center;
  justify-content:center;
  min-height:420px;
}
.wheel-wrapper{
  position:relative;
  width:600px;
  height:600px;
  display:flex;
  align-items:center;
  justify-content:center;
  margin:auto;
}
#wheel-canvas{
  border-radius:50%;
  box-shadow: 0 12px 30px rgba(0,0,0,0.12);
  background:transparent;
  /* ensure the canvas element scales responsively in layout; the backing store will be adjusted in JS */
  width:100%;
  height:100%;
  display:block;
}
#wheel-wrapper #pointer{
  position:absolute;
  top:18px;
  left:50%;
  transform:translateX(-50%);
  font-size:40px;
  color:var(--accent);
  text-shadow:0 2px 4px rgba(0,0,0,0.2);
  pointer-events:none;
}
footer{ text-align:center; margin-top:16px; color:var(--text); opacity:0.7; }
/* Responsive */
@media (max-width:960px){
  .main-grid{ grid-template-columns:1fr; }
  .wheel-wrapper{ width:420px; height:420px; }
  #wheel-canvas{ width:420px; height:420px; }
}
```
wheel.js
```js
'''
DOCSTRING:
wheel.js
Contains a Wheel class that draws the wheel on a canvas and animates spins.
Key methods:
- constructor(canvas, options)
- setNames(names)
- setTheme(theme)
- draw()
- resize() -> handle high-DPI displays
- spinToIndex(index) -> Promise resolves with index after animation
- getRandomIndex()
'''
/* A small utility to requestAnimationFrame safely (browser-provided) */
class Wheel {
  constructor(canvas, options = {}) {
    this.canvas = canvas;
    this.ctx = canvas.getContext('2d');
    this.names = options.names || [];
    this.colors = options.colors || ['#ffb3b3', '#ffd9b3', '#fff3b3', '#d9ffb3', '#b3ffd9', '#b3e6ff'];
    this.textColor = options.textColor || '#222';
    this.rotation = 0; // degrees
    this.font = options.font || '16px Inter, Arial';
    this.onDraw = options.onDraw || function(){};
    this._animating = false;
    // Set up high-DPI friendly canvas and metrics
    this.resize();
    // Redraw once created
    this.draw();
    // Optional: handle container resize via ResizeObserver if available
    if (window.ResizeObserver) {
      try {
        const ro = new ResizeObserver(() => this.resize());
        ro.observe(this.canvas.parentElement || this.canvas);
        this._resizeObserver = ro;
      } catch (e) {
        // ignore
      }
    } else {
      window.addEventListener('resize', () => this.resize());
    }
  }
  resize() {
    // Make the canvas crisp on high-DPI screens.
    const dpr = window.devicePixelRatio || 1;
    const rect = this.canvas.getBoundingClientRect();
    // Fallback to element width/height attributes if bounding rect is 0
    const cssWidth = rect.width || this.canvas.clientWidth || this.canvas.width / (dpr || 1);
    const cssHeight = rect.height || this.canvas.clientHeight || this.canvas.height / (dpr || 1);
    // Set backing store size
    this.canvas.width = Math.max(1, Math.round(cssWidth * dpr));
    this.canvas.height = Math.max(1, Math.round(cssHeight * dpr));
    // Keep CSS size consistent
    this.canvas.style.width = cssWidth + 'px';
    this.canvas.style.height = cssHeight + 'px';
    // Reset transform so we can set a scale for dpr
    this.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    // Use CSS pixel coordinates for drawing from now on
    this.centerX = cssWidth / 2;
    this.centerY = cssHeight / 2;
    this.radius = Math.min(cssWidth, cssHeight) / 2 - 10;
    // Recompute font size based on canvas size to keep labels legible
    // If user supplied a font (with px), keep it; otherwise set a sensible value.
    if (!this.font || typeof this.font !== 'string') {
      this.font = Math.max(12, Math.round(this.radius * 0.06)) + 'px Inter, Arial';
    } else {
      // keep user's font but ensure text scale reasonable
      // (we don't attempt to parse px here; leaving as provided)
    }
    this.draw();
  }
  setNames(names) {
    this.names = names.slice();
    this.draw();
  }
  setTheme(theme) {
    if (!theme) return;
    if (theme.colors && theme.colors.length) this.colors = theme.colors.slice();
    if (theme.text) this.textColor = theme.text;
    this.draw();
  }
  clearCanvas() {
    // Clear the visible canvas area (CSS pixels)
    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
  }
  draw() {
    this.clearCanvas();
    const ctx = this.ctx;
    const n = Math.max(1, this.names.length);
    const seg = 360 / n;
    ctx.save();
    // Translate to center using CSS pixel coordinates
    ctx.translate(this.centerX, this.centerY);
    ctx.rotate(this.degToRad(this.rotation));
    // Draw segments
    for (let i = 0; i < n; i++) {
      const start = this.degToRad(i * seg);
      const end = this.degToRad((i + 1) * seg);
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.arc(0, 0, this.radius, start, end);
      ctx.closePath();
      ctx.fillStyle = this.colors[i % this.colors.length];
      ctx.fill();
      // stroke
      ctx.lineWidth = Math.max(1, this.radius * 0.008);
      ctx.strokeStyle = 'rgba(0,0,0,0.08)';
      ctx.stroke();
      // Draw label
      ctx.save();
      const angle = start + (end - start) / 2;
      ctx.rotate(angle);
      ctx.translate(this.radius * 0.55, 0);
      ctx.rotate(Math.PI / 2);
      ctx.fillStyle = this.textColor;
      // Set font size relative to radius if not provided precisely
      ctx.font = this.font;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      const name = this.names[i] || '';
      this.wrapText(ctx, name, 0, 0, this.radius * 0.35, parseInt(Math.max(12, this.radius * 0.06), 10));
      ctx.restore();
    }
    ctx.restore();
    // center circle
    ctx.beginPath();
    ctx.arc(this.centerX, this.centerY, this.radius * 0.12, 0, Math.PI * 2);
    // Fill with background-like color; allow theme override by drawing over it in CSS if necessary
    ctx.fillStyle = '#ffffff';
    ctx.fill();
    ctx.lineWidth = Math.max(1, this.radius * 0.008);
    ctx.strokeStyle = 'rgba(0,0,0,0.06)';
    ctx.stroke();
    this.onDraw();
  }
  wrapText(ctx, text, x, y, maxWidth, lineHeight) {
    // A simple wrap for canvas text
    const words = String(text).split(' ');
    let line = '';
    let yOffset = y;
    for (let n = 0; n < words.length; n++) {
      const testLine = line + words[n] + ' ';
      const metrics = ctx.measureText(testLine);
      const testWidth = metrics.width;
      if (testWidth > maxWidth && n > 0) {
        ctx.fillText(line.trim(), x, yOffset);
        line = words[n] + ' ';
        yOffset += lineHeight;
      } else {
        line = testLine;
      }
    }
    ctx.fillText(line.trim(), x, yOffset);
  }
  degToRad(d) {
    return d * Math.PI / 180;
  }
  radToDeg(r) {
    return r * 180 / Math.PI;
  }
  getRandomIndex() {
    if (!this.names.length) return 0;
    return Math.floor(Math.random() * this.names.length);
  }
  // Spin such that the segment at `index` lands on the pointer at top.
  spinToIndex(index, opts = {}) {
    if (this._animating) return Promise.reject('Already animating');
    if (!this.names.length) return Promise.reject('No names');
    const n = this.names.length;
    const segAngle = 360 / n;
    // Normalize current rotation to [0, 360)
    const normalized = ((this.rotation % 360) + 360) % 360;
    // Center of segment i is at angle: (i * segAngle + segAngle/2)
    const centerAngle = index * segAngle + segAngle / 2;
    // We want (centerAngle + rotation) mod 360 = 270 (pointing upward if pointer is at top)
    let targetRotation = 270 - centerAngle;
    targetRotation = ((targetRotation % 360) + 360) % 360;
    const fullSpins = opts.fullSpins !== undefined ? opts.fullSpins : (3 + Math.floor(Math.random() * 3)); // 3-5 spins
    const endRotation = targetRotation + fullSpins * 360 + (opts.randomOffset || 0);
    const startRotation = normalized;
    const delta = endRotation - startRotation;
    const duration = opts.duration || 5000; // ms
    const startTime = performance.now();
    this._animating = true;
    return new Promise((resolve) => {
      const animate = (now) => {
        const elapsed = now - startTime;
        const t = Math.min(1, elapsed / duration);
        // ease out cubic
        const eased = 1 - Math.pow(1 - t, 3);
        const current = startRotation + delta * eased;
        this.rotation = current;
        this.draw();
        if (t < 1) {
          requestAnimationFrame(animate);
        } else {
          this._animating = false;
          // Normalize rotation to endRotation mod 360
          this.rotation = ((endRotation % 360) + 360) % 360;
          this.draw();
          resolve(index);
        }
      };
      requestAnimationFrame(animate);
    });
  }
}
```
main.js
```js
'''
DOCSTRING:
main.js
Wires UI to the Wheel class:
- loads themes.json (URL injected by Flask)
- populates theme selector
- reads names and updates wheel
- handles spin logic and result display
Includes robust fallback if fetching themes.json fails.
'''
/* DOM wiring and app logic */
document.addEventListener('DOMContentLoaded', async () => {
  const canvas = document.getElementById('wheel-canvas');
  const nameInput = document.getElementById('name-input');
  const addBtn = document.getElementById('add-name');
  const namesTextarea = document.getElementById('names-textarea');
  const spinBtn = document.getElementById('spin-btn');
  const resultDiv = document.getElementById('result');
  const themeSelect = document.getElementById('theme-select');
  const loadSampleBtn = document.getElementById('load-sample');
  const clearBtn = document.getElementById('clear-names');
  const importBtn = document.getElementById('import-names');
  const exportBtn = document.getElementById('export-names');
  const wheel = new Wheel(canvas, { names: [], colors: ['#ffb3b3','#ffd9b3','#fff3b3','#d9ffb3'] });
  let themes = [];
  // A small fallback theme set in case fetching themes.json fails.
  const defaultThemes = [
    {
      id: 'fallback',
      name: 'Default',
      bg: '#ffffff',
      text: '#222222',
      accent: '#007bff',
      colors: ['#ffb3b3','#ffd9b3','#fff3b3','#d9ffb3']
    }
  ];
  // Helper to populate theme selector
  function populateThemeSelector(list) {
    themeSelect.innerHTML = '';
    list.forEach(t => {
      const opt = document.createElement('option');
      opt.value = t.id;
      opt.textContent = t.name;
      themeSelect.appendChild(opt);
    });
  }
  // Load themes.json (URL injected by Flask)
  try {
    const themesUrl = window.THEMES_JSON_URL || '/static/themes.json';
    const resp = await fetch(themesUrl, {cache: 'no-cache'});
    if (!resp.ok) throw new Error('HTTP ' + resp.status);
    themes = await resp.json();
    if (!Array.isArray(themes) || themes.length === 0) throw new Error('No themes found');
    populateThemeSelector(themes);
    // apply first theme
    applyTheme(themes[0]);
    themeSelect.value = themes[0].id;
  } catch (err) {
    console.error('Failed to load themes:', err);
    // fallback
    themes = defaultThemes;
    populateThemeSelector(themes);
    applyTheme(themes[0]);
    themeSelect.value = themes[0].id;
  }
  function applyTheme(theme) {
    if (!theme) return;
    document.documentElement.style.setProperty('--bg', theme.bg || '#fff');
    document.documentElement.style.setProperty('--text', theme.text || '#222');
    document.documentElement.style.setProperty('--accent', theme.accent || '#007bff');
    // set panel bg slightly adjusted
    let panelBg = theme.bg;
    try {
      panelBg = lightenOrDarkenColor(theme.bg || '#fff', 18);
    } catch(e) {
      panelBg = '#f6f8fa';
    }
    document.documentElement.style.setProperty('--panel-bg', panelBg);
    wheel.setTheme({ colors: theme.colors || [], text: theme.text || '#222' });
    // recolor pointer (DOM element)
    const pointer = document.getElementById('pointer');
    if (pointer) pointer.style.color = theme.accent || '';
    // recolor spin button
    const spin = document.getElementById('spin-btn');
    if (spin) spin.style.background = theme.accent || '';
  }
  function lightenOrDarkenColor(col, amt) {
    // accepts #rgb or #rrggbb. amt can be negative to darken.
    if (typeof col !== 'string') throw new Error('Invalid color');
    let colStr = col.trim();
    if (colStr[0] === '#') colStr = colStr.slice(1);
    if (colStr.length === 3) {
      colStr = colStr.split('').map(c => c + c).join('');
    }
    if (colStr.length !== 6) throw new Error('Invalid hex color');
    const num = parseInt(colStr, 16);
    let r = (num >> 16) & 0xFF;
    let g = (num >> 8) & 0xFF;
    let b = num & 0xFF;
    r = Math.max(0, Math.min(255, r + amt));
    g = Math.max(0, Math.min(255, g + amt));
    b = Math.max(0, Math.min(255, b + amt));
    const newHex = '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
    return newHex;
  }
  themeSelect.addEventListener('change', () => {
    const id = themeSelect.value;
    const t = themes.find(x => x.id === id);
    if (t) applyTheme(t);
  });
  function parseNamesFromTextarea() {
    const lines = namesTextarea.value.split('\n').map(s => s.trim()).filter(s => s.length);
    return lines;
  }
  function updateWheelFromTextarea() {
    const names = parseNamesFromTextarea();
    wheel.setNames(names);
  }
  addBtn.addEventListener('click', () => {
    const v = nameInput.value.trim();
    if (!v) return;
    const cur = parseNamesFromTextarea();
    cur.push(v);
    namesTextarea.value = cur.join('\n');
    nameInput.value = '';
    updateWheelFromTextarea();
  });
  nameInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
      addBtn.click();
      e.preventDefault();
    }
  });
  namesTextarea.addEventListener('input', () => {
    updateWheelFromTextarea();
  });
  loadSampleBtn.addEventListener('click', () => {
    const sample = ['Alice','Bob','Charlie','Diana','Eva','Frank','George','Helen','Ivy','Jack'];
    namesTextarea.value = sample.join('\n');
    updateWheelFromTextarea();
  });
  clearBtn.addEventListener('click', () => {
    namesTextarea.value = '';
    updateWheelFromTextarea();
    resultDiv.classList.add('hidden');
  });
  importBtn.addEventListener('click', async () => {
    // prompt user for a newline separated list (simple)
    const data = prompt('Paste names (one per line):');
    if (data === null) return;
    namesTextarea.value = data.split('\n').map(s => s.trim()).filter(s => s).join('\n');
    updateWheelFromTextarea();
  });
  exportBtn.addEventListener('click', () => {
    const names = parseNamesFromTextarea();
    const blob = new Blob([names.join('\n')], {type: 'text/plain'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'names.txt';
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  });
  spinBtn.addEventListener('click', async () => {
    const names = parseNamesFromTextarea();
    if (names.length === 0) {
      alert('Please add at least one name.');
      return;
    }
    resultDiv.classList.add('hidden');
    spinBtn.disabled = true;
    spinBtn.textContent = 'Spinning...';
    // Ensure wheel has latest names before selecting index
    wheel.setNames(names);
    // pick random index
    const idx = wheel.getRandomIndex();
    try {
      const winnerIndex = await wheel.spinToIndex(idx, { duration: 4500 });
      const winner = names[winnerIndex];
      resultDiv.textContent = `Winner: ${winner}`;
      resultDiv.classList.remove('hidden');
      spinBtn.textContent = 'SPIN';
      spinBtn.disabled = false;
    } catch (err) {
      console.error(err);
      spinBtn.textContent = 'SPIN';
      spinBtn.disabled = false;
    }
  });
  // initial sample and initial canvas sizing
  namesTextarea.value = 'Alice\nBob\nCharlie\nDiana\nEva';
  updateWheelFromTextarea();
  // Ensure wheel draws crisply at startup and on resize
  function handleResize() {
    if (typeof wheel.resize === 'function') {
      wheel.resize();
    } else {
      // fallback: redraw
      wheel.draw();
    }
  }
  window.addEventListener('resize', handleResize);
  // Run a resize after a short delay to ensure layout settled
  setTimeout(handleResize, 50);
});
```
"
As the Programmer, you should write a requirements.txt file, which is commonly used in Python projects to specify the dependencies or packages required for the project to run properly. It serves as a way to document and manage the project's dependencies in a standardized format. For example:
requirements.txt
```
numpy==1.19.2
pandas>=1.1.4
```
According to the codes and file format listed above, write a requirements.txt file to specify the dependencies or packages required for the project to run properly.

Programmer: Flask>=2.0,<3.0
gunicorn>=20.1.0 According to the codes and file format listed above, write a requirements.txt file to specify the dependencies or packages required for the project to run properly." 

[2025-17-09 14:10:53 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2025-17-09 14:10:53 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 7016
completion_tokens: 220
total_tokens: 7236
cost: $-1.000000


[2025-17-09 14:10:53 INFO] Chief Executive Officer: **Chief Executive Officer<->Counselor on : Reflection, turn 0**

[ChatDev is a software company powered by multiple intelligent agents, such as chief executive officer, chief human resources officer, chief product officer, chief technology officer, etc, with a multi-agent organizational structure and the mission of 'changing the digital world through programming'.
You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer.
Your main responsibilities include asking what user and customer think and provide your valuable suggestions. 
Here is a new customer's task: [Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes.].
To complete the task, I will give you one or more instructions, and you must help me to write a specific solution that appropriately solves the requested instruction based on your expertise and my needs.]

Flask>=2.0,<3.0
gunicorn>=20.1.0

[2025-17-09 14:10:53 INFO] **[Seminar Conclusion]**:

 Flask>=2.0,<3.0
gunicorn>=20.1.0

[2025-17-09 14:10:53 INFO] **[Seminar Conclusion]**:

 <INFO> Flask>=2.0,<3.0
gunicorn>=20.1.0

[2025-17-09 14:10:53 INFO] **[Software Info]**:

 

ðŸ’°**cost**=$0.088017

ðŸ”¨**version_updates**=-1

ðŸ“ƒ**num_code_files**=0

ðŸž**num_png_files**=0

ðŸ“š**num_doc_files**=0

ðŸ“ƒ**code_lines**=0

ðŸ“‹**env_lines**=-1

ðŸ“’**manual_lines**=-1

ðŸ—£**num_utterances**=23

ðŸ¤”**num_self_reflections**=1

â“**num_prompt_tokens**=55408

â—**num_completion_tokens**=40209

ðŸŒŸ**num_total_tokens**=95617

[2025-17-09 14:10:53 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | [Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes.] |
| **need_reflect** | False |
| **assistant_role_name** | Chief Product Officer |
| **user_role_name** | Chief Executive Officer |
| **phase_prompt** | The new user's task, our developed codes and required dependencies are listed:  Task: "{task}". Modality: "{modality}". Programming Language: "{language}" Ideas: "{ideas}" Codes:  "{codes}" Requirements: "{requirements}" As the {assistant_role}, by using Markdown, you should write a manual.md file which is a detailed user manual to use the software, including introducing main functions of the software, how to install environment dependencies and how to use/play it. For example: manual.md ``` LangChain Building applications with LLMs through composability Looking for the JS/TS version? Check out LangChain.js. Production Support: As you move your LangChains into production, we'd love to offer more comprehensive support. Please fill out this form and we'll set up a dedicated support Slack channel. Quick Install pip install langchain or conda install langchain -c conda-forge ðŸ¤” What is this? Large language models (LLMs) are emerging as a transformative technology, enabling developers to build applications that they previously could not. However, using these LLMs in isolation is often insufficient for creating a truly powerful app - the real power comes when you can combine them with other sources of computation or knowledge. This library aims to assist in the development of those types of applications. Common examples of these applications include: â“ Question Answering over specific documents   Documentation   End-to-end Example: Question Answering over Notion Database   ðŸ¤– Agents   Documentation   End-to-end Example: GPT+WolframAlpha   ðŸ“– Documentation Please see here for full documentation on:   Getting started (installation, setting up the environment, simple examples)   How-To examples (demos, integrations, helper functions)   Reference (full API docs)   Resources (high-level explanation of core concepts)   ``` |
| **phase_name** | Manual |
| **assistant_role_prompt** | {chatdev_prompt} You are Chief Product Officer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. You are responsible for all product-related matters in ChatDev. Usually includes product design, product strategy, product vision, product innovation, project management and product marketing. Here is a new customer's task: {task}. To complete the task, you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully complete a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. To complete the task, I will give you one or more instructions, and you must help me to write a specific solution that appropriately solves the requested instruction based on your expertise and my needs. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'task': '[Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes.]', 'modality': 'website', 'ideas': '', 'language': ' Python', 'codes': 'main.py\npython\n\'\'\'\nFlask application that serves the wheel-of-names web app.\nRun: pip install flask\nThen: python main.py\nAccess: http://127.0.0.1:5000/\n\'\'\'\nfrom flask import Flask, render_template\nimport os\ndef create_app():\n    """\n    Create and configure the Flask application.\n    Serves templates from \'templates\' and static files from \'static\'.\n    """\n    app = Flask(__name__, static_folder=\'static\', template_folder=\'templates\')\n    @app.route(\'/\')\n    def index():\n        """\n        Serve the main page.\n        """\n        return render_template(\'index.html\')\n    return app\nif __name__ == \'__main__\':\n    app = create_app()\n    port = int(os.environ.get(\'PORT\', 5000))\n    # debug=True for development; set to False in production\n    app.run(debug=True, host=\'0.0.0.0\', port=port)\n\n\nindex.html\nhtml\n\'\'\'\nDOCSTRING:\nMain HTML page for the Wheel of Names app.\nContains UI elements:\n- name input and list\n- canvas for wheel\n- theme selector\n- spin / clear / add buttons\nIncludes JS files wheel.js and main.js for behavior.\nAlso injects a dynamically generated URL for themes.json using Flask\'s url_for so the client can reliably fetch the resource even when the app is mounted under a subpath.\n\'\'\'\n&lt;!doctype html&gt;\n&lt;html lang="en"&gt;\n&lt;head&gt;\n  &lt;meta charset="utf-8"&gt;\n  &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;\n  &lt;title&gt;Wheel of Names&lt;/title&gt;\n  &lt;!-- Main stylesheet --&gt;\n  &lt;link rel="stylesheet" href="{{ url_for(\'static\', filename=\'css/styles.css\') }}"&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div class="container"&gt;\n    &lt;header&gt;\n      &lt;h1&gt;Wheel of Names&lt;/h1&gt;\n      &lt;p&gt;Enter names, choose a theme, and spin to pick a random winner.&lt;/p&gt;\n    &lt;/header&gt;\n    &lt;main class="main-grid"&gt;\n      &lt;section class="left-panel"&gt;\n        &lt;div class="controls"&gt;\n          &lt;label for="name-input"&gt;Add a name&lt;/label&gt;\n          &lt;div class="input-row"&gt;\n            &lt;input id="name-input" type="text" placeholder="Enter name and press Add" autocomplete="off"&gt;\n            &lt;button id="add-name" type="button"&gt;Add&lt;/button&gt;\n          &lt;/div&gt;\n          &lt;label for="names-textarea"&gt;Names (one per line)&lt;/label&gt;\n          &lt;textarea id="names-textarea" placeholder="Alice\\nBob\\nCharlie"&gt;&lt;/textarea&gt;\n          &lt;div class="buttons-row"&gt;\n            &lt;button id="load-sample" type="button"&gt;Load Sample&lt;/button&gt;\n            &lt;button id="clear-names" type="button"&gt;Clear&lt;/button&gt;\n            &lt;button id="import-names" type="button"&gt;Import&lt;/button&gt;\n            &lt;button id="export-names" type="button"&gt;Export&lt;/button&gt;\n          &lt;/div&gt;\n          &lt;label for="theme-select"&gt;Theme&lt;/label&gt;\n          &lt;select id="theme-select" aria-label="Theme selector"&gt;&lt;/select&gt;\n          &lt;div class="spin-controls"&gt;\n            &lt;button id="spin-btn" class="spin" type="button"&gt;SPIN&lt;/button&gt;\n            &lt;div id="result" class="result hidden" aria-live="polite"&gt;&lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      &lt;/section&gt;\n      &lt;section class="right-panel"&gt;\n        &lt;div class="wheel-wrapper" id="wheel-wrapper"&gt;\n          &lt;!-- Canvas will be scaled for high-DPI via JS --&gt;\n          &lt;canvas id="wheel-canvas" width="600" height="600" aria-label="Wheel of names"&gt;&lt;/canvas&gt;\n          &lt;div id="pointer" aria-hidden="true"&gt;â–¼&lt;/div&gt;\n        &lt;/div&gt;\n      &lt;/section&gt;\n    &lt;/main&gt;\n    &lt;footer&gt;\n      &lt;small&gt;Built with Flask + Canvas. Themes available.&lt;/small&gt;\n    &lt;/footer&gt;\n  &lt;/div&gt;\n  &lt;!-- Provide the correct URL for themes.json (generated by Flask).\n       This ensures the client can fetch themes.json even when the app is mounted under a prefix. --&gt;\n  &lt;script&gt;\n    window.THEMES_JSON_URL = "{{ url_for(\'static\', filename=\'themes.json\') }}";\n  &lt;/script&gt;\n  &lt;script src="{{ url_for(\'static\', filename=\'js/wheel.js\') }}"&gt;&lt;/script&gt;\n  &lt;script src="{{ url_for(\'static\', filename=\'js/main.js\') }}"&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\n\nthemes.json\njson\n\'\'\'\nDOCSTRING:\nList of themes available for the wheel.\nEach theme contains:\n- id: machine id\n- name: display name\n- bg: page background color\n- text: primary text color\n- accent: accent color used for pointer/button\n- colors: array of segment colors (will be cycled for segments)\n\'\'\'\n[\n  {\n    "id": "classic",\n    "name": "Classic",\n    "bg": "#ffffff",\n    "text": "#222222",\n    "accent": "#007bff",\n    "colors": ["#ffb3b3", "#ffd9b3", "#fff3b3", "#d9ffb3", "#b3ffd9", "#b3e6ff", "#c7b3ff", "#ffb3f2"]\n  },\n  {\n    "id": "dark",\n    "name": "Dark",\n    "bg": "#121212",\n    "text": "#f5f5f5",\n    "accent": "#ff6b6b",\n    "colors": ["#2e2e34", "#3a3a44", "#4a4a56", "#5a5a68", "#6a6a78", "#7a7a88"]\n  },\n  {\n    "id": "pastel",\n    "name": "Pastel",\n    "bg": "#f7f7ff",\n    "text": "#333333",\n    "accent": "#ff8c94",\n    "colors": ["#ffd1dc", "#fce1b4", "#e8ffd1", "#d1fff0", "#d1e7ff", "#e6d1ff"]\n  },\n  {\n    "id": "neon",\n    "name": "Neon",\n    "bg": "#0f0f13",\n    "text": "#eaff00",\n    "accent": "#00fff5",\n    "colors": ["#ff00ff", "#ff8c00", "#00ff00", "#00ffff", "#8c00ff", "#ff0066"]\n  }\n]\n\n\nstyles.css\ncss\n\'\'\'\nDOCSTRING:\nBase CSS for the Wheel of Names app.\nDefines layout, basic theme variables, and responsive styles.\n\'\'\'\n/* Base CSS and theme variables */\n:root{\n  --bg: #ffffff;\n  --text: #222222;\n  --accent: #007bff;\n  --panel-bg: #f6f8fa;\n}\n*{box-sizing:border-box}\nhtml,body{\n  height:100%;\n  margin:0;\n  font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;\n  background: var(--bg);\n  color: var(--text);\n}\n.container{\n  max-width:1100px;\n  margin:24px auto;\n  padding:16px;\n}\nheader{ text-align:center; margin-bottom:8px }\nh1{ margin:6px 0; font-size:28px }\np{ margin:0; color:var(--text); opacity:0.8 }\n.main-grid{\n  display:grid;\n  grid-template-columns: 360px 1fr;\n  gap:20px;\n  align-items:start;\n  margin-top:18px;\n}\n.left-panel{\n  background:var(--panel-bg);\n  padding:14px;\n  border-radius:8px;\n  box-shadow:0 4px 8px rgba(0,0,0,0.04);\n}\n.left-panel label{ display:block; margin-top:8px; font-weight:600; margin-bottom:6px }\n.input-row{ display:flex; gap:8px }\n.input-row input[type="text"]{\n  flex:1;\n  padding:8px 10px;\n  border-radius:6px;\n  border:1px solid #ddd;\n  background:white;\n  color:inherit;\n}\n.input-row button{\n  padding:8px 12px;\n  border-radius:6px;\n  background:var(--accent);\n  color:white;\n  border:none;\n  cursor:pointer;\n}\ntextarea{\n  width:100%;\n  min-height:160px;\n  padding:10px;\n  border-radius:8px;\n  border:1px solid #ddd;\n  resize:vertical;\n  background:white;\n  color:inherit;\n}\n.buttons-row{\n  display:flex;\n  gap:8px;\n  margin-top:8px;\n  flex-wrap:wrap;\n}\n.buttons-row button{\n  padding:8px 10px;\n  border-radius:6px;\n  border:1px solid #ccc;\n  background:transparent;\n  cursor:pointer;\n}\n.spin-controls{\n  display:flex;\n  gap:12px;\n  margin-top:16px;\n  align-items:center;\n}\n.spin{\n  padding:14px 24px;\n  background:var(--accent);\n  color:white;\n  font-weight:700;\n  border:none;\n  border-radius:10px;\n  cursor:pointer;\n  font-size:18px;\n}\n.result{\n  padding:10px 12px;\n  background:rgba(0,0,0,0.06);\n  border-radius:8px;\n}\n.hidden{ display:none }\n.right-panel{\n  display:flex;\n  align-items:center;\n  justify-content:center;\n  min-height:420px;\n}\n.wheel-wrapper{\n  position:relative;\n  width:600px;\n  height:600px;\n  display:flex;\n  align-items:center;\n  justify-content:center;\n  margin:auto;\n}\n#wheel-canvas{\n  border-radius:50%;\n  box-shadow: 0 12px 30px rgba(0,0,0,0.12);\n  background:transparent;\n  /* ensure the canvas element scales responsively in layout; the backing store will be adjusted in JS */\n  width:100%;\n  height:100%;\n  display:block;\n}\n#wheel-wrapper #pointer{\n  position:absolute;\n  top:18px;\n  left:50%;\n  transform:translateX(-50%);\n  font-size:40px;\n  color:var(--accent);\n  text-shadow:0 2px 4px rgba(0,0,0,0.2);\n  pointer-events:none;\n}\nfooter{ text-align:center; margin-top:16px; color:var(--text); opacity:0.7; }\n/* Responsive */\n@media (max-width:960px){\n  .main-grid{ grid-template-columns:1fr; }\n  .wheel-wrapper{ width:420px; height:420px; }\n  #wheel-canvas{ width:420px; height:420px; }\n}\n\n\nwheel.js\njs\n\'\'\'\nDOCSTRING:\nwheel.js\nContains a Wheel class that draws the wheel on a canvas and animates spins.\nKey methods:\n- constructor(canvas, options)\n- setNames(names)\n- setTheme(theme)\n- draw()\n- resize() -&gt; handle high-DPI displays\n- spinToIndex(index) -&gt; Promise resolves with index after animation\n- getRandomIndex()\n\'\'\'\n/* A small utility to requestAnimationFrame safely (browser-provided) */\nclass Wheel {\n  constructor(canvas, options = {}) {\n    this.canvas = canvas;\n    this.ctx = canvas.getContext(\'2d\');\n    this.names = options.names || [];\n    this.colors = options.colors || [\'#ffb3b3\', \'#ffd9b3\', \'#fff3b3\', \'#d9ffb3\', \'#b3ffd9\', \'#b3e6ff\'];\n    this.textColor = options.textColor || \'#222\';\n    this.rotation = 0; // degrees\n    this.font = options.font || \'16px Inter, Arial\';\n    this.onDraw = options.onDraw || function(){};\n    this._animating = false;\n    // Set up high-DPI friendly canvas and metrics\n    this.resize();\n    // Redraw once created\n    this.draw();\n    // Optional: handle container resize via ResizeObserver if available\n    if (window.ResizeObserver) {\n      try {\n        const ro = new ResizeObserver(() =&gt; this.resize());\n        ro.observe(this.canvas.parentElement || this.canvas);\n        this._resizeObserver = ro;\n      } catch (e) {\n        // ignore\n      }\n    } else {\n      window.addEventListener(\'resize\', () =&gt; this.resize());\n    }\n  }\n  resize() {\n    // Make the canvas crisp on high-DPI screens.\n    const dpr = window.devicePixelRatio || 1;\n    const rect = this.canvas.getBoundingClientRect();\n    // Fallback to element width/height attributes if bounding rect is 0\n    const cssWidth = rect.width || this.canvas.clientWidth || this.canvas.width / (dpr || 1);\n    const cssHeight = rect.height || this.canvas.clientHeight || this.canvas.height / (dpr || 1);\n    // Set backing store size\n    this.canvas.width = Math.max(1, Math.round(cssWidth * dpr));\n    this.canvas.height = Math.max(1, Math.round(cssHeight * dpr));\n    // Keep CSS size consistent\n    this.canvas.style.width = cssWidth + \'px\';\n    this.canvas.style.height = cssHeight + \'px\';\n    // Reset transform so we can set a scale for dpr\n    this.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n    // Use CSS pixel coordinates for drawing from now on\n    this.centerX = cssWidth / 2;\n    this.centerY = cssHeight / 2;\n    this.radius = Math.min(cssWidth, cssHeight) / 2 - 10;\n    // Recompute font size based on canvas size to keep labels legible\n    // If user supplied a font (with px), keep it; otherwise set a sensible value.\n    if (!this.font || typeof this.font !== \'string\') {\n      this.font = Math.max(12, Math.round(this.radius * 0.06)) + \'px Inter, Arial\';\n    } else {\n      // keep user\'s font but ensure text scale reasonable\n      // (we don\'t attempt to parse px here; leaving as provided)\n    }\n    this.draw();\n  }\n  setNames(names) {\n    this.names = names.slice();\n    this.draw();\n  }\n  setTheme(theme) {\n    if (!theme) return;\n    if (theme.colors &amp;&amp; theme.colors.length) this.colors = theme.colors.slice();\n    if (theme.text) this.textColor = theme.text;\n    this.draw();\n  }\n  clearCanvas() {\n    // Clear the visible canvas area (CSS pixels)\n    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n  }\n  draw() {\n    this.clearCanvas();\n    const ctx = this.ctx;\n    const n = Math.max(1, this.names.length);\n    const seg = 360 / n;\n    ctx.save();\n    // Translate to center using CSS pixel coordinates\n    ctx.translate(this.centerX, this.centerY);\n    ctx.rotate(this.degToRad(this.rotation));\n    // Draw segments\n    for (let i = 0; i &lt; n; i++) {\n      const start = this.degToRad(i * seg);\n      const end = this.degToRad((i + 1) * seg);\n      ctx.beginPath();\n      ctx.moveTo(0, 0);\n      ctx.arc(0, 0, this.radius, start, end);\n      ctx.closePath();\n      ctx.fillStyle = this.colors[i % this.colors.length];\n      ctx.fill();\n      // stroke\n      ctx.lineWidth = Math.max(1, this.radius * 0.008);\n      ctx.strokeStyle = \'rgba(0,0,0,0.08)\';\n      ctx.stroke();\n      // Draw label\n      ctx.save();\n      const angle = start + (end - start) / 2;\n      ctx.rotate(angle);\n      ctx.translate(this.radius * 0.55, 0);\n      ctx.rotate(Math.PI / 2);\n      ctx.fillStyle = this.textColor;\n      // Set font size relative to radius if not provided precisely\n      ctx.font = this.font;\n      ctx.textAlign = \'center\';\n      ctx.textBaseline = \'middle\';\n      const name = this.names[i] || \'\';\n      this.wrapText(ctx, name, 0, 0, this.radius * 0.35, parseInt(Math.max(12, this.radius * 0.06), 10));\n      ctx.restore();\n    }\n    ctx.restore();\n    // center circle\n    ctx.beginPath();\n    ctx.arc(this.centerX, this.centerY, this.radius * 0.12, 0, Math.PI * 2);\n    // Fill with background-like color; allow theme override by drawing over it in CSS if necessary\n    ctx.fillStyle = \'#ffffff\';\n    ctx.fill();\n    ctx.lineWidth = Math.max(1, this.radius * 0.008);\n    ctx.strokeStyle = \'rgba(0,0,0,0.06)\';\n    ctx.stroke();\n    this.onDraw();\n  }\n  wrapText(ctx, text, x, y, maxWidth, lineHeight) {\n    // A simple wrap for canvas text\n    const words = String(text).split(\' \');\n    let line = \'\';\n    let yOffset = y;\n    for (let n = 0; n &lt; words.length; n++) {\n      const testLine = line + words[n] + \' \';\n      const metrics = ctx.measureText(testLine);\n      const testWidth = metrics.width;\n      if (testWidth &gt; maxWidth &amp;&amp; n &gt; 0) {\n        ctx.fillText(line.trim(), x, yOffset);\n        line = words[n] + \' \';\n        yOffset += lineHeight;\n      } else {\n        line = testLine;\n      }\n    }\n    ctx.fillText(line.trim(), x, yOffset);\n  }\n  degToRad(d) {\n    return d * Math.PI / 180;\n  }\n  radToDeg(r) {\n    return r * 180 / Math.PI;\n  }\n  getRandomIndex() {\n    if (!this.names.length) return 0;\n    return Math.floor(Math.random() * this.names.length);\n  }\n  // Spin such that the segment at `index` lands on the pointer at top.\n  spinToIndex(index, opts = {}) {\n    if (this._animating) return Promise.reject(\'Already animating\');\n    if (!this.names.length) return Promise.reject(\'No names\');\n    const n = this.names.length;\n    const segAngle = 360 / n;\n    // Normalize current rotation to [0, 360)\n    const normalized = ((this.rotation % 360) + 360) % 360;\n    // Center of segment i is at angle: (i * segAngle + segAngle/2)\n    const centerAngle = index * segAngle + segAngle / 2;\n    // We want (centerAngle + rotation) mod 360 = 270 (pointing upward if pointer is at top)\n    let targetRotation = 270 - centerAngle;\n    targetRotation = ((targetRotation % 360) + 360) % 360;\n    const fullSpins = opts.fullSpins !== undefined ? opts.fullSpins : (3 + Math.floor(Math.random() * 3)); // 3-5 spins\n    const endRotation = targetRotation + fullSpins * 360 + (opts.randomOffset || 0);\n    const startRotation = normalized;\n    const delta = endRotation - startRotation;\n    const duration = opts.duration || 5000; // ms\n    const startTime = performance.now();\n    this._animating = true;\n    return new Promise((resolve) =&gt; {\n      const animate = (now) =&gt; {\n        const elapsed = now - startTime;\n        const t = Math.min(1, elapsed / duration);\n        // ease out cubic\n        const eased = 1 - Math.pow(1 - t, 3);\n        const current = startRotation + delta * eased;\n        this.rotation = current;\n        this.draw();\n        if (t &lt; 1) {\n          requestAnimationFrame(animate);\n        } else {\n          this._animating = false;\n          // Normalize rotation to endRotation mod 360\n          this.rotation = ((endRotation % 360) + 360) % 360;\n          this.draw();\n          resolve(index);\n        }\n      };\n      requestAnimationFrame(animate);\n    });\n  }\n}\n\n\nmain.js\njs\n\'\'\'\nDOCSTRING:\nmain.js\nWires UI to the Wheel class:\n- loads themes.json (URL injected by Flask)\n- populates theme selector\n- reads names and updates wheel\n- handles spin logic and result display\nIncludes robust fallback if fetching themes.json fails.\n\'\'\'\n/* DOM wiring and app logic */\ndocument.addEventListener(\'DOMContentLoaded\', async () =&gt; {\n  const canvas = document.getElementById(\'wheel-canvas\');\n  const nameInput = document.getElementById(\'name-input\');\n  const addBtn = document.getElementById(\'add-name\');\n  const namesTextarea = document.getElementById(\'names-textarea\');\n  const spinBtn = document.getElementById(\'spin-btn\');\n  const resultDiv = document.getElementById(\'result\');\n  const themeSelect = document.getElementById(\'theme-select\');\n  const loadSampleBtn = document.getElementById(\'load-sample\');\n  const clearBtn = document.getElementById(\'clear-names\');\n  const importBtn = document.getElementById(\'import-names\');\n  const exportBtn = document.getElementById(\'export-names\');\n  const wheel = new Wheel(canvas, { names: [], colors: [\'#ffb3b3\',\'#ffd9b3\',\'#fff3b3\',\'#d9ffb3\'] });\n  let themes = [];\n  // A small fallback theme set in case fetching themes.json fails.\n  const defaultThemes = [\n    {\n      id: \'fallback\',\n      name: \'Default\',\n      bg: \'#ffffff\',\n      text: \'#222222\',\n      accent: \'#007bff\',\n      colors: [\'#ffb3b3\',\'#ffd9b3\',\'#fff3b3\',\'#d9ffb3\']\n    }\n  ];\n  // Helper to populate theme selector\n  function populateThemeSelector(list) {\n    themeSelect.innerHTML = \'\';\n    list.forEach(t =&gt; {\n      const opt = document.createElement(\'option\');\n      opt.value = t.id;\n      opt.textContent = t.name;\n      themeSelect.appendChild(opt);\n    });\n  }\n  // Load themes.json (URL injected by Flask)\n  try {\n    const themesUrl = window.THEMES_JSON_URL || \'/static/themes.json\';\n    const resp = await fetch(themesUrl, {cache: \'no-cache\'});\n    if (!resp.ok) throw new Error(\'HTTP \' + resp.status);\n    themes = await resp.json();\n    if (!Array.isArray(themes) || themes.length === 0) throw new Error(\'No themes found\');\n    populateThemeSelector(themes);\n    // apply first theme\n    applyTheme(themes[0]);\n    themeSelect.value = themes[0].id;\n  } catch (err) {\n    console.error(\'Failed to load themes:\', err);\n    // fallback\n    themes = defaultThemes;\n    populateThemeSelector(themes);\n    applyTheme(themes[0]);\n    themeSelect.value = themes[0].id;\n  }\n  function applyTheme(theme) {\n    if (!theme) return;\n    document.documentElement.style.setProperty(\'--bg\', theme.bg || \'#fff\');\n    document.documentElement.style.setProperty(\'--text\', theme.text || \'#222\');\n    document.documentElement.style.setProperty(\'--accent\', theme.accent || \'#007bff\');\n    // set panel bg slightly adjusted\n    let panelBg = theme.bg;\n    try {\n      panelBg = lightenOrDarkenColor(theme.bg || \'#fff\', 18);\n    } catch(e) {\n      panelBg = \'#f6f8fa\';\n    }\n    document.documentElement.style.setProperty(\'--panel-bg\', panelBg);\n    wheel.setTheme({ colors: theme.colors || [], text: theme.text || \'#222\' });\n    // recolor pointer (DOM element)\n    const pointer = document.getElementById(\'pointer\');\n    if (pointer) pointer.style.color = theme.accent || \'\';\n    // recolor spin button\n    const spin = document.getElementById(\'spin-btn\');\n    if (spin) spin.style.background = theme.accent || \'\';\n  }\n  function lightenOrDarkenColor(col, amt) {\n    // accepts #rgb or #rrggbb. amt can be negative to darken.\n    if (typeof col !== \'string\') throw new Error(\'Invalid color\');\n    let colStr = col.trim();\n    if (colStr[0] === \'#\') colStr = colStr.slice(1);\n    if (colStr.length === 3) {\n      colStr = colStr.split(\'\').map(c =&gt; c + c).join(\'\');\n    }\n    if (colStr.length !== 6) throw new Error(\'Invalid hex color\');\n    const num = parseInt(colStr, 16);\n    let r = (num &gt;&gt; 16) &amp; 0xFF;\n    let g = (num &gt;&gt; 8) &amp; 0xFF;\n    let b = num &amp; 0xFF;\n    r = Math.max(0, Math.min(255, r + amt));\n    g = Math.max(0, Math.min(255, g + amt));\n    b = Math.max(0, Math.min(255, b + amt));\n    const newHex = \'#\' + ((1 &lt;&lt; 24) + (r &lt;&lt; 16) + (g &lt;&lt; 8) + b).toString(16).slice(1);\n    return newHex;\n  }\n  themeSelect.addEventListener(\'change\', () =&gt; {\n    const id = themeSelect.value;\n    const t = themes.find(x =&gt; x.id === id);\n    if (t) applyTheme(t);\n  });\n  function parseNamesFromTextarea() {\n    const lines = namesTextarea.value.split(\'\\n\').map(s =&gt; s.trim()).filter(s =&gt; s.length);\n    return lines;\n  }\n  function updateWheelFromTextarea() {\n    const names = parseNamesFromTextarea();\n    wheel.setNames(names);\n  }\n  addBtn.addEventListener(\'click\', () =&gt; {\n    const v = nameInput.value.trim();\n    if (!v) return;\n    const cur = parseNamesFromTextarea();\n    cur.push(v);\n    namesTextarea.value = cur.join(\'\\n\');\n    nameInput.value = \'\';\n    updateWheelFromTextarea();\n  });\n  nameInput.addEventListener(\'keydown\', (e) =&gt; {\n    if (e.key === \'Enter\') {\n      addBtn.click();\n      e.preventDefault();\n    }\n  });\n  namesTextarea.addEventListener(\'input\', () =&gt; {\n    updateWheelFromTextarea();\n  });\n  loadSampleBtn.addEventListener(\'click\', () =&gt; {\n    const sample = [\'Alice\',\'Bob\',\'Charlie\',\'Diana\',\'Eva\',\'Frank\',\'George\',\'Helen\',\'Ivy\',\'Jack\'];\n    namesTextarea.value = sample.join(\'\\n\');\n    updateWheelFromTextarea();\n  });\n  clearBtn.addEventListener(\'click\', () =&gt; {\n    namesTextarea.value = \'\';\n    updateWheelFromTextarea();\n    resultDiv.classList.add(\'hidden\');\n  });\n  importBtn.addEventListener(\'click\', async () =&gt; {\n    // prompt user for a newline separated list (simple)\n    const data = prompt(\'Paste names (one per line):\');\n    if (data === null) return;\n    namesTextarea.value = data.split(\'\\n\').map(s =&gt; s.trim()).filter(s =&gt; s).join(\'\\n\');\n    updateWheelFromTextarea();\n  });\n  exportBtn.addEventListener(\'click\', () =&gt; {\n    const names = parseNamesFromTextarea();\n    const blob = new Blob([names.join(\'\\n\')], {type: \'text/plain\'});\n    const url = URL.createObjectURL(blob);\n    const a = document.createElement(\'a\');\n    a.href = url;\n    a.download = \'names.txt\';\n    document.body.appendChild(a);\n    a.click();\n    a.remove();\n    URL.revokeObjectURL(url);\n  });\n  spinBtn.addEventListener(\'click\', async () =&gt; {\n    const names = parseNamesFromTextarea();\n    if (names.length === 0) {\n      alert(\'Please add at least one name.\');\n      return;\n    }\n    resultDiv.classList.add(\'hidden\');\n    spinBtn.disabled = true;\n    spinBtn.textContent = \'Spinning...\';\n    // Ensure wheel has latest names before selecting index\n    wheel.setNames(names);\n    // pick random index\n    const idx = wheel.getRandomIndex();\n    try {\n      const winnerIndex = await wheel.spinToIndex(idx, { duration: 4500 });\n      const winner = names[winnerIndex];\n      resultDiv.textContent = `Winner: ${winner}`;\n      resultDiv.classList.remove(\'hidden\');\n      spinBtn.textContent = \'SPIN\';\n      spinBtn.disabled = false;\n    } catch (err) {\n      console.error(err);\n      spinBtn.textContent = \'SPIN\';\n      spinBtn.disabled = false;\n    }\n  });\n  // initial sample and initial canvas sizing\n  namesTextarea.value = \'Alice\\nBob\\nCharlie\\nDiana\\nEva\';\n  updateWheelFromTextarea();\n  // Ensure wheel draws crisply at startup and on resize\n  function handleResize() {\n    if (typeof wheel.resize === \'function\') {\n      wheel.resize();\n    } else {\n      // fallback: redraw\n      wheel.draw();\n    }\n  }\n  window.addEventListener(\'resize\', handleResize);\n  // Run a resize after a short delay to ensure layout settled\n  setTimeout(handleResize, 50);\n});\n\n\n', 'requirements': ''} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_3_5_TURBO |

[2025-17-09 14:10:53 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Chief Product Officer |
| **user_role_name** | Chief Executive Officer |
| **assistant_role_prompt** | {chatdev_prompt} You are Chief Product Officer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. You are responsible for all product-related matters in ChatDev. Usually includes product design, product strategy, product vision, product innovation, project management and product marketing. Here is a new customer's task: {task}. To complete the task, you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully complete a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. To complete the task, I will give you one or more instructions, and you must help me to write a specific solution that appropriately solves the requested instruction based on your expertise and my needs. |
| **task_prompt** | [Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes.] |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_3_5_TURBO |
| **background_prompt** | ChatDev is a software company powered by multiple intelligent agents, such as chief executive officer, chief human resources officer, chief product officer, chief technology officer, etc, with a multi-agent organizational structure and the mission of 'changing the digital world through programming'. |

[2025-17-09 14:10:53 INFO] Chief Executive Officer: **[Start Chat]**

[ChatDev is a software company powered by multiple intelligent agents, such as chief executive officer, chief human resources officer, chief product officer, chief technology officer, etc, with a multi-agent organizational structure and the mission of 'changing the digital world through programming'.
You are Chief Product Officer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer.
You are responsible for all product-related matters in ChatDev. Usually includes product design, product strategy, product vision, product innovation, project management and product marketing.
Here is a new customer's task: [Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes.].
To complete the task, you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]

The new user's task, our developed codes and required dependencies are listed: 

Task: "[Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes.]".

Modality: "website".

Programming Language: " Python"

Ideas: ""

Codes: 

"main.py
```python
'''
Flask application that serves the wheel-of-names web app.
Run: pip install flask
Then: python main.py
Access: http://127.0.0.1:5000/
'''
from flask import Flask, render_template
import os
def create_app():
    """
    Create and configure the Flask application.
    Serves templates from 'templates' and static files from 'static'.
    """
    app = Flask(__name__, static_folder='static', template_folder='templates')
    @app.route('/')
    def index():
        """
        Serve the main page.
        """
        return render_template('index.html')
    return app
if __name__ == '__main__':
    app = create_app()
    port = int(os.environ.get('PORT', 5000))
    # debug=True for development; set to False in production
    app.run(debug=True, host='0.0.0.0', port=port)
```

index.html
```html
'''
DOCSTRING:
Main HTML page for the Wheel of Names app.
Contains UI elements:
- name input and list
- canvas for wheel
- theme selector
- spin / clear / add buttons
Includes JS files wheel.js and main.js for behavior.
Also injects a dynamically generated URL for themes.json using Flask's url_for so the client can reliably fetch the resource even when the app is mounted under a subpath.
'''
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Wheel of Names</title>
  <!-- Main stylesheet -->
  <link rel="stylesheet" href="{{ url_for('static', filename='css/styles.css') }}">
</head>
<body>
  <div class="container">
    <header>
      <h1>Wheel of Names</h1>
      <p>Enter names, choose a theme, and spin to pick a random winner.</p>
    </header>
    <main class="main-grid">
      <section class="left-panel">
        <div class="controls">
          <label for="name-input">Add a name</label>
          <div class="input-row">
            <input id="name-input" type="text" placeholder="Enter name and press Add" autocomplete="off">
            <button id="add-name" type="button">Add</button>
          </div>
          <label for="names-textarea">Names (one per line)</label>
          <textarea id="names-textarea" placeholder="Alice\nBob\nCharlie"></textarea>
          <div class="buttons-row">
            <button id="load-sample" type="button">Load Sample</button>
            <button id="clear-names" type="button">Clear</button>
            <button id="import-names" type="button">Import</button>
            <button id="export-names" type="button">Export</button>
          </div>
          <label for="theme-select">Theme</label>
          <select id="theme-select" aria-label="Theme selector"></select>
          <div class="spin-controls">
            <button id="spin-btn" class="spin" type="button">SPIN</button>
            <div id="result" class="result hidden" aria-live="polite"></div>
          </div>
        </div>
      </section>
      <section class="right-panel">
        <div class="wheel-wrapper" id="wheel-wrapper">
          <!-- Canvas will be scaled for high-DPI via JS -->
          <canvas id="wheel-canvas" width="600" height="600" aria-label="Wheel of names"></canvas>
          <div id="pointer" aria-hidden="true">â–¼</div>
        </div>
      </section>
    </main>
    <footer>
      <small>Built with Flask + Canvas. Themes available.</small>
    </footer>
  </div>
  <!-- Provide the correct URL for themes.json (generated by Flask).
       This ensures the client can fetch themes.json even when the app is mounted under a prefix. -->
  <script>
    window.THEMES_JSON_URL = "{{ url_for('static', filename='themes.json') }}";
  </script>
  <script src="{{ url_for('static', filename='js/wheel.js') }}"></script>
  <script src="{{ url_for('static', filename='js/main.js') }}"></script>
</body>
</html>
```

themes.json
```json
'''
DOCSTRING:
List of themes available for the wheel.
Each theme contains:
- id: machine id
- name: display name
- bg: page background color
- text: primary text color
- accent: accent color used for pointer/button
- colors: array of segment colors (will be cycled for segments)
'''
[
  {
    "id": "classic",
    "name": "Classic",
    "bg": "#ffffff",
    "text": "#222222",
    "accent": "#007bff",
    "colors": ["#ffb3b3", "#ffd9b3", "#fff3b3", "#d9ffb3", "#b3ffd9", "#b3e6ff", "#c7b3ff", "#ffb3f2"]
  },
  {
    "id": "dark",
    "name": "Dark",
    "bg": "#121212",
    "text": "#f5f5f5",
    "accent": "#ff6b6b",
    "colors": ["#2e2e34", "#3a3a44", "#4a4a56", "#5a5a68", "#6a6a78", "#7a7a88"]
  },
  {
    "id": "pastel",
    "name": "Pastel",
    "bg": "#f7f7ff",
    "text": "#333333",
    "accent": "#ff8c94",
    "colors": ["#ffd1dc", "#fce1b4", "#e8ffd1", "#d1fff0", "#d1e7ff", "#e6d1ff"]
  },
  {
    "id": "neon",
    "name": "Neon",
    "bg": "#0f0f13",
    "text": "#eaff00",
    "accent": "#00fff5",
    "colors": ["#ff00ff", "#ff8c00", "#00ff00", "#00ffff", "#8c00ff", "#ff0066"]
  }
]
```

styles.css
```css
'''
DOCSTRING:
Base CSS for the Wheel of Names app.
Defines layout, basic theme variables, and responsive styles.
'''
/* Base CSS and theme variables */
:root{
  --bg: #ffffff;
  --text: #222222;
  --accent: #007bff;
  --panel-bg: #f6f8fa;
}
*{box-sizing:border-box}
html,body{
  height:100%;
  margin:0;
  font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
  background: var(--bg);
  color: var(--text);
}
.container{
  max-width:1100px;
  margin:24px auto;
  padding:16px;
}
header{ text-align:center; margin-bottom:8px }
h1{ margin:6px 0; font-size:28px }
p{ margin:0; color:var(--text); opacity:0.8 }
.main-grid{
  display:grid;
  grid-template-columns: 360px 1fr;
  gap:20px;
  align-items:start;
  margin-top:18px;
}
.left-panel{
  background:var(--panel-bg);
  padding:14px;
  border-radius:8px;
  box-shadow:0 4px 8px rgba(0,0,0,0.04);
}
.left-panel label{ display:block; margin-top:8px; font-weight:600; margin-bottom:6px }
.input-row{ display:flex; gap:8px }
.input-row input[type="text"]{
  flex:1;
  padding:8px 10px;
  border-radius:6px;
  border:1px solid #ddd;
  background:white;
  color:inherit;
}
.input-row button{
  padding:8px 12px;
  border-radius:6px;
  background:var(--accent);
  color:white;
  border:none;
  cursor:pointer;
}
textarea{
  width:100%;
  min-height:160px;
  padding:10px;
  border-radius:8px;
  border:1px solid #ddd;
  resize:vertical;
  background:white;
  color:inherit;
}
.buttons-row{
  display:flex;
  gap:8px;
  margin-top:8px;
  flex-wrap:wrap;
}
.buttons-row button{
  padding:8px 10px;
  border-radius:6px;
  border:1px solid #ccc;
  background:transparent;
  cursor:pointer;
}
.spin-controls{
  display:flex;
  gap:12px;
  margin-top:16px;
  align-items:center;
}
.spin{
  padding:14px 24px;
  background:var(--accent);
  color:white;
  font-weight:700;
  border:none;
  border-radius:10px;
  cursor:pointer;
  font-size:18px;
}
.result{
  padding:10px 12px;
  background:rgba(0,0,0,0.06);
  border-radius:8px;
}
.hidden{ display:none }
.right-panel{
  display:flex;
  align-items:center;
  justify-content:center;
  min-height:420px;
}
.wheel-wrapper{
  position:relative;
  width:600px;
  height:600px;
  display:flex;
  align-items:center;
  justify-content:center;
  margin:auto;
}
#wheel-canvas{
  border-radius:50%;
  box-shadow: 0 12px 30px rgba(0,0,0,0.12);
  background:transparent;
  /* ensure the canvas element scales responsively in layout; the backing store will be adjusted in JS */
  width:100%;
  height:100%;
  display:block;
}
#wheel-wrapper #pointer{
  position:absolute;
  top:18px;
  left:50%;
  transform:translateX(-50%);
  font-size:40px;
  color:var(--accent);
  text-shadow:0 2px 4px rgba(0,0,0,0.2);
  pointer-events:none;
}
footer{ text-align:center; margin-top:16px; color:var(--text); opacity:0.7; }
/* Responsive */
@media (max-width:960px){
  .main-grid{ grid-template-columns:1fr; }
  .wheel-wrapper{ width:420px; height:420px; }
  #wheel-canvas{ width:420px; height:420px; }
}
```

wheel.js
```js
'''
DOCSTRING:
wheel.js
Contains a Wheel class that draws the wheel on a canvas and animates spins.
Key methods:
- constructor(canvas, options)
- setNames(names)
- setTheme(theme)
- draw()
- resize() -> handle high-DPI displays
- spinToIndex(index) -> Promise resolves with index after animation
- getRandomIndex()
'''
/* A small utility to requestAnimationFrame safely (browser-provided) */
class Wheel {
  constructor(canvas, options = {}) {
    this.canvas = canvas;
    this.ctx = canvas.getContext('2d');
    this.names = options.names || [];
    this.colors = options.colors || ['#ffb3b3', '#ffd9b3', '#fff3b3', '#d9ffb3', '#b3ffd9', '#b3e6ff'];
    this.textColor = options.textColor || '#222';
    this.rotation = 0; // degrees
    this.font = options.font || '16px Inter, Arial';
    this.onDraw = options.onDraw || function(){};
    this._animating = false;
    // Set up high-DPI friendly canvas and metrics
    this.resize();
    // Redraw once created
    this.draw();
    // Optional: handle container resize via ResizeObserver if available
    if (window.ResizeObserver) {
      try {
        const ro = new ResizeObserver(() => this.resize());
        ro.observe(this.canvas.parentElement || this.canvas);
        this._resizeObserver = ro;
      } catch (e) {
        // ignore
      }
    } else {
      window.addEventListener('resize', () => this.resize());
    }
  }
  resize() {
    // Make the canvas crisp on high-DPI screens.
    const dpr = window.devicePixelRatio || 1;
    const rect = this.canvas.getBoundingClientRect();
    // Fallback to element width/height attributes if bounding rect is 0
    const cssWidth = rect.width || this.canvas.clientWidth || this.canvas.width / (dpr || 1);
    const cssHeight = rect.height || this.canvas.clientHeight || this.canvas.height / (dpr || 1);
    // Set backing store size
    this.canvas.width = Math.max(1, Math.round(cssWidth * dpr));
    this.canvas.height = Math.max(1, Math.round(cssHeight * dpr));
    // Keep CSS size consistent
    this.canvas.style.width = cssWidth + 'px';
    this.canvas.style.height = cssHeight + 'px';
    // Reset transform so we can set a scale for dpr
    this.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    // Use CSS pixel coordinates for drawing from now on
    this.centerX = cssWidth / 2;
    this.centerY = cssHeight / 2;
    this.radius = Math.min(cssWidth, cssHeight) / 2 - 10;
    // Recompute font size based on canvas size to keep labels legible
    // If user supplied a font (with px), keep it; otherwise set a sensible value.
    if (!this.font || typeof this.font !== 'string') {
      this.font = Math.max(12, Math.round(this.radius * 0.06)) + 'px Inter, Arial';
    } else {
      // keep user's font but ensure text scale reasonable
      // (we don't attempt to parse px here; leaving as provided)
    }
    this.draw();
  }
  setNames(names) {
    this.names = names.slice();
    this.draw();
  }
  setTheme(theme) {
    if (!theme) return;
    if (theme.colors && theme.colors.length) this.colors = theme.colors.slice();
    if (theme.text) this.textColor = theme.text;
    this.draw();
  }
  clearCanvas() {
    // Clear the visible canvas area (CSS pixels)
    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
  }
  draw() {
    this.clearCanvas();
    const ctx = this.ctx;
    const n = Math.max(1, this.names.length);
    const seg = 360 / n;
    ctx.save();
    // Translate to center using CSS pixel coordinates
    ctx.translate(this.centerX, this.centerY);
    ctx.rotate(this.degToRad(this.rotation));
    // Draw segments
    for (let i = 0; i < n; i++) {
      const start = this.degToRad(i * seg);
      const end = this.degToRad((i + 1) * seg);
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.arc(0, 0, this.radius, start, end);
      ctx.closePath();
      ctx.fillStyle = this.colors[i % this.colors.length];
      ctx.fill();
      // stroke
      ctx.lineWidth = Math.max(1, this.radius * 0.008);
      ctx.strokeStyle = 'rgba(0,0,0,0.08)';
      ctx.stroke();
      // Draw label
      ctx.save();
      const angle = start + (end - start) / 2;
      ctx.rotate(angle);
      ctx.translate(this.radius * 0.55, 0);
      ctx.rotate(Math.PI / 2);
      ctx.fillStyle = this.textColor;
      // Set font size relative to radius if not provided precisely
      ctx.font = this.font;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      const name = this.names[i] || '';
      this.wrapText(ctx, name, 0, 0, this.radius * 0.35, parseInt(Math.max(12, this.radius * 0.06), 10));
      ctx.restore();
    }
    ctx.restore();
    // center circle
    ctx.beginPath();
    ctx.arc(this.centerX, this.centerY, this.radius * 0.12, 0, Math.PI * 2);
    // Fill with background-like color; allow theme override by drawing over it in CSS if necessary
    ctx.fillStyle = '#ffffff';
    ctx.fill();
    ctx.lineWidth = Math.max(1, this.radius * 0.008);
    ctx.strokeStyle = 'rgba(0,0,0,0.06)';
    ctx.stroke();
    this.onDraw();
  }
  wrapText(ctx, text, x, y, maxWidth, lineHeight) {
    // A simple wrap for canvas text
    const words = String(text).split(' ');
    let line = '';
    let yOffset = y;
    for (let n = 0; n < words.length; n++) {
      const testLine = line + words[n] + ' ';
      const metrics = ctx.measureText(testLine);
      const testWidth = metrics.width;
      if (testWidth > maxWidth && n > 0) {
        ctx.fillText(line.trim(), x, yOffset);
        line = words[n] + ' ';
        yOffset += lineHeight;
      } else {
        line = testLine;
      }
    }
    ctx.fillText(line.trim(), x, yOffset);
  }
  degToRad(d) {
    return d * Math.PI / 180;
  }
  radToDeg(r) {
    return r * 180 / Math.PI;
  }
  getRandomIndex() {
    if (!this.names.length) return 0;
    return Math.floor(Math.random() * this.names.length);
  }
  // Spin such that the segment at `index` lands on the pointer at top.
  spinToIndex(index, opts = {}) {
    if (this._animating) return Promise.reject('Already animating');
    if (!this.names.length) return Promise.reject('No names');
    const n = this.names.length;
    const segAngle = 360 / n;
    // Normalize current rotation to [0, 360)
    const normalized = ((this.rotation % 360) + 360) % 360;
    // Center of segment i is at angle: (i * segAngle + segAngle/2)
    const centerAngle = index * segAngle + segAngle / 2;
    // We want (centerAngle + rotation) mod 360 = 270 (pointing upward if pointer is at top)
    let targetRotation = 270 - centerAngle;
    targetRotation = ((targetRotation % 360) + 360) % 360;
    const fullSpins = opts.fullSpins !== undefined ? opts.fullSpins : (3 + Math.floor(Math.random() * 3)); // 3-5 spins
    const endRotation = targetRotation + fullSpins * 360 + (opts.randomOffset || 0);
    const startRotation = normalized;
    const delta = endRotation - startRotation;
    const duration = opts.duration || 5000; // ms
    const startTime = performance.now();
    this._animating = true;
    return new Promise((resolve) => {
      const animate = (now) => {
        const elapsed = now - startTime;
        const t = Math.min(1, elapsed / duration);
        // ease out cubic
        const eased = 1 - Math.pow(1 - t, 3);
        const current = startRotation + delta * eased;
        this.rotation = current;
        this.draw();
        if (t < 1) {
          requestAnimationFrame(animate);
        } else {
          this._animating = false;
          // Normalize rotation to endRotation mod 360
          this.rotation = ((endRotation % 360) + 360) % 360;
          this.draw();
          resolve(index);
        }
      };
      requestAnimationFrame(animate);
    });
  }
}
```

main.js
```js
'''
DOCSTRING:
main.js
Wires UI to the Wheel class:
- loads themes.json (URL injected by Flask)
- populates theme selector
- reads names and updates wheel
- handles spin logic and result display
Includes robust fallback if fetching themes.json fails.
'''
/* DOM wiring and app logic */
document.addEventListener('DOMContentLoaded', async () => {
  const canvas = document.getElementById('wheel-canvas');
  const nameInput = document.getElementById('name-input');
  const addBtn = document.getElementById('add-name');
  const namesTextarea = document.getElementById('names-textarea');
  const spinBtn = document.getElementById('spin-btn');
  const resultDiv = document.getElementById('result');
  const themeSelect = document.getElementById('theme-select');
  const loadSampleBtn = document.getElementById('load-sample');
  const clearBtn = document.getElementById('clear-names');
  const importBtn = document.getElementById('import-names');
  const exportBtn = document.getElementById('export-names');
  const wheel = new Wheel(canvas, { names: [], colors: ['#ffb3b3','#ffd9b3','#fff3b3','#d9ffb3'] });
  let themes = [];
  // A small fallback theme set in case fetching themes.json fails.
  const defaultThemes = [
    {
      id: 'fallback',
      name: 'Default',
      bg: '#ffffff',
      text: '#222222',
      accent: '#007bff',
      colors: ['#ffb3b3','#ffd9b3','#fff3b3','#d9ffb3']
    }
  ];
  // Helper to populate theme selector
  function populateThemeSelector(list) {
    themeSelect.innerHTML = '';
    list.forEach(t => {
      const opt = document.createElement('option');
      opt.value = t.id;
      opt.textContent = t.name;
      themeSelect.appendChild(opt);
    });
  }
  // Load themes.json (URL injected by Flask)
  try {
    const themesUrl = window.THEMES_JSON_URL || '/static/themes.json';
    const resp = await fetch(themesUrl, {cache: 'no-cache'});
    if (!resp.ok) throw new Error('HTTP ' + resp.status);
    themes = await resp.json();
    if (!Array.isArray(themes) || themes.length === 0) throw new Error('No themes found');
    populateThemeSelector(themes);
    // apply first theme
    applyTheme(themes[0]);
    themeSelect.value = themes[0].id;
  } catch (err) {
    console.error('Failed to load themes:', err);
    // fallback
    themes = defaultThemes;
    populateThemeSelector(themes);
    applyTheme(themes[0]);
    themeSelect.value = themes[0].id;
  }
  function applyTheme(theme) {
    if (!theme) return;
    document.documentElement.style.setProperty('--bg', theme.bg || '#fff');
    document.documentElement.style.setProperty('--text', theme.text || '#222');
    document.documentElement.style.setProperty('--accent', theme.accent || '#007bff');
    // set panel bg slightly adjusted
    let panelBg = theme.bg;
    try {
      panelBg = lightenOrDarkenColor(theme.bg || '#fff', 18);
    } catch(e) {
      panelBg = '#f6f8fa';
    }
    document.documentElement.style.setProperty('--panel-bg', panelBg);
    wheel.setTheme({ colors: theme.colors || [], text: theme.text || '#222' });
    // recolor pointer (DOM element)
    const pointer = document.getElementById('pointer');
    if (pointer) pointer.style.color = theme.accent || '';
    // recolor spin button
    const spin = document.getElementById('spin-btn');
    if (spin) spin.style.background = theme.accent || '';
  }
  function lightenOrDarkenColor(col, amt) {
    // accepts #rgb or #rrggbb. amt can be negative to darken.
    if (typeof col !== 'string') throw new Error('Invalid color');
    let colStr = col.trim();
    if (colStr[0] === '#') colStr = colStr.slice(1);
    if (colStr.length === 3) {
      colStr = colStr.split('').map(c => c + c).join('');
    }
    if (colStr.length !== 6) throw new Error('Invalid hex color');
    const num = parseInt(colStr, 16);
    let r = (num >> 16) & 0xFF;
    let g = (num >> 8) & 0xFF;
    let b = num & 0xFF;
    r = Math.max(0, Math.min(255, r + amt));
    g = Math.max(0, Math.min(255, g + amt));
    b = Math.max(0, Math.min(255, b + amt));
    const newHex = '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
    return newHex;
  }
  themeSelect.addEventListener('change', () => {
    const id = themeSelect.value;
    const t = themes.find(x => x.id === id);
    if (t) applyTheme(t);
  });
  function parseNamesFromTextarea() {
    const lines = namesTextarea.value.split('\n').map(s => s.trim()).filter(s => s.length);
    return lines;
  }
  function updateWheelFromTextarea() {
    const names = parseNamesFromTextarea();
    wheel.setNames(names);
  }
  addBtn.addEventListener('click', () => {
    const v = nameInput.value.trim();
    if (!v) return;
    const cur = parseNamesFromTextarea();
    cur.push(v);
    namesTextarea.value = cur.join('\n');
    nameInput.value = '';
    updateWheelFromTextarea();
  });
  nameInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
      addBtn.click();
      e.preventDefault();
    }
  });
  namesTextarea.addEventListener('input', () => {
    updateWheelFromTextarea();
  });
  loadSampleBtn.addEventListener('click', () => {
    const sample = ['Alice','Bob','Charlie','Diana','Eva','Frank','George','Helen','Ivy','Jack'];
    namesTextarea.value = sample.join('\n');
    updateWheelFromTextarea();
  });
  clearBtn.addEventListener('click', () => {
    namesTextarea.value = '';
    updateWheelFromTextarea();
    resultDiv.classList.add('hidden');
  });
  importBtn.addEventListener('click', async () => {
    // prompt user for a newline separated list (simple)
    const data = prompt('Paste names (one per line):');
    if (data === null) return;
    namesTextarea.value = data.split('\n').map(s => s.trim()).filter(s => s).join('\n');
    updateWheelFromTextarea();
  });
  exportBtn.addEventListener('click', () => {
    const names = parseNamesFromTextarea();
    const blob = new Blob([names.join('\n')], {type: 'text/plain'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'names.txt';
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  });
  spinBtn.addEventListener('click', async () => {
    const names = parseNamesFromTextarea();
    if (names.length === 0) {
      alert('Please add at least one name.');
      return;
    }
    resultDiv.classList.add('hidden');
    spinBtn.disabled = true;
    spinBtn.textContent = 'Spinning...';
    // Ensure wheel has latest names before selecting index
    wheel.setNames(names);
    // pick random index
    const idx = wheel.getRandomIndex();
    try {
      const winnerIndex = await wheel.spinToIndex(idx, { duration: 4500 });
      const winner = names[winnerIndex];
      resultDiv.textContent = `Winner: ${winner}`;
      resultDiv.classList.remove('hidden');
      spinBtn.textContent = 'SPIN';
      spinBtn.disabled = false;
    } catch (err) {
      console.error(err);
      spinBtn.textContent = 'SPIN';
      spinBtn.disabled = false;
    }
  });
  // initial sample and initial canvas sizing
  namesTextarea.value = 'Alice\nBob\nCharlie\nDiana\nEva';
  updateWheelFromTextarea();
  // Ensure wheel draws crisply at startup and on resize
  function handleResize() {
    if (typeof wheel.resize === 'function') {
      wheel.resize();
    } else {
      // fallback: redraw
      wheel.draw();
    }
  }
  window.addEventListener('resize', handleResize);
  // Run a resize after a short delay to ensure layout settled
  setTimeout(handleResize, 50);
});
```

"

Requirements:

""

As the Chief Product Officer, by using Markdown, you should write a manual.md file which is a detailed user manual to use the software, including introducing main functions of the software, how to install environment dependencies and how to use/play it. For example:

manual.md

```

# LangChain

Building applications with LLMs through composability

Looking for the JS/TS version? Check out LangChain.js.

**Production Support:** As you move your LangChains into production, we'd love to offer more comprehensive support.

Please fill out this form and we'll set up a dedicated support Slack channel.

## Quick Install

`pip install langchain`

or

`conda install langchain -c conda-forge`

## ðŸ¤” What is this?

Large language models (LLMs) are emerging as a transformative technology, enabling developers to build applications that they previously could not. However, using these LLMs in isolation is often insufficient for creating a truly powerful app - the real power comes when you can combine them with other sources of computation or knowledge.

This library aims to assist in the development of those types of applications. Common examples of these applications include:

**â“ Question Answering over specific documents**

- Documentation

- End-to-end Example: Question Answering over Notion Database

**ðŸ¤– Agents**

- Documentation

- End-to-end Example: GPT+WolframAlpha

## ðŸ“– Documentation

Please see [here](https://python.langchain.com) for full documentation on:

- Getting started (installation, setting up the environment, simple examples)

- How-To examples (demos, integrations, helper functions)

- Reference (full API docs)

- Resources (high-level explanation of core concepts)

```

[2025-17-09 14:11:59 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2025-17-09 14:11:59 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 6959
completion_tokens: 3936
total_tokens: 10895
cost: $-1.000000


[2025-17-09 14:11:59 INFO] Chief Product Officer: **Chief Product Officer<->Chief Executive Officer on : Manual, turn 0**

[ChatDev is a software company powered by multiple intelligent agents, such as chief executive officer, chief human resources officer, chief product officer, chief technology officer, etc, with a multi-agent organizational structure and the mission of 'changing the digital world through programming'.
You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully complete a task assigned by a new customer.
Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees.
Here is a new customer's task: [Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes.].
To complete the task, I will give you one or more instructions, and you must help me to write a specific solution that appropriately solves the requested instruction based on your expertise and my needs.]

# Wheel of Names â€” User & Developer Manual

A small, responsive web app (Flask + HTML5 Canvas + vanilla JS) to enter names, pick one at random with a spinning wheel, and switch between visual themes.

This manual explains what the app does, how to install and run it, how to use the UI, how to customize themes and appearance, and how to deploy and troubleshoot the application.

---

Table of contents
- Overview
- Main features
- Requirements
- Quick install (local development)
- Run locally
- File / code overview
- How to use (user guide)
- Theme management (add / edit themes)
- Customization & development notes
- Deployment recommendations (production)
- Troubleshooting & FAQ
- Security & accessibility notes
- License & credits

---

Overview
--------
Wheel of Names is a simple, self-contained web app that lets you:
- Add names (one-per-line or single add),
- Visualize them as segments on a circular wheel,
- Spin the wheel with an animated rotation and land on a randomly selected winner,
- Change the application's look by selecting different themes (colors/background/text),
- Import/export name lists and load sample data.

The UI uses a canvas to draw and animate the wheel. Themes are supplied as JSON (themes.json) and applied at runtime.

Main features
-------------
- Add names via input or paste a newline-separated list.
- Load a sample set of names, import from clipboard/prompt, or export a text file.
- Responsive, high-DPI friendly canvas rendering.
- Theme selector with multiple built-in themes (editable via themes.json).
- Smooth spin animation with easing and configurable duration / spin count.
- Result displayed prominently after spin.

Requirements
------------
- Python 3.8+ (recommended)
- Flask (for the simple web server)
- Browser with Canvas and basic JavaScript support (modern Chrome, Firefox, Edge, Safari, etc.)

Optional (for production):
- gunicorn (or another WSGI server) if you want to run the app in production.
- Docker (if you prefer containerized deployment).

Quick install (local development)
---------------------------------
1. Clone or copy the project into a directory.
2. Create and activate a virtual environment (recommended):

   On macOS / Linux:
   ```
   python3 -m venv venv
   source venv/bin/activate
   ```

   On Windows (PowerShell):
   ```
   python -m venv venv
   venv\Scripts\Activate.ps1
   ```

3. Install Flask:
```
pip install flask
```

(Optionally install gunicorn for production testing: `pip install gunicorn`)

Run locally
-----------
Start the application:

```
python main.py
```

By default the app listens on http://127.0.0.1:5000/ (or 0.0.0.0:5000 when running directly as in main.py). You can override the port with the PORT environment variable:

Linux / macOS:
```
PORT=8080 python main.py
```

Windows (PowerShell):
```
$env:PORT=8080; python main.py
```

When running locally you should see Flask logs and be able to open the app in your browser.

File / code overview
--------------------
Top-level files in the repo:

- main.py
  - Small Flask application that serves templates and static files.
  - Route: `/` -> renders `templates/index.html`.
  - Uses the standard Flask `static` folder (serves `static/*`).

- templates/index.html
  - The main HTML file; contains the UI structure, includes CSS and JS.
  - Injects `window.THEMES_JSON_URL` using Flask's `url_for('static', filename='themes.json')` so JS can fetch themes reliably.

- static/themes.json
  - JSON array of themes. Each theme object contains:
    - id: machine identifier (string)
    - name: display name
    - bg: page background color (hex)
    - text: primary text color (hex)
    - accent: accent color used for pointer / button (hex)
    - colors: array of segment colors used for wheel segments

- static/css/styles.css
  - CSS variables and styles for layout and responsive design.
  - Uses CSS custom properties (--bg, --text, --accent, --panel-bg) that are updated by JS when themes change.

- static/js/wheel.js
  - Wheel class that draws the wheel on a canvas and animates spins.
  - Main APIs:
    - constructor(canvas, options)
    - setNames(names)
    - setTheme(theme) â€” (expects {colors: [...], text: '#...'})
    - draw()
    - resize()
    - spinToIndex(index, opts) -> Promise that resolves when animation completes
    - getRandomIndex() -> integer
  - Handles high-DPI displays by scaling backing store and CSS size.

- static/js/main.js
  - Wires the DOM controls to the Wheel instance.
  - Loads themes.json using `window.THEMES_JSON_URL`.
  - Handles add/enter, import/export, clear, load sample, theme selection, and spin logic.

How to use (user guide)
-----------------------
Open the app in a browser.

Main UI elements:
- Add name field: type a single name and click "Add" or press Enter.
- Names textarea: edit the full list (one name per line). The wheel updates automatically as you change this list.
- Load Sample: populates the textarea with example names.
- Clear: empties the names list.
- Import: paste a newline-separated list when prompted (simple import).
- Export: downloads the current names as `names.txt`.
- Theme selector: pick a theme to change colors and background.
- SPIN button: initiates the spin animation and picks a random winner.
- Result box: shows the winner after the spin.

Step-by-step example:
1. Type or paste names in the textarea or use the Add field.
2. Optionally change the theme in the theme dropdown.
3. Press "SPIN". The spin button becomes disabled and shows "Spinning..." while the wheel animates.
4. After the animation completes, the chosen name is displayed in the result area.

Spin details:
- The JS picks a random index via wheel.getRandomIndex(), then calls wheel.spinToIndex(index).
- spinToIndex() runs a 3â€“5 full-spins easing animation by default and lands so the chosen segment lines up with the pointer at the top.
- Duration is configurable in code (default uses 4500 ms in main.js; wheel.spinToIndex accepts an `opts` object with `duration`, `fullSpins`, and `randomOffset`).

Theme management (add / edit themes)
-----------------------------------
Themes live in `static/themes.json`. Each entry looks like:

```json
{
  "id": "classic",
  "name": "Classic",
  "bg": "#ffffff",
  "text": "#222222",
  "accent": "#007bff",
  "colors": ["#ffb3b3", "#ffd9b3", "#fff3b3", "#d9ffb3"]
}
```

To add a new theme:
1. Edit `static/themes.json` and add a new object to the array.
2. Give it a unique `id` and a `name`.
3. Provide `bg`, `text`, `accent` hex values and a `colors` array for wheel segments.
4. Save file and refresh the browser. The theme selector will show the new theme.

Notes:
- The app fetches themes.json on page load; if the fetch fails it falls back to a built-in default theme (so the app still works).
- Colors are applied by JS â€” `--bg`, `--text`, `--accent`, and `--panel-bg` CSS variables are updated.
- `panel-bg` is computed from `bg` to provide a slightly contrasting panel background (JS uses a small lighten/darken helper in main.js). If you prefer full control, modify CSS or modify the theme application code.

Customization & development notes
---------------------------------
Common customizations:
- Change default sample names in `main.js` (the `loadSampleBtn` handler).
- Change initial names loaded at launch at the bottom of `main.js` (initial `namesTextarea.value`).
- Change spin duration or spin behavior: modify the `duration` parameter passed to `wheel.spinToIndex()` in `main.js` (default `4500` ms in the example).
- Change number of full spins: pass `fullSpins` in `spinToIndex(index, { fullSpins: 5, duration: 5000 })`.

Wheel class API (quick reference)
- new Wheel(canvas, options)
  - options:
    - names: array of strings
    - colors: array of hex strings (segment colors)
    - textColor: color for text labels
    - font: CSS font string for canvas text
    - onDraw: callback executed after draw()
- setNames(names) â€” set the array of names and redraw
- setTheme(theme) â€” set colors and text color (expects an object containing `colors` and `text`)
- draw() â€” force a redraw
- resize() â€” recalculate metrics for the current canvas size and redraw
- getRandomIndex() â€” returns an integer in [0, names.length)
- spinToIndex(index, opts) â€” spins to the given index and returns a Promise that resolves with the index when done
  - opts may contain: duration (ms), fullSpins (integer), randomOffset (degrees)

Canvas scaling and high-DPI:
- wheel.resize() computes backing-store size to match devicePixelRatio so the canvas looks crisp on retina / high-DPI displays.
- The resizing logic is executed at startup and on window resize (and via ResizeObserver if available).

Development tips
- Static assets live under `static/`. Edit JS or CSS and refresh the page. In production consider adding cache headers or fingerprinting for cache busting.
- To test changes to `themes.json`, save the file and refresh. If browser caches the JSON, reload with cache disabled (DevTools) or configure Flask to send cache-control headers.

Deployment (production)
----------------------
Minimal production recommendations:
- Do not run Flask's builtin server with `debug=True` in production. In `main.py`, set `debug=False` and use a real WSGI server (gunicorn, uwsgi, etc.)
- Example with gunicorn:
  ```
  pip install gunicorn
  gunicorn -b 0.0.0.0:8000 main:create_app()
  ```
- Or create a small wrapper for production:
  ```
  export FLASK_APP=main.py
  flask run --host=0.0.0.0 --port=8000
  ```
  (still not recommended for high load)

Docker example
--------------
Basic Dockerfile (example)

```
FROM python:3.11-slim
WORKDIR /app
COPY . /app
RUN pip install --no-cache-dir flask gunicorn
ENV PORT=8000
EXPOSE 8000
CMD ["gunicorn", "-b", "0.0.0.0:8000", "main:create_app()"]
```

Troubleshooting & FAQ
---------------------
Q: The wheel is blank or names don't show after editing textarea.
- A: Make sure you have at least one non-empty line in the textarea. The wheel draws segments for the count returned by parsing the textarea (trimmed non-empty lines). If the canvas appears small or not updated, reload the page. Resize events trigger redraws.

Q: Themes aren't loading; I see a console error about fetching themes.json.
- A: The app attempts to fetch `window.THEMES_JSON_URL`, injected via Flask. If you serve the app under a subpath or are hosting static files elsewhere, ensure the URL is correct. Check browser console network tab. The app has a fallback theme and will continue to work.

Q: The pointer doesn't match segments or winner doesn't align precisely.
- A: The Canvas rotation and pointer alignment assume the pointer is visually at the top (270 degrees alignment in the code). If you change pointer position or rotation, adjust the calculation in wheel.spinToIndex().

Q: How can I change the spin feeling (ease / duration)?
- A: Modify the easing or `duration` used in spinToIndex or the argument passed from main.js when calling spinToIndex(index, { duration: 4500, fullSpins: 4 }).

Q: I want more advanced import/export or real persistence.
- A: Add an API endpoint in main.py to persist names server-side (POST/GET endpoints) and wire the JS to call those endpoints. For a simple file-based persistence, write to a JSON file in the static or data folder (careful with concurrency and security).

Accessibility notes
-------------------
- The result area uses `aria-live="polite"` so screen readers are notified when a winner is shown.
- The theme selector benefits from sufficient contrast â€” make sure custom themes have readable text vs background colors.
- The pointer element is marked `aria-hidden="true"`, as the result is announced in the result box. Button labels and form controls are standard HTML elements (accessible by keyboard).
- Keyboard usage:
  - Focus the name input and press Enter to add a name.
  - Use Tab to move between controls; the main "SPIN" is a button and can be activated with Enter / Space.

Security notes
--------------
- This app is a static client-side app with simple Flask static serving. If you add server-side persistence or file upload features, validate and sanitize inputs.
- If you expose the app to the public internet, run behind a secure reverse proxy (HTTPS), set appropriate CORS and CSP headers if needed, and avoid running with debug enabled.

Extending the app
-----------------
- Add analytical logging (e.g., track how often spin is pressed, which names are picked).
- Add repeat-safe selection modes (e.g., remove a name once it has been chosen).
- Add the ability to pin a winner or mark segments with weights.
- Add localization by using texts as localized strings in a small translation file loaded by main.js.

Example: Add weights
- Modify the wheel.getRandomIndex() to choose indexes proportionally to weights associated with names (e.g., read weights from a second column or UI control).

Contributing / Development workflow
-----------------------------------
- Edit JS/CSS/HTML under `static/` and `templates/`, then refresh the browser to preview.
- For larger changes consider using a bundler/build pipeline for minifying / transpiling assets, but the current app is intentionally dependency-free on the front end for simplicity.

License & credits
-----------------
- This manual and the sample app are provided as-is (no warranty). If you adapt the project, please include credits as you see fit.
- The app uses plain HTML/CSS/JS on the client and Flask on the server.

Contact & support
-----------------
If you need help integrating this into a larger product, or want production hardening and feature additions (e.g., persistence, user sessions, theming UI), reach out to your development team or modify the code locally.

---

Appendix: Useful commands summary
- Create venv:
  - `python3 -m venv venv`
- Activate venv:
  - macOS/Linux: `source venv/bin/activate`
  - Windows (PowerShell): `venv\Scripts\Activate.ps1`
- Install:
  - `pip install flask`
- Run:
  - `python main.py`
- Prod with gunicorn:
  - `pip install gunicorn`
  - `gunicorn -b 0.0.0.0:8000 main:create_app()`
- Build & run with Docker: create Dockerfile (example above), then `docker build -t wheel-of-names .` and `docker run -p 8000:8000 wheel-of-names`.

If you'd like, I can:
- produce a sample Dockerfile or docker-compose.yml tuned to this app,
- create a quick `requirements.txt` or `setup.py`,
- generate a small demo script to persist selected winners to disk,
- or write a short unit-test harness for the JavaScript wheel logic (using headless browser / Puppeteer) â€” tell me which you'd prefer next.

[2025-17-09 14:11:59 INFO] **[Seminar Conclusion]**:

 # Wheel of Names â€” User & Developer Manual

A small, responsive web app (Flask + HTML5 Canvas + vanilla JS) to enter names, pick one at random with a spinning wheel, and switch between visual themes.

This manual explains what the app does, how to install and run it, how to use the UI, how to customize themes and appearance, and how to deploy and troubleshoot the application.

---

Table of contents
- Overview
- Main features
- Requirements
- Quick install (local development)
- Run locally
- File / code overview
- How to use (user guide)
- Theme management (add / edit themes)
- Customization & development notes
- Deployment recommendations (production)
- Troubleshooting & FAQ
- Security & accessibility notes
- License & credits

---

Overview
--------
Wheel of Names is a simple, self-contained web app that lets you:
- Add names (one-per-line or single add),
- Visualize them as segments on a circular wheel,
- Spin the wheel with an animated rotation and land on a randomly selected winner,
- Change the application's look by selecting different themes (colors/background/text),
- Import/export name lists and load sample data.

The UI uses a canvas to draw and animate the wheel. Themes are supplied as JSON (themes.json) and applied at runtime.

Main features
-------------
- Add names via input or paste a newline-separated list.
- Load a sample set of names, import from clipboard/prompt, or export a text file.
- Responsive, high-DPI friendly canvas rendering.
- Theme selector with multiple built-in themes (editable via themes.json).
- Smooth spin animation with easing and configurable duration / spin count.
- Result displayed prominently after spin.

Requirements
------------
- Python 3.8+ (recommended)
- Flask (for the simple web server)
- Browser with Canvas and basic JavaScript support (modern Chrome, Firefox, Edge, Safari, etc.)

Optional (for production):
- gunicorn (or another WSGI server) if you want to run the app in production.
- Docker (if you prefer containerized deployment).

Quick install (local development)
---------------------------------
1. Clone or copy the project into a directory.
2. Create and activate a virtual environment (recommended):

   On macOS / Linux:
   ```
   python3 -m venv venv
   source venv/bin/activate
   ```

   On Windows (PowerShell):
   ```
   python -m venv venv
   venv\Scripts\Activate.ps1
   ```

3. Install Flask:
```
pip install flask
```

(Optionally install gunicorn for production testing: `pip install gunicorn`)

Run locally
-----------
Start the application:

```
python main.py
```

By default the app listens on http://127.0.0.1:5000/ (or 0.0.0.0:5000 when running directly as in main.py). You can override the port with the PORT environment variable:

Linux / macOS:
```
PORT=8080 python main.py
```

Windows (PowerShell):
```
$env:PORT=8080; python main.py
```

When running locally you should see Flask logs and be able to open the app in your browser.

File / code overview
--------------------
Top-level files in the repo:

- main.py
  - Small Flask application that serves templates and static files.
  - Route: `/` -> renders `templates/index.html`.
  - Uses the standard Flask `static` folder (serves `static/*`).

- templates/index.html
  - The main HTML file; contains the UI structure, includes CSS and JS.
  - Injects `window.THEMES_JSON_URL` using Flask's `url_for('static', filename='themes.json')` so JS can fetch themes reliably.

- static/themes.json
  - JSON array of themes. Each theme object contains:
    - id: machine identifier (string)
    - name: display name
    - bg: page background color (hex)
    - text: primary text color (hex)
    - accent: accent color used for pointer / button (hex)
    - colors: array of segment colors used for wheel segments

- static/css/styles.css
  - CSS variables and styles for layout and responsive design.
  - Uses CSS custom properties (--bg, --text, --accent, --panel-bg) that are updated by JS when themes change.

- static/js/wheel.js
  - Wheel class that draws the wheel on a canvas and animates spins.
  - Main APIs:
    - constructor(canvas, options)
    - setNames(names)
    - setTheme(theme) â€” (expects {colors: [...], text: '#...'})
    - draw()
    - resize()
    - spinToIndex(index, opts) -> Promise that resolves when animation completes
    - getRandomIndex() -> integer
  - Handles high-DPI displays by scaling backing store and CSS size.

- static/js/main.js
  - Wires the DOM controls to the Wheel instance.
  - Loads themes.json using `window.THEMES_JSON_URL`.
  - Handles add/enter, import/export, clear, load sample, theme selection, and spin logic.

How to use (user guide)
-----------------------
Open the app in a browser.

Main UI elements:
- Add name field: type a single name and click "Add" or press Enter.
- Names textarea: edit the full list (one name per line). The wheel updates automatically as you change this list.
- Load Sample: populates the textarea with example names.
- Clear: empties the names list.
- Import: paste a newline-separated list when prompted (simple import).
- Export: downloads the current names as `names.txt`.
- Theme selector: pick a theme to change colors and background.
- SPIN button: initiates the spin animation and picks a random winner.
- Result box: shows the winner after the spin.

Step-by-step example:
1. Type or paste names in the textarea or use the Add field.
2. Optionally change the theme in the theme dropdown.
3. Press "SPIN". The spin button becomes disabled and shows "Spinning..." while the wheel animates.
4. After the animation completes, the chosen name is displayed in the result area.

Spin details:
- The JS picks a random index via wheel.getRandomIndex(), then calls wheel.spinToIndex(index).
- spinToIndex() runs a 3â€“5 full-spins easing animation by default and lands so the chosen segment lines up with the pointer at the top.
- Duration is configurable in code (default uses 4500 ms in main.js; wheel.spinToIndex accepts an `opts` object with `duration`, `fullSpins`, and `randomOffset`).

Theme management (add / edit themes)
-----------------------------------
Themes live in `static/themes.json`. Each entry looks like:

```json
{
  "id": "classic",
  "name": "Classic",
  "bg": "#ffffff",
  "text": "#222222",
  "accent": "#007bff",
  "colors": ["#ffb3b3", "#ffd9b3", "#fff3b3", "#d9ffb3"]
}
```

To add a new theme:
1. Edit `static/themes.json` and add a new object to the array.
2. Give it a unique `id` and a `name`.
3. Provide `bg`, `text`, `accent` hex values and a `colors` array for wheel segments.
4. Save file and refresh the browser. The theme selector will show the new theme.

Notes:
- The app fetches themes.json on page load; if the fetch fails it falls back to a built-in default theme (so the app still works).
- Colors are applied by JS â€” `--bg`, `--text`, `--accent`, and `--panel-bg` CSS variables are updated.
- `panel-bg` is computed from `bg` to provide a slightly contrasting panel background (JS uses a small lighten/darken helper in main.js). If you prefer full control, modify CSS or modify the theme application code.

Customization & development notes
---------------------------------
Common customizations:
- Change default sample names in `main.js` (the `loadSampleBtn` handler).
- Change initial names loaded at launch at the bottom of `main.js` (initial `namesTextarea.value`).
- Change spin duration or spin behavior: modify the `duration` parameter passed to `wheel.spinToIndex()` in `main.js` (default `4500` ms in the example).
- Change number of full spins: pass `fullSpins` in `spinToIndex(index, { fullSpins: 5, duration: 5000 })`.

Wheel class API (quick reference)
- new Wheel(canvas, options)
  - options:
    - names: array of strings
    - colors: array of hex strings (segment colors)
    - textColor: color for text labels
    - font: CSS font string for canvas text
    - onDraw: callback executed after draw()
- setNames(names) â€” set the array of names and redraw
- setTheme(theme) â€” set colors and text color (expects an object containing `colors` and `text`)
- draw() â€” force a redraw
- resize() â€” recalculate metrics for the current canvas size and redraw
- getRandomIndex() â€” returns an integer in [0, names.length)
- spinToIndex(index, opts) â€” spins to the given index and returns a Promise that resolves with the index when done
  - opts may contain: duration (ms), fullSpins (integer), randomOffset (degrees)

Canvas scaling and high-DPI:
- wheel.resize() computes backing-store size to match devicePixelRatio so the canvas looks crisp on retina / high-DPI displays.
- The resizing logic is executed at startup and on window resize (and via ResizeObserver if available).

Development tips
- Static assets live under `static/`. Edit JS or CSS and refresh the page. In production consider adding cache headers or fingerprinting for cache busting.
- To test changes to `themes.json`, save the file and refresh. If browser caches the JSON, reload with cache disabled (DevTools) or configure Flask to send cache-control headers.

Deployment (production)
----------------------
Minimal production recommendations:
- Do not run Flask's builtin server with `debug=True` in production. In `main.py`, set `debug=False` and use a real WSGI server (gunicorn, uwsgi, etc.)
- Example with gunicorn:
  ```
  pip install gunicorn
  gunicorn -b 0.0.0.0:8000 main:create_app()
  ```
- Or create a small wrapper for production:
  ```
  export FLASK_APP=main.py
  flask run --host=0.0.0.0 --port=8000
  ```
  (still not recommended for high load)

Docker example
--------------
Basic Dockerfile (example)

```
FROM python:3.11-slim
WORKDIR /app
COPY . /app
RUN pip install --no-cache-dir flask gunicorn
ENV PORT=8000
EXPOSE 8000
CMD ["gunicorn", "-b", "0.0.0.0:8000", "main:create_app()"]
```

Troubleshooting & FAQ
---------------------
Q: The wheel is blank or names don't show after editing textarea.
- A: Make sure you have at least one non-empty line in the textarea. The wheel draws segments for the count returned by parsing the textarea (trimmed non-empty lines). If the canvas appears small or not updated, reload the page. Resize events trigger redraws.

Q: Themes aren't loading; I see a console error about fetching themes.json.
- A: The app attempts to fetch `window.THEMES_JSON_URL`, injected via Flask. If you serve the app under a subpath or are hosting static files elsewhere, ensure the URL is correct. Check browser console network tab. The app has a fallback theme and will continue to work.

Q: The pointer doesn't match segments or winner doesn't align precisely.
- A: The Canvas rotation and pointer alignment assume the pointer is visually at the top (270 degrees alignment in the code). If you change pointer position or rotation, adjust the calculation in wheel.spinToIndex().

Q: How can I change the spin feeling (ease / duration)?
- A: Modify the easing or `duration` used in spinToIndex or the argument passed from main.js when calling spinToIndex(index, { duration: 4500, fullSpins: 4 }).

Q: I want more advanced import/export or real persistence.
- A: Add an API endpoint in main.py to persist names server-side (POST/GET endpoints) and wire the JS to call those endpoints. For a simple file-based persistence, write to a JSON file in the static or data folder (careful with concurrency and security).

Accessibility notes
-------------------
- The result area uses `aria-live="polite"` so screen readers are notified when a winner is shown.
- The theme selector benefits from sufficient contrast â€” make sure custom themes have readable text vs background colors.
- The pointer element is marked `aria-hidden="true"`, as the result is announced in the result box. Button labels and form controls are standard HTML elements (accessible by keyboard).
- Keyboard usage:
  - Focus the name input and press Enter to add a name.
  - Use Tab to move between controls; the main "SPIN" is a button and can be activated with Enter / Space.

Security notes
--------------
- This app is a static client-side app with simple Flask static serving. If you add server-side persistence or file upload features, validate and sanitize inputs.
- If you expose the app to the public internet, run behind a secure reverse proxy (HTTPS), set appropriate CORS and CSP headers if needed, and avoid running with debug enabled.

Extending the app
-----------------
- Add analytical logging (e.g., track how often spin is pressed, which names are picked).
- Add repeat-safe selection modes (e.g., remove a name once it has been chosen).
- Add the ability to pin a winner or mark segments with weights.
- Add localization by using texts as localized strings in a small translation file loaded by main.js.

Example: Add weights
- Modify the wheel.getRandomIndex() to choose indexes proportionally to weights associated with names (e.g., read weights from a second column or UI control).

Contributing / Development workflow
-----------------------------------
- Edit JS/CSS/HTML under `static/` and `templates/`, then refresh the browser to preview.
- For larger changes consider using a bundler/build pipeline for minifying / transpiling assets, but the current app is intentionally dependency-free on the front end for simplicity.

License & credits
-----------------
- This manual and the sample app are provided as-is (no warranty). If you adapt the project, please include credits as you see fit.
- The app uses plain HTML/CSS/JS on the client and Flask on the server.

Contact & support
-----------------
If you need help integrating this into a larger product, or want production hardening and feature additions (e.g., persistence, user sessions, theming UI), reach out to your development team or modify the code locally.

---

Appendix: Useful commands summary
- Create venv:
  - `python3 -m venv venv`
- Activate venv:
  - macOS/Linux: `source venv/bin/activate`
  - Windows (PowerShell): `venv\Scripts\Activate.ps1`
- Install:
  - `pip install flask`
- Run:
  - `python main.py`
- Prod with gunicorn:
  - `pip install gunicorn`
  - `gunicorn -b 0.0.0.0:8000 main:create_app()`
- Build & run with Docker: create Dockerfile (example above), then `docker build -t wheel-of-names .` and `docker run -p 8000:8000 wheel-of-names`.

If you'd like, I can:
- produce a sample Dockerfile or docker-compose.yml tuned to this app,
- create a quick `requirements.txt` or `setup.py`,
- generate a small demo script to persist selected winners to disk,
- or write a short unit-test harness for the JavaScript wheel logic (using headless browser / Puppeteer) â€” tell me which you'd prefer next.

[2025-17-09 14:12:00 INFO] **[Post Info]**

Software Info: 

ðŸ’°**cost**=$0.097401

ðŸ”¨**version_updates**=4.0

ðŸ“ƒ**num_code_files**=0

ðŸž**num_png_files**=0

ðŸ“š**num_doc_files**=2

ðŸ“ƒ**code_lines**=0

ðŸ“‹**env_lines**=-1

ðŸ“’**manual_lines**=277

ðŸ—£**num_utterances**=25

ðŸ¤”**num_self_reflections**=1

â“**num_prompt_tokens**=62367

â—**num_completion_tokens**=44145

ðŸŒŸ**num_total_tokens**=106512

ðŸ•‘**duration**=895.00s

ChatDev Starts (20250917135704)

ChatDev Ends (20250917141159)



