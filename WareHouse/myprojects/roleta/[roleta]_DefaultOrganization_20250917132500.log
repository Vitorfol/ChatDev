[2025-17-09 13:25:00 INFO] **[Preprocessing]**

**ChatDev Starts** (20250917132500)

**Timestamp**: 20250917132500

**config_path**: C:\Users\necta\Desktop\Dev\ChatDev\ChatDev\CompanyConfig\Default\ChatChainConfig.json

**config_phase_path**: C:\Users\necta\Desktop\Dev\ChatDev\ChatDev\CompanyConfig\Default\PhaseConfig.json

**config_role_path**: C:\Users\necta\Desktop\Dev\ChatDev\ChatDev\CompanyConfig\Default\RoleConfig.json

**task_prompt**: [Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes. Do it in HTML, CSS, and JavaScript.]

**project_name**: [roleta]

**Log File**: C:\Users\necta\Desktop\Dev\ChatDev\ChatDev\WareHouse\[roleta]_DefaultOrganization_20250917132500.log

**ChatDevConfig**:
ChatEnvConfig.with_memory: False
ChatEnvConfig.clear_structure: True
ChatEnvConfig.git_management: False
ChatEnvConfig.gui_design: True
ChatEnvConfig.incremental_develop: False
ChatEnvConfig.background_prompt: ChatDev is a software company powered by multiple intelligent agents, such as chief executive officer, chief human resources officer, chief product officer, chief technology officer, etc, with a multi-agent organizational structure and the mission of 'changing the digital world through programming'.


**ChatGPTConfig**:
ChatGPTConfig(temperature=0.2, top_p=1.0, n=1, stream=False, stop=None, max_tokens=None, presence_penalty=0.0, frequency_penalty=0.0, logit_bias={}, user='')



[2025-17-09 13:25:00 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | [Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes. Do it in HTML, CSS, and JavaScript.] |
| **need_reflect** | True |
| **assistant_role_name** | Chief Product Officer |
| **user_role_name** | Chief Executive Officer |
| **phase_prompt** | ChatDev has made products in the following form before: Image: can present information in line chart, bar chart, flow chart, cloud chart, Gantt chart, etc. Document: can present information via .docx files. PowerPoint: can present information via .pptx files. Excel: can present information via .xlsx files. PDF: can present information via .pdf files. Website: can present personal resume, tutorial, products, or ideas, via .html files. Application: can implement visualized game, software, tool, etc, via python. Dashboard: can display a panel visualizing real-time information. Mind Map: can represent ideas, with related concepts arranged around a core concept. As the {assistant_role}, to satisfy the new user's demand and the product should be realizable, you should keep discussing with me to decide which product modality do we want the product to be? Note that we must ONLY discuss the product modality and do not discuss anything else! Once we all have expressed our opinion(s) and agree with the results of the discussion unanimously, any of us must actively terminate the discussion by replying with only one line, which starts with a single word , followed by our final product modality without any other words, e.g., " PowerPoint". |
| **phase_name** | DemandAnalysis |
| **assistant_role_prompt** | {chatdev_prompt} You are Chief Product Officer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. You are responsible for all product-related matters in ChatDev. Usually includes product design, product strategy, product vision, product innovation, project management and product marketing. Here is a new customer's task: {task}. To complete the task, you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully complete a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. To complete the task, I will give you one or more instructions, and you must help me to write a specific solution that appropriately solves the requested instruction based on your expertise and my needs. |
| **chat_turn_limit** | 10 |
| **placeholders** | {} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_3_5_TURBO |

[2025-17-09 13:25:00 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Chief Product Officer |
| **user_role_name** | Chief Executive Officer |
| **assistant_role_prompt** | {chatdev_prompt} You are Chief Product Officer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. You are responsible for all product-related matters in ChatDev. Usually includes product design, product strategy, product vision, product innovation, project management and product marketing. Here is a new customer's task: {task}. To complete the task, you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully complete a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. To complete the task, I will give you one or more instructions, and you must help me to write a specific solution that appropriately solves the requested instruction based on your expertise and my needs. |
| **task_prompt** | [Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes. Do it in HTML, CSS, and JavaScript.] |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_3_5_TURBO |
| **background_prompt** | ChatDev is a software company powered by multiple intelligent agents, such as chief executive officer, chief human resources officer, chief product officer, chief technology officer, etc, with a multi-agent organizational structure and the mission of 'changing the digital world through programming'. |

[2025-17-09 13:25:00 INFO] Chief Executive Officer: **[Start Chat]**

[ChatDev is a software company powered by multiple intelligent agents, such as chief executive officer, chief human resources officer, chief product officer, chief technology officer, etc, with a multi-agent organizational structure and the mission of 'changing the digital world through programming'.
You are Chief Product Officer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer.
You are responsible for all product-related matters in ChatDev. Usually includes product design, product strategy, product vision, product innovation, project management and product marketing.
Here is a new customer's task: [Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes. Do it in HTML, CSS, and JavaScript.].
To complete the task, you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]

ChatDev has made products in the following form before:

Image: can present information in line chart, bar chart, flow chart, cloud chart, Gantt chart, etc.

Document: can present information via .docx files.

PowerPoint: can present information via .pptx files.

Excel: can present information via .xlsx files.

PDF: can present information via .pdf files.

Website: can present personal resume, tutorial, products, or ideas, via .html files.

Application: can implement visualized game, software, tool, etc, via python.

Dashboard: can display a panel visualizing real-time information.

Mind Map: can represent ideas, with related concepts arranged around a core concept.

As the Chief Product Officer, to satisfy the new user's demand and the product should be realizable, you should keep discussing with me to decide which product modality do we want the product to be?

Note that we must ONLY discuss the product modality and do not discuss anything else! Once we all have expressed our opinion(s) and agree with the results of the discussion unanimously, any of us must actively terminate the discussion by replying with only one line, which starts with a single word <INFO>, followed by our final product modality without any other words, e.g., "<INFO> PowerPoint".

[2025-17-09 13:25:08 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2025-17-09 13:25:09 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 460
completion_tokens: 256
total_tokens: 716
cost: $-1.000000


[2025-17-09 13:25:26 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2025-17-09 13:25:26 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 558
completion_tokens: 269
total_tokens: 827
cost: $-1.000000


[2025-17-09 13:25:26 INFO] Chief Product Officer: **Chief Product Officer<->Chief Executive Officer on : DemandAnalysis, turn 0**

[ChatDev is a software company powered by multiple intelligent agents, such as chief executive officer, chief human resources officer, chief product officer, chief technology officer, etc, with a multi-agent organizational structure and the mission of 'changing the digital world through programming'.
You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully complete a task assigned by a new customer.
Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees.
Here is a new customer's task: [Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes. Do it in HTML, CSS, and JavaScript.].
To complete the task, I will give you one or more instructions, and you must help me to write a specific solution that appropriately solves the requested instruction based on your expertise and my needs.]

I propose we deliver this as a Website (HTML/CSS/JavaScript — .html files). Do you agree, or would you prefer one of the other modalities from the list (Image, Document, PowerPoint, Excel, PDF, Application, Dashboard, Mind Map)?

[2025-17-09 13:25:26 INFO] Chief Executive Officer: **Chief Product Officer<->Chief Executive Officer on : DemandAnalysis, turn 0**

[ChatDev is a software company powered by multiple intelligent agents, such as chief executive officer, chief human resources officer, chief product officer, chief technology officer, etc, with a multi-agent organizational structure and the mission of 'changing the digital world through programming'.
You are Chief Product Officer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer.
You are responsible for all product-related matters in ChatDev. Usually includes product design, product strategy, product vision, product innovation, project management and product marketing.
Here is a new customer's task: [Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes. Do it in HTML, CSS, and JavaScript.].
To complete the task, you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]

<INFO> Website

[2025-17-09 13:25:26 INFO] **[Seminar Conclusion]**:

 <INFO> Website

[2025-17-09 13:25:26 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | [Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes. Do it in HTML, CSS, and JavaScript.] |
| **need_reflect** | True |
| **assistant_role_name** | Chief Technology Officer |
| **user_role_name** | Chief Executive Officer |
| **phase_prompt** | According to the new user's task and some creative brainstorm ideas listed below:  Task: "{task}". Modality: "{modality}". Ideas: "{ideas}". We have decided to complete the task through a executable software implemented via a programming language.  As the {assistant_role}, to satisfy the new user's demand and make the software realizable, you should propose a concrete programming language. If python can complete this task via Python, please answer Python; otherwise, answer another programming language (e.g., Java, C++, etc,). Note that we must ONLY discuss the target programming language and do not discuss anything else! Once we all have expressed our opinion(s) and agree with the results of the discussion unanimously, any of us must actively terminate the discussion and conclude the best programming language we have discussed without any other words or reasons, return only one line using the format: " " where "" represents a programming language. |
| **phase_name** | LanguageChoose |
| **assistant_role_prompt** | {chatdev_prompt} You are Chief Technology Officer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. You are very familiar to information technology. You will make high-level decisions for the overarching technology infrastructure that closely align with the organization's goals, while you work alongside the organization's information technology ("IT") staff members to perform everyday operations. Here is a new customer's task: {task}. To complete the task, You must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully complete a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. To complete the task, I will give you one or more instructions, and you must help me to write a specific solution that appropriately solves the requested instruction based on your expertise and my needs. |
| **chat_turn_limit** | 10 |
| **placeholders** | {'task': '[Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes. Do it in HTML, CSS, and JavaScript.]', 'description': '', 'modality': 'website', 'ideas': ''} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_3_5_TURBO |

[2025-17-09 13:25:26 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Chief Technology Officer |
| **user_role_name** | Chief Executive Officer |
| **assistant_role_prompt** | {chatdev_prompt} You are Chief Technology Officer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. You are very familiar to information technology. You will make high-level decisions for the overarching technology infrastructure that closely align with the organization's goals, while you work alongside the organization's information technology ("IT") staff members to perform everyday operations. Here is a new customer's task: {task}. To complete the task, You must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully complete a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. To complete the task, I will give you one or more instructions, and you must help me to write a specific solution that appropriately solves the requested instruction based on your expertise and my needs. |
| **task_prompt** | [Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes. Do it in HTML, CSS, and JavaScript.] |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_3_5_TURBO |
| **background_prompt** | ChatDev is a software company powered by multiple intelligent agents, such as chief executive officer, chief human resources officer, chief product officer, chief technology officer, etc, with a multi-agent organizational structure and the mission of 'changing the digital world through programming'. |

[2025-17-09 13:25:26 INFO] Chief Executive Officer: **[Start Chat]**

[ChatDev is a software company powered by multiple intelligent agents, such as chief executive officer, chief human resources officer, chief product officer, chief technology officer, etc, with a multi-agent organizational structure and the mission of 'changing the digital world through programming'.
You are Chief Technology Officer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer.
You are very familiar to information technology. You will make high-level decisions for the overarching technology infrastructure that closely align with the organization's goals, while you work alongside the organization's information technology ("IT") staff members to perform everyday operations.
Here is a new customer's task: [Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes. Do it in HTML, CSS, and JavaScript.].
To complete the task, You must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]

According to the new user's task and some creative brainstorm ideas listed below: 

Task: "[Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes. Do it in HTML, CSS, and JavaScript.]".

Modality: "website".

Ideas: "".

We have decided to complete the task through a executable software implemented via a programming language. 

As the Chief Technology Officer, to satisfy the new user's demand and make the software realizable, you should propose a concrete programming language. If python can complete this task via Python, please answer Python; otherwise, answer another programming language (e.g., Java, C++, etc,).

Note that we must ONLY discuss the target programming language and do not discuss anything else! Once we all have expressed our opinion(s) and agree with the results of the discussion unanimously, any of us must actively terminate the discussion and conclude the best programming language we have discussed without any other words or reasons, return only one line using the format: "<INFO> *" where "*" represents a programming language.

[2025-17-09 13:25:32 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2025-17-09 13:25:32 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 439
completion_tokens: 142
total_tokens: 581
cost: $-1.000000


[2025-17-09 13:25:32 INFO] Chief Technology Officer: **Chief Technology Officer<->Chief Executive Officer on : LanguageChoose, turn 0**

[ChatDev is a software company powered by multiple intelligent agents, such as chief executive officer, chief human resources officer, chief product officer, chief technology officer, etc, with a multi-agent organizational structure and the mission of 'changing the digital world through programming'.
You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully complete a task assigned by a new customer.
Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees.
Here is a new customer's task: [Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes. Do it in HTML, CSS, and JavaScript.].
To complete the task, I will give you one or more instructions, and you must help me to write a specific solution that appropriately solves the requested instruction based on your expertise and my needs.]

<INFO> JavaScript

[2025-17-09 13:25:32 INFO] **[Seminar Conclusion]**:

 <INFO> JavaScript

[2025-17-09 13:25:32 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | [Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes. Do it in HTML, CSS, and JavaScript.] |
| **need_reflect** | False |
| **assistant_role_name** | Programmer |
| **user_role_name** | Chief Technology Officer |
| **phase_prompt** | According to the new user's task and our software designs listed below:  Task: "{task}". Task description: "{description}". Modality: "{modality}". Programming Language: "{language}" Ideas:"{ideas}" We have decided to complete the task through a executable software with multiple files implemented via {language}. As the {assistant_role}, to satisfy the new user's demands, you should write one or multiple files and make sure that every detail of the architecture is, in the end, implemented as code. {gui} Think step by step and reason yourself to the right decisions to make sure we get it right. You will first lay out the names of the core classes, functions, methods that will be necessary, as well as a quick comment on their purpose. Then you will output the content of each file including complete code. Each file must strictly follow a markdown code block format, where the following tokens must be replaced such that "FILENAME" is the lowercase file name including the file extension, "LANGUAGE" in the programming language, "DOCSTRING" is a string literal specified in source code that is used to document a specific segment of code, and "CODE" is the original code: FILENAME ```LANGUAGE ''' DOCSTRING ''' CODE ``` You will start with the "main" file, then go to the ones that are imported by that file, and so on. Please note that the code should be fully functional. Ensure to implement all functions. No placeholders (such as 'pass' in Python). |
| **phase_name** | Coding |
| **assistant_role_prompt** | {chatdev_prompt} You are Programmer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. You can write/create computer software or applications by providing a specific programming language to the computer. You have extensive computing and coding experience in many varieties of programming languages and platforms, such as Python, Java, C, C++, HTML, CSS, JavaScript, XML, SQL, PHP, etc,. Here is a new customer's task: {task}. To complete the task, you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Chief Technology Officer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. You are very familiar to information technology. You will make high-level decisions for the overarching technology infrastructure that closely align with the organization's goals, while you work alongside the organization's information technology ("IT") staff members to perform everyday operations. Here is a new customer's task: {task}. To complete the task, You must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'task': '[Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes. Do it in HTML, CSS, and JavaScript.]', 'description': '', 'modality': 'website', 'ideas': '', 'language': ' JavaScript', 'gui': 'The software should be equipped with graphical user interface (GUI) so that user can visually and graphically use it; so you must choose a GUI framework (e.g., in Python, you can implement GUI via tkinter, Pygame, Flexx, PyGUI, etc,).'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_3_5_TURBO |

[2025-17-09 13:25:32 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Programmer |
| **user_role_name** | Chief Technology Officer |
| **assistant_role_prompt** | {chatdev_prompt} You are Programmer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. You can write/create computer software or applications by providing a specific programming language to the computer. You have extensive computing and coding experience in many varieties of programming languages and platforms, such as Python, Java, C, C++, HTML, CSS, JavaScript, XML, SQL, PHP, etc,. Here is a new customer's task: {task}. To complete the task, you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Chief Technology Officer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. You are very familiar to information technology. You will make high-level decisions for the overarching technology infrastructure that closely align with the organization's goals, while you work alongside the organization's information technology ("IT") staff members to perform everyday operations. Here is a new customer's task: {task}. To complete the task, You must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **task_prompt** | [Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes. Do it in HTML, CSS, and JavaScript.] |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_3_5_TURBO |
| **background_prompt** | ChatDev is a software company powered by multiple intelligent agents, such as chief executive officer, chief human resources officer, chief product officer, chief technology officer, etc, with a multi-agent organizational structure and the mission of 'changing the digital world through programming'. |

[2025-17-09 13:25:32 INFO] Chief Technology Officer: **[Start Chat]**

[ChatDev is a software company powered by multiple intelligent agents, such as chief executive officer, chief human resources officer, chief product officer, chief technology officer, etc, with a multi-agent organizational structure and the mission of 'changing the digital world through programming'.
You are Programmer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer.
You can write/create computer software or applications by providing a specific programming language to the computer. You have extensive computing and coding experience in many varieties of programming languages and platforms, such as Python, Java, C, C++, HTML, CSS, JavaScript, XML, SQL, PHP, etc,.
Here is a new customer's task: [Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes. Do it in HTML, CSS, and JavaScript.].
To complete the task, you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]

According to the new user's task and our software designs listed below: 

Task: "[Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes. Do it in HTML, CSS, and JavaScript.]".

Task description: "".

Modality: "website".

Programming Language: " JavaScript"

Ideas:""

We have decided to complete the task through a executable software with multiple files implemented via  JavaScript. As the Programmer, to satisfy the new user's demands, you should write one or multiple files and make sure that every detail of the architecture is, in the end, implemented as code. The software should be equipped with graphical user interface (GUI) so that user can visually and graphically use it; so you must choose a GUI framework (e.g., in Python, you can implement GUI via tkinter, Pygame, Flexx, PyGUI, etc,).

Think step by step and reason yourself to the right decisions to make sure we get it right.

You will first lay out the names of the core classes, functions, methods that will be necessary, as well as a quick comment on their purpose.

Then you will output the content of each file including complete code. Each file must strictly follow a markdown code block format, where the following tokens must be replaced such that "FILENAME" is the lowercase file name including the file extension, "LANGUAGE" in the programming language, "DOCSTRING" is a string literal specified in source code that is used to document a specific segment of code, and "CODE" is the original code:

FILENAME

```LANGUAGE

'''

DOCSTRING

'''

CODE

```

You will start with the "main" file, then go to the ones that are imported by that file, and so on.

Please note that the code should be fully functional. Ensure to implement all functions. No placeholders (such as 'pass' in Python).

[2025-17-09 13:28:29 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2025-17-09 13:28:29 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 627
completion_tokens: 7717
total_tokens: 8344
cost: $-1.000000


[2025-17-09 13:28:29 INFO] Programmer: **Programmer<->Chief Technology Officer on : Coding, turn 0**

[ChatDev is a software company powered by multiple intelligent agents, such as chief executive officer, chief human resources officer, chief product officer, chief technology officer, etc, with a multi-agent organizational structure and the mission of 'changing the digital world through programming'.
You are Chief Technology Officer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer.
You are very familiar to information technology. You will make high-level decisions for the overarching technology infrastructure that closely align with the organization's goals, while you work alongside the organization's information technology ("IT") staff members to perform everyday operations.
Here is a new customer's task: [Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes. Do it in HTML, CSS, and JavaScript.].
To complete the task, You must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]

Core classes / functions and their purpose

- Wheel (class)
  - Purpose: Manage the drawing of the spinning wheel on a canvas, calculate segment angles, handle spin animation, and determine the winning name.

- UI functions
  - initUI(): set up event listeners and initialize UI state.
  - addName(name): add a single name to the list and update UI.
  - bulkAddNames(text): parse multiple names from a textarea and add them.
  - removeName(index): remove a name from the list.
  - clearNames(): clear all names.
  - renderNameList(): update the displayed list of names.
  - applyTheme(themeId): apply a visual theme to the page and wheel.
  - showMessage(text, type): show a temporary message to the user.
  - exportNames()/importNames(): optional helpers for saving/loading names (basic CSV).

- Utilities
  - rand(min, max): random integer
  - easeOutCubic(t): easing for spin animation

Files (in order)

index.html

```html
'''
<!--
DOCSTRING
This is the main HTML file for the Random Winner Wheel.
It contains the structure: input fields to add names, a canvas for the wheel,
controls (spin, clear, bulk add), theme selector, and placeholders for CSS/JS.
-->
'''

<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Random Winner Wheel</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body class="theme-light">
  <header>
    <h1>Random Winner Wheel</h1>
    <p>Enter participant names, choose a theme, and spin to pick a winner.</p>
  </header>

  <main>
    <section class="controls">
      <div class="add-single">
        <input id="nameInput" type="text" placeholder="Enter a name and press Add" aria-label="Name input" />
        <button id="addBtn">Add</button>
        <button id="addRandomBtn" title="Add a few sample random names">Add Sample</button>
      </div>

      <div class="bulk-add">
        <label for="bulkInput">Bulk add (comma, newline or semicolon separated):</label>
        <textarea id="bulkInput" placeholder="Alice, Bob, Charlie"></textarea>
        <div class="bulk-actions">
          <button id="bulkAddBtn">Bulk Add</button>
          <button id="clearBulkBtn">Clear Bulk</button>
        </div>
      </div>

      <div class="list-actions">
        <div class="theme-select">
          <label for="themeSelect">Theme:</label>
          <select id="themeSelect">
            <option value="light">Light</option>
            <option value="dark">Dark</option>
            <option value="neon">Neon</option>
            <option value="pastel">Pastel</option>
            <option value="retro">Retro</option>
          </select>
        </div>

        <div class="wheel-controls">
          <button id="spinBtn" class="primary">Spin</button>
          <button id="clearNamesBtn">Clear Names</button>
          <button id="exportBtn">Export CSV</button>
          <input id="importFile" type="file" accept=".csv,text/csv" style="display:none">
          <button id="importBtn">Import CSV</button>
        </div>
      </div>
    </section>

    <section class="wheel-area">
      <div class="wheel-container">
        <canvas id="wheelCanvas" width="600" height="600" aria-label="Spinning wheel"></canvas>
        <div class="pointer">▼</div>
      </div>

      <aside class="participants">
        <h2>Participants (<span id="count">0</span>)</h2>
        <ul id="nameList" aria-live="polite"></ul>
      </aside>
    </section>

    <section class="result" id="result" aria-live="polite" hidden>
      <h2>Winner</h2>
      <div id="winnerName" class="winnerName"></div>
      <button id="rerollBtn">Spin Again</button>
    </section>
  </main>

  <footer>
    <small>Built with HTML, CSS, and JavaScript. Themes change both UI and wheel colors.</small>
  </footer>

  <script src="script.js"></script>
</body>
</html>
```

styles.css

```css
'''
DOCSTRING
Stylesheet for the Random Winner Wheel.
Defines layout, themes, wheel container sizing, and animations.
'''
/* Reset & base */
* { box-sizing: border-box; margin: 0; padding: 0; }
html,body { height: 100%; font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; background: var(--bg); color: var(--fg); }
:root {
  --bg: #f7f8fb;
  --fg: #222;
  --muted: #666;
  --accent: #2b8cff;
  --card: #ffffff;
  --primary-btn-bg: var(--accent);
  --primary-btn-fg: #fff;
  --shadow: rgba(15,15,15,0.08);
}

/* Themes */
body.theme-light {
  --bg: #f7f8fb;
  --fg: #222;
  --muted: #5b6170;
  --accent: #2b8cff;
  --card: #fff;
  --wheel-seq: 0;
}
body.theme-dark {
  --bg: #0f1724;
  --fg: #e6eef8;
  --muted: #a9b1c2;
  --accent: #7c5cff;
  --card: #0b1220;
}
body.theme-neon {
  --bg: #0a0a0f;
  --fg: #e9f9ff;
  --muted: #a6f3ff;
  --accent: #39ff14;
  --card: #09101a;
}
body.theme-pastel {
  --bg: #fffaf6;
  --fg: #3c3a3a;
  --muted: #8d8a8a;
  --accent: #ff7aa2;
  --card: #fff;
}
body.theme-retro {
  --bg: #fff6e7;
  --fg: #402b2b;
  --muted: #856e6e;
  --accent: #ffb86b;
  --card: #fff0e6;
}

/* Layout */
header { padding: 18px 24px; text-align: center; background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent); }
header h1 { font-size: 1.5rem; margin-bottom: 6px; }
main { padding: 18px; max-width: 1100px; margin: 0 auto; }
.controls { display: grid; gap: 12px; margin-bottom: 18px; }
.add-single { display:flex; gap:8px; }
.add-single input[type="text"] { flex:1; padding:10px; border-radius:8px; border:1px solid rgba(0,0,0,0.08); background:var(--card); color:var(--fg); }
.add-single button { padding:10px 12px; border-radius:8px; border: none; cursor:pointer; background: var(--primary-btn-bg); color: var(--primary-btn-fg); }
.add-single button#addRandomBtn { background: transparent; border: 1px solid rgba(0,0,0,0.06); color: var(--fg); }

.bulk-add textarea { width:100%; min-height:64px; margin-top:6px; padding:8px; border-radius:8px; border:1px solid rgba(0,0,0,0.06); background:var(--card); color:var(--fg); }
.bulk-actions { display:flex; gap:8px; margin-top:8px; }

.list-actions { display:flex; justify-content:space-between; align-items:center; gap:16px; flex-wrap:wrap; }
.theme-select select { padding:8px; border-radius:8px; border:1px solid rgba(0,0,0,0.06); }

.wheel-area { display:flex; gap:18px; align-items:start; flex-wrap:wrap; }
.wheel-container { position: relative; width: 600px; height: 600px; max-width: 90vw; max-height: 90vw; display:flex; align-items:center; justify-content:center; background: transparent; }
.pointer { position:absolute; top:6px; font-size:28px; transform: translateY(-50%); text-shadow: 0 2px 8px rgba(0,0,0,0.25); color: var(--accent); pointer-events:none; }

.participants { width: 320px; max-width: 40vw; background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent); padding:12px; border-radius:10px; box-shadow: 0 6px 18px var(--shadow); }
.participants h2 { margin-bottom:8px; font-size:1.05rem; }
#nameList { list-style:none; max-height:420px; overflow:auto; display:block; }
#nameList li { padding:8px; border-radius:6px; display:flex; justify-content:space-between; align-items:center; gap:8px; margin-bottom:8px; background: var(--card); border:1px solid rgba(0,0,0,0.04); }
#nameList li button { background: transparent; border: none; color: var(--muted); cursor:pointer; }

.result { margin-top:18px; padding:12px; border-radius:8px; background: var(--card); text-align:center; box-shadow: 0 6px 18px var(--shadow); }
.result .winnerName { font-size:1.4rem; font-weight:700; margin:8px 0; color: var(--accent); }

/* Buttons */
button { cursor:pointer; padding:8px 12px; border-radius:8px; border:1px solid rgba(0,0,0,0.06); background: transparent; color:var(--fg); }
button.primary { background: var(--primary-btn-bg); color: var(--primary-btn-fg); border: none; }

/* Responsive */
@media (max-width: 900px) {
  .wheel-area { flex-direction:column; align-items:center; }
  .participants { width: 100%; max-width: 100%; }
}

/* Wheel canvas scaling helper */
#wheelCanvas { border-radius:50%; box-shadow: 0 12px 26px rgba(0,0,0,0.12); background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.02), transparent); }
```

script.js

```javascript
'''
DOCSTRING
Script for the Random Winner Wheel.
Contains the Wheel class to draw and spin the canvas-based wheel and UI glue code to manage names and themes.
'''
/* Main JavaScript - Wheel + UI logic */

(() => {
  // Utilities
  function rand(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }
  function easeOutCubic(t) { return 1 - Math.pow(1 - t, 3); }

  // Color palettes for themes (will be used to paint wheel segments)
  const THEME_PALETTES = {
    light: ['#FF8A80','#FFD180','#FFF59D','#C8E6C9','#80DEEA','#A7FFEB','#B39DDB','#90CAF9'],
    dark: ['#ff6b6b','#ffd166','#faff8e','#b9f6ca','#4dd0e1','#80cbc4','#b388ff','#64b5f6'],
    neon: ['#ff2d95','#7cff01','#00ffff','#ffdd00','#ff6a00','#00ff9e','#ff00ff','#47ffa2'],
    pastel: ['#ffdbe9','#fff0b3','#d1ffd6','#cfefff','#e7dfff','#ffd6e7','#fbe7d6','#e6f7ff'],
    retro: ['#ffb86b','#ffd3a8','#f3e2a9','#b8e0d2','#c0b9ff','#ffb6c1','#f6c49f','#c3d69b']
  };

  // Wheel class
  class Wheel {
    /*
    Manage wheel: drawing, recalculating segments, spinning animation, and determining winner.
    */
    constructor(canvas, options = {}) {
      this.canvas = canvas;
      this.ctx = canvas.getContext('2d');
      this.names = [];
      this.rotation = 0; // radians
      this.isSpinning = false;
      this.frame = null;
      this.onResult = options.onResult || function() {};
      this.theme = options.theme || 'light';
      this.padAngle = 0.02; // radians padding between segments
      this.textColor = '#111';
      this._devicePixelRatioFix();
      window.addEventListener('resize', () => { this._devicePixelRatioFix(); this.draw(); });
    }

    _devicePixelRatioFix() {
      const dpr = window.devicePixelRatio || 1;
      const rect = this.canvas.getBoundingClientRect();
      this.canvas.width = rect.width * dpr;
      this.canvas.height = rect.height * dpr;
      this.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      this.centerX = rect.width / 2;
      this.centerY = rect.height / 2;
      this.radius = Math.min(rect.width, rect.height) / 2 - 18;
    }

    setTheme(themeId) { this.theme = themeId; this.draw(); }

    setNames(names) {
      this.names = names.slice();
      this.draw();
    }

    addName(name) {
      this.names.push(name);
      this.draw();
    }

    removeName(index) {
      if (index >= 0 && index < this.names.length) {
        this.names.splice(index,1);
        this.draw();
      }
    }

    clearNames() {
      this.names = [];
      this.draw();
    }

    draw() {
      const ctx = this.ctx;
      const w = this.canvas.width / (window.devicePixelRatio || 1);
      const h = this.canvas.height / (window.devicePixelRatio || 1);
      ctx.clearRect(0,0,w,h);
      ctx.save();
      ctx.translate(this.centerX, this.centerY);
      ctx.rotate(this.rotation);
      // draw segments
      const count = Math.max(this.names.length, 1);
      const palette = THEME_PALETTES[this.theme] || THEME_PALETTES.light;
      for (let i = 0; i < count; i++) {
        const start = (i / count) * Math.PI * 2;
        const end = ((i + 1) / count) * Math.PI * 2;
        ctx.beginPath();
        ctx.moveTo(0,0);
        ctx.arc(0,0,this.radius, start + this.padAngle, end - this.padAngle, false);
        ctx.closePath();
        const color = palette[i % palette.length];
        ctx.fillStyle = color;
        ctx.fill();
        ctx.strokeStyle = (i % 2 === 0) ? 'rgba(0,0,0,0.06)' : 'rgba(0,0,0,0.03)';
        ctx.lineWidth = 1;
        ctx.stroke();

        // draw text label
        const mid = (start + end) / 2;
        ctx.save();
        ctx.rotate(mid);
        ctx.translate(this.radius * 0.6, 0);
        ctx.rotate(Math.PI/2);
        ctx.fillStyle = getTextColor(color);
        ctx.font = `${Math.max(12, Math.min(22, this.radius / 8))}px sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        const label = (this.names.length === 0) ? 'Add names' : this.names[i % this.names.length];
        wrapFillText(ctx, label, 0, 0, this.radius * 0.5, 16);
        ctx.restore();
      }

      // draw center circle
      ctx.beginPath();
      ctx.arc(0,0, this.radius * 0.16, 0, Math.PI*2);
      ctx.fillStyle = 'rgba(255,255,255,0.9)';
      ctx.fill();
      ctx.strokeStyle = 'rgba(0,0,0,0.06)';
      ctx.stroke();

      ctx.restore();
      // draw outer ring (pointer side neutral)
      ctx.beginPath();
      ctx.arc(this.centerX, this.centerY, this.radius + 10, 0, Math.PI*2);
      ctx.strokeStyle = 'rgba(0,0,0,0.03)';
      ctx.lineWidth = 2;
      ctx.stroke();
    }

    spin() {
      if (this.isSpinning || this.names.length === 0) return;
      this.isSpinning = true;
      const count = this.names.length;
      // Determine random winner index to land on:
      const winnerIndex = rand(0, count - 1);
      // Calculate final rotation so that winner segment lines up with pointer at top (pointer at canvas top - rotation must align)
      // Our pointer is at the top (canvas 0 angle). The segment mid-angle for index i (without rotation) is ((i + 0.5)/count)*2pi
      const segmentMid = ((winnerIndex + 0.5) / count) * Math.PI * 2;
      // We want segmentMid + rotation_final == -Math.PI/2 (so it points at the top pointer), so rotation_final = -Math.PI/2 - segmentMid + 2pi*N
      const extraTurns = rand(5, 8); // full spins
      const rotationFinal = -Math.PI/2 - segmentMid + extraTurns * Math.PI * 2;
      const startRotation = this.rotation % (Math.PI * 2);
      const delta = rotationFinal - startRotation;
      const duration = 4000 + Math.random() * 1500; // ms
      const startTime = performance.now();

      const animate = (now) => {
        const elapsed = now - startTime;
        const t = Math.min(elapsed / duration, 1);
        const eased = easeOutCubic(t);
        this.rotation = startRotation + delta * eased;
        this.draw();
        if (t < 1) {
          this.frame = requestAnimationFrame(animate);
        } else {
          this.isSpinning = false;
          // Normalize rotation within 0..2pi
          this.rotation = ((this.rotation % (Math.PI*2)) + Math.PI*2) % (Math.PI*2);
          this.draw();
          // Compute final winner index again from rotation
          const finalAngle = (-this.rotation - Math.PI/2 + Math.PI*2) % (Math.PI*2);
          const resultingIndex = Math.floor(((finalAngle / (Math.PI*2)) * count + count) % count);
          const winner = this.names[resultingIndex];
          this.onResult({ index: resultingIndex, name: winner });
        }
      };

      this.frame = requestAnimationFrame(animate);
    }
  }

  // Helper: pick readable text color for a background
  function getTextColor(hex) {
    // remove # and convert
    const h = hex.replace('#','');
    const r = parseInt(h.substring(0,2),16);
    const g = parseInt(h.substring(2,4),16);
    const b = parseInt(h.substring(4,6),16);
    // luminance
    const lum = (0.299*r + 0.587*g + 0.114*b) / 255;
    return lum > 0.65 ? '#111' : '#fff';
  }

  // Helper: wrap text within a given width (draws multi-line if necessary)
  function wrapFillText(ctx, text, x, y, maxWidth, lineHeight) {
    const words = (text || '').split(/\s+/);
    if (words.length === 0) return;
    let line = '';
    const lines = [];
    for (let n = 0; n < words.length; n++) {
      const testLine = line ? line + ' ' + words[n] : words[n];
      const metrics = ctx.measureText(testLine);
      if (metrics.width > maxWidth && line) {
        lines.push(line);
        line = words[n];
      } else {
        line = testLine;
      }
    }
    if (line) lines.push(line);
    // If still too many lines, shrink font or truncate
    for (let i=0;i<lines.length;i++){
      ctx.fillText(lines[i], x, y + (i - (lines.length-1)/2) * lineHeight);
    }
  }

  // UI glue
  document.addEventListener('DOMContentLoaded', () => {
    const canvas = document.getElementById('wheelCanvas');
    const wheel = new Wheel(canvas, { theme: 'light', onResult: onWinner });
    const nameInput = document.getElementById('nameInput');
    const addBtn = document.getElementById('addBtn');
    const addRandomBtn = document.getElementById('addRandomBtn');
    const bulkInput = document.getElementById('bulkInput');
    const bulkAddBtn = document.getElementById('bulkAddBtn');
    const clearBulkBtn = document.getElementById('clearBulkBtn');
    const nameList = document.getElementById('nameList');
    const countSpan = document.getElementById('count');
    const spinBtn = document.getElementById('spinBtn');
    const rerollBtn = document.getElementById('rerollBtn');
    const clearNamesBtn = document.getElementById('clearNamesBtn');
    const themeSelect = document.getElementById('themeSelect');
    const resultSection = document.getElementById('result');
    const winnerNameDiv = document.getElementById('winnerName');
    const exportBtn = document.getElementById('exportBtn');
    const importBtn = document.getElementById('importBtn');
    const importFile = document.getElementById('importFile');

    // Initial draw
    wheel.draw();

    function updateUI() {
      const names = wheel.names;
      countSpan.textContent = names.length;
      renderNameList();
    }

    function renderNameList() {
      nameList.innerHTML = '';
      wheel.names.forEach((n, i) => {
        const li = document.createElement('li');
        const span = document.createElement('span');
        span.textContent = n;
        li.appendChild(span);
        const btn = document.createElement('button');
        btn.title = 'Remove';
        btn.innerHTML = '✕';
        btn.addEventListener('click', () => {
          wheel.removeName(i);
          updateUI();
        });
        li.appendChild(btn);
        nameList.appendChild(li);
      });
    }

    function addNameFromInput() {
      const v = nameInput.value.trim();
      if (!v) { showMessage('Please enter a name.', 'warn'); return; }
      wheel.addName(v);
      nameInput.value = '';
      updateUI();
    }

    addBtn.addEventListener('click', addNameFromInput);
    nameInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') addNameFromInput(); });

    addRandomBtn.addEventListener('click', () => {
      const samples = ['Alex','Jordan','Taylor','Sam','Jamie','Casey','Morgan','Riley','Avery','Dana'];
      const count = rand(3,6);
      for (let i=0;i<count;i++) wheel.addName(samples[rand(0,samples.length-1)] + (rand(1,100)));
      updateUI();
    });

    bulkAddBtn.addEventListener('click', () => {
      const text = bulkInput.value.trim();
      if (!text) { showMessage('Bulk input is empty.', 'warn'); return; }
      const parsed = text.split(/[\n,;]+/).map(s => s.trim()).filter(s => s);
      parsed.forEach(p => wheel.addName(p));
      bulkInput.value = '';
      updateUI();
      showMessage(`Added ${parsed.length} names.`, 'info');
    });

    clearBulkBtn.addEventListener('click', () => { bulkInput.value = ''; });

    spinBtn.addEventListener('click', () => {
      if (wheel.names.length === 0) { showMessage('Add at least one name to spin.', 'warn'); return; }
      resultSection.hidden = true;
      winnerNameDiv.textContent = '';
      wheel.spin();
      spinBtn.disabled = true;
      const checkFinish = setInterval(() => {
        if (!wheel.isSpinning) {
          clearInterval(checkFinish);
          spinBtn.disabled = false;
        }
      }, 200);
    });

    rerollBtn.addEventListener('click', () => {
      resultSection.hidden = true;
      wheel.spin();
    });

    clearNamesBtn.addEventListener('click', () => {
      if (confirm('Clear all names?')) {
        wheel.clearNames();
        updateUI();
      }
    });

    themeSelect.addEventListener('change', (e) => {
      const t = e.target.value;
      document.body.className = 'theme-' + t;
      wheel.setTheme(t);
    });

    function onWinner(result) {
      winnerNameDiv.textContent = result.name || '—';
      resultSection.hidden = false;
      // Flash the winner item in the list (if still present)
      const items = Array.from(nameList.children);
      items.forEach((li, idx) => { li.classList.toggle('winner', idx === result.index); });
      showMessage(`Winner: ${result.name}`, 'success', 4000);
    }

    // Simple message area
    function showMessage(text, type = 'info', duration = 2200) {
      // create small toast
      const t = document.createElement('div');
      t.className = 'tmp-toast ' + type;
      t.textContent = text;
      document.body.appendChild(t);
      setTimeout(()=> { t.style.opacity = '0'; t.style.transform = 'translateY(-10px)'; }, duration - 300);
      setTimeout(()=> { try { t.remove(); } catch(e){} }, duration);
    }

    // Export/import CSV
    exportBtn.addEventListener('click', () => {
      if (wheel.names.length === 0) { showMessage('No names to export.', 'warn'); return; }
      const csv = wheel.names.map(n => `"${(n||'').replace(/"/g,'""')}"`).join('\n');
      const blob = new Blob([csv], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'participants.csv';
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
      showMessage('Exported CSV', 'info');
    });

    importBtn.addEventListener('click', () => { importFile.click(); });

    importFile.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (ev) => {
        const txt = ev.target.result;
        const lines = txt.split(/\r?\n/).map(s => s.trim()).filter(s => s);
        // basic CSV unquote
        const parsed = lines.map(l => {
          if (l.startsWith('"') && l.endsWith('"')) {
            return l.slice(1,-1).replace(/""/g,'"');
          }
          return l;
        });
        parsed.forEach(p => wheel.addName(p));
        updateUI();
        showMessage(`Imported ${parsed.length} names`, 'info');
      };
      reader.readAsText(file);
      importFile.value = '';
    });

    // Initial sample
    // wheel.addName('Alice'); wheel.addName('Bob'); wheel.addName('Charlie');
    updateUI();

    // (Optional) keyboard shortcuts
    window.addEventListener('keydown', (e) => {
      if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'k') {
        e.preventDefault();
        nameInput.focus();
      }
      if (e.key === ' ') {
        // space triggers spin if not focusing an input
        if (document.activeElement.tagName !== 'INPUT' && document.activeElement.tagName !== 'TEXTAREA') {
          e.preventDefault();
          spinBtn.click();
        }
      }
    });
  });
})();
```

[2025-17-09 13:28:29 INFO] **[Seminar Conclusion]**:

 Core classes / functions and their purpose

- Wheel (class)
  - Purpose: Manage the drawing of the spinning wheel on a canvas, calculate segment angles, handle spin animation, and determine the winning name.

- UI functions
  - initUI(): set up event listeners and initialize UI state.
  - addName(name): add a single name to the list and update UI.
  - bulkAddNames(text): parse multiple names from a textarea and add them.
  - removeName(index): remove a name from the list.
  - clearNames(): clear all names.
  - renderNameList(): update the displayed list of names.
  - applyTheme(themeId): apply a visual theme to the page and wheel.
  - showMessage(text, type): show a temporary message to the user.
  - exportNames()/importNames(): optional helpers for saving/loading names (basic CSV).

- Utilities
  - rand(min, max): random integer
  - easeOutCubic(t): easing for spin animation

Files (in order)

index.html

```html
'''
<!--
DOCSTRING
This is the main HTML file for the Random Winner Wheel.
It contains the structure: input fields to add names, a canvas for the wheel,
controls (spin, clear, bulk add), theme selector, and placeholders for CSS/JS.
-->
'''

<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Random Winner Wheel</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body class="theme-light">
  <header>
    <h1>Random Winner Wheel</h1>
    <p>Enter participant names, choose a theme, and spin to pick a winner.</p>
  </header>

  <main>
    <section class="controls">
      <div class="add-single">
        <input id="nameInput" type="text" placeholder="Enter a name and press Add" aria-label="Name input" />
        <button id="addBtn">Add</button>
        <button id="addRandomBtn" title="Add a few sample random names">Add Sample</button>
      </div>

      <div class="bulk-add">
        <label for="bulkInput">Bulk add (comma, newline or semicolon separated):</label>
        <textarea id="bulkInput" placeholder="Alice, Bob, Charlie"></textarea>
        <div class="bulk-actions">
          <button id="bulkAddBtn">Bulk Add</button>
          <button id="clearBulkBtn">Clear Bulk</button>
        </div>
      </div>

      <div class="list-actions">
        <div class="theme-select">
          <label for="themeSelect">Theme:</label>
          <select id="themeSelect">
            <option value="light">Light</option>
            <option value="dark">Dark</option>
            <option value="neon">Neon</option>
            <option value="pastel">Pastel</option>
            <option value="retro">Retro</option>
          </select>
        </div>

        <div class="wheel-controls">
          <button id="spinBtn" class="primary">Spin</button>
          <button id="clearNamesBtn">Clear Names</button>
          <button id="exportBtn">Export CSV</button>
          <input id="importFile" type="file" accept=".csv,text/csv" style="display:none">
          <button id="importBtn">Import CSV</button>
        </div>
      </div>
    </section>

    <section class="wheel-area">
      <div class="wheel-container">
        <canvas id="wheelCanvas" width="600" height="600" aria-label="Spinning wheel"></canvas>
        <div class="pointer">▼</div>
      </div>

      <aside class="participants">
        <h2>Participants (<span id="count">0</span>)</h2>
        <ul id="nameList" aria-live="polite"></ul>
      </aside>
    </section>

    <section class="result" id="result" aria-live="polite" hidden>
      <h2>Winner</h2>
      <div id="winnerName" class="winnerName"></div>
      <button id="rerollBtn">Spin Again</button>
    </section>
  </main>

  <footer>
    <small>Built with HTML, CSS, and JavaScript. Themes change both UI and wheel colors.</small>
  </footer>

  <script src="script.js"></script>
</body>
</html>
```

styles.css

```css
'''
DOCSTRING
Stylesheet for the Random Winner Wheel.
Defines layout, themes, wheel container sizing, and animations.
'''
/* Reset & base */
* { box-sizing: border-box; margin: 0; padding: 0; }
html,body { height: 100%; font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; background: var(--bg); color: var(--fg); }
:root {
  --bg: #f7f8fb;
  --fg: #222;
  --muted: #666;
  --accent: #2b8cff;
  --card: #ffffff;
  --primary-btn-bg: var(--accent);
  --primary-btn-fg: #fff;
  --shadow: rgba(15,15,15,0.08);
}

/* Themes */
body.theme-light {
  --bg: #f7f8fb;
  --fg: #222;
  --muted: #5b6170;
  --accent: #2b8cff;
  --card: #fff;
  --wheel-seq: 0;
}
body.theme-dark {
  --bg: #0f1724;
  --fg: #e6eef8;
  --muted: #a9b1c2;
  --accent: #7c5cff;
  --card: #0b1220;
}
body.theme-neon {
  --bg: #0a0a0f;
  --fg: #e9f9ff;
  --muted: #a6f3ff;
  --accent: #39ff14;
  --card: #09101a;
}
body.theme-pastel {
  --bg: #fffaf6;
  --fg: #3c3a3a;
  --muted: #8d8a8a;
  --accent: #ff7aa2;
  --card: #fff;
}
body.theme-retro {
  --bg: #fff6e7;
  --fg: #402b2b;
  --muted: #856e6e;
  --accent: #ffb86b;
  --card: #fff0e6;
}

/* Layout */
header { padding: 18px 24px; text-align: center; background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent); }
header h1 { font-size: 1.5rem; margin-bottom: 6px; }
main { padding: 18px; max-width: 1100px; margin: 0 auto; }
.controls { display: grid; gap: 12px; margin-bottom: 18px; }
.add-single { display:flex; gap:8px; }
.add-single input[type="text"] { flex:1; padding:10px; border-radius:8px; border:1px solid rgba(0,0,0,0.08); background:var(--card); color:var(--fg); }
.add-single button { padding:10px 12px; border-radius:8px; border: none; cursor:pointer; background: var(--primary-btn-bg); color: var(--primary-btn-fg); }
.add-single button#addRandomBtn { background: transparent; border: 1px solid rgba(0,0,0,0.06); color: var(--fg); }

.bulk-add textarea { width:100%; min-height:64px; margin-top:6px; padding:8px; border-radius:8px; border:1px solid rgba(0,0,0,0.06); background:var(--card); color:var(--fg); }
.bulk-actions { display:flex; gap:8px; margin-top:8px; }

.list-actions { display:flex; justify-content:space-between; align-items:center; gap:16px; flex-wrap:wrap; }
.theme-select select { padding:8px; border-radius:8px; border:1px solid rgba(0,0,0,0.06); }

.wheel-area { display:flex; gap:18px; align-items:start; flex-wrap:wrap; }
.wheel-container { position: relative; width: 600px; height: 600px; max-width: 90vw; max-height: 90vw; display:flex; align-items:center; justify-content:center; background: transparent; }
.pointer { position:absolute; top:6px; font-size:28px; transform: translateY(-50%); text-shadow: 0 2px 8px rgba(0,0,0,0.25); color: var(--accent); pointer-events:none; }

.participants { width: 320px; max-width: 40vw; background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent); padding:12px; border-radius:10px; box-shadow: 0 6px 18px var(--shadow); }
.participants h2 { margin-bottom:8px; font-size:1.05rem; }
#nameList { list-style:none; max-height:420px; overflow:auto; display:block; }
#nameList li { padding:8px; border-radius:6px; display:flex; justify-content:space-between; align-items:center; gap:8px; margin-bottom:8px; background: var(--card); border:1px solid rgba(0,0,0,0.04); }
#nameList li button { background: transparent; border: none; color: var(--muted); cursor:pointer; }

.result { margin-top:18px; padding:12px; border-radius:8px; background: var(--card); text-align:center; box-shadow: 0 6px 18px var(--shadow); }
.result .winnerName { font-size:1.4rem; font-weight:700; margin:8px 0; color: var(--accent); }

/* Buttons */
button { cursor:pointer; padding:8px 12px; border-radius:8px; border:1px solid rgba(0,0,0,0.06); background: transparent; color:var(--fg); }
button.primary { background: var(--primary-btn-bg); color: var(--primary-btn-fg); border: none; }

/* Responsive */
@media (max-width: 900px) {
  .wheel-area { flex-direction:column; align-items:center; }
  .participants { width: 100%; max-width: 100%; }
}

/* Wheel canvas scaling helper */
#wheelCanvas { border-radius:50%; box-shadow: 0 12px 26px rgba(0,0,0,0.12); background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.02), transparent); }
```

script.js

```javascript
'''
DOCSTRING
Script for the Random Winner Wheel.
Contains the Wheel class to draw and spin the canvas-based wheel and UI glue code to manage names and themes.
'''
/* Main JavaScript - Wheel + UI logic */

(() => {
  // Utilities
  function rand(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }
  function easeOutCubic(t) { return 1 - Math.pow(1 - t, 3); }

  // Color palettes for themes (will be used to paint wheel segments)
  const THEME_PALETTES = {
    light: ['#FF8A80','#FFD180','#FFF59D','#C8E6C9','#80DEEA','#A7FFEB','#B39DDB','#90CAF9'],
    dark: ['#ff6b6b','#ffd166','#faff8e','#b9f6ca','#4dd0e1','#80cbc4','#b388ff','#64b5f6'],
    neon: ['#ff2d95','#7cff01','#00ffff','#ffdd00','#ff6a00','#00ff9e','#ff00ff','#47ffa2'],
    pastel: ['#ffdbe9','#fff0b3','#d1ffd6','#cfefff','#e7dfff','#ffd6e7','#fbe7d6','#e6f7ff'],
    retro: ['#ffb86b','#ffd3a8','#f3e2a9','#b8e0d2','#c0b9ff','#ffb6c1','#f6c49f','#c3d69b']
  };

  // Wheel class
  class Wheel {
    /*
    Manage wheel: drawing, recalculating segments, spinning animation, and determining winner.
    */
    constructor(canvas, options = {}) {
      this.canvas = canvas;
      this.ctx = canvas.getContext('2d');
      this.names = [];
      this.rotation = 0; // radians
      this.isSpinning = false;
      this.frame = null;
      this.onResult = options.onResult || function() {};
      this.theme = options.theme || 'light';
      this.padAngle = 0.02; // radians padding between segments
      this.textColor = '#111';
      this._devicePixelRatioFix();
      window.addEventListener('resize', () => { this._devicePixelRatioFix(); this.draw(); });
    }

    _devicePixelRatioFix() {
      const dpr = window.devicePixelRatio || 1;
      const rect = this.canvas.getBoundingClientRect();
      this.canvas.width = rect.width * dpr;
      this.canvas.height = rect.height * dpr;
      this.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      this.centerX = rect.width / 2;
      this.centerY = rect.height / 2;
      this.radius = Math.min(rect.width, rect.height) / 2 - 18;
    }

    setTheme(themeId) { this.theme = themeId; this.draw(); }

    setNames(names) {
      this.names = names.slice();
      this.draw();
    }

    addName(name) {
      this.names.push(name);
      this.draw();
    }

    removeName(index) {
      if (index >= 0 && index < this.names.length) {
        this.names.splice(index,1);
        this.draw();
      }
    }

    clearNames() {
      this.names = [];
      this.draw();
    }

    draw() {
      const ctx = this.ctx;
      const w = this.canvas.width / (window.devicePixelRatio || 1);
      const h = this.canvas.height / (window.devicePixelRatio || 1);
      ctx.clearRect(0,0,w,h);
      ctx.save();
      ctx.translate(this.centerX, this.centerY);
      ctx.rotate(this.rotation);
      // draw segments
      const count = Math.max(this.names.length, 1);
      const palette = THEME_PALETTES[this.theme] || THEME_PALETTES.light;
      for (let i = 0; i < count; i++) {
        const start = (i / count) * Math.PI * 2;
        const end = ((i + 1) / count) * Math.PI * 2;
        ctx.beginPath();
        ctx.moveTo(0,0);
        ctx.arc(0,0,this.radius, start + this.padAngle, end - this.padAngle, false);
        ctx.closePath();
        const color = palette[i % palette.length];
        ctx.fillStyle = color;
        ctx.fill();
        ctx.strokeStyle = (i % 2 === 0) ? 'rgba(0,0,0,0.06)' : 'rgba(0,0,0,0.03)';
        ctx.lineWidth = 1;
        ctx.stroke();

        // draw text label
        const mid = (start + end) / 2;
        ctx.save();
        ctx.rotate(mid);
        ctx.translate(this.radius * 0.6, 0);
        ctx.rotate(Math.PI/2);
        ctx.fillStyle = getTextColor(color);
        ctx.font = `${Math.max(12, Math.min(22, this.radius / 8))}px sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        const label = (this.names.length === 0) ? 'Add names' : this.names[i % this.names.length];
        wrapFillText(ctx, label, 0, 0, this.radius * 0.5, 16);
        ctx.restore();
      }

      // draw center circle
      ctx.beginPath();
      ctx.arc(0,0, this.radius * 0.16, 0, Math.PI*2);
      ctx.fillStyle = 'rgba(255,255,255,0.9)';
      ctx.fill();
      ctx.strokeStyle = 'rgba(0,0,0,0.06)';
      ctx.stroke();

      ctx.restore();
      // draw outer ring (pointer side neutral)
      ctx.beginPath();
      ctx.arc(this.centerX, this.centerY, this.radius + 10, 0, Math.PI*2);
      ctx.strokeStyle = 'rgba(0,0,0,0.03)';
      ctx.lineWidth = 2;
      ctx.stroke();
    }

    spin() {
      if (this.isSpinning || this.names.length === 0) return;
      this.isSpinning = true;
      const count = this.names.length;
      // Determine random winner index to land on:
      const winnerIndex = rand(0, count - 1);
      // Calculate final rotation so that winner segment lines up with pointer at top (pointer at canvas top - rotation must align)
      // Our pointer is at the top (canvas 0 angle). The segment mid-angle for index i (without rotation) is ((i + 0.5)/count)*2pi
      const segmentMid = ((winnerIndex + 0.5) / count) * Math.PI * 2;
      // We want segmentMid + rotation_final == -Math.PI/2 (so it points at the top pointer), so rotation_final = -Math.PI/2 - segmentMid + 2pi*N
      const extraTurns = rand(5, 8); // full spins
      const rotationFinal = -Math.PI/2 - segmentMid + extraTurns * Math.PI * 2;
      const startRotation = this.rotation % (Math.PI * 2);
      const delta = rotationFinal - startRotation;
      const duration = 4000 + Math.random() * 1500; // ms
      const startTime = performance.now();

      const animate = (now) => {
        const elapsed = now - startTime;
        const t = Math.min(elapsed / duration, 1);
        const eased = easeOutCubic(t);
        this.rotation = startRotation + delta * eased;
        this.draw();
        if (t < 1) {
          this.frame = requestAnimationFrame(animate);
        } else {
          this.isSpinning = false;
          // Normalize rotation within 0..2pi
          this.rotation = ((this.rotation % (Math.PI*2)) + Math.PI*2) % (Math.PI*2);
          this.draw();
          // Compute final winner index again from rotation
          const finalAngle = (-this.rotation - Math.PI/2 + Math.PI*2) % (Math.PI*2);
          const resultingIndex = Math.floor(((finalAngle / (Math.PI*2)) * count + count) % count);
          const winner = this.names[resultingIndex];
          this.onResult({ index: resultingIndex, name: winner });
        }
      };

      this.frame = requestAnimationFrame(animate);
    }
  }

  // Helper: pick readable text color for a background
  function getTextColor(hex) {
    // remove # and convert
    const h = hex.replace('#','');
    const r = parseInt(h.substring(0,2),16);
    const g = parseInt(h.substring(2,4),16);
    const b = parseInt(h.substring(4,6),16);
    // luminance
    const lum = (0.299*r + 0.587*g + 0.114*b) / 255;
    return lum > 0.65 ? '#111' : '#fff';
  }

  // Helper: wrap text within a given width (draws multi-line if necessary)
  function wrapFillText(ctx, text, x, y, maxWidth, lineHeight) {
    const words = (text || '').split(/\s+/);
    if (words.length === 0) return;
    let line = '';
    const lines = [];
    for (let n = 0; n < words.length; n++) {
      const testLine = line ? line + ' ' + words[n] : words[n];
      const metrics = ctx.measureText(testLine);
      if (metrics.width > maxWidth && line) {
        lines.push(line);
        line = words[n];
      } else {
        line = testLine;
      }
    }
    if (line) lines.push(line);
    // If still too many lines, shrink font or truncate
    for (let i=0;i<lines.length;i++){
      ctx.fillText(lines[i], x, y + (i - (lines.length-1)/2) * lineHeight);
    }
  }

  // UI glue
  document.addEventListener('DOMContentLoaded', () => {
    const canvas = document.getElementById('wheelCanvas');
    const wheel = new Wheel(canvas, { theme: 'light', onResult: onWinner });
    const nameInput = document.getElementById('nameInput');
    const addBtn = document.getElementById('addBtn');
    const addRandomBtn = document.getElementById('addRandomBtn');
    const bulkInput = document.getElementById('bulkInput');
    const bulkAddBtn = document.getElementById('bulkAddBtn');
    const clearBulkBtn = document.getElementById('clearBulkBtn');
    const nameList = document.getElementById('nameList');
    const countSpan = document.getElementById('count');
    const spinBtn = document.getElementById('spinBtn');
    const rerollBtn = document.getElementById('rerollBtn');
    const clearNamesBtn = document.getElementById('clearNamesBtn');
    const themeSelect = document.getElementById('themeSelect');
    const resultSection = document.getElementById('result');
    const winnerNameDiv = document.getElementById('winnerName');
    const exportBtn = document.getElementById('exportBtn');
    const importBtn = document.getElementById('importBtn');
    const importFile = document.getElementById('importFile');

    // Initial draw
    wheel.draw();

    function updateUI() {
      const names = wheel.names;
      countSpan.textContent = names.length;
      renderNameList();
    }

    function renderNameList() {
      nameList.innerHTML = '';
      wheel.names.forEach((n, i) => {
        const li = document.createElement('li');
        const span = document.createElement('span');
        span.textContent = n;
        li.appendChild(span);
        const btn = document.createElement('button');
        btn.title = 'Remove';
        btn.innerHTML = '✕';
        btn.addEventListener('click', () => {
          wheel.removeName(i);
          updateUI();
        });
        li.appendChild(btn);
        nameList.appendChild(li);
      });
    }

    function addNameFromInput() {
      const v = nameInput.value.trim();
      if (!v) { showMessage('Please enter a name.', 'warn'); return; }
      wheel.addName(v);
      nameInput.value = '';
      updateUI();
    }

    addBtn.addEventListener('click', addNameFromInput);
    nameInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') addNameFromInput(); });

    addRandomBtn.addEventListener('click', () => {
      const samples = ['Alex','Jordan','Taylor','Sam','Jamie','Casey','Morgan','Riley','Avery','Dana'];
      const count = rand(3,6);
      for (let i=0;i<count;i++) wheel.addName(samples[rand(0,samples.length-1)] + (rand(1,100)));
      updateUI();
    });

    bulkAddBtn.addEventListener('click', () => {
      const text = bulkInput.value.trim();
      if (!text) { showMessage('Bulk input is empty.', 'warn'); return; }
      const parsed = text.split(/[\n,;]+/).map(s => s.trim()).filter(s => s);
      parsed.forEach(p => wheel.addName(p));
      bulkInput.value = '';
      updateUI();
      showMessage(`Added ${parsed.length} names.`, 'info');
    });

    clearBulkBtn.addEventListener('click', () => { bulkInput.value = ''; });

    spinBtn.addEventListener('click', () => {
      if (wheel.names.length === 0) { showMessage('Add at least one name to spin.', 'warn'); return; }
      resultSection.hidden = true;
      winnerNameDiv.textContent = '';
      wheel.spin();
      spinBtn.disabled = true;
      const checkFinish = setInterval(() => {
        if (!wheel.isSpinning) {
          clearInterval(checkFinish);
          spinBtn.disabled = false;
        }
      }, 200);
    });

    rerollBtn.addEventListener('click', () => {
      resultSection.hidden = true;
      wheel.spin();
    });

    clearNamesBtn.addEventListener('click', () => {
      if (confirm('Clear all names?')) {
        wheel.clearNames();
        updateUI();
      }
    });

    themeSelect.addEventListener('change', (e) => {
      const t = e.target.value;
      document.body.className = 'theme-' + t;
      wheel.setTheme(t);
    });

    function onWinner(result) {
      winnerNameDiv.textContent = result.name || '—';
      resultSection.hidden = false;
      // Flash the winner item in the list (if still present)
      const items = Array.from(nameList.children);
      items.forEach((li, idx) => { li.classList.toggle('winner', idx === result.index); });
      showMessage(`Winner: ${result.name}`, 'success', 4000);
    }

    // Simple message area
    function showMessage(text, type = 'info', duration = 2200) {
      // create small toast
      const t = document.createElement('div');
      t.className = 'tmp-toast ' + type;
      t.textContent = text;
      document.body.appendChild(t);
      setTimeout(()=> { t.style.opacity = '0'; t.style.transform = 'translateY(-10px)'; }, duration - 300);
      setTimeout(()=> { try { t.remove(); } catch(e){} }, duration);
    }

    // Export/import CSV
    exportBtn.addEventListener('click', () => {
      if (wheel.names.length === 0) { showMessage('No names to export.', 'warn'); return; }
      const csv = wheel.names.map(n => `"${(n||'').replace(/"/g,'""')}"`).join('\n');
      const blob = new Blob([csv], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'participants.csv';
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
      showMessage('Exported CSV', 'info');
    });

    importBtn.addEventListener('click', () => { importFile.click(); });

    importFile.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (ev) => {
        const txt = ev.target.result;
        const lines = txt.split(/\r?\n/).map(s => s.trim()).filter(s => s);
        // basic CSV unquote
        const parsed = lines.map(l => {
          if (l.startsWith('"') && l.endsWith('"')) {
            return l.slice(1,-1).replace(/""/g,'"');
          }
          return l;
        });
        parsed.forEach(p => wheel.addName(p));
        updateUI();
        showMessage(`Imported ${parsed.length} names`, 'info');
      };
      reader.readAsText(file);
      importFile.value = '';
    });

    // Initial sample
    // wheel.addName('Alice'); wheel.addName('Bob'); wheel.addName('Charlie');
    updateUI();

    // (Optional) keyboard shortcuts
    window.addEventListener('keydown', (e) => {
      if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'k') {
        e.preventDefault();
        nameInput.focus();
      }
      if (e.key === ' ') {
        // space triggers spin if not focusing an input
        if (document.activeElement.tagName !== 'INPUT' && document.activeElement.tagName !== 'TEXTAREA') {
          e.preventDefault();
          spinBtn.click();
        }
      }
    });
  });
})();
```

[2025-17-09 13:28:29 INFO] **[Update Codes]**

index.html updated.


```
'''

'''
--- Old
+++ New
@@ -1 +1,78 @@
-# None
+'''
+<!--
+DOCSTRING
+This is the main HTML file for the Random Winner Wheel.
+It contains the structure: input fields to add names, a canvas for the wheel,
+controls (spin, clear, bulk add), theme selector, and placeholders for CSS/JS.
+-->
+'''
+<!doctype html>
+<html lang="en">
+<head>
+  <meta charset="utf-8" />
+  <meta name="viewport" content="width=device-width,initial-scale=1" />
+  <title>Random Winner Wheel</title>
+  <link rel="stylesheet" href="styles.css">
+</head>
+<body class="theme-light">
+  <header>
+    <h1>Random Winner Wheel</h1>
+    <p>Enter participant names, choose a theme, and spin to pick a winner.</p>
+  </header>
+  <main>
+    <section class="controls">
+      <div class="add-single">
+        <input id="nameInput" type="text" placeholder="Enter a name and press Add" aria-label="Name input" />
+        <button id="addBtn">Add</button>
+        <button id="addRandomBtn" title="Add a few sample random names">Add Sample</button>
+      </div>
+      <div class="bulk-add">
+        <label for="bulkInput">Bulk add (comma, newline or semicolon separated):</label>
+        <textarea id="bulkInput" placeholder="Alice, Bob, Charlie"></textarea>
+        <div class="bulk-actions">
+          <button id="bulkAddBtn">Bulk Add</button>
+          <button id="clearBulkBtn">Clear Bulk</button>
+        </div>
+      </div>
+      <div class="list-actions">
+        <div class="theme-select">
+          <label for="themeSelect">Theme:</label>
+          <select id="themeSelect">
+            <option value="light">Light</option>
+            <option value="dark">Dark</option>
+            <option value="neon">Neon</option>
+            <option value="pastel">Pastel</option>
+            <option value="retro">Retro</option>
+          </select>
+        </div>
+        <div class="wheel-controls">
+          <button id="spinBtn" class="primary">Spin</button>
+          <button id="clearNamesBtn">Clear Names</button>
+          <button id="exportBtn">Export CSV</button>
+          <input id="importFile" type="file" accept=".csv,text/csv" style="display:none">
+          <button id="importBtn">Import CSV</button>
+        </div>
+      </div>
+    </section>
+    <section class="wheel-area">
+      <div class="wheel-container">
+        <canvas id="wheelCanvas" width="600" height="600" aria-label="Spinning wheel"></canvas>
+        <div class="pointer">▼</div>
+      </div>
+      <aside class="participants">
+        <h2>Participants (<span id="count">0</span>)</h2>
+        <ul id="nameList" aria-live="polite"></ul>
+      </aside>
+    </section>
+    <section class="result" id="result" aria-live="polite" hidden>
+      <h2>Winner</h2>
+      <div id="winnerName" class="winnerName"></div>
+      <button id="rerollBtn">Spin Again</button>
+    </section>
+  </main>
+  <footer>
+    <small>Built with HTML, CSS, and JavaScript. Themes change both UI and wheel colors.</small>
+  </footer>
+  <script src="script.js"></script>
+</body>
+</html>
```

[2025-17-09 13:28:29 INFO] **[Update Codes]**

styles.css updated.


```
'''

'''
--- Old
+++ New
@@ -1 +1,88 @@
-# None
+'''
+DOCSTRING
+Stylesheet for the Random Winner Wheel.
+Defines layout, themes, wheel container sizing, and animations.
+'''
+/* Reset & base */
+* { box-sizing: border-box; margin: 0; padding: 0; }
+html,body { height: 100%; font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; background: var(--bg); color: var(--fg); }
+:root {
+  --bg: #f7f8fb;
+  --fg: #222;
+  --muted: #666;
+  --accent: #2b8cff;
+  --card: #ffffff;
+  --primary-btn-bg: var(--accent);
+  --primary-btn-fg: #fff;
+  --shadow: rgba(15,15,15,0.08);
+}
+/* Themes */
+body.theme-light {
+  --bg: #f7f8fb;
+  --fg: #222;
+  --muted: #5b6170;
+  --accent: #2b8cff;
+  --card: #fff;
+  --wheel-seq: 0;
+}
+body.theme-dark {
+  --bg: #0f1724;
+  --fg: #e6eef8;
+  --muted: #a9b1c2;
+  --accent: #7c5cff;
+  --card: #0b1220;
+}
+body.theme-neon {
+  --bg: #0a0a0f;
+  --fg: #e9f9ff;
+  --muted: #a6f3ff;
+  --accent: #39ff14;
+  --card: #09101a;
+}
+body.theme-pastel {
+  --bg: #fffaf6;
+  --fg: #3c3a3a;
+  --muted: #8d8a8a;
+  --accent: #ff7aa2;
+  --card: #fff;
+}
+body.theme-retro {
+  --bg: #fff6e7;
+  --fg: #402b2b;
+  --muted: #856e6e;
+  --accent: #ffb86b;
+  --card: #fff0e6;
+}
+/* Layout */
+header { padding: 18px 24px; text-align: center; background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent); }
+header h1 { font-size: 1.5rem; margin-bottom: 6px; }
+main { padding: 18px; max-width: 1100px; margin: 0 auto; }
+.controls { display: grid; gap: 12px; margin-bottom: 18px; }
+.add-single { display:flex; gap:8px; }
+.add-single input[type="text"] { flex:1; padding:10px; border-radius:8px; border:1px solid rgba(0,0,0,0.08); background:var(--card); color:var(--fg); }
+.add-single button { padding:10px 12px; border-radius:8px; border: none; cursor:pointer; background: var(--primary-btn-bg); color: var(--primary-btn-fg); }
+.add-single button#addRandomBtn { background: transparent; border: 1px solid rgba(0,0,0,0.06); color: var(--fg); }
+.bulk-add textarea { width:100%; min-height:64px; margin-top:6px; padding:8px; border-radius:8px; border:1px solid rgba(0,0,0,0.06); background:var(--card); color:var(--fg); }
+.bulk-actions { display:flex; gap:8px; margin-top:8px; }
+.list-actions { display:flex; justify-content:space-between; align-items:center; gap:16px; flex-wrap:wrap; }
+.theme-select select { padding:8px; border-radius:8px; border:1px solid rgba(0,0,0,0.06); }
+.wheel-area { display:flex; gap:18px; align-items:start; flex-wrap:wrap; }
+.wheel-container { position: relative; width: 600px; height: 600px; max-width: 90vw; max-height: 90vw; display:flex; align-items:center; justify-content:center; background: transparent; }
+.pointer { position:absolute; top:6px; font-size:28px; transform: translateY(-50%); text-shadow: 0 2px 8px rgba(0,0,0,0.25); color: var(--accent); pointer-events:none; }
+.participants { width: 320px; max-width: 40vw; background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent); padding:12px; border-radius:10px; box-shadow: 0 6px 18px var(--shadow); }
+.participants h2 { margin-bottom:8px; font-size:1.05rem; }
+#nameList { list-style:none; max-height:420px; overflow:auto; display:block; }
+#nameList li { padding:8px; border-radius:6px; display:flex; justify-content:space-between; align-items:center; gap:8px; margin-bottom:8px; background: var(--card); border:1px solid rgba(0,0,0,0.04); }
+#nameList li button { background: transparent; border: none; color: var(--muted); cursor:pointer; }
+.result { margin-top:18px; padding:12px; border-radius:8px; background: var(--card); text-align:center; box-shadow: 0 6px 18px var(--shadow); }
+.result .winnerName { font-size:1.4rem; font-weight:700; margin:8px 0; color: var(--accent); }
+/* Buttons */
+button { cursor:pointer; padding:8px 12px; border-radius:8px; border:1px solid rgba(0,0,0,0.06); background: transparent; color:var(--fg); }
+button.primary { background: var(--primary-btn-bg); color: var(--primary-btn-fg); border: none; }
+/* Responsive */
+@media (max-width: 900px) {
+  .wheel-area { flex-direction:column; align-items:center; }
+  .participants { width: 100%; max-width: 100%; }
+}
+/* Wheel canvas scaling helper */
+#wheelCanvas { border-radius:50%; box-shadow: 0 12px 26px rgba(0,0,0,0.12); background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.02), transparent); }
```

[2025-17-09 13:28:29 INFO] **[Update Codes]**

script.js updated.


```
'''

'''
--- Old
+++ New
@@ -1 +1,364 @@
-# None
+'''
+DOCSTRING
+Script for the Random Winner Wheel.
+Contains the Wheel class to draw and spin the canvas-based wheel and UI glue code to manage names and themes.
+'''
+/* Main JavaScript - Wheel + UI logic */
+(() => {
+  // Utilities
+  function rand(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }
+  function easeOutCubic(t) { return 1 - Math.pow(1 - t, 3); }
+  // Color palettes for themes (will be used to paint wheel segments)
+  const THEME_PALETTES = {
+    light: ['#FF8A80','#FFD180','#FFF59D','#C8E6C9','#80DEEA','#A7FFEB','#B39DDB','#90CAF9'],
+    dark: ['#ff6b6b','#ffd166','#faff8e','#b9f6ca','#4dd0e1','#80cbc4','#b388ff','#64b5f6'],
+    neon: ['#ff2d95','#7cff01','#00ffff','#ffdd00','#ff6a00','#00ff9e','#ff00ff','#47ffa2'],
+    pastel: ['#ffdbe9','#fff0b3','#d1ffd6','#cfefff','#e7dfff','#ffd6e7','#fbe7d6','#e6f7ff'],
+    retro: ['#ffb86b','#ffd3a8','#f3e2a9','#b8e0d2','#c0b9ff','#ffb6c1','#f6c49f','#c3d69b']
+  };
+  // Wheel class
+  class Wheel {
+    /*
+    Manage wheel: drawing, recalculating segments, spinning animation, and determining winner.
+    */
+    constructor(canvas, options = {}) {
+      this.canvas = canvas;
+      this.ctx = canvas.getContext('2d');
+      this.names = [];
+      this.rotation = 0; // radians
+      this.isSpinning = false;
+      this.frame = null;
+      this.onResult = options.onResult || function() {};
+      this.theme = options.theme || 'light';
+      this.padAngle = 0.02; // radians padding between segments
+      this.textColor = '#111';
+      this._devicePixelRatioFix();
+      window.addEventListener('resize', () => { this._devicePixelRatioFix(); this.draw(); });
+    }
+    _devicePixelRatioFix() {
+      const dpr = window.devicePixelRatio || 1;
+      const rect = this.canvas.getBoundingClientRect();
+      this.canvas.width = rect.width * dpr;
+      this.canvas.height = rect.height * dpr;
+      this.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
+      this.centerX = rect.width / 2;
+      this.centerY = rect.height / 2;
+      this.radius = Math.min(rect.width, rect.height) / 2 - 18;
+    }
+    setTheme(themeId) { this.theme = themeId; this.draw(); }
+    setNames(names) {
+      this.names = names.slice();
+      this.draw();
+    }
+    addName(name) {
+      this.names.push(name);
+      this.draw();
+    }
+    removeName(index) {
+      if (index >= 0 && index < this.names.length) {
+        this.names.splice(index,1);
+        this.draw();
+      }
+    }
+    clearNames() {
+      this.names = [];
+      this.draw();
+    }
+    draw() {
+      const ctx = this.ctx;
+      const w = this.canvas.width / (window.devicePixelRatio || 1);
+      const h = this.canvas.height / (window.devicePixelRatio || 1);
+      ctx.clearRect(0,0,w,h);
+      ctx.save();
+      ctx.translate(this.centerX, this.centerY);
+      ctx.rotate(this.rotation);
+      // draw segments
+      const count = Math.max(this.names.length, 1);
+      const palette = THEME_PALETTES[this.theme] || THEME_PALETTES.light;
+      for (let i = 0; i < count; i++) {
+        const start = (i / count) * Math.PI * 2;
+        const end = ((i + 1) / count) * Math.PI * 2;
+        ctx.beginPath();
+        ctx.moveTo(0,0);
+        ctx.arc(0,0,this.radius, start + this.padAngle, end - this.padAngle, false);
+        ctx.closePath();
+        const color = palette[i % palette.length];
+        ctx.fillStyle = color;
+        ctx.fill();
+        ctx.strokeStyle = (i % 2 === 0) ? 'rgba(0,0,0,0.06)' : 'rgba(0,0,0,0.03)';
+        ctx.lineWidth = 1;
+        ctx.stroke();
+        // draw text label
+        const mid = (start + end) / 2;
+        ctx.save();
+        ctx.rotate(mid);
+        ctx.translate(this.radius * 0.6, 0);
+        ctx.rotate(Math.PI/2);
+        ctx.fillStyle = getTextColor(color);
+        ctx.font = `${Math.max(12, Math.min(22, this.radius / 8))}px sans-serif`;
+        ctx.textAlign = 'center';
+        ctx.textBaseline = 'middle';
+        const label = (this.names.length === 0) ? 'Add names' : this.names[i % this.names.length];
+        wrapFillText(ctx, label, 0, 0, this.radius * 0.5, 16);
+        ctx.restore();
+      }
+      // draw center circle
+      ctx.beginPath();
+      ctx.arc(0,0, this.radius * 0.16, 0, Math.PI*2);
+      ctx.fillStyle = 'rgba(255,255,255,0.9)';
+      ctx.fill();
+      ctx.strokeStyle = 'rgba(0,0,0,0.06)';
+      ctx.stroke();
+      ctx.restore();
+      // draw outer ring (pointer side neutral)
+      ctx.beginPath();
+      ctx.arc(this.centerX, this.centerY, this.radius + 10, 0, Math.PI*2);
+      ctx.strokeStyle = 'rgba(0,0,0,0.03)';
+      ctx.lineWidth = 2;
+      ctx.stroke();
+    }
+    spin() {
+      if (this.isSpinning || this.names.length === 0) return;
+      this.isSpinning = true;
+      const count = this.names.length;
+      // Determine random winner index to land on:
+      const winnerIndex = rand(0, count - 1);
+      // Calculate final rotation so that winner segment lines up with pointer at top (pointer at canvas top - rotation must align)
+      // Our pointer is at the top (canvas 0 angle). The segment mid-angle for index i (without rotation) is ((i + 0.5)/count)*2pi
+      const segmentMid = ((winnerIndex + 0.5) / count) * Math.PI * 2;
+      // We want segmentMid + rotation_final == -Math.PI/2 (so it points at the top pointer), so rotation_final = -Math.PI/2 - segmentMid + 2pi*N
+      const extraTurns = rand(5, 8); // full spins
+      const rotationFinal = -Math.PI/2 - segmentMid + extraTurns * Math.PI * 2;
+      const startRotation = this.rotation % (Math.PI * 2);
+      const delta = rotationFinal - startRotation;
+      const duration = 4000 + Math.random() * 1500; // ms
+      const startTime = performance.now();
+      const animate = (now) => {
+        const elapsed = now - startTime;
+        const t = Math.min(elapsed / duration, 1);
+        const eased = easeOutCubic(t);
+        this.rotation = startRotation + delta * eased;
+        this.draw();
+        if (t < 1) {
+          this.frame = requestAnimationFrame(animate);
+        } else {
+          this.isSpinning = false;
+          // Normalize rotation within 0..2pi
+          this.rotation = ((this.rotation % (Math.PI*2)) + Math.PI*2) % (Math.PI*2);
+          this.draw();
+          // Compute final winner index again from rotation
+          const finalAngle = (-this.rotation - Math.PI/2 + Math.PI*2) % (Math.PI*2);
+          const resultingIndex = Math.floor(((finalAngle / (Math.PI*2)) * count + count) % count);
+          const winner = this.names[resultingIndex];
+          this.onResult({ index: resultingIndex, name: winner });
+        }
+      };
+      this.frame = requestAnimationFrame(animate);
+    }
+  }
+  // Helper: pick readable text color for a background
+  function getTextColor(hex) {
+    // remove # and convert
+    const h = hex.replace('#','');
+    const r = parseInt(h.substring(0,2),16);
+    const g = parseInt(h.substring(2,4),16);
+    const b = parseInt(h.substring(4,6),16);
+    // luminance
+    const lum = (0.299*r + 0.587*g + 0.114*b) / 255;
+    return lum > 0.65 ? '#111' : '#fff';
+  }
+  // Helper: wrap text within a given width (draws multi-line if necessary)
+  function wrapFillText(ctx, text, x, y, maxWidth, lineHeight) {
+    const words = (text || '').split(/\s+/);
+    if (words.length === 0) return;
+    let line = '';
+    const lines = [];
+    for (let n = 0; n < words.length; n++) {
+      const testLine = line ? line + ' ' + words[n] : words[n];
+      const metrics = ctx.measureText(testLine);
+      if (metrics.width > maxWidth && line) {
+        lines.push(line);
+        line = words[n];
+      } else {
+        line = testLine;
+      }
+    }
+    if (line) lines.push(line);
+    // If still too many lines, shrink font or truncate
+    for (let i=0;i<lines.length;i++){
+      ctx.fillText(lines[i], x, y + (i - (lines.length-1)/2) * lineHeight);
+    }
+  }
+  // UI glue
+  document.addEventListener('DOMContentLoaded', () => {
+    const canvas = document.getElementById('wheelCanvas');
+    const wheel = new Wheel(canvas, { theme: 'light', onResult: onWinner });
+    const nameInput = document.getElementById('nameInput');
+    const addBtn = document.getElementById('addBtn');
+    const addRandomBtn = document.getElementById('addRandomBtn');
+    const bulkInput = document.getElementById('bulkInput');
+    const bulkAddBtn = document.getElementById('bulkAddBtn');
+    const clearBulkBtn = document.getElementById('clearBulkBtn');
+    const nameList = document.getElementById('nameList');
+    const countSpan = document.getElementById('count');
+    const spinBtn = document.getElementById('spinBtn');
+    const rerollBtn = document.getElementById('rerollBtn');
+    const clearNamesBtn = document.getElementById('clearNamesBtn');
+    const themeSelect = document.getElementById('themeSelect');
+    const resultSection = document.getElementById('result');
+    const winnerNameDiv = document.getElementById('winnerName');
+    const exportBtn = document.getElementById('exportBtn');
+    const importBtn = document.getElementById('importBtn');
+    const importFile = document.getElementById('importFile');
+    // Initial draw
+    wheel.draw();
+    function updateUI() {
+      const names = wheel.names;
+      countSpan.textContent = names.length;
+      renderNameList();
+    }
+    function renderNameList() {
+      nameList.innerHTML = '';
+      wheel.names.forEach((n, i) => {
+        const li = document.createElement('li');
+        const span = document.createElement('span');
+        span.textContent = n;
+        li.appendChild(span);
+        const btn = document.createElement('button');
+        btn.title = 'Remove';
+        btn.innerHTML = '✕';
+        btn.addEventListener('click', () => {
+          wheel.removeName(i);
+          updateUI();
+        });
+        li.appendChild(btn);
+        nameList.appendChild(li);
+      });
+    }
+    function addNameFromInput() {
+      const v = nameInput.value.trim();
+      if (!v) { showMessage('Please enter a name.', 'warn'); return; }
+      wheel.addName(v);
+      nameInput.value = '';
+      updateUI();
+    }
+    addBtn.addEventListener('click', addNameFromInput);
+    nameInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') addNameFromInput(); });
+    addRandomBtn.addEventListener('click', () => {
+      const samples = ['Alex','Jordan','Taylor','Sam','Jamie','Casey','Morgan','Riley','Avery','Dana'];
+      const count = rand(3,6);
+      for (let i=0;i<count;i++) wheel.addName(samples[rand(0,samples.length-1)] + (rand(1,100)));
+      updateUI();
+    });
+    bulkAddBtn.addEventListener('click', () => {
+      const text = bulkInput.value.trim();
+      if (!text) { showMessage('Bulk input is empty.', 'warn'); return; }
+      const parsed = text.split(/[\n,;]+/).map(s => s.trim()).filter(s => s);
+      parsed.forEach(p => wheel.addName(p));
+      bulkInput.value = '';
+      updateUI();
+      showMessage(`Added ${parsed.length} names.`, 'info');
+    });
+    clearBulkBtn.addEventListener('click', () => { bulkInput.value = ''; });
+    spinBtn.addEventListener('click', () => {
+      if (wheel.names.length === 0) { showMessage('Add at least one name to spin.', 'warn'); return; }
+      resultSection.hidden = true;
+      winnerNameDiv.textContent = '';
+      wheel.spin();
+      spinBtn.disabled = true;
+      const checkFinish = setInterval(() => {
+        if (!wheel.isSpinning) {
+          clearInterval(checkFinish);
+          spinBtn.disabled = false;
+        }
+      }, 200);
+    });
+    rerollBtn.addEventListener('click', () => {
+      resultSection.hidden = true;
+      wheel.spin();
+    });
+    clearNamesBtn.addEventListener('click', () => {
+      if (confirm('Clear all names?')) {
+        wheel.clearNames();
+        updateUI();
+      }
+    });
+    themeSelect.addEventListener('change', (e) => {
+      const t = e.target.value;
+      document.body.className = 'theme-' + t;
+      wheel.setTheme(t);
+    });
+    function onWinner(result) {
+      winnerNameDiv.textContent = result.name || '—';
+      resultSection.hidden = false;
+      // Flash the winner item in the list (if still present)
+      const items = Array.from(nameList.children);
+      items.forEach((li, idx) => { li.classList.toggle('winner', idx === result.index); });
+      showMessage(`Winner: ${result.name}`, 'success', 4000);
+    }
+    // Simple message area
+    function showMessage(text, type = 'info', duration = 2200) {
+      // create small toast
+      const t = document.createElement('div');
+      t.className = 'tmp-toast ' + type;
+      t.textContent = text;
+      document.body.appendChild(t);
+      setTimeout(()=> { t.style.opacity = '0'; t.style.transform = 'translateY(-10px)'; }, duration - 300);
+      setTimeout(()=> { try { t.remove(); } catch(e){} }, duration);
+    }
+    // Export/import CSV
+    exportBtn.addEventListener('click', () => {
+      if (wheel.names.length === 0) { showMessage('No names to export.', 'warn'); return; }
+      const csv = wheel.names.map(n => `"${(n||'').replace(/"/g,'""')}"`).join('\n');
+      const blob = new Blob([csv], { type: 'text/csv' });
+      const url = URL.createObjectURL(blob);
+      const a = document.createElement('a');
+      a.href = url;
+      a.download = 'participants.csv';
+      document.body.appendChild(a);
+      a.click();
+      a.remove();
+      URL.revokeObjectURL(url);
+      showMessage('Exported CSV', 'info');
+    });
+    importBtn.addEventListener('click', () => { importFile.click(); });
+    importFile.addEventListener('change', (e) => {
+      const file = e.target.files[0];
+      if (!file) return;
+      const reader = new FileReader();
+      reader.onload = (ev) => {
+        const txt = ev.target.result;
+        const lines = txt.split(/\r?\n/).map(s => s.trim()).filter(s => s);
+        // basic CSV unquote
+        const parsed = lines.map(l => {
+          if (l.startsWith('"') && l.endsWith('"')) {
+            return l.slice(1,-1).replace(/""/g,'"');
+          }
+          return l;
+        });
+        parsed.forEach(p => wheel.addName(p));
+        updateUI();
+        showMessage(`Imported ${parsed.length} names`, 'info');
+      };
+      reader.readAsText(file);
+      importFile.value = '';
+    });
+    // Initial sample
+    // wheel.addName('Alice'); wheel.addName('Bob'); wheel.addName('Charlie');
+    updateUI();
+    // (Optional) keyboard shortcuts
+    window.addEventListener('keydown', (e) => {
+      if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'k') {
+        e.preventDefault();
+        nameInput.focus();
+      }
+      if (e.key === ' ') {
+        // space triggers spin if not focusing an input
+        if (document.activeElement.tagName !== 'INPUT' && document.activeElement.tagName !== 'TEXTAREA') {
+          e.preventDefault();
+          spinBtn.click();
+        }
+      }
+    });
+  });
+})();
```

[2025-17-09 13:28:29 INFO] **[Software Info]**:

 

💰**cost**=$0.013618

🔨**version_updates**=-1

📃**num_code_files**=0

🏞**num_png_files**=0

📚**num_doc_files**=7

📃**code_lines**=0

📋**env_lines**=-1

📒**manual_lines**=-1

🗣**num_utterances**=7

🤔**num_self_reflections**=0

❓**num_prompt_tokens**=2084

❗**num_completion_tokens**=8384

🌟**num_total_tokens**=10468

[2025-17-09 13:28:29 INFO] **[Execute Detail]**

execute SimplePhase:[CodeComplete] in ComposedPhase:[CodeCompleteAll], cycle 1

[2025-17-09 13:28:29 INFO] **[Execute Detail]**

execute SimplePhase:[CodeReviewComment] in ComposedPhase:[CodeReview], cycle 1

[2025-17-09 13:28:29 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | [Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes. Do it in HTML, CSS, and JavaScript.] |
| **need_reflect** | False |
| **assistant_role_name** | Code Reviewer |
| **user_role_name** | Programmer |
| **phase_prompt** | According to the new user's task and our software designs:  Task: "{task}". Modality: "{modality}". Programming Language: "{language}" Ideas: "{ideas}" Codes: "{codes}" As the {assistant_role}, to make the software directly operable without further coding, ChatDev have formulated the following regulations: 1) all referenced classes should be imported; 2) all methods should be implemented; 3) all methods need to have the necessary comments; 4) no potential bugs; 5) The entire project conforms to the tasks proposed by the user; 6) most importantly, do not only check the errors in the code, but also the logic of code. Make sure that user can interact with generated software without losing any feature in the requirement; Now, you should check the above regulations one by one and review the codes in detail, propose one comment with the highest priority about the codes, and give me instructions on how to fix. Tell me your comment with the highest priority and corresponding suggestions on revision. If the codes are perfect and you have no comment on them, return only one line like " Finished". |
| **phase_name** | CodeReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Code Reviewer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. You can help programmers to assess source codes for software troubleshooting, fix bugs to increase code quality and robustness, and offer proposals to improve the source codes. Here is a new customer's task: {task}. To complete the task, you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Programmer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. You can write/create computer software or applications by providing a specific programming language to the computer. You have extensive computing and coding experience in many varieties of programming languages and platforms, such as Python, Java, C, C++, HTML, CSS, JavaScript, XML, SQL, PHP, etc,. Here is a new customer's task: {task}. To complete the task, you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 1, 'task': '[Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes. Do it in HTML, CSS, and JavaScript.]', 'modality': 'website', 'ideas': '', 'language': ' JavaScript', 'codes': 'index.html\nhtml\n\'\'\'\n&lt;!--\nDOCSTRING\nThis is the main HTML file for the Random Winner Wheel.\nIt contains the structure: input fields to add names, a canvas for the wheel,\ncontrols (spin, clear, bulk add), theme selector, and placeholders for CSS/JS.\n--&gt;\n\'\'\'\n&lt;!doctype html&gt;\n&lt;html lang="en"&gt;\n&lt;head&gt;\n  &lt;meta charset="utf-8" /&gt;\n  &lt;meta name="viewport" content="width=device-width,initial-scale=1" /&gt;\n  &lt;title&gt;Random Winner Wheel&lt;/title&gt;\n  &lt;link rel="stylesheet" href="styles.css"&gt;\n&lt;/head&gt;\n&lt;body class="theme-light"&gt;\n  &lt;header&gt;\n    &lt;h1&gt;Random Winner Wheel&lt;/h1&gt;\n    &lt;p&gt;Enter participant names, choose a theme, and spin to pick a winner.&lt;/p&gt;\n  &lt;/header&gt;\n  &lt;main&gt;\n    &lt;section class="controls"&gt;\n      &lt;div class="add-single"&gt;\n        &lt;input id="nameInput" type="text" placeholder="Enter a name and press Add" aria-label="Name input" /&gt;\n        &lt;button id="addBtn"&gt;Add&lt;/button&gt;\n        &lt;button id="addRandomBtn" title="Add a few sample random names"&gt;Add Sample&lt;/button&gt;\n      &lt;/div&gt;\n      &lt;div class="bulk-add"&gt;\n        &lt;label for="bulkInput"&gt;Bulk add (comma, newline or semicolon separated):&lt;/label&gt;\n        &lt;textarea id="bulkInput" placeholder="Alice, Bob, Charlie"&gt;&lt;/textarea&gt;\n        &lt;div class="bulk-actions"&gt;\n          &lt;button id="bulkAddBtn"&gt;Bulk Add&lt;/button&gt;\n          &lt;button id="clearBulkBtn"&gt;Clear Bulk&lt;/button&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;\n      &lt;div class="list-actions"&gt;\n        &lt;div class="theme-select"&gt;\n          &lt;label for="themeSelect"&gt;Theme:&lt;/label&gt;\n          &lt;select id="themeSelect"&gt;\n            &lt;option value="light"&gt;Light&lt;/option&gt;\n            &lt;option value="dark"&gt;Dark&lt;/option&gt;\n            &lt;option value="neon"&gt;Neon&lt;/option&gt;\n            &lt;option value="pastel"&gt;Pastel&lt;/option&gt;\n            &lt;option value="retro"&gt;Retro&lt;/option&gt;\n          &lt;/select&gt;\n        &lt;/div&gt;\n        &lt;div class="wheel-controls"&gt;\n          &lt;button id="spinBtn" class="primary"&gt;Spin&lt;/button&gt;\n          &lt;button id="clearNamesBtn"&gt;Clear Names&lt;/button&gt;\n          &lt;button id="exportBtn"&gt;Export CSV&lt;/button&gt;\n          &lt;input id="importFile" type="file" accept=".csv,text/csv" style="display:none"&gt;\n          &lt;button id="importBtn"&gt;Import CSV&lt;/button&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;\n    &lt;/section&gt;\n    &lt;section class="wheel-area"&gt;\n      &lt;div class="wheel-container"&gt;\n        &lt;canvas id="wheelCanvas" width="600" height="600" aria-label="Spinning wheel"&gt;&lt;/canvas&gt;\n        &lt;div class="pointer"&gt;▼&lt;/div&gt;\n      &lt;/div&gt;\n      &lt;aside class="participants"&gt;\n        &lt;h2&gt;Participants (&lt;span id="count"&gt;0&lt;/span&gt;)&lt;/h2&gt;\n        &lt;ul id="nameList" aria-live="polite"&gt;&lt;/ul&gt;\n      &lt;/aside&gt;\n    &lt;/section&gt;\n    &lt;section class="result" id="result" aria-live="polite" hidden&gt;\n      &lt;h2&gt;Winner&lt;/h2&gt;\n      &lt;div id="winnerName" class="winnerName"&gt;&lt;/div&gt;\n      &lt;button id="rerollBtn"&gt;Spin Again&lt;/button&gt;\n    &lt;/section&gt;\n  &lt;/main&gt;\n  &lt;footer&gt;\n    &lt;small&gt;Built with HTML, CSS, and JavaScript. Themes change both UI and wheel colors.&lt;/small&gt;\n  &lt;/footer&gt;\n  &lt;script src="script.js"&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\n\nstyles.css\ncss\n\'\'\'\nDOCSTRING\nStylesheet for the Random Winner Wheel.\nDefines layout, themes, wheel container sizing, and animations.\n\'\'\'\n/* Reset &amp; base */\n* { box-sizing: border-box; margin: 0; padding: 0; }\nhtml,body { height: 100%; font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; background: var(--bg); color: var(--fg); }\n:root {\n  --bg: #f7f8fb;\n  --fg: #222;\n  --muted: #666;\n  --accent: #2b8cff;\n  --card: #ffffff;\n  --primary-btn-bg: var(--accent);\n  --primary-btn-fg: #fff;\n  --shadow: rgba(15,15,15,0.08);\n}\n/* Themes */\nbody.theme-light {\n  --bg: #f7f8fb;\n  --fg: #222;\n  --muted: #5b6170;\n  --accent: #2b8cff;\n  --card: #fff;\n  --wheel-seq: 0;\n}\nbody.theme-dark {\n  --bg: #0f1724;\n  --fg: #e6eef8;\n  --muted: #a9b1c2;\n  --accent: #7c5cff;\n  --card: #0b1220;\n}\nbody.theme-neon {\n  --bg: #0a0a0f;\n  --fg: #e9f9ff;\n  --muted: #a6f3ff;\n  --accent: #39ff14;\n  --card: #09101a;\n}\nbody.theme-pastel {\n  --bg: #fffaf6;\n  --fg: #3c3a3a;\n  --muted: #8d8a8a;\n  --accent: #ff7aa2;\n  --card: #fff;\n}\nbody.theme-retro {\n  --bg: #fff6e7;\n  --fg: #402b2b;\n  --muted: #856e6e;\n  --accent: #ffb86b;\n  --card: #fff0e6;\n}\n/* Layout */\nheader { padding: 18px 24px; text-align: center; background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent); }\nheader h1 { font-size: 1.5rem; margin-bottom: 6px; }\nmain { padding: 18px; max-width: 1100px; margin: 0 auto; }\n.controls { display: grid; gap: 12px; margin-bottom: 18px; }\n.add-single { display:flex; gap:8px; }\n.add-single input[type="text"] { flex:1; padding:10px; border-radius:8px; border:1px solid rgba(0,0,0,0.08); background:var(--card); color:var(--fg); }\n.add-single button { padding:10px 12px; border-radius:8px; border: none; cursor:pointer; background: var(--primary-btn-bg); color: var(--primary-btn-fg); }\n.add-single button#addRandomBtn { background: transparent; border: 1px solid rgba(0,0,0,0.06); color: var(--fg); }\n.bulk-add textarea { width:100%; min-height:64px; margin-top:6px; padding:8px; border-radius:8px; border:1px solid rgba(0,0,0,0.06); background:var(--card); color:var(--fg); }\n.bulk-actions { display:flex; gap:8px; margin-top:8px; }\n.list-actions { display:flex; justify-content:space-between; align-items:center; gap:16px; flex-wrap:wrap; }\n.theme-select select { padding:8px; border-radius:8px; border:1px solid rgba(0,0,0,0.06); }\n.wheel-area { display:flex; gap:18px; align-items:start; flex-wrap:wrap; }\n.wheel-container { position: relative; width: 600px; height: 600px; max-width: 90vw; max-height: 90vw; display:flex; align-items:center; justify-content:center; background: transparent; }\n.pointer { position:absolute; top:6px; font-size:28px; transform: translateY(-50%); text-shadow: 0 2px 8px rgba(0,0,0,0.25); color: var(--accent); pointer-events:none; }\n.participants { width: 320px; max-width: 40vw; background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent); padding:12px; border-radius:10px; box-shadow: 0 6px 18px var(--shadow); }\n.participants h2 { margin-bottom:8px; font-size:1.05rem; }\n#nameList { list-style:none; max-height:420px; overflow:auto; display:block; }\n#nameList li { padding:8px; border-radius:6px; display:flex; justify-content:space-between; align-items:center; gap:8px; margin-bottom:8px; background: var(--card); border:1px solid rgba(0,0,0,0.04); }\n#nameList li button { background: transparent; border: none; color: var(--muted); cursor:pointer; }\n.result { margin-top:18px; padding:12px; border-radius:8px; background: var(--card); text-align:center; box-shadow: 0 6px 18px var(--shadow); }\n.result .winnerName { font-size:1.4rem; font-weight:700; margin:8px 0; color: var(--accent); }\n/* Buttons */\nbutton { cursor:pointer; padding:8px 12px; border-radius:8px; border:1px solid rgba(0,0,0,0.06); background: transparent; color:var(--fg); }\nbutton.primary { background: var(--primary-btn-bg); color: var(--primary-btn-fg); border: none; }\n/* Responsive */\n@media (max-width: 900px) {\n  .wheel-area { flex-direction:column; align-items:center; }\n  .participants { width: 100%; max-width: 100%; }\n}\n/* Wheel canvas scaling helper */\n#wheelCanvas { border-radius:50%; box-shadow: 0 12px 26px rgba(0,0,0,0.12); background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.02), transparent); }\n\n\nscript.js\njs\n\'\'\'\nDOCSTRING\nScript for the Random Winner Wheel.\nContains the Wheel class to draw and spin the canvas-based wheel and UI glue code to manage names and themes.\n\'\'\'\n/* Main JavaScript - Wheel + UI logic */\n(() =&gt; {\n  // Utilities\n  function rand(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }\n  function easeOutCubic(t) { return 1 - Math.pow(1 - t, 3); }\n  // Color palettes for themes (will be used to paint wheel segments)\n  const THEME_PALETTES = {\n    light: [\'#FF8A80\',\'#FFD180\',\'#FFF59D\',\'#C8E6C9\',\'#80DEEA\',\'#A7FFEB\',\'#B39DDB\',\'#90CAF9\'],\n    dark: [\'#ff6b6b\',\'#ffd166\',\'#faff8e\',\'#b9f6ca\',\'#4dd0e1\',\'#80cbc4\',\'#b388ff\',\'#64b5f6\'],\n    neon: [\'#ff2d95\',\'#7cff01\',\'#00ffff\',\'#ffdd00\',\'#ff6a00\',\'#00ff9e\',\'#ff00ff\',\'#47ffa2\'],\n    pastel: [\'#ffdbe9\',\'#fff0b3\',\'#d1ffd6\',\'#cfefff\',\'#e7dfff\',\'#ffd6e7\',\'#fbe7d6\',\'#e6f7ff\'],\n    retro: [\'#ffb86b\',\'#ffd3a8\',\'#f3e2a9\',\'#b8e0d2\',\'#c0b9ff\',\'#ffb6c1\',\'#f6c49f\',\'#c3d69b\']\n  };\n  // Wheel class\n  class Wheel {\n    /*\n    Manage wheel: drawing, recalculating segments, spinning animation, and determining winner.\n    */\n    constructor(canvas, options = {}) {\n      this.canvas = canvas;\n      this.ctx = canvas.getContext(\'2d\');\n      this.names = [];\n      this.rotation = 0; // radians\n      this.isSpinning = false;\n      this.frame = null;\n      this.onResult = options.onResult || function() {};\n      this.theme = options.theme || \'light\';\n      this.padAngle = 0.02; // radians padding between segments\n      this.textColor = \'#111\';\n      this._devicePixelRatioFix();\n      window.addEventListener(\'resize\', () =&gt; { this._devicePixelRatioFix(); this.draw(); });\n    }\n    _devicePixelRatioFix() {\n      const dpr = window.devicePixelRatio || 1;\n      const rect = this.canvas.getBoundingClientRect();\n      this.canvas.width = rect.width * dpr;\n      this.canvas.height = rect.height * dpr;\n      this.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n      this.centerX = rect.width / 2;\n      this.centerY = rect.height / 2;\n      this.radius = Math.min(rect.width, rect.height) / 2 - 18;\n    }\n    setTheme(themeId) { this.theme = themeId; this.draw(); }\n    setNames(names) {\n      this.names = names.slice();\n      this.draw();\n    }\n    addName(name) {\n      this.names.push(name);\n      this.draw();\n    }\n    removeName(index) {\n      if (index &gt;= 0 &amp;&amp; index &lt; this.names.length) {\n        this.names.splice(index,1);\n        this.draw();\n      }\n    }\n    clearNames() {\n      this.names = [];\n      this.draw();\n    }\n    draw() {\n      const ctx = this.ctx;\n      const w = this.canvas.width / (window.devicePixelRatio || 1);\n      const h = this.canvas.height / (window.devicePixelRatio || 1);\n      ctx.clearRect(0,0,w,h);\n      ctx.save();\n      ctx.translate(this.centerX, this.centerY);\n      ctx.rotate(this.rotation);\n      // draw segments\n      const count = Math.max(this.names.length, 1);\n      const palette = THEME_PALETTES[this.theme] || THEME_PALETTES.light;\n      for (let i = 0; i &lt; count; i++) {\n        const start = (i / count) * Math.PI * 2;\n        const end = ((i + 1) / count) * Math.PI * 2;\n        ctx.beginPath();\n        ctx.moveTo(0,0);\n        ctx.arc(0,0,this.radius, start + this.padAngle, end - this.padAngle, false);\n        ctx.closePath();\n        const color = palette[i % palette.length];\n        ctx.fillStyle = color;\n        ctx.fill();\n        ctx.strokeStyle = (i % 2 === 0) ? \'rgba(0,0,0,0.06)\' : \'rgba(0,0,0,0.03)\';\n        ctx.lineWidth = 1;\n        ctx.stroke();\n        // draw text label\n        const mid = (start + end) / 2;\n        ctx.save();\n        ctx.rotate(mid);\n        ctx.translate(this.radius * 0.6, 0);\n        ctx.rotate(Math.PI/2);\n        ctx.fillStyle = getTextColor(color);\n        ctx.font = `${Math.max(12, Math.min(22, this.radius / 8))}px sans-serif`;\n        ctx.textAlign = \'center\';\n        ctx.textBaseline = \'middle\';\n        const label = (this.names.length === 0) ? \'Add names\' : this.names[i % this.names.length];\n        wrapFillText(ctx, label, 0, 0, this.radius * 0.5, 16);\n        ctx.restore();\n      }\n      // draw center circle\n      ctx.beginPath();\n      ctx.arc(0,0, this.radius * 0.16, 0, Math.PI*2);\n      ctx.fillStyle = \'rgba(255,255,255,0.9)\';\n      ctx.fill();\n      ctx.strokeStyle = \'rgba(0,0,0,0.06)\';\n      ctx.stroke();\n      ctx.restore();\n      // draw outer ring (pointer side neutral)\n      ctx.beginPath();\n      ctx.arc(this.centerX, this.centerY, this.radius + 10, 0, Math.PI*2);\n      ctx.strokeStyle = \'rgba(0,0,0,0.03)\';\n      ctx.lineWidth = 2;\n      ctx.stroke();\n    }\n    spin() {\n      if (this.isSpinning || this.names.length === 0) return;\n      this.isSpinning = true;\n      const count = this.names.length;\n      // Determine random winner index to land on:\n      const winnerIndex = rand(0, count - 1);\n      // Calculate final rotation so that winner segment lines up with pointer at top (pointer at canvas top - rotation must align)\n      // Our pointer is at the top (canvas 0 angle). The segment mid-angle for index i (without rotation) is ((i + 0.5)/count)*2pi\n      const segmentMid = ((winnerIndex + 0.5) / count) * Math.PI * 2;\n      // We want segmentMid + rotation_final == -Math.PI/2 (so it points at the top pointer), so rotation_final = -Math.PI/2 - segmentMid + 2pi*N\n      const extraTurns = rand(5, 8); // full spins\n      const rotationFinal = -Math.PI/2 - segmentMid + extraTurns * Math.PI * 2;\n      const startRotation = this.rotation % (Math.PI * 2);\n      const delta = rotationFinal - startRotation;\n      const duration = 4000 + Math.random() * 1500; // ms\n      const startTime = performance.now();\n      const animate = (now) =&gt; {\n        const elapsed = now - startTime;\n        const t = Math.min(elapsed / duration, 1);\n        const eased = easeOutCubic(t);\n        this.rotation = startRotation + delta * eased;\n        this.draw();\n        if (t &lt; 1) {\n          this.frame = requestAnimationFrame(animate);\n        } else {\n          this.isSpinning = false;\n          // Normalize rotation within 0..2pi\n          this.rotation = ((this.rotation % (Math.PI*2)) + Math.PI*2) % (Math.PI*2);\n          this.draw();\n          // Compute final winner index again from rotation\n          const finalAngle = (-this.rotation - Math.PI/2 + Math.PI*2) % (Math.PI*2);\n          const resultingIndex = Math.floor(((finalAngle / (Math.PI*2)) * count + count) % count);\n          const winner = this.names[resultingIndex];\n          this.onResult({ index: resultingIndex, name: winner });\n        }\n      };\n      this.frame = requestAnimationFrame(animate);\n    }\n  }\n  // Helper: pick readable text color for a background\n  function getTextColor(hex) {\n    // remove # and convert\n    const h = hex.replace(\'#\',\'\');\n    const r = parseInt(h.substring(0,2),16);\n    const g = parseInt(h.substring(2,4),16);\n    const b = parseInt(h.substring(4,6),16);\n    // luminance\n    const lum = (0.299*r + 0.587*g + 0.114*b) / 255;\n    return lum &gt; 0.65 ? \'#111\' : \'#fff\';\n  }\n  // Helper: wrap text within a given width (draws multi-line if necessary)\n  function wrapFillText(ctx, text, x, y, maxWidth, lineHeight) {\n    const words = (text || \'\').split(/\\s+/);\n    if (words.length === 0) return;\n    let line = \'\';\n    const lines = [];\n    for (let n = 0; n &lt; words.length; n++) {\n      const testLine = line ? line + \' \' + words[n] : words[n];\n      const metrics = ctx.measureText(testLine);\n      if (metrics.width &gt; maxWidth &amp;&amp; line) {\n        lines.push(line);\n        line = words[n];\n      } else {\n        line = testLine;\n      }\n    }\n    if (line) lines.push(line);\n    // If still too many lines, shrink font or truncate\n    for (let i=0;i&lt;lines.length;i++){\n      ctx.fillText(lines[i], x, y + (i - (lines.length-1)/2) * lineHeight);\n    }\n  }\n  // UI glue\n  document.addEventListener(\'DOMContentLoaded\', () =&gt; {\n    const canvas = document.getElementById(\'wheelCanvas\');\n    const wheel = new Wheel(canvas, { theme: \'light\', onResult: onWinner });\n    const nameInput = document.getElementById(\'nameInput\');\n    const addBtn = document.getElementById(\'addBtn\');\n    const addRandomBtn = document.getElementById(\'addRandomBtn\');\n    const bulkInput = document.getElementById(\'bulkInput\');\n    const bulkAddBtn = document.getElementById(\'bulkAddBtn\');\n    const clearBulkBtn = document.getElementById(\'clearBulkBtn\');\n    const nameList = document.getElementById(\'nameList\');\n    const countSpan = document.getElementById(\'count\');\n    const spinBtn = document.getElementById(\'spinBtn\');\n    const rerollBtn = document.getElementById(\'rerollBtn\');\n    const clearNamesBtn = document.getElementById(\'clearNamesBtn\');\n    const themeSelect = document.getElementById(\'themeSelect\');\n    const resultSection = document.getElementById(\'result\');\n    const winnerNameDiv = document.getElementById(\'winnerName\');\n    const exportBtn = document.getElementById(\'exportBtn\');\n    const importBtn = document.getElementById(\'importBtn\');\n    const importFile = document.getElementById(\'importFile\');\n    // Initial draw\n    wheel.draw();\n    function updateUI() {\n      const names = wheel.names;\n      countSpan.textContent = names.length;\n      renderNameList();\n    }\n    function renderNameList() {\n      nameList.innerHTML = \'\';\n      wheel.names.forEach((n, i) =&gt; {\n        const li = document.createElement(\'li\');\n        const span = document.createElement(\'span\');\n        span.textContent = n;\n        li.appendChild(span);\n        const btn = document.createElement(\'button\');\n        btn.title = \'Remove\';\n        btn.innerHTML = \'✕\';\n        btn.addEventListener(\'click\', () =&gt; {\n          wheel.removeName(i);\n          updateUI();\n        });\n        li.appendChild(btn);\n        nameList.appendChild(li);\n      });\n    }\n    function addNameFromInput() {\n      const v = nameInput.value.trim();\n      if (!v) { showMessage(\'Please enter a name.\', \'warn\'); return; }\n      wheel.addName(v);\n      nameInput.value = \'\';\n      updateUI();\n    }\n    addBtn.addEventListener(\'click\', addNameFromInput);\n    nameInput.addEventListener(\'keydown\', (e) =&gt; { if (e.key === \'Enter\') addNameFromInput(); });\n    addRandomBtn.addEventListener(\'click\', () =&gt; {\n      const samples = [\'Alex\',\'Jordan\',\'Taylor\',\'Sam\',\'Jamie\',\'Casey\',\'Morgan\',\'Riley\',\'Avery\',\'Dana\'];\n      const count = rand(3,6);\n      for (let i=0;i&lt;count;i++) wheel.addName(samples[rand(0,samples.length-1)] + (rand(1,100)));\n      updateUI();\n    });\n    bulkAddBtn.addEventListener(\'click\', () =&gt; {\n      const text = bulkInput.value.trim();\n      if (!text) { showMessage(\'Bulk input is empty.\', \'warn\'); return; }\n      const parsed = text.split(/[\\n,;]+/).map(s =&gt; s.trim()).filter(s =&gt; s);\n      parsed.forEach(p =&gt; wheel.addName(p));\n      bulkInput.value = \'\';\n      updateUI();\n      showMessage(`Added ${parsed.length} names.`, \'info\');\n    });\n    clearBulkBtn.addEventListener(\'click\', () =&gt; { bulkInput.value = \'\'; });\n    spinBtn.addEventListener(\'click\', () =&gt; {\n      if (wheel.names.length === 0) { showMessage(\'Add at least one name to spin.\', \'warn\'); return; }\n      resultSection.hidden = true;\n      winnerNameDiv.textContent = \'\';\n      wheel.spin();\n      spinBtn.disabled = true;\n      const checkFinish = setInterval(() =&gt; {\n        if (!wheel.isSpinning) {\n          clearInterval(checkFinish);\n          spinBtn.disabled = false;\n        }\n      }, 200);\n    });\n    rerollBtn.addEventListener(\'click\', () =&gt; {\n      resultSection.hidden = true;\n      wheel.spin();\n    });\n    clearNamesBtn.addEventListener(\'click\', () =&gt; {\n      if (confirm(\'Clear all names?\')) {\n        wheel.clearNames();\n        updateUI();\n      }\n    });\n    themeSelect.addEventListener(\'change\', (e) =&gt; {\n      const t = e.target.value;\n      document.body.className = \'theme-\' + t;\n      wheel.setTheme(t);\n    });\n    function onWinner(result) {\n      winnerNameDiv.textContent = result.name || \'—\';\n      resultSection.hidden = false;\n      // Flash the winner item in the list (if still present)\n      const items = Array.from(nameList.children);\n      items.forEach((li, idx) =&gt; { li.classList.toggle(\'winner\', idx === result.index); });\n      showMessage(`Winner: ${result.name}`, \'success\', 4000);\n    }\n    // Simple message area\n    function showMessage(text, type = \'info\', duration = 2200) {\n      // create small toast\n      const t = document.createElement(\'div\');\n      t.className = \'tmp-toast \' + type;\n      t.textContent = text;\n      document.body.appendChild(t);\n      setTimeout(()=&gt; { t.style.opacity = \'0\'; t.style.transform = \'translateY(-10px)\'; }, duration - 300);\n      setTimeout(()=&gt; { try { t.remove(); } catch(e){} }, duration);\n    }\n    // Export/import CSV\n    exportBtn.addEventListener(\'click\', () =&gt; {\n      if (wheel.names.length === 0) { showMessage(\'No names to export.\', \'warn\'); return; }\n      const csv = wheel.names.map(n =&gt; `"${(n||\'\').replace(/"/g,\'""\')}"`).join(\'\\n\');\n      const blob = new Blob([csv], { type: \'text/csv\' });\n      const url = URL.createObjectURL(blob);\n      const a = document.createElement(\'a\');\n      a.href = url;\n      a.download = \'participants.csv\';\n      document.body.appendChild(a);\n      a.click();\n      a.remove();\n      URL.revokeObjectURL(url);\n      showMessage(\'Exported CSV\', \'info\');\n    });\n    importBtn.addEventListener(\'click\', () =&gt; { importFile.click(); });\n    importFile.addEventListener(\'change\', (e) =&gt; {\n      const file = e.target.files[0];\n      if (!file) return;\n      const reader = new FileReader();\n      reader.onload = (ev) =&gt; {\n        const txt = ev.target.result;\n        const lines = txt.split(/\\r?\\n/).map(s =&gt; s.trim()).filter(s =&gt; s);\n        // basic CSV unquote\n        const parsed = lines.map(l =&gt; {\n          if (l.startsWith(\'"\') &amp;&amp; l.endsWith(\'"\')) {\n            return l.slice(1,-1).replace(/""/g,\'"\');\n          }\n          return l;\n        });\n        parsed.forEach(p =&gt; wheel.addName(p));\n        updateUI();\n        showMessage(`Imported ${parsed.length} names`, \'info\');\n      };\n      reader.readAsText(file);\n      importFile.value = \'\';\n    });\n    // Initial sample\n    // wheel.addName(\'Alice\'); wheel.addName(\'Bob\'); wheel.addName(\'Charlie\');\n    updateUI();\n    // (Optional) keyboard shortcuts\n    window.addEventListener(\'keydown\', (e) =&gt; {\n      if ((e.ctrlKey || e.metaKey) &amp;&amp; e.key.toLowerCase() === \'k\') {\n        e.preventDefault();\n        nameInput.focus();\n      }\n      if (e.key === \' \') {\n        // space triggers spin if not focusing an input\n        if (document.activeElement.tagName !== \'INPUT\' &amp;&amp; document.activeElement.tagName !== \'TEXTAREA\') {\n          e.preventDefault();\n          spinBtn.click();\n        }\n      }\n    });\n  });\n})();\n\n\n', 'images': ''} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_3_5_TURBO |

[2025-17-09 13:28:29 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Code Reviewer |
| **user_role_name** | Programmer |
| **assistant_role_prompt** | {chatdev_prompt} You are Code Reviewer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. You can help programmers to assess source codes for software troubleshooting, fix bugs to increase code quality and robustness, and offer proposals to improve the source codes. Here is a new customer's task: {task}. To complete the task, you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Programmer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. You can write/create computer software or applications by providing a specific programming language to the computer. You have extensive computing and coding experience in many varieties of programming languages and platforms, such as Python, Java, C, C++, HTML, CSS, JavaScript, XML, SQL, PHP, etc,. Here is a new customer's task: {task}. To complete the task, you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **task_prompt** | [Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes. Do it in HTML, CSS, and JavaScript.] |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_3_5_TURBO |
| **background_prompt** | ChatDev is a software company powered by multiple intelligent agents, such as chief executive officer, chief human resources officer, chief product officer, chief technology officer, etc, with a multi-agent organizational structure and the mission of 'changing the digital world through programming'. |

[2025-17-09 13:28:29 INFO] Programmer: **[Start Chat]**

[ChatDev is a software company powered by multiple intelligent agents, such as chief executive officer, chief human resources officer, chief product officer, chief technology officer, etc, with a multi-agent organizational structure and the mission of 'changing the digital world through programming'.
You are Code Reviewer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer.
You can help programmers to assess source codes for software troubleshooting, fix bugs to increase code quality and robustness, and offer proposals to improve the source codes.
Here is a new customer's task: [Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes. Do it in HTML, CSS, and JavaScript.].
To complete the task, you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]

According to the new user's task and our software designs: 
Task: "[Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes. Do it in HTML, CSS, and JavaScript.]".
Modality: "website".
Programming Language: " JavaScript"
Ideas: ""
Codes:
"index.html
```html
'''
<!--
DOCSTRING
This is the main HTML file for the Random Winner Wheel.
It contains the structure: input fields to add names, a canvas for the wheel,
controls (spin, clear, bulk add), theme selector, and placeholders for CSS/JS.
-->
'''
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Random Winner Wheel</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body class="theme-light">
  <header>
    <h1>Random Winner Wheel</h1>
    <p>Enter participant names, choose a theme, and spin to pick a winner.</p>
  </header>
  <main>
    <section class="controls">
      <div class="add-single">
        <input id="nameInput" type="text" placeholder="Enter a name and press Add" aria-label="Name input" />
        <button id="addBtn">Add</button>
        <button id="addRandomBtn" title="Add a few sample random names">Add Sample</button>
      </div>
      <div class="bulk-add">
        <label for="bulkInput">Bulk add (comma, newline or semicolon separated):</label>
        <textarea id="bulkInput" placeholder="Alice, Bob, Charlie"></textarea>
        <div class="bulk-actions">
          <button id="bulkAddBtn">Bulk Add</button>
          <button id="clearBulkBtn">Clear Bulk</button>
        </div>
      </div>
      <div class="list-actions">
        <div class="theme-select">
          <label for="themeSelect">Theme:</label>
          <select id="themeSelect">
            <option value="light">Light</option>
            <option value="dark">Dark</option>
            <option value="neon">Neon</option>
            <option value="pastel">Pastel</option>
            <option value="retro">Retro</option>
          </select>
        </div>
        <div class="wheel-controls">
          <button id="spinBtn" class="primary">Spin</button>
          <button id="clearNamesBtn">Clear Names</button>
          <button id="exportBtn">Export CSV</button>
          <input id="importFile" type="file" accept=".csv,text/csv" style="display:none">
          <button id="importBtn">Import CSV</button>
        </div>
      </div>
    </section>
    <section class="wheel-area">
      <div class="wheel-container">
        <canvas id="wheelCanvas" width="600" height="600" aria-label="Spinning wheel"></canvas>
        <div class="pointer">▼</div>
      </div>
      <aside class="participants">
        <h2>Participants (<span id="count">0</span>)</h2>
        <ul id="nameList" aria-live="polite"></ul>
      </aside>
    </section>
    <section class="result" id="result" aria-live="polite" hidden>
      <h2>Winner</h2>
      <div id="winnerName" class="winnerName"></div>
      <button id="rerollBtn">Spin Again</button>
    </section>
  </main>
  <footer>
    <small>Built with HTML, CSS, and JavaScript. Themes change both UI and wheel colors.</small>
  </footer>
  <script src="script.js"></script>
</body>
</html>
```

styles.css
```css
'''
DOCSTRING
Stylesheet for the Random Winner Wheel.
Defines layout, themes, wheel container sizing, and animations.
'''
/* Reset & base */
* { box-sizing: border-box; margin: 0; padding: 0; }
html,body { height: 100%; font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; background: var(--bg); color: var(--fg); }
:root {
  --bg: #f7f8fb;
  --fg: #222;
  --muted: #666;
  --accent: #2b8cff;
  --card: #ffffff;
  --primary-btn-bg: var(--accent);
  --primary-btn-fg: #fff;
  --shadow: rgba(15,15,15,0.08);
}
/* Themes */
body.theme-light {
  --bg: #f7f8fb;
  --fg: #222;
  --muted: #5b6170;
  --accent: #2b8cff;
  --card: #fff;
  --wheel-seq: 0;
}
body.theme-dark {
  --bg: #0f1724;
  --fg: #e6eef8;
  --muted: #a9b1c2;
  --accent: #7c5cff;
  --card: #0b1220;
}
body.theme-neon {
  --bg: #0a0a0f;
  --fg: #e9f9ff;
  --muted: #a6f3ff;
  --accent: #39ff14;
  --card: #09101a;
}
body.theme-pastel {
  --bg: #fffaf6;
  --fg: #3c3a3a;
  --muted: #8d8a8a;
  --accent: #ff7aa2;
  --card: #fff;
}
body.theme-retro {
  --bg: #fff6e7;
  --fg: #402b2b;
  --muted: #856e6e;
  --accent: #ffb86b;
  --card: #fff0e6;
}
/* Layout */
header { padding: 18px 24px; text-align: center; background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent); }
header h1 { font-size: 1.5rem; margin-bottom: 6px; }
main { padding: 18px; max-width: 1100px; margin: 0 auto; }
.controls { display: grid; gap: 12px; margin-bottom: 18px; }
.add-single { display:flex; gap:8px; }
.add-single input[type="text"] { flex:1; padding:10px; border-radius:8px; border:1px solid rgba(0,0,0,0.08); background:var(--card); color:var(--fg); }
.add-single button { padding:10px 12px; border-radius:8px; border: none; cursor:pointer; background: var(--primary-btn-bg); color: var(--primary-btn-fg); }
.add-single button#addRandomBtn { background: transparent; border: 1px solid rgba(0,0,0,0.06); color: var(--fg); }
.bulk-add textarea { width:100%; min-height:64px; margin-top:6px; padding:8px; border-radius:8px; border:1px solid rgba(0,0,0,0.06); background:var(--card); color:var(--fg); }
.bulk-actions { display:flex; gap:8px; margin-top:8px; }
.list-actions { display:flex; justify-content:space-between; align-items:center; gap:16px; flex-wrap:wrap; }
.theme-select select { padding:8px; border-radius:8px; border:1px solid rgba(0,0,0,0.06); }
.wheel-area { display:flex; gap:18px; align-items:start; flex-wrap:wrap; }
.wheel-container { position: relative; width: 600px; height: 600px; max-width: 90vw; max-height: 90vw; display:flex; align-items:center; justify-content:center; background: transparent; }
.pointer { position:absolute; top:6px; font-size:28px; transform: translateY(-50%); text-shadow: 0 2px 8px rgba(0,0,0,0.25); color: var(--accent); pointer-events:none; }
.participants { width: 320px; max-width: 40vw; background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent); padding:12px; border-radius:10px; box-shadow: 0 6px 18px var(--shadow); }
.participants h2 { margin-bottom:8px; font-size:1.05rem; }
#nameList { list-style:none; max-height:420px; overflow:auto; display:block; }
#nameList li { padding:8px; border-radius:6px; display:flex; justify-content:space-between; align-items:center; gap:8px; margin-bottom:8px; background: var(--card); border:1px solid rgba(0,0,0,0.04); }
#nameList li button { background: transparent; border: none; color: var(--muted); cursor:pointer; }
.result { margin-top:18px; padding:12px; border-radius:8px; background: var(--card); text-align:center; box-shadow: 0 6px 18px var(--shadow); }
.result .winnerName { font-size:1.4rem; font-weight:700; margin:8px 0; color: var(--accent); }
/* Buttons */
button { cursor:pointer; padding:8px 12px; border-radius:8px; border:1px solid rgba(0,0,0,0.06); background: transparent; color:var(--fg); }
button.primary { background: var(--primary-btn-bg); color: var(--primary-btn-fg); border: none; }
/* Responsive */
@media (max-width: 900px) {
  .wheel-area { flex-direction:column; align-items:center; }
  .participants { width: 100%; max-width: 100%; }
}
/* Wheel canvas scaling helper */
#wheelCanvas { border-radius:50%; box-shadow: 0 12px 26px rgba(0,0,0,0.12); background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.02), transparent); }
```

script.js
```js
'''
DOCSTRING
Script for the Random Winner Wheel.
Contains the Wheel class to draw and spin the canvas-based wheel and UI glue code to manage names and themes.
'''
/* Main JavaScript - Wheel + UI logic */
(() => {
  // Utilities
  function rand(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }
  function easeOutCubic(t) { return 1 - Math.pow(1 - t, 3); }
  // Color palettes for themes (will be used to paint wheel segments)
  const THEME_PALETTES = {
    light: ['#FF8A80','#FFD180','#FFF59D','#C8E6C9','#80DEEA','#A7FFEB','#B39DDB','#90CAF9'],
    dark: ['#ff6b6b','#ffd166','#faff8e','#b9f6ca','#4dd0e1','#80cbc4','#b388ff','#64b5f6'],
    neon: ['#ff2d95','#7cff01','#00ffff','#ffdd00','#ff6a00','#00ff9e','#ff00ff','#47ffa2'],
    pastel: ['#ffdbe9','#fff0b3','#d1ffd6','#cfefff','#e7dfff','#ffd6e7','#fbe7d6','#e6f7ff'],
    retro: ['#ffb86b','#ffd3a8','#f3e2a9','#b8e0d2','#c0b9ff','#ffb6c1','#f6c49f','#c3d69b']
  };
  // Wheel class
  class Wheel {
    /*
    Manage wheel: drawing, recalculating segments, spinning animation, and determining winner.
    */
    constructor(canvas, options = {}) {
      this.canvas = canvas;
      this.ctx = canvas.getContext('2d');
      this.names = [];
      this.rotation = 0; // radians
      this.isSpinning = false;
      this.frame = null;
      this.onResult = options.onResult || function() {};
      this.theme = options.theme || 'light';
      this.padAngle = 0.02; // radians padding between segments
      this.textColor = '#111';
      this._devicePixelRatioFix();
      window.addEventListener('resize', () => { this._devicePixelRatioFix(); this.draw(); });
    }
    _devicePixelRatioFix() {
      const dpr = window.devicePixelRatio || 1;
      const rect = this.canvas.getBoundingClientRect();
      this.canvas.width = rect.width * dpr;
      this.canvas.height = rect.height * dpr;
      this.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      this.centerX = rect.width / 2;
      this.centerY = rect.height / 2;
      this.radius = Math.min(rect.width, rect.height) / 2 - 18;
    }
    setTheme(themeId) { this.theme = themeId; this.draw(); }
    setNames(names) {
      this.names = names.slice();
      this.draw();
    }
    addName(name) {
      this.names.push(name);
      this.draw();
    }
    removeName(index) {
      if (index >= 0 && index < this.names.length) {
        this.names.splice(index,1);
        this.draw();
      }
    }
    clearNames() {
      this.names = [];
      this.draw();
    }
    draw() {
      const ctx = this.ctx;
      const w = this.canvas.width / (window.devicePixelRatio || 1);
      const h = this.canvas.height / (window.devicePixelRatio || 1);
      ctx.clearRect(0,0,w,h);
      ctx.save();
      ctx.translate(this.centerX, this.centerY);
      ctx.rotate(this.rotation);
      // draw segments
      const count = Math.max(this.names.length, 1);
      const palette = THEME_PALETTES[this.theme] || THEME_PALETTES.light;
      for (let i = 0; i < count; i++) {
        const start = (i / count) * Math.PI * 2;
        const end = ((i + 1) / count) * Math.PI * 2;
        ctx.beginPath();
        ctx.moveTo(0,0);
        ctx.arc(0,0,this.radius, start + this.padAngle, end - this.padAngle, false);
        ctx.closePath();
        const color = palette[i % palette.length];
        ctx.fillStyle = color;
        ctx.fill();
        ctx.strokeStyle = (i % 2 === 0) ? 'rgba(0,0,0,0.06)' : 'rgba(0,0,0,0.03)';
        ctx.lineWidth = 1;
        ctx.stroke();
        // draw text label
        const mid = (start + end) / 2;
        ctx.save();
        ctx.rotate(mid);
        ctx.translate(this.radius * 0.6, 0);
        ctx.rotate(Math.PI/2);
        ctx.fillStyle = getTextColor(color);
        ctx.font = `${Math.max(12, Math.min(22, this.radius / 8))}px sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        const label = (this.names.length === 0) ? 'Add names' : this.names[i % this.names.length];
        wrapFillText(ctx, label, 0, 0, this.radius * 0.5, 16);
        ctx.restore();
      }
      // draw center circle
      ctx.beginPath();
      ctx.arc(0,0, this.radius * 0.16, 0, Math.PI*2);
      ctx.fillStyle = 'rgba(255,255,255,0.9)';
      ctx.fill();
      ctx.strokeStyle = 'rgba(0,0,0,0.06)';
      ctx.stroke();
      ctx.restore();
      // draw outer ring (pointer side neutral)
      ctx.beginPath();
      ctx.arc(this.centerX, this.centerY, this.radius + 10, 0, Math.PI*2);
      ctx.strokeStyle = 'rgba(0,0,0,0.03)';
      ctx.lineWidth = 2;
      ctx.stroke();
    }
    spin() {
      if (this.isSpinning || this.names.length === 0) return;
      this.isSpinning = true;
      const count = this.names.length;
      // Determine random winner index to land on:
      const winnerIndex = rand(0, count - 1);
      // Calculate final rotation so that winner segment lines up with pointer at top (pointer at canvas top - rotation must align)
      // Our pointer is at the top (canvas 0 angle). The segment mid-angle for index i (without rotation) is ((i + 0.5)/count)*2pi
      const segmentMid = ((winnerIndex + 0.5) / count) * Math.PI * 2;
      // We want segmentMid + rotation_final == -Math.PI/2 (so it points at the top pointer), so rotation_final = -Math.PI/2 - segmentMid + 2pi*N
      const extraTurns = rand(5, 8); // full spins
      const rotationFinal = -Math.PI/2 - segmentMid + extraTurns * Math.PI * 2;
      const startRotation = this.rotation % (Math.PI * 2);
      const delta = rotationFinal - startRotation;
      const duration = 4000 + Math.random() * 1500; // ms
      const startTime = performance.now();
      const animate = (now) => {
        const elapsed = now - startTime;
        const t = Math.min(elapsed / duration, 1);
        const eased = easeOutCubic(t);
        this.rotation = startRotation + delta * eased;
        this.draw();
        if (t < 1) {
          this.frame = requestAnimationFrame(animate);
        } else {
          this.isSpinning = false;
          // Normalize rotation within 0..2pi
          this.rotation = ((this.rotation % (Math.PI*2)) + Math.PI*2) % (Math.PI*2);
          this.draw();
          // Compute final winner index again from rotation
          const finalAngle = (-this.rotation - Math.PI/2 + Math.PI*2) % (Math.PI*2);
          const resultingIndex = Math.floor(((finalAngle / (Math.PI*2)) * count + count) % count);
          const winner = this.names[resultingIndex];
          this.onResult({ index: resultingIndex, name: winner });
        }
      };
      this.frame = requestAnimationFrame(animate);
    }
  }
  // Helper: pick readable text color for a background
  function getTextColor(hex) {
    // remove # and convert
    const h = hex.replace('#','');
    const r = parseInt(h.substring(0,2),16);
    const g = parseInt(h.substring(2,4),16);
    const b = parseInt(h.substring(4,6),16);
    // luminance
    const lum = (0.299*r + 0.587*g + 0.114*b) / 255;
    return lum > 0.65 ? '#111' : '#fff';
  }
  // Helper: wrap text within a given width (draws multi-line if necessary)
  function wrapFillText(ctx, text, x, y, maxWidth, lineHeight) {
    const words = (text || '').split(/\s+/);
    if (words.length === 0) return;
    let line = '';
    const lines = [];
    for (let n = 0; n < words.length; n++) {
      const testLine = line ? line + ' ' + words[n] : words[n];
      const metrics = ctx.measureText(testLine);
      if (metrics.width > maxWidth && line) {
        lines.push(line);
        line = words[n];
      } else {
        line = testLine;
      }
    }
    if (line) lines.push(line);
    // If still too many lines, shrink font or truncate
    for (let i=0;i<lines.length;i++){
      ctx.fillText(lines[i], x, y + (i - (lines.length-1)/2) * lineHeight);
    }
  }
  // UI glue
  document.addEventListener('DOMContentLoaded', () => {
    const canvas = document.getElementById('wheelCanvas');
    const wheel = new Wheel(canvas, { theme: 'light', onResult: onWinner });
    const nameInput = document.getElementById('nameInput');
    const addBtn = document.getElementById('addBtn');
    const addRandomBtn = document.getElementById('addRandomBtn');
    const bulkInput = document.getElementById('bulkInput');
    const bulkAddBtn = document.getElementById('bulkAddBtn');
    const clearBulkBtn = document.getElementById('clearBulkBtn');
    const nameList = document.getElementById('nameList');
    const countSpan = document.getElementById('count');
    const spinBtn = document.getElementById('spinBtn');
    const rerollBtn = document.getElementById('rerollBtn');
    const clearNamesBtn = document.getElementById('clearNamesBtn');
    const themeSelect = document.getElementById('themeSelect');
    const resultSection = document.getElementById('result');
    const winnerNameDiv = document.getElementById('winnerName');
    const exportBtn = document.getElementById('exportBtn');
    const importBtn = document.getElementById('importBtn');
    const importFile = document.getElementById('importFile');
    // Initial draw
    wheel.draw();
    function updateUI() {
      const names = wheel.names;
      countSpan.textContent = names.length;
      renderNameList();
    }
    function renderNameList() {
      nameList.innerHTML = '';
      wheel.names.forEach((n, i) => {
        const li = document.createElement('li');
        const span = document.createElement('span');
        span.textContent = n;
        li.appendChild(span);
        const btn = document.createElement('button');
        btn.title = 'Remove';
        btn.innerHTML = '✕';
        btn.addEventListener('click', () => {
          wheel.removeName(i);
          updateUI();
        });
        li.appendChild(btn);
        nameList.appendChild(li);
      });
    }
    function addNameFromInput() {
      const v = nameInput.value.trim();
      if (!v) { showMessage('Please enter a name.', 'warn'); return; }
      wheel.addName(v);
      nameInput.value = '';
      updateUI();
    }
    addBtn.addEventListener('click', addNameFromInput);
    nameInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') addNameFromInput(); });
    addRandomBtn.addEventListener('click', () => {
      const samples = ['Alex','Jordan','Taylor','Sam','Jamie','Casey','Morgan','Riley','Avery','Dana'];
      const count = rand(3,6);
      for (let i=0;i<count;i++) wheel.addName(samples[rand(0,samples.length-1)] + (rand(1,100)));
      updateUI();
    });
    bulkAddBtn.addEventListener('click', () => {
      const text = bulkInput.value.trim();
      if (!text) { showMessage('Bulk input is empty.', 'warn'); return; }
      const parsed = text.split(/[\n,;]+/).map(s => s.trim()).filter(s => s);
      parsed.forEach(p => wheel.addName(p));
      bulkInput.value = '';
      updateUI();
      showMessage(`Added ${parsed.length} names.`, 'info');
    });
    clearBulkBtn.addEventListener('click', () => { bulkInput.value = ''; });
    spinBtn.addEventListener('click', () => {
      if (wheel.names.length === 0) { showMessage('Add at least one name to spin.', 'warn'); return; }
      resultSection.hidden = true;
      winnerNameDiv.textContent = '';
      wheel.spin();
      spinBtn.disabled = true;
      const checkFinish = setInterval(() => {
        if (!wheel.isSpinning) {
          clearInterval(checkFinish);
          spinBtn.disabled = false;
        }
      }, 200);
    });
    rerollBtn.addEventListener('click', () => {
      resultSection.hidden = true;
      wheel.spin();
    });
    clearNamesBtn.addEventListener('click', () => {
      if (confirm('Clear all names?')) {
        wheel.clearNames();
        updateUI();
      }
    });
    themeSelect.addEventListener('change', (e) => {
      const t = e.target.value;
      document.body.className = 'theme-' + t;
      wheel.setTheme(t);
    });
    function onWinner(result) {
      winnerNameDiv.textContent = result.name || '—';
      resultSection.hidden = false;
      // Flash the winner item in the list (if still present)
      const items = Array.from(nameList.children);
      items.forEach((li, idx) => { li.classList.toggle('winner', idx === result.index); });
      showMessage(`Winner: ${result.name}`, 'success', 4000);
    }
    // Simple message area
    function showMessage(text, type = 'info', duration = 2200) {
      // create small toast
      const t = document.createElement('div');
      t.className = 'tmp-toast ' + type;
      t.textContent = text;
      document.body.appendChild(t);
      setTimeout(()=> { t.style.opacity = '0'; t.style.transform = 'translateY(-10px)'; }, duration - 300);
      setTimeout(()=> { try { t.remove(); } catch(e){} }, duration);
    }
    // Export/import CSV
    exportBtn.addEventListener('click', () => {
      if (wheel.names.length === 0) { showMessage('No names to export.', 'warn'); return; }
      const csv = wheel.names.map(n => `"${(n||'').replace(/"/g,'""')}"`).join('\n');
      const blob = new Blob([csv], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'participants.csv';
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
      showMessage('Exported CSV', 'info');
    });
    importBtn.addEventListener('click', () => { importFile.click(); });
    importFile.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (ev) => {
        const txt = ev.target.result;
        const lines = txt.split(/\r?\n/).map(s => s.trim()).filter(s => s);
        // basic CSV unquote
        const parsed = lines.map(l => {
          if (l.startsWith('"') && l.endsWith('"')) {
            return l.slice(1,-1).replace(/""/g,'"');
          }
          return l;
        });
        parsed.forEach(p => wheel.addName(p));
        updateUI();
        showMessage(`Imported ${parsed.length} names`, 'info');
      };
      reader.readAsText(file);
      importFile.value = '';
    });
    // Initial sample
    // wheel.addName('Alice'); wheel.addName('Bob'); wheel.addName('Charlie');
    updateUI();
    // (Optional) keyboard shortcuts
    window.addEventListener('keydown', (e) => {
      if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'k') {
        e.preventDefault();
        nameInput.focus();
      }
      if (e.key === ' ') {
        // space triggers spin if not focusing an input
        if (document.activeElement.tagName !== 'INPUT' && document.activeElement.tagName !== 'TEXTAREA') {
          e.preventDefault();
          spinBtn.click();
        }
      }
    });
  });
})();
```

"
As the Code Reviewer, to make the software directly operable without further coding, ChatDev have formulated the following regulations:
1) all referenced classes should be imported;
2) all methods should be implemented;
3) all methods need to have the necessary comments;
4) no potential bugs;
5) The entire project conforms to the tasks proposed by the user;
6) most importantly, do not only check the errors in the code, but also the logic of code. Make sure that user can interact with generated software without losing any feature in the requirement;
Now, you should check the above regulations one by one and review the codes in detail, propose one comment with the highest priority about the codes, and give me instructions on how to fix. Tell me your comment with the highest priority and corresponding suggestions on revision. If the codes are perfect and you have no comment on them, return only one line like "<INFO> Finished".

[2025-17-09 13:29:13 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2025-17-09 13:29:13 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 6615
completion_tokens: 2474
total_tokens: 9089
cost: $-1.000000


[2025-17-09 13:29:13 INFO] Code Reviewer: **Code Reviewer<->Programmer on : CodeReviewComment, turn 0**

[ChatDev is a software company powered by multiple intelligent agents, such as chief executive officer, chief human resources officer, chief product officer, chief technology officer, etc, with a multi-agent organizational structure and the mission of 'changing the digital world through programming'.
You are Programmer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer.
You can write/create computer software or applications by providing a specific programming language to the computer. You have extensive computing and coding experience in many varieties of programming languages and platforms, such as Python, Java, C, C++, HTML, CSS, JavaScript, XML, SQL, PHP, etc,.
Here is a new customer's task: [Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes. Do it in HTML, CSS, and JavaScript.].
To complete the task, you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]

<CRITICAL> Remove the Python-style triple-quote docstring wrappers present at the top of your HTML, CSS and JS files — they break parsing/loading of the site.

Why this is highest priority:
- Each file (index.html, styles.css, script.js) starts with literal lines containing three single quotes (''') surrounding a "DOCSTRING" block. Those triple-quote lines are not valid tokens in HTML/CSS/JS and will cause syntax errors or make the browser ignore/stop parsing the files. The app will fail to run (no script execution, CSS not applied, HTML may contain stray text).
- Fixing these simple invalid tokens is required before any other runtime or UX fixes can be verified.

How to fix (exact steps):

1) index.html
- Remove the lines that look like ''' immediately before and after the HTML comment block.
- Keep the HTML comment, or convert it into a normal HTML comment only. The file should begin with <!doctype html>.

Example change:
Current top of file:
'''
<!--
DOCSTRING
This is...
-->
'''
<!doctype html>

Replace with:
<!--
DOCSTRING
This is the main HTML file for the Random Winner Wheel.
It contains the structure: input fields to add names, a canvas for the wheel,
controls (spin, clear, bulk add), theme selector, and placeholders for CSS/JS.
-->
<!doctype html>

2) styles.css
- Remove the leading and trailing ''' lines.
- Convert the "DOCSTRING" block to a proper CSS comment /* ... */ or remove it.

Example change:
Current top:
'''
DOCSTRING
Stylesheet for the Random Winner Wheel.
Defines layout, themes, wheel container sizing, and animations.
'''
/* Reset & base */
...

Replace with:
/* DOCSTRING
   Stylesheet for the Random Winner Wheel.
   Defines layout, themes, wheel container sizing, and animations.
*/
 /* Reset & base */
...

3) script.js
- Remove the leading/trailing ''' lines.
- Convert the DOCSTRING block to a JS comment (/* ... */) or use // comments.

Example change:
Current top:
'''
DOCSTRING
Script for the Random Winner Wheel.
Contains the Wheel class to draw and spin the canvas-based wheel and UI glue code to manage names and themes.
'''
/* Main JavaScript - Wheel + UI logic */
(() => {

Replace with:
/* DOCSTRING
   Script for the Random Winner Wheel.
   Contains the Wheel class to draw and spin the canvas-based wheel and UI glue code to manage names and themes.
*/
/* Main JavaScript - Wheel + UI logic */
(() => {

4) (Recommended but lower priority) Add CSS rules for the toast messages inserted by showMessage
- Your showMessage creates elements with class "tmp-toast" and type classes like "info", "warn", "success" but no CSS exists for these. Add minimal styling so messages are visible, e.g.:

/* add near end of styles.css */
.tmp-toast {
  position: fixed;
  left: 50%;
  transform: translateX(-50%);
  top: 18px;
  background: rgba(0,0,0,0.85);
  color: #fff;
  padding: 8px 12px;
  border-radius: 6px;
  z-index: 9999;
  transition: opacity 0.25s, transform 0.25s;
  opacity: 1;
  pointer-events: none;
}
.tmp-toast.success { background: rgba(56, 198, 123, 0.95); }
.tmp-toast.warn    { background: rgba(255, 159, 67, 0.95); }
.tmp-toast.info    { background: rgba(12, 74, 255, 0.95); }

Why include the toast CSS: after fixing the syntax errors you will want visible feedback for users (error/warn/info messages).

After you remove those triple-quote lines and adjust the comments as shown, reload and re-test the page. If other runtime issues remain (e.g., pointer alignment, winner-index calculation edge-cases, or UX enhancements like better CSV parsing), I can run through a prioritized list of additional improvements.

[2025-17-09 13:29:13 INFO] **[Seminar Conclusion]**:

 <CRITICAL> Remove the Python-style triple-quote docstring wrappers present at the top of your HTML, CSS and JS files — they break parsing/loading of the site.

Why this is highest priority:
- Each file (index.html, styles.css, script.js) starts with literal lines containing three single quotes (''') surrounding a "DOCSTRING" block. Those triple-quote lines are not valid tokens in HTML/CSS/JS and will cause syntax errors or make the browser ignore/stop parsing the files. The app will fail to run (no script execution, CSS not applied, HTML may contain stray text).
- Fixing these simple invalid tokens is required before any other runtime or UX fixes can be verified.

How to fix (exact steps):

1) index.html
- Remove the lines that look like ''' immediately before and after the HTML comment block.
- Keep the HTML comment, or convert it into a normal HTML comment only. The file should begin with <!doctype html>.

Example change:
Current top of file:
'''
<!--
DOCSTRING
This is...
-->
'''
<!doctype html>

Replace with:
<!--
DOCSTRING
This is the main HTML file for the Random Winner Wheel.
It contains the structure: input fields to add names, a canvas for the wheel,
controls (spin, clear, bulk add), theme selector, and placeholders for CSS/JS.
-->
<!doctype html>

2) styles.css
- Remove the leading and trailing ''' lines.
- Convert the "DOCSTRING" block to a proper CSS comment /* ... */ or remove it.

Example change:
Current top:
'''
DOCSTRING
Stylesheet for the Random Winner Wheel.
Defines layout, themes, wheel container sizing, and animations.
'''
/* Reset & base */
...

Replace with:
/* DOCSTRING
   Stylesheet for the Random Winner Wheel.
   Defines layout, themes, wheel container sizing, and animations.
*/
 /* Reset & base */
...

3) script.js
- Remove the leading/trailing ''' lines.
- Convert the DOCSTRING block to a JS comment (/* ... */) or use // comments.

Example change:
Current top:
'''
DOCSTRING
Script for the Random Winner Wheel.
Contains the Wheel class to draw and spin the canvas-based wheel and UI glue code to manage names and themes.
'''
/* Main JavaScript - Wheel + UI logic */
(() => {

Replace with:
/* DOCSTRING
   Script for the Random Winner Wheel.
   Contains the Wheel class to draw and spin the canvas-based wheel and UI glue code to manage names and themes.
*/
/* Main JavaScript - Wheel + UI logic */
(() => {

4) (Recommended but lower priority) Add CSS rules for the toast messages inserted by showMessage
- Your showMessage creates elements with class "tmp-toast" and type classes like "info", "warn", "success" but no CSS exists for these. Add minimal styling so messages are visible, e.g.:

/* add near end of styles.css */
.tmp-toast {
  position: fixed;
  left: 50%;
  transform: translateX(-50%);
  top: 18px;
  background: rgba(0,0,0,0.85);
  color: #fff;
  padding: 8px 12px;
  border-radius: 6px;
  z-index: 9999;
  transition: opacity 0.25s, transform 0.25s;
  opacity: 1;
  pointer-events: none;
}
.tmp-toast.success { background: rgba(56, 198, 123, 0.95); }
.tmp-toast.warn    { background: rgba(255, 159, 67, 0.95); }
.tmp-toast.info    { background: rgba(12, 74, 255, 0.95); }

Why include the toast CSS: after fixing the syntax errors you will want visible feedback for users (error/warn/info messages).

After you remove those triple-quote lines and adjust the comments as shown, reload and re-test the page. If other runtime issues remain (e.g., pointer alignment, winner-index calculation edge-cases, or UX enhancements like better CSV parsing), I can run through a prioritized list of additional improvements.

[2025-17-09 13:29:13 INFO] **[Execute Detail]**

execute SimplePhase:[CodeReviewModification] in ComposedPhase:[CodeReview], cycle 1

[2025-17-09 13:29:13 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | [Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes. Do it in HTML, CSS, and JavaScript.] |
| **need_reflect** | False |
| **assistant_role_name** | Programmer |
| **user_role_name** | Code Reviewer |
| **phase_prompt** | According to the new user's task, our designed product modality, languages and ideas, our developed first-edition source codes are listed below:  Task: "{task}". Modality: "{modality}". Programming Language: "{language}" Ideas: "{ideas}" Codes:  "{codes}" Comments on Codes: "{comments}" In the software, each file must strictly follow a markdown code block format, where the following tokens must be replaced such that "FILENAME" is the lowercase file name including the file extension, "LANGUAGE" in the programming language, "DOCSTRING" is a string literal specified in source code that is used to document a specific segment of code, and "CODE" is the original code. Format: FILENAME LANGUAGE ''' DOCSTRING ''' CODE As the {assistant_role}, to satisfy the new user's demand and make the software creative, executive and robust, you should modify corresponding codes according to the comments. Then, output the full and complete codes with all bugs fixed based on the comments. Return all codes strictly following the required format. |
| **phase_name** | CodeReviewModification |
| **assistant_role_prompt** | {chatdev_prompt} You are Programmer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. You can write/create computer software or applications by providing a specific programming language to the computer. You have extensive computing and coding experience in many varieties of programming languages and platforms, such as Python, Java, C, C++, HTML, CSS, JavaScript, XML, SQL, PHP, etc,. Here is a new customer's task: {task}. To complete the task, you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Code Reviewer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. You can help programmers to assess source codes for software troubleshooting, fix bugs to increase code quality and robustness, and offer proposals to improve the source codes. Here is a new customer's task: {task}. To complete the task, you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 1, 'task': '[Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes. Do it in HTML, CSS, and JavaScript.]', 'modality': 'website', 'ideas': '', 'language': ' JavaScript', 'codes': 'index.html\nhtml\n\'\'\'\n&lt;!--\nDOCSTRING\nThis is the main HTML file for the Random Winner Wheel.\nIt contains the structure: input fields to add names, a canvas for the wheel,\ncontrols (spin, clear, bulk add), theme selector, and placeholders for CSS/JS.\n--&gt;\n\'\'\'\n&lt;!doctype html&gt;\n&lt;html lang="en"&gt;\n&lt;head&gt;\n  &lt;meta charset="utf-8" /&gt;\n  &lt;meta name="viewport" content="width=device-width,initial-scale=1" /&gt;\n  &lt;title&gt;Random Winner Wheel&lt;/title&gt;\n  &lt;link rel="stylesheet" href="styles.css"&gt;\n&lt;/head&gt;\n&lt;body class="theme-light"&gt;\n  &lt;header&gt;\n    &lt;h1&gt;Random Winner Wheel&lt;/h1&gt;\n    &lt;p&gt;Enter participant names, choose a theme, and spin to pick a winner.&lt;/p&gt;\n  &lt;/header&gt;\n  &lt;main&gt;\n    &lt;section class="controls"&gt;\n      &lt;div class="add-single"&gt;\n        &lt;input id="nameInput" type="text" placeholder="Enter a name and press Add" aria-label="Name input" /&gt;\n        &lt;button id="addBtn"&gt;Add&lt;/button&gt;\n        &lt;button id="addRandomBtn" title="Add a few sample random names"&gt;Add Sample&lt;/button&gt;\n      &lt;/div&gt;\n      &lt;div class="bulk-add"&gt;\n        &lt;label for="bulkInput"&gt;Bulk add (comma, newline or semicolon separated):&lt;/label&gt;\n        &lt;textarea id="bulkInput" placeholder="Alice, Bob, Charlie"&gt;&lt;/textarea&gt;\n        &lt;div class="bulk-actions"&gt;\n          &lt;button id="bulkAddBtn"&gt;Bulk Add&lt;/button&gt;\n          &lt;button id="clearBulkBtn"&gt;Clear Bulk&lt;/button&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;\n      &lt;div class="list-actions"&gt;\n        &lt;div class="theme-select"&gt;\n          &lt;label for="themeSelect"&gt;Theme:&lt;/label&gt;\n          &lt;select id="themeSelect"&gt;\n            &lt;option value="light"&gt;Light&lt;/option&gt;\n            &lt;option value="dark"&gt;Dark&lt;/option&gt;\n            &lt;option value="neon"&gt;Neon&lt;/option&gt;\n            &lt;option value="pastel"&gt;Pastel&lt;/option&gt;\n            &lt;option value="retro"&gt;Retro&lt;/option&gt;\n          &lt;/select&gt;\n        &lt;/div&gt;\n        &lt;div class="wheel-controls"&gt;\n          &lt;button id="spinBtn" class="primary"&gt;Spin&lt;/button&gt;\n          &lt;button id="clearNamesBtn"&gt;Clear Names&lt;/button&gt;\n          &lt;button id="exportBtn"&gt;Export CSV&lt;/button&gt;\n          &lt;input id="importFile" type="file" accept=".csv,text/csv" style="display:none"&gt;\n          &lt;button id="importBtn"&gt;Import CSV&lt;/button&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;\n    &lt;/section&gt;\n    &lt;section class="wheel-area"&gt;\n      &lt;div class="wheel-container"&gt;\n        &lt;canvas id="wheelCanvas" width="600" height="600" aria-label="Spinning wheel"&gt;&lt;/canvas&gt;\n        &lt;div class="pointer"&gt;▼&lt;/div&gt;\n      &lt;/div&gt;\n      &lt;aside class="participants"&gt;\n        &lt;h2&gt;Participants (&lt;span id="count"&gt;0&lt;/span&gt;)&lt;/h2&gt;\n        &lt;ul id="nameList" aria-live="polite"&gt;&lt;/ul&gt;\n      &lt;/aside&gt;\n    &lt;/section&gt;\n    &lt;section class="result" id="result" aria-live="polite" hidden&gt;\n      &lt;h2&gt;Winner&lt;/h2&gt;\n      &lt;div id="winnerName" class="winnerName"&gt;&lt;/div&gt;\n      &lt;button id="rerollBtn"&gt;Spin Again&lt;/button&gt;\n    &lt;/section&gt;\n  &lt;/main&gt;\n  &lt;footer&gt;\n    &lt;small&gt;Built with HTML, CSS, and JavaScript. Themes change both UI and wheel colors.&lt;/small&gt;\n  &lt;/footer&gt;\n  &lt;script src="script.js"&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\n\nstyles.css\ncss\n\'\'\'\nDOCSTRING\nStylesheet for the Random Winner Wheel.\nDefines layout, themes, wheel container sizing, and animations.\n\'\'\'\n/* Reset &amp; base */\n* { box-sizing: border-box; margin: 0; padding: 0; }\nhtml,body { height: 100%; font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; background: var(--bg); color: var(--fg); }\n:root {\n  --bg: #f7f8fb;\n  --fg: #222;\n  --muted: #666;\n  --accent: #2b8cff;\n  --card: #ffffff;\n  --primary-btn-bg: var(--accent);\n  --primary-btn-fg: #fff;\n  --shadow: rgba(15,15,15,0.08);\n}\n/* Themes */\nbody.theme-light {\n  --bg: #f7f8fb;\n  --fg: #222;\n  --muted: #5b6170;\n  --accent: #2b8cff;\n  --card: #fff;\n  --wheel-seq: 0;\n}\nbody.theme-dark {\n  --bg: #0f1724;\n  --fg: #e6eef8;\n  --muted: #a9b1c2;\n  --accent: #7c5cff;\n  --card: #0b1220;\n}\nbody.theme-neon {\n  --bg: #0a0a0f;\n  --fg: #e9f9ff;\n  --muted: #a6f3ff;\n  --accent: #39ff14;\n  --card: #09101a;\n}\nbody.theme-pastel {\n  --bg: #fffaf6;\n  --fg: #3c3a3a;\n  --muted: #8d8a8a;\n  --accent: #ff7aa2;\n  --card: #fff;\n}\nbody.theme-retro {\n  --bg: #fff6e7;\n  --fg: #402b2b;\n  --muted: #856e6e;\n  --accent: #ffb86b;\n  --card: #fff0e6;\n}\n/* Layout */\nheader { padding: 18px 24px; text-align: center; background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent); }\nheader h1 { font-size: 1.5rem; margin-bottom: 6px; }\nmain { padding: 18px; max-width: 1100px; margin: 0 auto; }\n.controls { display: grid; gap: 12px; margin-bottom: 18px; }\n.add-single { display:flex; gap:8px; }\n.add-single input[type="text"] { flex:1; padding:10px; border-radius:8px; border:1px solid rgba(0,0,0,0.08); background:var(--card); color:var(--fg); }\n.add-single button { padding:10px 12px; border-radius:8px; border: none; cursor:pointer; background: var(--primary-btn-bg); color: var(--primary-btn-fg); }\n.add-single button#addRandomBtn { background: transparent; border: 1px solid rgba(0,0,0,0.06); color: var(--fg); }\n.bulk-add textarea { width:100%; min-height:64px; margin-top:6px; padding:8px; border-radius:8px; border:1px solid rgba(0,0,0,0.06); background:var(--card); color:var(--fg); }\n.bulk-actions { display:flex; gap:8px; margin-top:8px; }\n.list-actions { display:flex; justify-content:space-between; align-items:center; gap:16px; flex-wrap:wrap; }\n.theme-select select { padding:8px; border-radius:8px; border:1px solid rgba(0,0,0,0.06); }\n.wheel-area { display:flex; gap:18px; align-items:start; flex-wrap:wrap; }\n.wheel-container { position: relative; width: 600px; height: 600px; max-width: 90vw; max-height: 90vw; display:flex; align-items:center; justify-content:center; background: transparent; }\n.pointer { position:absolute; top:6px; font-size:28px; transform: translateY(-50%); text-shadow: 0 2px 8px rgba(0,0,0,0.25); color: var(--accent); pointer-events:none; }\n.participants { width: 320px; max-width: 40vw; background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent); padding:12px; border-radius:10px; box-shadow: 0 6px 18px var(--shadow); }\n.participants h2 { margin-bottom:8px; font-size:1.05rem; }\n#nameList { list-style:none; max-height:420px; overflow:auto; display:block; }\n#nameList li { padding:8px; border-radius:6px; display:flex; justify-content:space-between; align-items:center; gap:8px; margin-bottom:8px; background: var(--card); border:1px solid rgba(0,0,0,0.04); }\n#nameList li button { background: transparent; border: none; color: var(--muted); cursor:pointer; }\n.result { margin-top:18px; padding:12px; border-radius:8px; background: var(--card); text-align:center; box-shadow: 0 6px 18px var(--shadow); }\n.result .winnerName { font-size:1.4rem; font-weight:700; margin:8px 0; color: var(--accent); }\n/* Buttons */\nbutton { cursor:pointer; padding:8px 12px; border-radius:8px; border:1px solid rgba(0,0,0,0.06); background: transparent; color:var(--fg); }\nbutton.primary { background: var(--primary-btn-bg); color: var(--primary-btn-fg); border: none; }\n/* Responsive */\n@media (max-width: 900px) {\n  .wheel-area { flex-direction:column; align-items:center; }\n  .participants { width: 100%; max-width: 100%; }\n}\n/* Wheel canvas scaling helper */\n#wheelCanvas { border-radius:50%; box-shadow: 0 12px 26px rgba(0,0,0,0.12); background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.02), transparent); }\n\n\nscript.js\njs\n\'\'\'\nDOCSTRING\nScript for the Random Winner Wheel.\nContains the Wheel class to draw and spin the canvas-based wheel and UI glue code to manage names and themes.\n\'\'\'\n/* Main JavaScript - Wheel + UI logic */\n(() =&gt; {\n  // Utilities\n  function rand(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }\n  function easeOutCubic(t) { return 1 - Math.pow(1 - t, 3); }\n  // Color palettes for themes (will be used to paint wheel segments)\n  const THEME_PALETTES = {\n    light: [\'#FF8A80\',\'#FFD180\',\'#FFF59D\',\'#C8E6C9\',\'#80DEEA\',\'#A7FFEB\',\'#B39DDB\',\'#90CAF9\'],\n    dark: [\'#ff6b6b\',\'#ffd166\',\'#faff8e\',\'#b9f6ca\',\'#4dd0e1\',\'#80cbc4\',\'#b388ff\',\'#64b5f6\'],\n    neon: [\'#ff2d95\',\'#7cff01\',\'#00ffff\',\'#ffdd00\',\'#ff6a00\',\'#00ff9e\',\'#ff00ff\',\'#47ffa2\'],\n    pastel: [\'#ffdbe9\',\'#fff0b3\',\'#d1ffd6\',\'#cfefff\',\'#e7dfff\',\'#ffd6e7\',\'#fbe7d6\',\'#e6f7ff\'],\n    retro: [\'#ffb86b\',\'#ffd3a8\',\'#f3e2a9\',\'#b8e0d2\',\'#c0b9ff\',\'#ffb6c1\',\'#f6c49f\',\'#c3d69b\']\n  };\n  // Wheel class\n  class Wheel {\n    /*\n    Manage wheel: drawing, recalculating segments, spinning animation, and determining winner.\n    */\n    constructor(canvas, options = {}) {\n      this.canvas = canvas;\n      this.ctx = canvas.getContext(\'2d\');\n      this.names = [];\n      this.rotation = 0; // radians\n      this.isSpinning = false;\n      this.frame = null;\n      this.onResult = options.onResult || function() {};\n      this.theme = options.theme || \'light\';\n      this.padAngle = 0.02; // radians padding between segments\n      this.textColor = \'#111\';\n      this._devicePixelRatioFix();\n      window.addEventListener(\'resize\', () =&gt; { this._devicePixelRatioFix(); this.draw(); });\n    }\n    _devicePixelRatioFix() {\n      const dpr = window.devicePixelRatio || 1;\n      const rect = this.canvas.getBoundingClientRect();\n      this.canvas.width = rect.width * dpr;\n      this.canvas.height = rect.height * dpr;\n      this.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n      this.centerX = rect.width / 2;\n      this.centerY = rect.height / 2;\n      this.radius = Math.min(rect.width, rect.height) / 2 - 18;\n    }\n    setTheme(themeId) { this.theme = themeId; this.draw(); }\n    setNames(names) {\n      this.names = names.slice();\n      this.draw();\n    }\n    addName(name) {\n      this.names.push(name);\n      this.draw();\n    }\n    removeName(index) {\n      if (index &gt;= 0 &amp;&amp; index &lt; this.names.length) {\n        this.names.splice(index,1);\n        this.draw();\n      }\n    }\n    clearNames() {\n      this.names = [];\n      this.draw();\n    }\n    draw() {\n      const ctx = this.ctx;\n      const w = this.canvas.width / (window.devicePixelRatio || 1);\n      const h = this.canvas.height / (window.devicePixelRatio || 1);\n      ctx.clearRect(0,0,w,h);\n      ctx.save();\n      ctx.translate(this.centerX, this.centerY);\n      ctx.rotate(this.rotation);\n      // draw segments\n      const count = Math.max(this.names.length, 1);\n      const palette = THEME_PALETTES[this.theme] || THEME_PALETTES.light;\n      for (let i = 0; i &lt; count; i++) {\n        const start = (i / count) * Math.PI * 2;\n        const end = ((i + 1) / count) * Math.PI * 2;\n        ctx.beginPath();\n        ctx.moveTo(0,0);\n        ctx.arc(0,0,this.radius, start + this.padAngle, end - this.padAngle, false);\n        ctx.closePath();\n        const color = palette[i % palette.length];\n        ctx.fillStyle = color;\n        ctx.fill();\n        ctx.strokeStyle = (i % 2 === 0) ? \'rgba(0,0,0,0.06)\' : \'rgba(0,0,0,0.03)\';\n        ctx.lineWidth = 1;\n        ctx.stroke();\n        // draw text label\n        const mid = (start + end) / 2;\n        ctx.save();\n        ctx.rotate(mid);\n        ctx.translate(this.radius * 0.6, 0);\n        ctx.rotate(Math.PI/2);\n        ctx.fillStyle = getTextColor(color);\n        ctx.font = `${Math.max(12, Math.min(22, this.radius / 8))}px sans-serif`;\n        ctx.textAlign = \'center\';\n        ctx.textBaseline = \'middle\';\n        const label = (this.names.length === 0) ? \'Add names\' : this.names[i % this.names.length];\n        wrapFillText(ctx, label, 0, 0, this.radius * 0.5, 16);\n        ctx.restore();\n      }\n      // draw center circle\n      ctx.beginPath();\n      ctx.arc(0,0, this.radius * 0.16, 0, Math.PI*2);\n      ctx.fillStyle = \'rgba(255,255,255,0.9)\';\n      ctx.fill();\n      ctx.strokeStyle = \'rgba(0,0,0,0.06)\';\n      ctx.stroke();\n      ctx.restore();\n      // draw outer ring (pointer side neutral)\n      ctx.beginPath();\n      ctx.arc(this.centerX, this.centerY, this.radius + 10, 0, Math.PI*2);\n      ctx.strokeStyle = \'rgba(0,0,0,0.03)\';\n      ctx.lineWidth = 2;\n      ctx.stroke();\n    }\n    spin() {\n      if (this.isSpinning || this.names.length === 0) return;\n      this.isSpinning = true;\n      const count = this.names.length;\n      // Determine random winner index to land on:\n      const winnerIndex = rand(0, count - 1);\n      // Calculate final rotation so that winner segment lines up with pointer at top (pointer at canvas top - rotation must align)\n      // Our pointer is at the top (canvas 0 angle). The segment mid-angle for index i (without rotation) is ((i + 0.5)/count)*2pi\n      const segmentMid = ((winnerIndex + 0.5) / count) * Math.PI * 2;\n      // We want segmentMid + rotation_final == -Math.PI/2 (so it points at the top pointer), so rotation_final = -Math.PI/2 - segmentMid + 2pi*N\n      const extraTurns = rand(5, 8); // full spins\n      const rotationFinal = -Math.PI/2 - segmentMid + extraTurns * Math.PI * 2;\n      const startRotation = this.rotation % (Math.PI * 2);\n      const delta = rotationFinal - startRotation;\n      const duration = 4000 + Math.random() * 1500; // ms\n      const startTime = performance.now();\n      const animate = (now) =&gt; {\n        const elapsed = now - startTime;\n        const t = Math.min(elapsed / duration, 1);\n        const eased = easeOutCubic(t);\n        this.rotation = startRotation + delta * eased;\n        this.draw();\n        if (t &lt; 1) {\n          this.frame = requestAnimationFrame(animate);\n        } else {\n          this.isSpinning = false;\n          // Normalize rotation within 0..2pi\n          this.rotation = ((this.rotation % (Math.PI*2)) + Math.PI*2) % (Math.PI*2);\n          this.draw();\n          // Compute final winner index again from rotation\n          const finalAngle = (-this.rotation - Math.PI/2 + Math.PI*2) % (Math.PI*2);\n          const resultingIndex = Math.floor(((finalAngle / (Math.PI*2)) * count + count) % count);\n          const winner = this.names[resultingIndex];\n          this.onResult({ index: resultingIndex, name: winner });\n        }\n      };\n      this.frame = requestAnimationFrame(animate);\n    }\n  }\n  // Helper: pick readable text color for a background\n  function getTextColor(hex) {\n    // remove # and convert\n    const h = hex.replace(\'#\',\'\');\n    const r = parseInt(h.substring(0,2),16);\n    const g = parseInt(h.substring(2,4),16);\n    const b = parseInt(h.substring(4,6),16);\n    // luminance\n    const lum = (0.299*r + 0.587*g + 0.114*b) / 255;\n    return lum &gt; 0.65 ? \'#111\' : \'#fff\';\n  }\n  // Helper: wrap text within a given width (draws multi-line if necessary)\n  function wrapFillText(ctx, text, x, y, maxWidth, lineHeight) {\n    const words = (text || \'\').split(/\\s+/);\n    if (words.length === 0) return;\n    let line = \'\';\n    const lines = [];\n    for (let n = 0; n &lt; words.length; n++) {\n      const testLine = line ? line + \' \' + words[n] : words[n];\n      const metrics = ctx.measureText(testLine);\n      if (metrics.width &gt; maxWidth &amp;&amp; line) {\n        lines.push(line);\n        line = words[n];\n      } else {\n        line = testLine;\n      }\n    }\n    if (line) lines.push(line);\n    // If still too many lines, shrink font or truncate\n    for (let i=0;i&lt;lines.length;i++){\n      ctx.fillText(lines[i], x, y + (i - (lines.length-1)/2) * lineHeight);\n    }\n  }\n  // UI glue\n  document.addEventListener(\'DOMContentLoaded\', () =&gt; {\n    const canvas = document.getElementById(\'wheelCanvas\');\n    const wheel = new Wheel(canvas, { theme: \'light\', onResult: onWinner });\n    const nameInput = document.getElementById(\'nameInput\');\n    const addBtn = document.getElementById(\'addBtn\');\n    const addRandomBtn = document.getElementById(\'addRandomBtn\');\n    const bulkInput = document.getElementById(\'bulkInput\');\n    const bulkAddBtn = document.getElementById(\'bulkAddBtn\');\n    const clearBulkBtn = document.getElementById(\'clearBulkBtn\');\n    const nameList = document.getElementById(\'nameList\');\n    const countSpan = document.getElementById(\'count\');\n    const spinBtn = document.getElementById(\'spinBtn\');\n    const rerollBtn = document.getElementById(\'rerollBtn\');\n    const clearNamesBtn = document.getElementById(\'clearNamesBtn\');\n    const themeSelect = document.getElementById(\'themeSelect\');\n    const resultSection = document.getElementById(\'result\');\n    const winnerNameDiv = document.getElementById(\'winnerName\');\n    const exportBtn = document.getElementById(\'exportBtn\');\n    const importBtn = document.getElementById(\'importBtn\');\n    const importFile = document.getElementById(\'importFile\');\n    // Initial draw\n    wheel.draw();\n    function updateUI() {\n      const names = wheel.names;\n      countSpan.textContent = names.length;\n      renderNameList();\n    }\n    function renderNameList() {\n      nameList.innerHTML = \'\';\n      wheel.names.forEach((n, i) =&gt; {\n        const li = document.createElement(\'li\');\n        const span = document.createElement(\'span\');\n        span.textContent = n;\n        li.appendChild(span);\n        const btn = document.createElement(\'button\');\n        btn.title = \'Remove\';\n        btn.innerHTML = \'✕\';\n        btn.addEventListener(\'click\', () =&gt; {\n          wheel.removeName(i);\n          updateUI();\n        });\n        li.appendChild(btn);\n        nameList.appendChild(li);\n      });\n    }\n    function addNameFromInput() {\n      const v = nameInput.value.trim();\n      if (!v) { showMessage(\'Please enter a name.\', \'warn\'); return; }\n      wheel.addName(v);\n      nameInput.value = \'\';\n      updateUI();\n    }\n    addBtn.addEventListener(\'click\', addNameFromInput);\n    nameInput.addEventListener(\'keydown\', (e) =&gt; { if (e.key === \'Enter\') addNameFromInput(); });\n    addRandomBtn.addEventListener(\'click\', () =&gt; {\n      const samples = [\'Alex\',\'Jordan\',\'Taylor\',\'Sam\',\'Jamie\',\'Casey\',\'Morgan\',\'Riley\',\'Avery\',\'Dana\'];\n      const count = rand(3,6);\n      for (let i=0;i&lt;count;i++) wheel.addName(samples[rand(0,samples.length-1)] + (rand(1,100)));\n      updateUI();\n    });\n    bulkAddBtn.addEventListener(\'click\', () =&gt; {\n      const text = bulkInput.value.trim();\n      if (!text) { showMessage(\'Bulk input is empty.\', \'warn\'); return; }\n      const parsed = text.split(/[\\n,;]+/).map(s =&gt; s.trim()).filter(s =&gt; s);\n      parsed.forEach(p =&gt; wheel.addName(p));\n      bulkInput.value = \'\';\n      updateUI();\n      showMessage(`Added ${parsed.length} names.`, \'info\');\n    });\n    clearBulkBtn.addEventListener(\'click\', () =&gt; { bulkInput.value = \'\'; });\n    spinBtn.addEventListener(\'click\', () =&gt; {\n      if (wheel.names.length === 0) { showMessage(\'Add at least one name to spin.\', \'warn\'); return; }\n      resultSection.hidden = true;\n      winnerNameDiv.textContent = \'\';\n      wheel.spin();\n      spinBtn.disabled = true;\n      const checkFinish = setInterval(() =&gt; {\n        if (!wheel.isSpinning) {\n          clearInterval(checkFinish);\n          spinBtn.disabled = false;\n        }\n      }, 200);\n    });\n    rerollBtn.addEventListener(\'click\', () =&gt; {\n      resultSection.hidden = true;\n      wheel.spin();\n    });\n    clearNamesBtn.addEventListener(\'click\', () =&gt; {\n      if (confirm(\'Clear all names?\')) {\n        wheel.clearNames();\n        updateUI();\n      }\n    });\n    themeSelect.addEventListener(\'change\', (e) =&gt; {\n      const t = e.target.value;\n      document.body.className = \'theme-\' + t;\n      wheel.setTheme(t);\n    });\n    function onWinner(result) {\n      winnerNameDiv.textContent = result.name || \'—\';\n      resultSection.hidden = false;\n      // Flash the winner item in the list (if still present)\n      const items = Array.from(nameList.children);\n      items.forEach((li, idx) =&gt; { li.classList.toggle(\'winner\', idx === result.index); });\n      showMessage(`Winner: ${result.name}`, \'success\', 4000);\n    }\n    // Simple message area\n    function showMessage(text, type = \'info\', duration = 2200) {\n      // create small toast\n      const t = document.createElement(\'div\');\n      t.className = \'tmp-toast \' + type;\n      t.textContent = text;\n      document.body.appendChild(t);\n      setTimeout(()=&gt; { t.style.opacity = \'0\'; t.style.transform = \'translateY(-10px)\'; }, duration - 300);\n      setTimeout(()=&gt; { try { t.remove(); } catch(e){} }, duration);\n    }\n    // Export/import CSV\n    exportBtn.addEventListener(\'click\', () =&gt; {\n      if (wheel.names.length === 0) { showMessage(\'No names to export.\', \'warn\'); return; }\n      const csv = wheel.names.map(n =&gt; `"${(n||\'\').replace(/"/g,\'""\')}"`).join(\'\\n\');\n      const blob = new Blob([csv], { type: \'text/csv\' });\n      const url = URL.createObjectURL(blob);\n      const a = document.createElement(\'a\');\n      a.href = url;\n      a.download = \'participants.csv\';\n      document.body.appendChild(a);\n      a.click();\n      a.remove();\n      URL.revokeObjectURL(url);\n      showMessage(\'Exported CSV\', \'info\');\n    });\n    importBtn.addEventListener(\'click\', () =&gt; { importFile.click(); });\n    importFile.addEventListener(\'change\', (e) =&gt; {\n      const file = e.target.files[0];\n      if (!file) return;\n      const reader = new FileReader();\n      reader.onload = (ev) =&gt; {\n        const txt = ev.target.result;\n        const lines = txt.split(/\\r?\\n/).map(s =&gt; s.trim()).filter(s =&gt; s);\n        // basic CSV unquote\n        const parsed = lines.map(l =&gt; {\n          if (l.startsWith(\'"\') &amp;&amp; l.endsWith(\'"\')) {\n            return l.slice(1,-1).replace(/""/g,\'"\');\n          }\n          return l;\n        });\n        parsed.forEach(p =&gt; wheel.addName(p));\n        updateUI();\n        showMessage(`Imported ${parsed.length} names`, \'info\');\n      };\n      reader.readAsText(file);\n      importFile.value = \'\';\n    });\n    // Initial sample\n    // wheel.addName(\'Alice\'); wheel.addName(\'Bob\'); wheel.addName(\'Charlie\');\n    updateUI();\n    // (Optional) keyboard shortcuts\n    window.addEventListener(\'keydown\', (e) =&gt; {\n      if ((e.ctrlKey || e.metaKey) &amp;&amp; e.key.toLowerCase() === \'k\') {\n        e.preventDefault();\n        nameInput.focus();\n      }\n      if (e.key === \' \') {\n        // space triggers spin if not focusing an input\n        if (document.activeElement.tagName !== \'INPUT\' &amp;&amp; document.activeElement.tagName !== \'TEXTAREA\') {\n          e.preventDefault();\n          spinBtn.click();\n        }\n      }\n    });\n  });\n})();\n\n\n', 'images': '', 'comments': ' Remove the Python-style triple-quote docstring wrappers present at the top of your HTML, CSS and JS files — they break parsing/loading of the site.\n\nWhy this is highest priority:\n- Each file (index.html, styles.css, script.js) starts with literal lines containing three single quotes (\'\'\') surrounding a "DOCSTRING" block. Those triple-quote lines are not valid tokens in HTML/CSS/JS and will cause syntax errors or make the browser ignore/stop parsing the files. The app will fail to run (no script execution, CSS not applied, HTML may contain stray text).\n- Fixing these simple invalid tokens is required before any other runtime or UX fixes can be verified.\n\nHow to fix (exact steps):\n\n1) index.html\n- Remove the lines that look like \'\'\' immediately before and after the HTML comment block.\n- Keep the HTML comment, or convert it into a normal HTML comment only. The file should begin with &lt;!doctype html&gt;.\n\nExample change:\nCurrent top of file:\n\'\'\'\n\n\'\'\'\n&lt;!doctype html&gt;\n\nReplace with:\n\n&lt;!doctype html&gt;\n\n2) styles.css\n- Remove the leading and trailing \'\'\' lines.\n- Convert the "DOCSTRING" block to a proper CSS comment / ... / or remove it.\n\nExample change:\nCurrent top:\n\'\'\'\nDOCSTRING\nStylesheet for the Random Winner Wheel.\nDefines layout, themes, wheel container sizing, and animations.\n\'\'\'\n/ Reset &amp; base /\n...\n\nReplace with:\n/ DOCSTRING\n   Stylesheet for the Random Winner Wheel.\n   Defines layout, themes, wheel container sizing, and animations.\n/\n / Reset &amp; base /\n...\n\n3) script.js\n- Remove the leading/trailing \'\'\' lines.\n- Convert the DOCSTRING block to a JS comment (/ ... /) or use // comments.\n\nExample change:\nCurrent top:\n\'\'\'\nDOCSTRING\nScript for the Random Winner Wheel.\nContains the Wheel class to draw and spin the canvas-based wheel and UI glue code to manage names and themes.\n\'\'\'\n/ Main JavaScript - Wheel + UI logic /\n(() =&gt; {\n\nReplace with:\n/ DOCSTRING\n   Script for the Random Winner Wheel.\n   Contains the Wheel class to draw and spin the canvas-based wheel and UI glue code to manage names and themes.\n/\n/ Main JavaScript - Wheel + UI logic /\n(() =&gt; {\n\n4) (Recommended but lower priority) Add CSS rules for the toast messages inserted by showMessage\n- Your showMessage creates elements with class "tmp-toast" and type classes like "info", "warn", "success" but no CSS exists for these. Add minimal styling so messages are visible, e.g.:\n\n/ add near end of styles.css /\n.tmp-toast {\n  position: fixed;\n  left: 50%;\n  transform: translateX(-50%);\n  top: 18px;\n  background: rgba(0,0,0,0.85);\n  color: #fff;\n  padding: 8px 12px;\n  border-radius: 6px;\n  z-index: 9999;\n  transition: opacity 0.25s, transform 0.25s;\n  opacity: 1;\n  pointer-events: none;\n}\n.tmp-toast.success { background: rgba(56, 198, 123, 0.95); }\n.tmp-toast.warn    { background: rgba(255, 159, 67, 0.95); }\n.tmp-toast.info    { background: rgba(12, 74, 255, 0.95); }\n\nWhy include the toast CSS: after fixing the syntax errors you will want visible feedback for users (error/warn/info messages).\n\nAfter you remove those triple-quote lines and adjust the comments as shown, reload and re-test the page. If other runtime issues remain (e.g., pointer alignment, winner-index calculation edge-cases, or UX enhancements like better CSV parsing), I can run through a prioritized list of additional improvements.'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_3_5_TURBO |

[2025-17-09 13:29:13 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Programmer |
| **user_role_name** | Code Reviewer |
| **assistant_role_prompt** | {chatdev_prompt} You are Programmer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. You can write/create computer software or applications by providing a specific programming language to the computer. You have extensive computing and coding experience in many varieties of programming languages and platforms, such as Python, Java, C, C++, HTML, CSS, JavaScript, XML, SQL, PHP, etc,. Here is a new customer's task: {task}. To complete the task, you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Code Reviewer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. You can help programmers to assess source codes for software troubleshooting, fix bugs to increase code quality and robustness, and offer proposals to improve the source codes. Here is a new customer's task: {task}. To complete the task, you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **task_prompt** | [Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes. Do it in HTML, CSS, and JavaScript.] |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_3_5_TURBO |
| **background_prompt** | ChatDev is a software company powered by multiple intelligent agents, such as chief executive officer, chief human resources officer, chief product officer, chief technology officer, etc, with a multi-agent organizational structure and the mission of 'changing the digital world through programming'. |

[2025-17-09 13:29:13 INFO] Code Reviewer: **[Start Chat]**

[ChatDev is a software company powered by multiple intelligent agents, such as chief executive officer, chief human resources officer, chief product officer, chief technology officer, etc, with a multi-agent organizational structure and the mission of 'changing the digital world through programming'.
You are Programmer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer.
You can write/create computer software or applications by providing a specific programming language to the computer. You have extensive computing and coding experience in many varieties of programming languages and platforms, such as Python, Java, C, C++, HTML, CSS, JavaScript, XML, SQL, PHP, etc,.
Here is a new customer's task: [Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes. Do it in HTML, CSS, and JavaScript.].
To complete the task, you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]

According to the new user's task, our designed product modality, languages and ideas, our developed first-edition source codes are listed below: 
Task: "[Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes. Do it in HTML, CSS, and JavaScript.]".
Modality: "website".
Programming Language: " JavaScript"
Ideas: ""
Codes: 
"index.html
```html
'''
<!--
DOCSTRING
This is the main HTML file for the Random Winner Wheel.
It contains the structure: input fields to add names, a canvas for the wheel,
controls (spin, clear, bulk add), theme selector, and placeholders for CSS/JS.
-->
'''
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Random Winner Wheel</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body class="theme-light">
  <header>
    <h1>Random Winner Wheel</h1>
    <p>Enter participant names, choose a theme, and spin to pick a winner.</p>
  </header>
  <main>
    <section class="controls">
      <div class="add-single">
        <input id="nameInput" type="text" placeholder="Enter a name and press Add" aria-label="Name input" />
        <button id="addBtn">Add</button>
        <button id="addRandomBtn" title="Add a few sample random names">Add Sample</button>
      </div>
      <div class="bulk-add">
        <label for="bulkInput">Bulk add (comma, newline or semicolon separated):</label>
        <textarea id="bulkInput" placeholder="Alice, Bob, Charlie"></textarea>
        <div class="bulk-actions">
          <button id="bulkAddBtn">Bulk Add</button>
          <button id="clearBulkBtn">Clear Bulk</button>
        </div>
      </div>
      <div class="list-actions">
        <div class="theme-select">
          <label for="themeSelect">Theme:</label>
          <select id="themeSelect">
            <option value="light">Light</option>
            <option value="dark">Dark</option>
            <option value="neon">Neon</option>
            <option value="pastel">Pastel</option>
            <option value="retro">Retro</option>
          </select>
        </div>
        <div class="wheel-controls">
          <button id="spinBtn" class="primary">Spin</button>
          <button id="clearNamesBtn">Clear Names</button>
          <button id="exportBtn">Export CSV</button>
          <input id="importFile" type="file" accept=".csv,text/csv" style="display:none">
          <button id="importBtn">Import CSV</button>
        </div>
      </div>
    </section>
    <section class="wheel-area">
      <div class="wheel-container">
        <canvas id="wheelCanvas" width="600" height="600" aria-label="Spinning wheel"></canvas>
        <div class="pointer">▼</div>
      </div>
      <aside class="participants">
        <h2>Participants (<span id="count">0</span>)</h2>
        <ul id="nameList" aria-live="polite"></ul>
      </aside>
    </section>
    <section class="result" id="result" aria-live="polite" hidden>
      <h2>Winner</h2>
      <div id="winnerName" class="winnerName"></div>
      <button id="rerollBtn">Spin Again</button>
    </section>
  </main>
  <footer>
    <small>Built with HTML, CSS, and JavaScript. Themes change both UI and wheel colors.</small>
  </footer>
  <script src="script.js"></script>
</body>
</html>
```

styles.css
```css
'''
DOCSTRING
Stylesheet for the Random Winner Wheel.
Defines layout, themes, wheel container sizing, and animations.
'''
/* Reset & base */
* { box-sizing: border-box; margin: 0; padding: 0; }
html,body { height: 100%; font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; background: var(--bg); color: var(--fg); }
:root {
  --bg: #f7f8fb;
  --fg: #222;
  --muted: #666;
  --accent: #2b8cff;
  --card: #ffffff;
  --primary-btn-bg: var(--accent);
  --primary-btn-fg: #fff;
  --shadow: rgba(15,15,15,0.08);
}
/* Themes */
body.theme-light {
  --bg: #f7f8fb;
  --fg: #222;
  --muted: #5b6170;
  --accent: #2b8cff;
  --card: #fff;
  --wheel-seq: 0;
}
body.theme-dark {
  --bg: #0f1724;
  --fg: #e6eef8;
  --muted: #a9b1c2;
  --accent: #7c5cff;
  --card: #0b1220;
}
body.theme-neon {
  --bg: #0a0a0f;
  --fg: #e9f9ff;
  --muted: #a6f3ff;
  --accent: #39ff14;
  --card: #09101a;
}
body.theme-pastel {
  --bg: #fffaf6;
  --fg: #3c3a3a;
  --muted: #8d8a8a;
  --accent: #ff7aa2;
  --card: #fff;
}
body.theme-retro {
  --bg: #fff6e7;
  --fg: #402b2b;
  --muted: #856e6e;
  --accent: #ffb86b;
  --card: #fff0e6;
}
/* Layout */
header { padding: 18px 24px; text-align: center; background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent); }
header h1 { font-size: 1.5rem; margin-bottom: 6px; }
main { padding: 18px; max-width: 1100px; margin: 0 auto; }
.controls { display: grid; gap: 12px; margin-bottom: 18px; }
.add-single { display:flex; gap:8px; }
.add-single input[type="text"] { flex:1; padding:10px; border-radius:8px; border:1px solid rgba(0,0,0,0.08); background:var(--card); color:var(--fg); }
.add-single button { padding:10px 12px; border-radius:8px; border: none; cursor:pointer; background: var(--primary-btn-bg); color: var(--primary-btn-fg); }
.add-single button#addRandomBtn { background: transparent; border: 1px solid rgba(0,0,0,0.06); color: var(--fg); }
.bulk-add textarea { width:100%; min-height:64px; margin-top:6px; padding:8px; border-radius:8px; border:1px solid rgba(0,0,0,0.06); background:var(--card); color:var(--fg); }
.bulk-actions { display:flex; gap:8px; margin-top:8px; }
.list-actions { display:flex; justify-content:space-between; align-items:center; gap:16px; flex-wrap:wrap; }
.theme-select select { padding:8px; border-radius:8px; border:1px solid rgba(0,0,0,0.06); }
.wheel-area { display:flex; gap:18px; align-items:start; flex-wrap:wrap; }
.wheel-container { position: relative; width: 600px; height: 600px; max-width: 90vw; max-height: 90vw; display:flex; align-items:center; justify-content:center; background: transparent; }
.pointer { position:absolute; top:6px; font-size:28px; transform: translateY(-50%); text-shadow: 0 2px 8px rgba(0,0,0,0.25); color: var(--accent); pointer-events:none; }
.participants { width: 320px; max-width: 40vw; background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent); padding:12px; border-radius:10px; box-shadow: 0 6px 18px var(--shadow); }
.participants h2 { margin-bottom:8px; font-size:1.05rem; }
#nameList { list-style:none; max-height:420px; overflow:auto; display:block; }
#nameList li { padding:8px; border-radius:6px; display:flex; justify-content:space-between; align-items:center; gap:8px; margin-bottom:8px; background: var(--card); border:1px solid rgba(0,0,0,0.04); }
#nameList li button { background: transparent; border: none; color: var(--muted); cursor:pointer; }
.result { margin-top:18px; padding:12px; border-radius:8px; background: var(--card); text-align:center; box-shadow: 0 6px 18px var(--shadow); }
.result .winnerName { font-size:1.4rem; font-weight:700; margin:8px 0; color: var(--accent); }
/* Buttons */
button { cursor:pointer; padding:8px 12px; border-radius:8px; border:1px solid rgba(0,0,0,0.06); background: transparent; color:var(--fg); }
button.primary { background: var(--primary-btn-bg); color: var(--primary-btn-fg); border: none; }
/* Responsive */
@media (max-width: 900px) {
  .wheel-area { flex-direction:column; align-items:center; }
  .participants { width: 100%; max-width: 100%; }
}
/* Wheel canvas scaling helper */
#wheelCanvas { border-radius:50%; box-shadow: 0 12px 26px rgba(0,0,0,0.12); background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.02), transparent); }
```

script.js
```js
'''
DOCSTRING
Script for the Random Winner Wheel.
Contains the Wheel class to draw and spin the canvas-based wheel and UI glue code to manage names and themes.
'''
/* Main JavaScript - Wheel + UI logic */
(() => {
  // Utilities
  function rand(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }
  function easeOutCubic(t) { return 1 - Math.pow(1 - t, 3); }
  // Color palettes for themes (will be used to paint wheel segments)
  const THEME_PALETTES = {
    light: ['#FF8A80','#FFD180','#FFF59D','#C8E6C9','#80DEEA','#A7FFEB','#B39DDB','#90CAF9'],
    dark: ['#ff6b6b','#ffd166','#faff8e','#b9f6ca','#4dd0e1','#80cbc4','#b388ff','#64b5f6'],
    neon: ['#ff2d95','#7cff01','#00ffff','#ffdd00','#ff6a00','#00ff9e','#ff00ff','#47ffa2'],
    pastel: ['#ffdbe9','#fff0b3','#d1ffd6','#cfefff','#e7dfff','#ffd6e7','#fbe7d6','#e6f7ff'],
    retro: ['#ffb86b','#ffd3a8','#f3e2a9','#b8e0d2','#c0b9ff','#ffb6c1','#f6c49f','#c3d69b']
  };
  // Wheel class
  class Wheel {
    /*
    Manage wheel: drawing, recalculating segments, spinning animation, and determining winner.
    */
    constructor(canvas, options = {}) {
      this.canvas = canvas;
      this.ctx = canvas.getContext('2d');
      this.names = [];
      this.rotation = 0; // radians
      this.isSpinning = false;
      this.frame = null;
      this.onResult = options.onResult || function() {};
      this.theme = options.theme || 'light';
      this.padAngle = 0.02; // radians padding between segments
      this.textColor = '#111';
      this._devicePixelRatioFix();
      window.addEventListener('resize', () => { this._devicePixelRatioFix(); this.draw(); });
    }
    _devicePixelRatioFix() {
      const dpr = window.devicePixelRatio || 1;
      const rect = this.canvas.getBoundingClientRect();
      this.canvas.width = rect.width * dpr;
      this.canvas.height = rect.height * dpr;
      this.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      this.centerX = rect.width / 2;
      this.centerY = rect.height / 2;
      this.radius = Math.min(rect.width, rect.height) / 2 - 18;
    }
    setTheme(themeId) { this.theme = themeId; this.draw(); }
    setNames(names) {
      this.names = names.slice();
      this.draw();
    }
    addName(name) {
      this.names.push(name);
      this.draw();
    }
    removeName(index) {
      if (index >= 0 && index < this.names.length) {
        this.names.splice(index,1);
        this.draw();
      }
    }
    clearNames() {
      this.names = [];
      this.draw();
    }
    draw() {
      const ctx = this.ctx;
      const w = this.canvas.width / (window.devicePixelRatio || 1);
      const h = this.canvas.height / (window.devicePixelRatio || 1);
      ctx.clearRect(0,0,w,h);
      ctx.save();
      ctx.translate(this.centerX, this.centerY);
      ctx.rotate(this.rotation);
      // draw segments
      const count = Math.max(this.names.length, 1);
      const palette = THEME_PALETTES[this.theme] || THEME_PALETTES.light;
      for (let i = 0; i < count; i++) {
        const start = (i / count) * Math.PI * 2;
        const end = ((i + 1) / count) * Math.PI * 2;
        ctx.beginPath();
        ctx.moveTo(0,0);
        ctx.arc(0,0,this.radius, start + this.padAngle, end - this.padAngle, false);
        ctx.closePath();
        const color = palette[i % palette.length];
        ctx.fillStyle = color;
        ctx.fill();
        ctx.strokeStyle = (i % 2 === 0) ? 'rgba(0,0,0,0.06)' : 'rgba(0,0,0,0.03)';
        ctx.lineWidth = 1;
        ctx.stroke();
        // draw text label
        const mid = (start + end) / 2;
        ctx.save();
        ctx.rotate(mid);
        ctx.translate(this.radius * 0.6, 0);
        ctx.rotate(Math.PI/2);
        ctx.fillStyle = getTextColor(color);
        ctx.font = `${Math.max(12, Math.min(22, this.radius / 8))}px sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        const label = (this.names.length === 0) ? 'Add names' : this.names[i % this.names.length];
        wrapFillText(ctx, label, 0, 0, this.radius * 0.5, 16);
        ctx.restore();
      }
      // draw center circle
      ctx.beginPath();
      ctx.arc(0,0, this.radius * 0.16, 0, Math.PI*2);
      ctx.fillStyle = 'rgba(255,255,255,0.9)';
      ctx.fill();
      ctx.strokeStyle = 'rgba(0,0,0,0.06)';
      ctx.stroke();
      ctx.restore();
      // draw outer ring (pointer side neutral)
      ctx.beginPath();
      ctx.arc(this.centerX, this.centerY, this.radius + 10, 0, Math.PI*2);
      ctx.strokeStyle = 'rgba(0,0,0,0.03)';
      ctx.lineWidth = 2;
      ctx.stroke();
    }
    spin() {
      if (this.isSpinning || this.names.length === 0) return;
      this.isSpinning = true;
      const count = this.names.length;
      // Determine random winner index to land on:
      const winnerIndex = rand(0, count - 1);
      // Calculate final rotation so that winner segment lines up with pointer at top (pointer at canvas top - rotation must align)
      // Our pointer is at the top (canvas 0 angle). The segment mid-angle for index i (without rotation) is ((i + 0.5)/count)*2pi
      const segmentMid = ((winnerIndex + 0.5) / count) * Math.PI * 2;
      // We want segmentMid + rotation_final == -Math.PI/2 (so it points at the top pointer), so rotation_final = -Math.PI/2 - segmentMid + 2pi*N
      const extraTurns = rand(5, 8); // full spins
      const rotationFinal = -Math.PI/2 - segmentMid + extraTurns * Math.PI * 2;
      const startRotation = this.rotation % (Math.PI * 2);
      const delta = rotationFinal - startRotation;
      const duration = 4000 + Math.random() * 1500; // ms
      const startTime = performance.now();
      const animate = (now) => {
        const elapsed = now - startTime;
        const t = Math.min(elapsed / duration, 1);
        const eased = easeOutCubic(t);
        this.rotation = startRotation + delta * eased;
        this.draw();
        if (t < 1) {
          this.frame = requestAnimationFrame(animate);
        } else {
          this.isSpinning = false;
          // Normalize rotation within 0..2pi
          this.rotation = ((this.rotation % (Math.PI*2)) + Math.PI*2) % (Math.PI*2);
          this.draw();
          // Compute final winner index again from rotation
          const finalAngle = (-this.rotation - Math.PI/2 + Math.PI*2) % (Math.PI*2);
          const resultingIndex = Math.floor(((finalAngle / (Math.PI*2)) * count + count) % count);
          const winner = this.names[resultingIndex];
          this.onResult({ index: resultingIndex, name: winner });
        }
      };
      this.frame = requestAnimationFrame(animate);
    }
  }
  // Helper: pick readable text color for a background
  function getTextColor(hex) {
    // remove # and convert
    const h = hex.replace('#','');
    const r = parseInt(h.substring(0,2),16);
    const g = parseInt(h.substring(2,4),16);
    const b = parseInt(h.substring(4,6),16);
    // luminance
    const lum = (0.299*r + 0.587*g + 0.114*b) / 255;
    return lum > 0.65 ? '#111' : '#fff';
  }
  // Helper: wrap text within a given width (draws multi-line if necessary)
  function wrapFillText(ctx, text, x, y, maxWidth, lineHeight) {
    const words = (text || '').split(/\s+/);
    if (words.length === 0) return;
    let line = '';
    const lines = [];
    for (let n = 0; n < words.length; n++) {
      const testLine = line ? line + ' ' + words[n] : words[n];
      const metrics = ctx.measureText(testLine);
      if (metrics.width > maxWidth && line) {
        lines.push(line);
        line = words[n];
      } else {
        line = testLine;
      }
    }
    if (line) lines.push(line);
    // If still too many lines, shrink font or truncate
    for (let i=0;i<lines.length;i++){
      ctx.fillText(lines[i], x, y + (i - (lines.length-1)/2) * lineHeight);
    }
  }
  // UI glue
  document.addEventListener('DOMContentLoaded', () => {
    const canvas = document.getElementById('wheelCanvas');
    const wheel = new Wheel(canvas, { theme: 'light', onResult: onWinner });
    const nameInput = document.getElementById('nameInput');
    const addBtn = document.getElementById('addBtn');
    const addRandomBtn = document.getElementById('addRandomBtn');
    const bulkInput = document.getElementById('bulkInput');
    const bulkAddBtn = document.getElementById('bulkAddBtn');
    const clearBulkBtn = document.getElementById('clearBulkBtn');
    const nameList = document.getElementById('nameList');
    const countSpan = document.getElementById('count');
    const spinBtn = document.getElementById('spinBtn');
    const rerollBtn = document.getElementById('rerollBtn');
    const clearNamesBtn = document.getElementById('clearNamesBtn');
    const themeSelect = document.getElementById('themeSelect');
    const resultSection = document.getElementById('result');
    const winnerNameDiv = document.getElementById('winnerName');
    const exportBtn = document.getElementById('exportBtn');
    const importBtn = document.getElementById('importBtn');
    const importFile = document.getElementById('importFile');
    // Initial draw
    wheel.draw();
    function updateUI() {
      const names = wheel.names;
      countSpan.textContent = names.length;
      renderNameList();
    }
    function renderNameList() {
      nameList.innerHTML = '';
      wheel.names.forEach((n, i) => {
        const li = document.createElement('li');
        const span = document.createElement('span');
        span.textContent = n;
        li.appendChild(span);
        const btn = document.createElement('button');
        btn.title = 'Remove';
        btn.innerHTML = '✕';
        btn.addEventListener('click', () => {
          wheel.removeName(i);
          updateUI();
        });
        li.appendChild(btn);
        nameList.appendChild(li);
      });
    }
    function addNameFromInput() {
      const v = nameInput.value.trim();
      if (!v) { showMessage('Please enter a name.', 'warn'); return; }
      wheel.addName(v);
      nameInput.value = '';
      updateUI();
    }
    addBtn.addEventListener('click', addNameFromInput);
    nameInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') addNameFromInput(); });
    addRandomBtn.addEventListener('click', () => {
      const samples = ['Alex','Jordan','Taylor','Sam','Jamie','Casey','Morgan','Riley','Avery','Dana'];
      const count = rand(3,6);
      for (let i=0;i<count;i++) wheel.addName(samples[rand(0,samples.length-1)] + (rand(1,100)));
      updateUI();
    });
    bulkAddBtn.addEventListener('click', () => {
      const text = bulkInput.value.trim();
      if (!text) { showMessage('Bulk input is empty.', 'warn'); return; }
      const parsed = text.split(/[\n,;]+/).map(s => s.trim()).filter(s => s);
      parsed.forEach(p => wheel.addName(p));
      bulkInput.value = '';
      updateUI();
      showMessage(`Added ${parsed.length} names.`, 'info');
    });
    clearBulkBtn.addEventListener('click', () => { bulkInput.value = ''; });
    spinBtn.addEventListener('click', () => {
      if (wheel.names.length === 0) { showMessage('Add at least one name to spin.', 'warn'); return; }
      resultSection.hidden = true;
      winnerNameDiv.textContent = '';
      wheel.spin();
      spinBtn.disabled = true;
      const checkFinish = setInterval(() => {
        if (!wheel.isSpinning) {
          clearInterval(checkFinish);
          spinBtn.disabled = false;
        }
      }, 200);
    });
    rerollBtn.addEventListener('click', () => {
      resultSection.hidden = true;
      wheel.spin();
    });
    clearNamesBtn.addEventListener('click', () => {
      if (confirm('Clear all names?')) {
        wheel.clearNames();
        updateUI();
      }
    });
    themeSelect.addEventListener('change', (e) => {
      const t = e.target.value;
      document.body.className = 'theme-' + t;
      wheel.setTheme(t);
    });
    function onWinner(result) {
      winnerNameDiv.textContent = result.name || '—';
      resultSection.hidden = false;
      // Flash the winner item in the list (if still present)
      const items = Array.from(nameList.children);
      items.forEach((li, idx) => { li.classList.toggle('winner', idx === result.index); });
      showMessage(`Winner: ${result.name}`, 'success', 4000);
    }
    // Simple message area
    function showMessage(text, type = 'info', duration = 2200) {
      // create small toast
      const t = document.createElement('div');
      t.className = 'tmp-toast ' + type;
      t.textContent = text;
      document.body.appendChild(t);
      setTimeout(()=> { t.style.opacity = '0'; t.style.transform = 'translateY(-10px)'; }, duration - 300);
      setTimeout(()=> { try { t.remove(); } catch(e){} }, duration);
    }
    // Export/import CSV
    exportBtn.addEventListener('click', () => {
      if (wheel.names.length === 0) { showMessage('No names to export.', 'warn'); return; }
      const csv = wheel.names.map(n => `"${(n||'').replace(/"/g,'""')}"`).join('\n');
      const blob = new Blob([csv], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'participants.csv';
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
      showMessage('Exported CSV', 'info');
    });
    importBtn.addEventListener('click', () => { importFile.click(); });
    importFile.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (ev) => {
        const txt = ev.target.result;
        const lines = txt.split(/\r?\n/).map(s => s.trim()).filter(s => s);
        // basic CSV unquote
        const parsed = lines.map(l => {
          if (l.startsWith('"') && l.endsWith('"')) {
            return l.slice(1,-1).replace(/""/g,'"');
          }
          return l;
        });
        parsed.forEach(p => wheel.addName(p));
        updateUI();
        showMessage(`Imported ${parsed.length} names`, 'info');
      };
      reader.readAsText(file);
      importFile.value = '';
    });
    // Initial sample
    // wheel.addName('Alice'); wheel.addName('Bob'); wheel.addName('Charlie');
    updateUI();
    // (Optional) keyboard shortcuts
    window.addEventListener('keydown', (e) => {
      if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'k') {
        e.preventDefault();
        nameInput.focus();
      }
      if (e.key === ' ') {
        // space triggers spin if not focusing an input
        if (document.activeElement.tagName !== 'INPUT' && document.activeElement.tagName !== 'TEXTAREA') {
          e.preventDefault();
          spinBtn.click();
        }
      }
    });
  });
})();
```

"
Comments on Codes:
"<CRITICAL> Remove the Python-style triple-quote docstring wrappers present at the top of your HTML, CSS and JS files — they break parsing/loading of the site.

Why this is highest priority:
- Each file (index.html, styles.css, script.js) starts with literal lines containing three single quotes (''') surrounding a "DOCSTRING" block. Those triple-quote lines are not valid tokens in HTML/CSS/JS and will cause syntax errors or make the browser ignore/stop parsing the files. The app will fail to run (no script execution, CSS not applied, HTML may contain stray text).
- Fixing these simple invalid tokens is required before any other runtime or UX fixes can be verified.

How to fix (exact steps):

1) index.html
- Remove the lines that look like ''' immediately before and after the HTML comment block.
- Keep the HTML comment, or convert it into a normal HTML comment only. The file should begin with <!doctype html>.

Example change:
Current top of file:
'''
<!--
DOCSTRING
This is...
-->
'''
<!doctype html>

Replace with:
<!--
DOCSTRING
This is the main HTML file for the Random Winner Wheel.
It contains the structure: input fields to add names, a canvas for the wheel,
controls (spin, clear, bulk add), theme selector, and placeholders for CSS/JS.
-->
<!doctype html>

2) styles.css
- Remove the leading and trailing ''' lines.
- Convert the "DOCSTRING" block to a proper CSS comment /* ... */ or remove it.

Example change:
Current top:
'''
DOCSTRING
Stylesheet for the Random Winner Wheel.
Defines layout, themes, wheel container sizing, and animations.
'''
/* Reset & base */
...

Replace with:
/* DOCSTRING
   Stylesheet for the Random Winner Wheel.
   Defines layout, themes, wheel container sizing, and animations.
*/
 /* Reset & base */
...

3) script.js
- Remove the leading/trailing ''' lines.
- Convert the DOCSTRING block to a JS comment (/* ... */) or use // comments.

Example change:
Current top:
'''
DOCSTRING
Script for the Random Winner Wheel.
Contains the Wheel class to draw and spin the canvas-based wheel and UI glue code to manage names and themes.
'''
/* Main JavaScript - Wheel + UI logic */
(() => {

Replace with:
/* DOCSTRING
   Script for the Random Winner Wheel.
   Contains the Wheel class to draw and spin the canvas-based wheel and UI glue code to manage names and themes.
*/
/* Main JavaScript - Wheel + UI logic */
(() => {

4) (Recommended but lower priority) Add CSS rules for the toast messages inserted by showMessage
- Your showMessage creates elements with class "tmp-toast" and type classes like "info", "warn", "success" but no CSS exists for these. Add minimal styling so messages are visible, e.g.:

/* add near end of styles.css */
.tmp-toast {
  position: fixed;
  left: 50%;
  transform: translateX(-50%);
  top: 18px;
  background: rgba(0,0,0,0.85);
  color: #fff;
  padding: 8px 12px;
  border-radius: 6px;
  z-index: 9999;
  transition: opacity 0.25s, transform 0.25s;
  opacity: 1;
  pointer-events: none;
}
.tmp-toast.success { background: rgba(56, 198, 123, 0.95); }
.tmp-toast.warn    { background: rgba(255, 159, 67, 0.95); }
.tmp-toast.info    { background: rgba(12, 74, 255, 0.95); }

Why include the toast CSS: after fixing the syntax errors you will want visible feedback for users (error/warn/info messages).

After you remove those triple-quote lines and adjust the comments as shown, reload and re-test the page. If other runtime issues remain (e.g., pointer alignment, winner-index calculation edge-cases, or UX enhancements like better CSV parsing), I can run through a prioritized list of additional improvements."
In the software, each file must strictly follow a markdown code block format, where the following tokens must be replaced such that "FILENAME" is the lowercase file name including the file extension, "LANGUAGE" in the programming language, "DOCSTRING" is a string literal specified in source code that is used to document a specific segment of code, and "CODE" is the original code. Format:
FILENAME
```LANGUAGE
'''
DOCSTRING
'''
CODE
```
As the Programmer, to satisfy the new user's demand and make the software creative, executive and robust, you should modify corresponding codes according to the comments. Then, output the full and complete codes with all bugs fixed based on the comments. Return all codes strictly following the required format.

[2025-17-09 13:39:14 INFO] Retrying request to /chat/completions in 0.399966 seconds
[2025-17-09 13:41:29 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2025-17-09 13:41:29 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 7495
completion_tokens: 8139
total_tokens: 15634
cost: $-1.000000


[2025-17-09 13:41:30 INFO] Programmer: **Programmer<->Code Reviewer on : CodeReviewModification, turn 0**

[ChatDev is a software company powered by multiple intelligent agents, such as chief executive officer, chief human resources officer, chief product officer, chief technology officer, etc, with a multi-agent organizational structure and the mission of 'changing the digital world through programming'.
You are Code Reviewer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer.
You can help programmers to assess source codes for software troubleshooting, fix bugs to increase code quality and robustness, and offer proposals to improve the source codes.
Here is a new customer's task: [Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes. Do it in HTML, CSS, and JavaScript.].
To complete the task, you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]

index.html
```html
<!--
DOCSTRING
This is the main HTML file for the Random Winner Wheel.
It contains the structure: input fields to add names, a canvas for the wheel,
controls (spin, clear, bulk add), theme selector, and placeholders for CSS/JS.
-->
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Random Winner Wheel</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body class="theme-light">
  <header>
    <h1>Random Winner Wheel</h1>
    <p>Enter participant names, choose a theme, and spin to pick a winner.</p>
  </header>
  <main>
    <section class="controls">
      <div class="add-single">
        <input id="nameInput" type="text" placeholder="Enter a name and press Add" aria-label="Name input" />
        <button id="addBtn">Add</button>
        <button id="addRandomBtn" title="Add a few sample random names">Add Sample</button>
      </div>
      <div class="bulk-add">
        <label for="bulkInput">Bulk add (comma, newline or semicolon separated):</label>
        <textarea id="bulkInput" placeholder="Alice, Bob, Charlie"></textarea>
        <div class="bulk-actions">
          <button id="bulkAddBtn">Bulk Add</button>
          <button id="clearBulkBtn">Clear Bulk</button>
        </div>
      </div>
      <div class="list-actions">
        <div class="theme-select">
          <label for="themeSelect">Theme:</label>
          <select id="themeSelect">
            <option value="light">Light</option>
            <option value="dark">Dark</option>
            <option value="neon">Neon</option>
            <option value="pastel">Pastel</option>
            <option value="retro">Retro</option>
          </select>
        </div>
        <div class="wheel-controls">
          <button id="spinBtn" class="primary">Spin</button>
          <button id="clearNamesBtn">Clear Names</button>
          <button id="exportBtn">Export CSV</button>
          <input id="importFile" type="file" accept=".csv,text/csv" style="display:none">
          <button id="importBtn">Import CSV</button>
        </div>
      </div>
    </section>
    <section class="wheel-area">
      <div class="wheel-container">
        <canvas id="wheelCanvas" width="600" height="600" aria-label="Spinning wheel"></canvas>
        <div class="pointer" aria-hidden="true">▼</div>
      </div>
      <aside class="participants">
        <h2>Participants (<span id="count">0</span>)</h2>
        <ul id="nameList" aria-live="polite"></ul>
      </aside>
    </section>
    <section class="result" id="result" aria-live="polite" hidden>
      <h2>Winner</h2>
      <div id="winnerName" class="winnerName"></div>
      <button id="rerollBtn">Spin Again</button>
    </section>
  </main>
  <footer>
    <small>Built with HTML, CSS, and JavaScript. Themes change both UI and wheel colors.</small>
  </footer>
  <script src="script.js"></script>
</body>
</html>
```

styles.css
```css
/*
DOCSTRING
Stylesheet for the Random Winner Wheel.
Defines layout, themes, wheel container sizing, animations, and toast styles.
*/
/* Reset & base */
* { box-sizing: border-box; margin: 0; padding: 0; }
html,body { height: 100%; font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; background: var(--bg); color: var(--fg); }
:root {
  --bg: #f7f8fb;
  --fg: #222;
  --muted: #666;
  --accent: #2b8cff;
  --card: #ffffff;
  --primary-btn-bg: var(--accent);
  --primary-btn-fg: #fff;
  --shadow: rgba(15,15,15,0.08);
}
/* Themes */
body.theme-light {
  --bg: #f7f8fb;
  --fg: #222;
  --muted: #5b6170;
  --accent: #2b8cff;
  --card: #fff;
  --wheel-seq: 0;
}
body.theme-dark {
  --bg: #0f1724;
  --fg: #e6eef8;
  --muted: #a9b1c2;
  --accent: #7c5cff;
  --card: #0b1220;
}
body.theme-neon {
  --bg: #0a0a0f;
  --fg: #e9f9ff;
  --muted: #a6f3ff;
  --accent: #39ff14;
  --card: #09101a;
}
body.theme-pastel {
  --bg: #fffaf6;
  --fg: #3c3a3a;
  --muted: #8d8a8a;
  --accent: #ff7aa2;
  --card: #fff;
}
body.theme-retro {
  --bg: #fff6e7;
  --fg: #402b2b;
  --muted: #856e6e;
  --accent: #ffb86b;
  --card: #fff0e6;
}
/* Layout */
header { padding: 18px 24px; text-align: center; background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent); }
header h1 { font-size: 1.5rem; margin-bottom: 6px; }
main { padding: 18px; max-width: 1100px; margin: 0 auto; }
.controls { display: grid; gap: 12px; margin-bottom: 18px; }
.add-single { display:flex; gap:8px; }
.add-single input[type="text"] { flex:1; padding:10px; border-radius:8px; border:1px solid rgba(0,0,0,0.08); background:var(--card); color:var(--fg); }
.add-single button { padding:10px 12px; border-radius:8px; border: none; cursor:pointer; background: var(--primary-btn-bg); color: var(--primary-btn-fg); }
.add-single button#addRandomBtn { background: transparent; border: 1px solid rgba(0,0,0,0.06); color: var(--fg); }
.bulk-add textarea { width:100%; min-height:64px; margin-top:6px; padding:8px; border-radius:8px; border:1px solid rgba(0,0,0,0.06); background:var(--card); color:var(--fg); }
.bulk-actions { display:flex; gap:8px; margin-top:8px; }
.list-actions { display:flex; justify-content:space-between; align-items:center; gap:16px; flex-wrap:wrap; }
.theme-select select { padding:8px; border-radius:8px; border:1px solid rgba(0,0,0,0.06); }
.wheel-area { display:flex; gap:18px; align-items:start; flex-wrap:wrap; }
.wheel-container { position: relative; width: 600px; height: 600px; max-width: 90vw; max-height: 90vw; display:flex; align-items:center; justify-content:center; background: transparent; }
.pointer { position:absolute; top:6px; font-size:28px; transform: translateY(-50%); text-shadow: 0 2px 8px rgba(0,0,0,0.25); color: var(--accent); pointer-events:none; }
.participants { width: 320px; max-width: 40vw; background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent); padding:12px; border-radius:10px; box-shadow: 0 6px 18px var(--shadow); }
.participants h2 { margin-bottom:8px; font-size:1.05rem; }
#nameList { list-style:none; max-height:420px; overflow:auto; display:block; }
#nameList li { padding:8px; border-radius:6px; display:flex; justify-content:space-between; align-items:center; gap:8px; margin-bottom:8px; background: var(--card); border:1px solid rgba(0,0,0,0.04); }
#nameList li button { background: transparent; border: none; color: var(--muted); cursor:pointer; }
.result { margin-top:18px; padding:12px; border-radius:8px; background: var(--card); text-align:center; box-shadow: 0 6px 18px var(--shadow); }
.result .winnerName { font-size:1.4rem; font-weight:700; margin:8px 0; color: var(--accent); }
/* Buttons */
button { cursor:pointer; padding:8px 12px; border-radius:8px; border:1px solid rgba(0,0,0,0.06); background: transparent; color:var(--fg); }
button.primary { background: var(--primary-btn-bg); color: var(--primary-btn-fg); border: none; }
/* Responsive */
@media (max-width: 900px) {
  .wheel-area { flex-direction:column; align-items:center; }
  .participants { width: 100%; max-width: 100%; }
}
/* Wheel canvas scaling helper */
#wheelCanvas { border-radius:50%; box-shadow: 0 12px 26px rgba(0,0,0,0.12); background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.02), transparent); }

/* Toast / temporary message styles (used by showMessage) */
.tmp-toast {
  position: fixed;
  left: 50%;
  transform: translateX(-50%);
  top: 18px;
  background: rgba(0,0,0,0.85);
  color: #fff;
  padding: 8px 12px;
  border-radius: 6px;
  z-index: 9999;
  transition: opacity 0.25s, transform 0.25s;
  opacity: 1;
  pointer-events: none;
  font-size: 0.95rem;
  box-shadow: 0 6px 18px rgba(0,0,0,0.18);
}
.tmp-toast.success { background: rgba(56, 198, 123, 0.95); }
.tmp-toast.warn    { background: rgba(255, 159, 67, 0.95); color: #2b1500; }
.tmp-toast.info    { background: rgba(12, 74, 255, 0.95); }

/* Winner highlight for participants list */
#nameList li.winner {
  outline: 3px solid rgba(255,215,0,0.15);
  box-shadow: 0 6px 18px rgba(255,215,0,0.06);
  transform: scale(1.01);
}
```

script.js
```js
/* 
DOCSTRING
Script for the Random Winner Wheel.
Contains the Wheel class to draw and spin the canvas-based wheel and UI glue code to manage names and themes.
*/
/* Main JavaScript - Wheel + UI logic */
(() => {
  // Utilities
  function rand(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }
  function easeOutCubic(t) { return 1 - Math.pow(1 - t, 3); }
  // Color palettes for themes (will be used to paint wheel segments)
  const THEME_PALETTES = {
    light: ['#FF8A80','#FFD180','#FFF59D','#C8E6C9','#80DEEA','#A7FFEB','#B39DDB','#90CAF9'],
    dark: ['#ff6b6b','#ffd166','#faff8e','#b9f6ca','#4dd0e1','#80cbc4','#b388ff','#64b5f6'],
    neon: ['#ff2d95','#7cff01','#00ffff','#ffdd00','#ff6a00','#00ff9e','#ff00ff','#47ffa2'],
    pastel: ['#ffdbe9','#fff0b3','#d1ffd6','#cfefff','#e7dfff','#ffd6e7','#fbe7d6','#e6f7ff'],
    retro: ['#ffb86b','#ffd3a8','#f3e2a9','#b8e0d2','#c0b9ff','#ffb6c1','#f6c49f','#c3d69b']
  };
  // Wheel class
  class Wheel {
    /*
    Manage wheel: drawing, recalculating segments, spinning animation, and determining winner.
    */
    constructor(canvas, options = {}) {
      this.canvas = canvas;
      this.ctx = canvas.getContext('2d');
      this.names = [];
      this.rotation = 0; // radians
      this.isSpinning = false;
      this.frame = null;
      this.onResult = options.onResult || function() {};
      this.theme = options.theme || 'light';
      this.padAngle = 0.02; // radians padding between segments
      this.textColor = '#111';
      this._devicePixelRatioFix();
      window.addEventListener('resize', () => { this._devicePixelRatioFix(); this.draw(); });
    }
    _devicePixelRatioFix() {
      const dpr = window.devicePixelRatio || 1;
      const rect = this.canvas.getBoundingClientRect();
      // If rect has zero size (canvas not yet laid out), use current width/height attributes as fallback
      const width = rect.width || (this.canvas.width / dpr);
      const height = rect.height || (this.canvas.height / dpr);
      this.canvas.width = width * dpr;
      this.canvas.height = height * dpr;
      this.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      this.centerX = width / 2;
      this.centerY = height / 2;
      this.radius = Math.min(width, height) / 2 - 18;
    }
    setTheme(themeId) { this.theme = themeId; this.draw(); }
    setNames(names) {
      this.names = names.slice();
      this.draw();
    }
    addName(name) {
      this.names.push(name);
      this.draw();
    }
    removeName(index) {
      if (index >= 0 && index < this.names.length) {
        this.names.splice(index,1);
        this.draw();
      }
    }
    clearNames() {
      this.names = [];
      this.draw();
    }
    draw() {
      const ctx = this.ctx;
      const w = this.canvas.width / (window.devicePixelRatio || 1);
      const h = this.canvas.height / (window.devicePixelRatio || 1);
      ctx.clearRect(0,0,w,h);
      ctx.save();
      ctx.translate(this.centerX, this.centerY);
      ctx.rotate(this.rotation);
      // draw segments
      const count = Math.max(this.names.length, 1);
      const palette = THEME_PALETTES[this.theme] || THEME_PALETTES.light;
      for (let i = 0; i < count; i++) {
        const start = (i / count) * Math.PI * 2;
        const end = ((i + 1) / count) * Math.PI * 2;
        ctx.beginPath();
        ctx.moveTo(0,0);
        ctx.arc(0,0,this.radius, start + this.padAngle, end - this.padAngle, false);
        ctx.closePath();
        const color = palette[i % palette.length];
        ctx.fillStyle = color;
        ctx.fill();
        ctx.strokeStyle = (i % 2 === 0) ? 'rgba(0,0,0,0.06)' : 'rgba(0,0,0,0.03)';
        ctx.lineWidth = 1;
        ctx.stroke();
        // draw text label
        const mid = (start + end) / 2;
        ctx.save();
        ctx.rotate(mid);
        ctx.translate(this.radius * 0.6, 0);
        ctx.rotate(Math.PI/2);
        ctx.fillStyle = getTextColor(color);
        ctx.font = `${Math.max(12, Math.min(22, this.radius / 8))}px sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        const label = (this.names.length === 0) ? 'Add names' : this.names[i % this.names.length];
        wrapFillText(ctx, label, 0, 0, this.radius * 0.5, 16);
        ctx.restore();
      }
      // draw center circle
      ctx.beginPath();
      ctx.arc(0,0, this.radius * 0.16, 0, Math.PI*2);
      ctx.fillStyle = 'rgba(255,255,255,0.9)';
      ctx.fill();
      ctx.strokeStyle = 'rgba(0,0,0,0.06)';
      ctx.stroke();
      ctx.restore();
      // draw outer ring (pointer side neutral)
      ctx.beginPath();
      ctx.arc(this.centerX, this.centerY, this.radius + 10, 0, Math.PI*2);
      ctx.strokeStyle = 'rgba(0,0,0,0.03)';
      ctx.lineWidth = 2;
      ctx.stroke();
    }
    spin() {
      if (this.isSpinning || this.names.length === 0) return;
      this.isSpinning = true;
      const count = this.names.length;
      // Determine random winner index to land on:
      const winnerIndex = rand(0, count - 1);
      // Calculate final rotation so that winner segment lines up with pointer at top (pointer at canvas top - rotation must align)
      // Our pointer is at the top (canvas 0 angle). The segment mid-angle for index i (without rotation) is ((i + 0.5)/count)*2pi
      const segmentMid = ((winnerIndex + 0.5) / count) * Math.PI * 2;
      // We want segmentMid + rotation_final == -Math.PI/2 (so it points at the top pointer), so rotation_final = -Math.PI/2 - segmentMid + 2pi*N
      const extraTurns = rand(5, 8); // full spins
      const rotationFinal = -Math.PI/2 - segmentMid + extraTurns * Math.PI * 2;
      const startRotation = this.rotation % (Math.PI * 2);
      const delta = rotationFinal - startRotation;
      const duration = 4000 + Math.random() * 1500; // ms
      const startTime = performance.now();
      const animate = (now) => {
        const elapsed = now - startTime;
        const t = Math.min(elapsed / duration, 1);
        const eased = easeOutCubic(t);
        this.rotation = startRotation + delta * eased;
        this.draw();
        if (t < 1) {
          this.frame = requestAnimationFrame(animate);
        } else {
          this.isSpinning = false;
          // Normalize rotation within 0..2pi
          this.rotation = ((this.rotation % (Math.PI*2)) + Math.PI*2) % (Math.PI*2);
          this.draw();
          // Compute final winner index again from rotation
          // finalAngle: the angle of the segment at pointer (0 at right, +counterclockwise). We compute a normalized angle that maps to segment index.
          const finalAngle = ((-this.rotation - Math.PI/2) % (Math.PI*2) + Math.PI*2) % (Math.PI*2);
          const resultingIndex = Math.floor((finalAngle / (Math.PI*2)) * count) % count;
          const winner = this.names[resultingIndex];
          this.onResult({ index: resultingIndex, name: winner });
        }
      };
      this.frame = requestAnimationFrame(animate);
    }
  }
  // Helper: pick readable text color for a background
  function getTextColor(hex) {
    // remove # and convert
    const h = hex.replace('#','');
    const r = parseInt(h.substring(0,2),16);
    const g = parseInt(h.substring(2,4),16);
    const b = parseInt(h.substring(4,6),16);
    // luminance
    const lum = (0.299*r + 0.587*g + 0.114*b) / 255;
    return lum > 0.65 ? '#111' : '#fff';
  }
  // Helper: wrap text within a given width (draws multi-line if necessary)
  function wrapFillText(ctx, text, x, y, maxWidth, lineHeight) {
    const words = (text || '').split(/\s+/);
    if (words.length === 0) return;
    let line = '';
    const lines = [];
    for (let n = 0; n < words.length; n++) {
      const testLine = line ? line + ' ' + words[n] : words[n];
      const metrics = ctx.measureText(testLine);
      if (metrics.width > maxWidth && line) {
        lines.push(line);
        line = words[n];
      } else {
        line = testLine;
      }
    }
    if (line) lines.push(line);
    // If still too many lines, just draw what's possible (we rely on font size)
    for (let i=0;i<lines.length;i++){
      ctx.fillText(lines[i], x, y + (i - (lines.length-1)/2) * lineHeight);
    }
  }
  // UI glue
  document.addEventListener('DOMContentLoaded', () => {
    const canvas = document.getElementById('wheelCanvas');
    const wheel = new Wheel(canvas, { theme: 'light', onResult: onWinner });
    const nameInput = document.getElementById('nameInput');
    const addBtn = document.getElementById('addBtn');
    const addRandomBtn = document.getElementById('addRandomBtn');
    const bulkInput = document.getElementById('bulkInput');
    const bulkAddBtn = document.getElementById('bulkAddBtn');
    const clearBulkBtn = document.getElementById('clearBulkBtn');
    const nameList = document.getElementById('nameList');
    const countSpan = document.getElementById('count');
    const spinBtn = document.getElementById('spinBtn');
    const rerollBtn = document.getElementById('rerollBtn');
    const clearNamesBtn = document.getElementById('clearNamesBtn');
    const themeSelect = document.getElementById('themeSelect');
    const resultSection = document.getElementById('result');
    const winnerNameDiv = document.getElementById('winnerName');
    const exportBtn = document.getElementById('exportBtn');
    const importBtn = document.getElementById('importBtn');
    const importFile = document.getElementById('importFile');
    // Initial draw
    wheel.draw();
    function updateUI() {
      const names = wheel.names;
      countSpan.textContent = names.length;
      renderNameList();
    }
    function renderNameList() {
      nameList.innerHTML = '';
      wheel.names.forEach((n, i) => {
        const li = document.createElement('li');
        const span = document.createElement('span');
        span.textContent = n;
        li.appendChild(span);
        const btn = document.createElement('button');
        btn.title = 'Remove';
        btn.setAttribute('aria-label', `Remove ${n}`);
        btn.innerHTML = '✕';
        btn.addEventListener('click', () => {
          wheel.removeName(i);
          updateUI();
        });
        li.appendChild(btn);
        nameList.appendChild(li);
      });
    }
    function addNameFromInput() {
      const v = nameInput.value.trim();
      if (!v) { showMessage('Please enter a name.', 'warn'); return; }
      wheel.addName(v);
      nameInput.value = '';
      updateUI();
    }
    addBtn.addEventListener('click', addNameFromInput);
    nameInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') addNameFromInput(); });
    addRandomBtn.addEventListener('click', () => {
      const samples = ['Alex','Jordan','Taylor','Sam','Jamie','Casey','Morgan','Riley','Avery','Dana'];
      const count = rand(3,6);
      for (let i=0;i<count;i++) wheel.addName(samples[rand(0,samples.length-1)] + (rand(1,100)));
      updateUI();
    });
    bulkAddBtn.addEventListener('click', () => {
      const text = bulkInput.value.trim();
      if (!text) { showMessage('Bulk input is empty.', 'warn'); return; }
      const parsed = text.split(/[\n,;]+/).map(s => s.trim()).filter(s => s);
      parsed.forEach(p => wheel.addName(p));
      bulkInput.value = '';
      updateUI();
      showMessage(`Added ${parsed.length} names.`, 'info');
    });
    clearBulkBtn.addEventListener('click', () => { bulkInput.value = ''; });
    spinBtn.addEventListener('click', () => {
      if (wheel.names.length === 0) { showMessage('Add at least one name to spin.', 'warn'); return; }
      resultSection.hidden = true;
      winnerNameDiv.textContent = '';
      wheel.spin();
      spinBtn.disabled = true;
      const checkFinish = setInterval(() => {
        if (!wheel.isSpinning) {
          clearInterval(checkFinish);
          spinBtn.disabled = false;
        }
      }, 200);
    });
    rerollBtn.addEventListener('click', () => {
      resultSection.hidden = true;
      wheel.spin();
    });
    clearNamesBtn.addEventListener('click', () => {
      if (confirm('Clear all names?')) {
        wheel.clearNames();
        updateUI();
      }
    });
    themeSelect.addEventListener('change', (e) => {
      const t = e.target.value;
      document.body.className = 'theme-' + t;
      wheel.setTheme(t);
    });
    function onWinner(result) {
      winnerNameDiv.textContent = result.name || '—';
      resultSection.hidden = false;
      // Flash the winner item in the list (if still present)
      const items = Array.from(nameList.children);
      items.forEach((li, idx) => { li.classList.toggle('winner', idx === result.index); });
      showMessage(`Winner: ${result.name}`, 'success', 4000);
    }
    // Simple message area
    function showMessage(text, type = 'info', duration = 2200) {
      // create small toast
      const t = document.createElement('div');
      t.className = 'tmp-toast ' + type;
      t.textContent = text;
      document.body.appendChild(t);
      // Force reflow to pick up transitions
      window.getComputedStyle(t).opacity;
      setTimeout(()=> { t.style.opacity = '0'; t.style.transform = 'translateY(-10px)'; }, duration - 300);
      setTimeout(()=> { try { t.remove(); } catch(e){} }, duration);
    }
    // Export/import CSV
    exportBtn.addEventListener('click', () => {
      if (wheel.names.length === 0) { showMessage('No names to export.', 'warn'); return; }
      const csv = wheel.names.map(n => `"${(n||'').replace(/"/g,'""')}"`).join('\n');
      const blob = new Blob([csv], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'participants.csv';
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
      showMessage('Exported CSV', 'info');
    });
    importBtn.addEventListener('click', () => { importFile.click(); });
    importFile.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (ev) => {
        const txt = ev.target.result;
        const lines = txt.split(/\r?\n/).map(s => s.trim()).filter(s => s);
        // basic CSV unquote
        const parsed = lines.map(l => {
          // simple CSV single-column parse: handle quoted fields
          if (l.startsWith('"') && l.endsWith('"')) {
            return l.slice(1,-1).replace(/""/g,'"');
          }
          return l;
        });
        parsed.forEach(p => wheel.addName(p));
        updateUI();
        showMessage(`Imported ${parsed.length} names`, 'info');
      };
      reader.readAsText(file);
      importFile.value = '';
    });
    // Initial sample (optional)
    // wheel.addName('Alice'); wheel.addName('Bob'); wheel.addName('Charlie');
    updateUI();
    // (Optional) keyboard shortcuts
    window.addEventListener('keydown', (e) => {
      if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'k') {
        e.preventDefault();
        nameInput.focus();
      }
      if (e.key === ' ') {
        // space triggers spin if not focusing an input
        if (document.activeElement.tagName !== 'INPUT' && document.activeElement.tagName !== 'TEXTAREA') {
          e.preventDefault();
          spinBtn.click();
        }
      }
    });
  });
})(); 
```

[2025-17-09 13:41:30 INFO] **[Seminar Conclusion]**:

 index.html
```html
<!--
DOCSTRING
This is the main HTML file for the Random Winner Wheel.
It contains the structure: input fields to add names, a canvas for the wheel,
controls (spin, clear, bulk add), theme selector, and placeholders for CSS/JS.
-->
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Random Winner Wheel</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body class="theme-light">
  <header>
    <h1>Random Winner Wheel</h1>
    <p>Enter participant names, choose a theme, and spin to pick a winner.</p>
  </header>
  <main>
    <section class="controls">
      <div class="add-single">
        <input id="nameInput" type="text" placeholder="Enter a name and press Add" aria-label="Name input" />
        <button id="addBtn">Add</button>
        <button id="addRandomBtn" title="Add a few sample random names">Add Sample</button>
      </div>
      <div class="bulk-add">
        <label for="bulkInput">Bulk add (comma, newline or semicolon separated):</label>
        <textarea id="bulkInput" placeholder="Alice, Bob, Charlie"></textarea>
        <div class="bulk-actions">
          <button id="bulkAddBtn">Bulk Add</button>
          <button id="clearBulkBtn">Clear Bulk</button>
        </div>
      </div>
      <div class="list-actions">
        <div class="theme-select">
          <label for="themeSelect">Theme:</label>
          <select id="themeSelect">
            <option value="light">Light</option>
            <option value="dark">Dark</option>
            <option value="neon">Neon</option>
            <option value="pastel">Pastel</option>
            <option value="retro">Retro</option>
          </select>
        </div>
        <div class="wheel-controls">
          <button id="spinBtn" class="primary">Spin</button>
          <button id="clearNamesBtn">Clear Names</button>
          <button id="exportBtn">Export CSV</button>
          <input id="importFile" type="file" accept=".csv,text/csv" style="display:none">
          <button id="importBtn">Import CSV</button>
        </div>
      </div>
    </section>
    <section class="wheel-area">
      <div class="wheel-container">
        <canvas id="wheelCanvas" width="600" height="600" aria-label="Spinning wheel"></canvas>
        <div class="pointer" aria-hidden="true">▼</div>
      </div>
      <aside class="participants">
        <h2>Participants (<span id="count">0</span>)</h2>
        <ul id="nameList" aria-live="polite"></ul>
      </aside>
    </section>
    <section class="result" id="result" aria-live="polite" hidden>
      <h2>Winner</h2>
      <div id="winnerName" class="winnerName"></div>
      <button id="rerollBtn">Spin Again</button>
    </section>
  </main>
  <footer>
    <small>Built with HTML, CSS, and JavaScript. Themes change both UI and wheel colors.</small>
  </footer>
  <script src="script.js"></script>
</body>
</html>
```

styles.css
```css
/*
DOCSTRING
Stylesheet for the Random Winner Wheel.
Defines layout, themes, wheel container sizing, animations, and toast styles.
*/
/* Reset & base */
* { box-sizing: border-box; margin: 0; padding: 0; }
html,body { height: 100%; font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; background: var(--bg); color: var(--fg); }
:root {
  --bg: #f7f8fb;
  --fg: #222;
  --muted: #666;
  --accent: #2b8cff;
  --card: #ffffff;
  --primary-btn-bg: var(--accent);
  --primary-btn-fg: #fff;
  --shadow: rgba(15,15,15,0.08);
}
/* Themes */
body.theme-light {
  --bg: #f7f8fb;
  --fg: #222;
  --muted: #5b6170;
  --accent: #2b8cff;
  --card: #fff;
  --wheel-seq: 0;
}
body.theme-dark {
  --bg: #0f1724;
  --fg: #e6eef8;
  --muted: #a9b1c2;
  --accent: #7c5cff;
  --card: #0b1220;
}
body.theme-neon {
  --bg: #0a0a0f;
  --fg: #e9f9ff;
  --muted: #a6f3ff;
  --accent: #39ff14;
  --card: #09101a;
}
body.theme-pastel {
  --bg: #fffaf6;
  --fg: #3c3a3a;
  --muted: #8d8a8a;
  --accent: #ff7aa2;
  --card: #fff;
}
body.theme-retro {
  --bg: #fff6e7;
  --fg: #402b2b;
  --muted: #856e6e;
  --accent: #ffb86b;
  --card: #fff0e6;
}
/* Layout */
header { padding: 18px 24px; text-align: center; background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent); }
header h1 { font-size: 1.5rem; margin-bottom: 6px; }
main { padding: 18px; max-width: 1100px; margin: 0 auto; }
.controls { display: grid; gap: 12px; margin-bottom: 18px; }
.add-single { display:flex; gap:8px; }
.add-single input[type="text"] { flex:1; padding:10px; border-radius:8px; border:1px solid rgba(0,0,0,0.08); background:var(--card); color:var(--fg); }
.add-single button { padding:10px 12px; border-radius:8px; border: none; cursor:pointer; background: var(--primary-btn-bg); color: var(--primary-btn-fg); }
.add-single button#addRandomBtn { background: transparent; border: 1px solid rgba(0,0,0,0.06); color: var(--fg); }
.bulk-add textarea { width:100%; min-height:64px; margin-top:6px; padding:8px; border-radius:8px; border:1px solid rgba(0,0,0,0.06); background:var(--card); color:var(--fg); }
.bulk-actions { display:flex; gap:8px; margin-top:8px; }
.list-actions { display:flex; justify-content:space-between; align-items:center; gap:16px; flex-wrap:wrap; }
.theme-select select { padding:8px; border-radius:8px; border:1px solid rgba(0,0,0,0.06); }
.wheel-area { display:flex; gap:18px; align-items:start; flex-wrap:wrap; }
.wheel-container { position: relative; width: 600px; height: 600px; max-width: 90vw; max-height: 90vw; display:flex; align-items:center; justify-content:center; background: transparent; }
.pointer { position:absolute; top:6px; font-size:28px; transform: translateY(-50%); text-shadow: 0 2px 8px rgba(0,0,0,0.25); color: var(--accent); pointer-events:none; }
.participants { width: 320px; max-width: 40vw; background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent); padding:12px; border-radius:10px; box-shadow: 0 6px 18px var(--shadow); }
.participants h2 { margin-bottom:8px; font-size:1.05rem; }
#nameList { list-style:none; max-height:420px; overflow:auto; display:block; }
#nameList li { padding:8px; border-radius:6px; display:flex; justify-content:space-between; align-items:center; gap:8px; margin-bottom:8px; background: var(--card); border:1px solid rgba(0,0,0,0.04); }
#nameList li button { background: transparent; border: none; color: var(--muted); cursor:pointer; }
.result { margin-top:18px; padding:12px; border-radius:8px; background: var(--card); text-align:center; box-shadow: 0 6px 18px var(--shadow); }
.result .winnerName { font-size:1.4rem; font-weight:700; margin:8px 0; color: var(--accent); }
/* Buttons */
button { cursor:pointer; padding:8px 12px; border-radius:8px; border:1px solid rgba(0,0,0,0.06); background: transparent; color:var(--fg); }
button.primary { background: var(--primary-btn-bg); color: var(--primary-btn-fg); border: none; }
/* Responsive */
@media (max-width: 900px) {
  .wheel-area { flex-direction:column; align-items:center; }
  .participants { width: 100%; max-width: 100%; }
}
/* Wheel canvas scaling helper */
#wheelCanvas { border-radius:50%; box-shadow: 0 12px 26px rgba(0,0,0,0.12); background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.02), transparent); }

/* Toast / temporary message styles (used by showMessage) */
.tmp-toast {
  position: fixed;
  left: 50%;
  transform: translateX(-50%);
  top: 18px;
  background: rgba(0,0,0,0.85);
  color: #fff;
  padding: 8px 12px;
  border-radius: 6px;
  z-index: 9999;
  transition: opacity 0.25s, transform 0.25s;
  opacity: 1;
  pointer-events: none;
  font-size: 0.95rem;
  box-shadow: 0 6px 18px rgba(0,0,0,0.18);
}
.tmp-toast.success { background: rgba(56, 198, 123, 0.95); }
.tmp-toast.warn    { background: rgba(255, 159, 67, 0.95); color: #2b1500; }
.tmp-toast.info    { background: rgba(12, 74, 255, 0.95); }

/* Winner highlight for participants list */
#nameList li.winner {
  outline: 3px solid rgba(255,215,0,0.15);
  box-shadow: 0 6px 18px rgba(255,215,0,0.06);
  transform: scale(1.01);
}
```

script.js
```js
/* 
DOCSTRING
Script for the Random Winner Wheel.
Contains the Wheel class to draw and spin the canvas-based wheel and UI glue code to manage names and themes.
*/
/* Main JavaScript - Wheel + UI logic */
(() => {
  // Utilities
  function rand(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }
  function easeOutCubic(t) { return 1 - Math.pow(1 - t, 3); }
  // Color palettes for themes (will be used to paint wheel segments)
  const THEME_PALETTES = {
    light: ['#FF8A80','#FFD180','#FFF59D','#C8E6C9','#80DEEA','#A7FFEB','#B39DDB','#90CAF9'],
    dark: ['#ff6b6b','#ffd166','#faff8e','#b9f6ca','#4dd0e1','#80cbc4','#b388ff','#64b5f6'],
    neon: ['#ff2d95','#7cff01','#00ffff','#ffdd00','#ff6a00','#00ff9e','#ff00ff','#47ffa2'],
    pastel: ['#ffdbe9','#fff0b3','#d1ffd6','#cfefff','#e7dfff','#ffd6e7','#fbe7d6','#e6f7ff'],
    retro: ['#ffb86b','#ffd3a8','#f3e2a9','#b8e0d2','#c0b9ff','#ffb6c1','#f6c49f','#c3d69b']
  };
  // Wheel class
  class Wheel {
    /*
    Manage wheel: drawing, recalculating segments, spinning animation, and determining winner.
    */
    constructor(canvas, options = {}) {
      this.canvas = canvas;
      this.ctx = canvas.getContext('2d');
      this.names = [];
      this.rotation = 0; // radians
      this.isSpinning = false;
      this.frame = null;
      this.onResult = options.onResult || function() {};
      this.theme = options.theme || 'light';
      this.padAngle = 0.02; // radians padding between segments
      this.textColor = '#111';
      this._devicePixelRatioFix();
      window.addEventListener('resize', () => { this._devicePixelRatioFix(); this.draw(); });
    }
    _devicePixelRatioFix() {
      const dpr = window.devicePixelRatio || 1;
      const rect = this.canvas.getBoundingClientRect();
      // If rect has zero size (canvas not yet laid out), use current width/height attributes as fallback
      const width = rect.width || (this.canvas.width / dpr);
      const height = rect.height || (this.canvas.height / dpr);
      this.canvas.width = width * dpr;
      this.canvas.height = height * dpr;
      this.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      this.centerX = width / 2;
      this.centerY = height / 2;
      this.radius = Math.min(width, height) / 2 - 18;
    }
    setTheme(themeId) { this.theme = themeId; this.draw(); }
    setNames(names) {
      this.names = names.slice();
      this.draw();
    }
    addName(name) {
      this.names.push(name);
      this.draw();
    }
    removeName(index) {
      if (index >= 0 && index < this.names.length) {
        this.names.splice(index,1);
        this.draw();
      }
    }
    clearNames() {
      this.names = [];
      this.draw();
    }
    draw() {
      const ctx = this.ctx;
      const w = this.canvas.width / (window.devicePixelRatio || 1);
      const h = this.canvas.height / (window.devicePixelRatio || 1);
      ctx.clearRect(0,0,w,h);
      ctx.save();
      ctx.translate(this.centerX, this.centerY);
      ctx.rotate(this.rotation);
      // draw segments
      const count = Math.max(this.names.length, 1);
      const palette = THEME_PALETTES[this.theme] || THEME_PALETTES.light;
      for (let i = 0; i < count; i++) {
        const start = (i / count) * Math.PI * 2;
        const end = ((i + 1) / count) * Math.PI * 2;
        ctx.beginPath();
        ctx.moveTo(0,0);
        ctx.arc(0,0,this.radius, start + this.padAngle, end - this.padAngle, false);
        ctx.closePath();
        const color = palette[i % palette.length];
        ctx.fillStyle = color;
        ctx.fill();
        ctx.strokeStyle = (i % 2 === 0) ? 'rgba(0,0,0,0.06)' : 'rgba(0,0,0,0.03)';
        ctx.lineWidth = 1;
        ctx.stroke();
        // draw text label
        const mid = (start + end) / 2;
        ctx.save();
        ctx.rotate(mid);
        ctx.translate(this.radius * 0.6, 0);
        ctx.rotate(Math.PI/2);
        ctx.fillStyle = getTextColor(color);
        ctx.font = `${Math.max(12, Math.min(22, this.radius / 8))}px sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        const label = (this.names.length === 0) ? 'Add names' : this.names[i % this.names.length];
        wrapFillText(ctx, label, 0, 0, this.radius * 0.5, 16);
        ctx.restore();
      }
      // draw center circle
      ctx.beginPath();
      ctx.arc(0,0, this.radius * 0.16, 0, Math.PI*2);
      ctx.fillStyle = 'rgba(255,255,255,0.9)';
      ctx.fill();
      ctx.strokeStyle = 'rgba(0,0,0,0.06)';
      ctx.stroke();
      ctx.restore();
      // draw outer ring (pointer side neutral)
      ctx.beginPath();
      ctx.arc(this.centerX, this.centerY, this.radius + 10, 0, Math.PI*2);
      ctx.strokeStyle = 'rgba(0,0,0,0.03)';
      ctx.lineWidth = 2;
      ctx.stroke();
    }
    spin() {
      if (this.isSpinning || this.names.length === 0) return;
      this.isSpinning = true;
      const count = this.names.length;
      // Determine random winner index to land on:
      const winnerIndex = rand(0, count - 1);
      // Calculate final rotation so that winner segment lines up with pointer at top (pointer at canvas top - rotation must align)
      // Our pointer is at the top (canvas 0 angle). The segment mid-angle for index i (without rotation) is ((i + 0.5)/count)*2pi
      const segmentMid = ((winnerIndex + 0.5) / count) * Math.PI * 2;
      // We want segmentMid + rotation_final == -Math.PI/2 (so it points at the top pointer), so rotation_final = -Math.PI/2 - segmentMid + 2pi*N
      const extraTurns = rand(5, 8); // full spins
      const rotationFinal = -Math.PI/2 - segmentMid + extraTurns * Math.PI * 2;
      const startRotation = this.rotation % (Math.PI * 2);
      const delta = rotationFinal - startRotation;
      const duration = 4000 + Math.random() * 1500; // ms
      const startTime = performance.now();
      const animate = (now) => {
        const elapsed = now - startTime;
        const t = Math.min(elapsed / duration, 1);
        const eased = easeOutCubic(t);
        this.rotation = startRotation + delta * eased;
        this.draw();
        if (t < 1) {
          this.frame = requestAnimationFrame(animate);
        } else {
          this.isSpinning = false;
          // Normalize rotation within 0..2pi
          this.rotation = ((this.rotation % (Math.PI*2)) + Math.PI*2) % (Math.PI*2);
          this.draw();
          // Compute final winner index again from rotation
          // finalAngle: the angle of the segment at pointer (0 at right, +counterclockwise). We compute a normalized angle that maps to segment index.
          const finalAngle = ((-this.rotation - Math.PI/2) % (Math.PI*2) + Math.PI*2) % (Math.PI*2);
          const resultingIndex = Math.floor((finalAngle / (Math.PI*2)) * count) % count;
          const winner = this.names[resultingIndex];
          this.onResult({ index: resultingIndex, name: winner });
        }
      };
      this.frame = requestAnimationFrame(animate);
    }
  }
  // Helper: pick readable text color for a background
  function getTextColor(hex) {
    // remove # and convert
    const h = hex.replace('#','');
    const r = parseInt(h.substring(0,2),16);
    const g = parseInt(h.substring(2,4),16);
    const b = parseInt(h.substring(4,6),16);
    // luminance
    const lum = (0.299*r + 0.587*g + 0.114*b) / 255;
    return lum > 0.65 ? '#111' : '#fff';
  }
  // Helper: wrap text within a given width (draws multi-line if necessary)
  function wrapFillText(ctx, text, x, y, maxWidth, lineHeight) {
    const words = (text || '').split(/\s+/);
    if (words.length === 0) return;
    let line = '';
    const lines = [];
    for (let n = 0; n < words.length; n++) {
      const testLine = line ? line + ' ' + words[n] : words[n];
      const metrics = ctx.measureText(testLine);
      if (metrics.width > maxWidth && line) {
        lines.push(line);
        line = words[n];
      } else {
        line = testLine;
      }
    }
    if (line) lines.push(line);
    // If still too many lines, just draw what's possible (we rely on font size)
    for (let i=0;i<lines.length;i++){
      ctx.fillText(lines[i], x, y + (i - (lines.length-1)/2) * lineHeight);
    }
  }
  // UI glue
  document.addEventListener('DOMContentLoaded', () => {
    const canvas = document.getElementById('wheelCanvas');
    const wheel = new Wheel(canvas, { theme: 'light', onResult: onWinner });
    const nameInput = document.getElementById('nameInput');
    const addBtn = document.getElementById('addBtn');
    const addRandomBtn = document.getElementById('addRandomBtn');
    const bulkInput = document.getElementById('bulkInput');
    const bulkAddBtn = document.getElementById('bulkAddBtn');
    const clearBulkBtn = document.getElementById('clearBulkBtn');
    const nameList = document.getElementById('nameList');
    const countSpan = document.getElementById('count');
    const spinBtn = document.getElementById('spinBtn');
    const rerollBtn = document.getElementById('rerollBtn');
    const clearNamesBtn = document.getElementById('clearNamesBtn');
    const themeSelect = document.getElementById('themeSelect');
    const resultSection = document.getElementById('result');
    const winnerNameDiv = document.getElementById('winnerName');
    const exportBtn = document.getElementById('exportBtn');
    const importBtn = document.getElementById('importBtn');
    const importFile = document.getElementById('importFile');
    // Initial draw
    wheel.draw();
    function updateUI() {
      const names = wheel.names;
      countSpan.textContent = names.length;
      renderNameList();
    }
    function renderNameList() {
      nameList.innerHTML = '';
      wheel.names.forEach((n, i) => {
        const li = document.createElement('li');
        const span = document.createElement('span');
        span.textContent = n;
        li.appendChild(span);
        const btn = document.createElement('button');
        btn.title = 'Remove';
        btn.setAttribute('aria-label', `Remove ${n}`);
        btn.innerHTML = '✕';
        btn.addEventListener('click', () => {
          wheel.removeName(i);
          updateUI();
        });
        li.appendChild(btn);
        nameList.appendChild(li);
      });
    }
    function addNameFromInput() {
      const v = nameInput.value.trim();
      if (!v) { showMessage('Please enter a name.', 'warn'); return; }
      wheel.addName(v);
      nameInput.value = '';
      updateUI();
    }
    addBtn.addEventListener('click', addNameFromInput);
    nameInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') addNameFromInput(); });
    addRandomBtn.addEventListener('click', () => {
      const samples = ['Alex','Jordan','Taylor','Sam','Jamie','Casey','Morgan','Riley','Avery','Dana'];
      const count = rand(3,6);
      for (let i=0;i<count;i++) wheel.addName(samples[rand(0,samples.length-1)] + (rand(1,100)));
      updateUI();
    });
    bulkAddBtn.addEventListener('click', () => {
      const text = bulkInput.value.trim();
      if (!text) { showMessage('Bulk input is empty.', 'warn'); return; }
      const parsed = text.split(/[\n,;]+/).map(s => s.trim()).filter(s => s);
      parsed.forEach(p => wheel.addName(p));
      bulkInput.value = '';
      updateUI();
      showMessage(`Added ${parsed.length} names.`, 'info');
    });
    clearBulkBtn.addEventListener('click', () => { bulkInput.value = ''; });
    spinBtn.addEventListener('click', () => {
      if (wheel.names.length === 0) { showMessage('Add at least one name to spin.', 'warn'); return; }
      resultSection.hidden = true;
      winnerNameDiv.textContent = '';
      wheel.spin();
      spinBtn.disabled = true;
      const checkFinish = setInterval(() => {
        if (!wheel.isSpinning) {
          clearInterval(checkFinish);
          spinBtn.disabled = false;
        }
      }, 200);
    });
    rerollBtn.addEventListener('click', () => {
      resultSection.hidden = true;
      wheel.spin();
    });
    clearNamesBtn.addEventListener('click', () => {
      if (confirm('Clear all names?')) {
        wheel.clearNames();
        updateUI();
      }
    });
    themeSelect.addEventListener('change', (e) => {
      const t = e.target.value;
      document.body.className = 'theme-' + t;
      wheel.setTheme(t);
    });
    function onWinner(result) {
      winnerNameDiv.textContent = result.name || '—';
      resultSection.hidden = false;
      // Flash the winner item in the list (if still present)
      const items = Array.from(nameList.children);
      items.forEach((li, idx) => { li.classList.toggle('winner', idx === result.index); });
      showMessage(`Winner: ${result.name}`, 'success', 4000);
    }
    // Simple message area
    function showMessage(text, type = 'info', duration = 2200) {
      // create small toast
      const t = document.createElement('div');
      t.className = 'tmp-toast ' + type;
      t.textContent = text;
      document.body.appendChild(t);
      // Force reflow to pick up transitions
      window.getComputedStyle(t).opacity;
      setTimeout(()=> { t.style.opacity = '0'; t.style.transform = 'translateY(-10px)'; }, duration - 300);
      setTimeout(()=> { try { t.remove(); } catch(e){} }, duration);
    }
    // Export/import CSV
    exportBtn.addEventListener('click', () => {
      if (wheel.names.length === 0) { showMessage('No names to export.', 'warn'); return; }
      const csv = wheel.names.map(n => `"${(n||'').replace(/"/g,'""')}"`).join('\n');
      const blob = new Blob([csv], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'participants.csv';
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
      showMessage('Exported CSV', 'info');
    });
    importBtn.addEventListener('click', () => { importFile.click(); });
    importFile.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (ev) => {
        const txt = ev.target.result;
        const lines = txt.split(/\r?\n/).map(s => s.trim()).filter(s => s);
        // basic CSV unquote
        const parsed = lines.map(l => {
          // simple CSV single-column parse: handle quoted fields
          if (l.startsWith('"') && l.endsWith('"')) {
            return l.slice(1,-1).replace(/""/g,'"');
          }
          return l;
        });
        parsed.forEach(p => wheel.addName(p));
        updateUI();
        showMessage(`Imported ${parsed.length} names`, 'info');
      };
      reader.readAsText(file);
      importFile.value = '';
    });
    // Initial sample (optional)
    // wheel.addName('Alice'); wheel.addName('Bob'); wheel.addName('Charlie');
    updateUI();
    // (Optional) keyboard shortcuts
    window.addEventListener('keydown', (e) => {
      if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'k') {
        e.preventDefault();
        nameInput.focus();
      }
      if (e.key === ' ') {
        // space triggers spin if not focusing an input
        if (document.activeElement.tagName !== 'INPUT' && document.activeElement.tagName !== 'TEXTAREA') {
          e.preventDefault();
          spinBtn.click();
        }
      }
    });
  });
})(); 
```

[2025-17-09 13:41:30 INFO] **[Update Codes]**

index.html updated.


```
'''

'''
--- Old
+++ New
@@ -1,11 +1,9 @@
-'''
 <!--
 DOCSTRING
 This is the main HTML file for the Random Winner Wheel.
 It contains the structure: input fields to add names, a canvas for the wheel,
 controls (spin, clear, bulk add), theme selector, and placeholders for CSS/JS.
 -->
-'''
 <!doctype html>
 <html lang="en">
 <head>
@@ -57,7 +55,7 @@
     <section class="wheel-area">
       <div class="wheel-container">
         <canvas id="wheelCanvas" width="600" height="600" aria-label="Spinning wheel"></canvas>
-        <div class="pointer">▼</div>
+        <div class="pointer" aria-hidden="true">▼</div>
       </div>
       <aside class="participants">
         <h2>Participants (<span id="count">0</span>)</h2>
```

[2025-17-09 13:41:30 INFO] **[Update Codes]**

styles.css updated.


```
'''

'''
--- Old
+++ New
@@ -1,8 +1,8 @@
-'''
+/*
 DOCSTRING
 Stylesheet for the Random Winner Wheel.
-Defines layout, themes, wheel container sizing, and animations.
-'''
+Defines layout, themes, wheel container sizing, animations, and toast styles.
+*/
 /* Reset & base */
 * { box-sizing: border-box; margin: 0; padding: 0; }
 html,body { height: 100%; font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; background: var(--bg); color: var(--fg); }
@@ -86,3 +86,29 @@
 }
 /* Wheel canvas scaling helper */
 #wheelCanvas { border-radius:50%; box-shadow: 0 12px 26px rgba(0,0,0,0.12); background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.02), transparent); }
+/* Toast / temporary message styles (used by showMessage) */
+.tmp-toast {
+  position: fixed;
+  left: 50%;
+  transform: translateX(-50%);
+  top: 18px;
+  background: rgba(0,0,0,0.85);
+  color: #fff;
+  padding: 8px 12px;
+  border-radius: 6px;
+  z-index: 9999;
+  transition: opacity 0.25s, transform 0.25s;
+  opacity: 1;
+  pointer-events: none;
+  font-size: 0.95rem;
+  box-shadow: 0 6px 18px rgba(0,0,0,0.18);
+}
+.tmp-toast.success { background: rgba(56, 198, 123, 0.95); }
+.tmp-toast.warn    { background: rgba(255, 159, 67, 0.95); color: #2b1500; }
+.tmp-toast.info    { background: rgba(12, 74, 255, 0.95); }
+/* Winner highlight for participants list */
+#nameList li.winner {
+  outline: 3px solid rgba(255,215,0,0.15);
+  box-shadow: 0 6px 18px rgba(255,215,0,0.06);
+  transform: scale(1.01);
+}
```

[2025-17-09 13:41:30 INFO] **[Update Codes]**

script.js updated.


```
'''

'''
--- Old
+++ New
@@ -1,8 +1,8 @@
-'''
+/* 
 DOCSTRING
 Script for the Random Winner Wheel.
 Contains the Wheel class to draw and spin the canvas-based wheel and UI glue code to manage names and themes.
-'''
+*/
 /* Main JavaScript - Wheel + UI logic */
 (() => {
   // Utilities
@@ -38,12 +38,15 @@
     _devicePixelRatioFix() {
       const dpr = window.devicePixelRatio || 1;
       const rect = this.canvas.getBoundingClientRect();
-      this.canvas.width = rect.width * dpr;
-      this.canvas.height = rect.height * dpr;
+      // If rect has zero size (canvas not yet laid out), use current width/height attributes as fallback
+      const width = rect.width || (this.canvas.width / dpr);
+      const height = rect.height || (this.canvas.height / dpr);
+      this.canvas.width = width * dpr;
+      this.canvas.height = height * dpr;
       this.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
-      this.centerX = rect.width / 2;
-      this.centerY = rect.height / 2;
-      this.radius = Math.min(rect.width, rect.height) / 2 - 18;
+      this.centerX = width / 2;
+      this.centerY = height / 2;
+      this.radius = Math.min(width, height) / 2 - 18;
     }
     setTheme(themeId) { this.theme = themeId; this.draw(); }
     setNames(names) {
@@ -147,8 +150,9 @@
           this.rotation = ((this.rotation % (Math.PI*2)) + Math.PI*2) % (Math.PI*2);
           this.draw();
           // Compute final winner index again from rotation
-          const finalAngle = (-this.rotation - Math.PI/2 + Math.PI*2) % (Math.PI*2);
-          const resultingIndex = Math.floor(((finalAngle / (Math.PI*2)) * count + count) % count);
+          // finalAngle: the angle of the segment at pointer (0 at right, +counterclockwise). We compute a normalized angle that maps to segment index.
+          const finalAngle = ((-this.rotation - Math.PI/2) % (Math.PI*2) + Math.PI*2) % (Math.PI*2);
+          const resultingIndex = Math.floor((finalAngle / (Math.PI*2)) * count) % count;
           const winner = this.names[resultingIndex];
           this.onResult({ index: resultingIndex, name: winner });
         }
@@ -184,7 +188,7 @@
       }
     }
     if (line) lines.push(line);
-    // If still too many lines, shrink font or truncate
+    // If still too many lines, just draw what's possible (we rely on font size)
     for (let i=0;i<lines.length;i++){
       ctx.fillText(lines[i], x, y + (i - (lines.length-1)/2) * lineHeight);
     }
@@ -226,6 +230,7 @@
         li.appendChild(span);
         const btn = document.createElement('button');
         btn.title = 'Remove';
+        btn.setAttribute('aria-label', `Remove ${n}`);
         btn.innerHTML = '✕';
         btn.addEventListener('click', () => {
           wheel.removeName(i);
@@ -303,6 +308,8 @@
       t.className = 'tmp-toast ' + type;
       t.textContent = text;
       document.body.appendChild(t);
+      // Force reflow to pick up transitions
+      window.getComputedStyle(t).opacity;
       setTimeout(()=> { t.style.opacity = '0'; t.style.transform = 'translateY(-10px)'; }, duration - 300);
       setTimeout(()=> { try { t.remove(); } catch(e){} }, duration);
     }
@@ -331,6 +338,7 @@
         const lines = txt.split(/\r?\n/).map(s => s.trim()).filter(s => s);
         // basic CSV unquote
         const parsed = lines.map(l => {
+          // simple CSV single-column parse: handle quoted fields
           if (l.startsWith('"') && l.endsWith('"')) {
             return l.slice(1,-1).replace(/""/g,'"');
           }
@@ -343,7 +351,7 @@
       reader.readAsText(file);
       importFile.value = '';
     });
-    // Initial sample
+    // Initial sample (optional)
     // wheel.addName('Alice'); wheel.addName('Bob'); wheel.addName('Charlie');
     updateUI();
     // (Optional) keyboard shortcuts
@@ -361,4 +369,4 @@
       }
     });
   });
-})();
+})(); 
```

[2025-17-09 13:41:30 INFO] **[Software Info]**:

 

💰**cost**=$0.036593

🔨**version_updates**=-1

📃**num_code_files**=0

🏞**num_png_files**=0

📚**num_doc_files**=7

📃**code_lines**=0

📋**env_lines**=-1

📒**manual_lines**=-1

🗣**num_utterances**=11

🤔**num_self_reflections**=0

❓**num_prompt_tokens**=16194

❗**num_completion_tokens**=18997

🌟**num_total_tokens**=35191

[2025-17-09 13:41:30 INFO] **[Execute Detail]**

execute SimplePhase:[CodeReviewComment] in ComposedPhase:[CodeReview], cycle 2

[2025-17-09 13:41:30 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | [Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes. Do it in HTML, CSS, and JavaScript.] |
| **need_reflect** | False |
| **assistant_role_name** | Code Reviewer |
| **user_role_name** | Programmer |
| **phase_prompt** | According to the new user's task and our software designs:  Task: "{task}". Modality: "{modality}". Programming Language: "{language}" Ideas: "{ideas}" Codes: "{codes}" As the {assistant_role}, to make the software directly operable without further coding, ChatDev have formulated the following regulations: 1) all referenced classes should be imported; 2) all methods should be implemented; 3) all methods need to have the necessary comments; 4) no potential bugs; 5) The entire project conforms to the tasks proposed by the user; 6) most importantly, do not only check the errors in the code, but also the logic of code. Make sure that user can interact with generated software without losing any feature in the requirement; Now, you should check the above regulations one by one and review the codes in detail, propose one comment with the highest priority about the codes, and give me instructions on how to fix. Tell me your comment with the highest priority and corresponding suggestions on revision. If the codes are perfect and you have no comment on them, return only one line like " Finished". |
| **phase_name** | CodeReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Code Reviewer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. You can help programmers to assess source codes for software troubleshooting, fix bugs to increase code quality and robustness, and offer proposals to improve the source codes. Here is a new customer's task: {task}. To complete the task, you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Programmer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. You can write/create computer software or applications by providing a specific programming language to the computer. You have extensive computing and coding experience in many varieties of programming languages and platforms, such as Python, Java, C, C++, HTML, CSS, JavaScript, XML, SQL, PHP, etc,. Here is a new customer's task: {task}. To complete the task, you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': 'index.html\nhtml\n&lt;!--\nDOCSTRING\nThis is the main HTML file for the Random Winner Wheel.\nIt contains the structure: input fields to add names, a canvas for the wheel,\ncontrols (spin, clear, bulk add), theme selector, and placeholders for CSS/JS.\n--&gt;\n&lt;!doctype html&gt;\n&lt;html lang="en"&gt;\n&lt;head&gt;\n  &lt;meta charset="utf-8" /&gt;\n  &lt;meta name="viewport" content="width=device-width,initial-scale=1" /&gt;\n  &lt;title&gt;Random Winner Wheel&lt;/title&gt;\n  &lt;link rel="stylesheet" href="styles.css"&gt;\n&lt;/head&gt;\n&lt;body class="theme-light"&gt;\n  &lt;header&gt;\n    &lt;h1&gt;Random Winner Wheel&lt;/h1&gt;\n    &lt;p&gt;Enter participant names, choose a theme, and spin to pick a winner.&lt;/p&gt;\n  &lt;/header&gt;\n  &lt;main&gt;\n    &lt;section class="controls"&gt;\n      &lt;div class="add-single"&gt;\n        &lt;input id="nameInput" type="text" placeholder="Enter a name and press Add" aria-label="Name input" /&gt;\n        &lt;button id="addBtn"&gt;Add&lt;/button&gt;\n        &lt;button id="addRandomBtn" title="Add a few sample random names"&gt;Add Sample&lt;/button&gt;\n      &lt;/div&gt;\n      &lt;div class="bulk-add"&gt;\n        &lt;label for="bulkInput"&gt;Bulk add (comma, newline or semicolon separated):&lt;/label&gt;\n        &lt;textarea id="bulkInput" placeholder="Alice, Bob, Charlie"&gt;&lt;/textarea&gt;\n        &lt;div class="bulk-actions"&gt;\n          &lt;button id="bulkAddBtn"&gt;Bulk Add&lt;/button&gt;\n          &lt;button id="clearBulkBtn"&gt;Clear Bulk&lt;/button&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;\n      &lt;div class="list-actions"&gt;\n        &lt;div class="theme-select"&gt;\n          &lt;label for="themeSelect"&gt;Theme:&lt;/label&gt;\n          &lt;select id="themeSelect"&gt;\n            &lt;option value="light"&gt;Light&lt;/option&gt;\n            &lt;option value="dark"&gt;Dark&lt;/option&gt;\n            &lt;option value="neon"&gt;Neon&lt;/option&gt;\n            &lt;option value="pastel"&gt;Pastel&lt;/option&gt;\n            &lt;option value="retro"&gt;Retro&lt;/option&gt;\n          &lt;/select&gt;\n        &lt;/div&gt;\n        &lt;div class="wheel-controls"&gt;\n          &lt;button id="spinBtn" class="primary"&gt;Spin&lt;/button&gt;\n          &lt;button id="clearNamesBtn"&gt;Clear Names&lt;/button&gt;\n          &lt;button id="exportBtn"&gt;Export CSV&lt;/button&gt;\n          &lt;input id="importFile" type="file" accept=".csv,text/csv" style="display:none"&gt;\n          &lt;button id="importBtn"&gt;Import CSV&lt;/button&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;\n    &lt;/section&gt;\n    &lt;section class="wheel-area"&gt;\n      &lt;div class="wheel-container"&gt;\n        &lt;canvas id="wheelCanvas" width="600" height="600" aria-label="Spinning wheel"&gt;&lt;/canvas&gt;\n        &lt;div class="pointer" aria-hidden="true"&gt;▼&lt;/div&gt;\n      &lt;/div&gt;\n      &lt;aside class="participants"&gt;\n        &lt;h2&gt;Participants (&lt;span id="count"&gt;0&lt;/span&gt;)&lt;/h2&gt;\n        &lt;ul id="nameList" aria-live="polite"&gt;&lt;/ul&gt;\n      &lt;/aside&gt;\n    &lt;/section&gt;\n    &lt;section class="result" id="result" aria-live="polite" hidden&gt;\n      &lt;h2&gt;Winner&lt;/h2&gt;\n      &lt;div id="winnerName" class="winnerName"&gt;&lt;/div&gt;\n      &lt;button id="rerollBtn"&gt;Spin Again&lt;/button&gt;\n    &lt;/section&gt;\n  &lt;/main&gt;\n  &lt;footer&gt;\n    &lt;small&gt;Built with HTML, CSS, and JavaScript. Themes change both UI and wheel colors.&lt;/small&gt;\n  &lt;/footer&gt;\n  &lt;script src="script.js"&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\n\nstyles.css\ncss\n/*\nDOCSTRING\nStylesheet for the Random Winner Wheel.\nDefines layout, themes, wheel container sizing, animations, and toast styles.\n*/\n/* Reset &amp; base */\n* { box-sizing: border-box; margin: 0; padding: 0; }\nhtml,body { height: 100%; font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; background: var(--bg); color: var(--fg); }\n:root {\n  --bg: #f7f8fb;\n  --fg: #222;\n  --muted: #666;\n  --accent: #2b8cff;\n  --card: #ffffff;\n  --primary-btn-bg: var(--accent);\n  --primary-btn-fg: #fff;\n  --shadow: rgba(15,15,15,0.08);\n}\n/* Themes */\nbody.theme-light {\n  --bg: #f7f8fb;\n  --fg: #222;\n  --muted: #5b6170;\n  --accent: #2b8cff;\n  --card: #fff;\n  --wheel-seq: 0;\n}\nbody.theme-dark {\n  --bg: #0f1724;\n  --fg: #e6eef8;\n  --muted: #a9b1c2;\n  --accent: #7c5cff;\n  --card: #0b1220;\n}\nbody.theme-neon {\n  --bg: #0a0a0f;\n  --fg: #e9f9ff;\n  --muted: #a6f3ff;\n  --accent: #39ff14;\n  --card: #09101a;\n}\nbody.theme-pastel {\n  --bg: #fffaf6;\n  --fg: #3c3a3a;\n  --muted: #8d8a8a;\n  --accent: #ff7aa2;\n  --card: #fff;\n}\nbody.theme-retro {\n  --bg: #fff6e7;\n  --fg: #402b2b;\n  --muted: #856e6e;\n  --accent: #ffb86b;\n  --card: #fff0e6;\n}\n/* Layout */\nheader { padding: 18px 24px; text-align: center; background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent); }\nheader h1 { font-size: 1.5rem; margin-bottom: 6px; }\nmain { padding: 18px; max-width: 1100px; margin: 0 auto; }\n.controls { display: grid; gap: 12px; margin-bottom: 18px; }\n.add-single { display:flex; gap:8px; }\n.add-single input[type="text"] { flex:1; padding:10px; border-radius:8px; border:1px solid rgba(0,0,0,0.08); background:var(--card); color:var(--fg); }\n.add-single button { padding:10px 12px; border-radius:8px; border: none; cursor:pointer; background: var(--primary-btn-bg); color: var(--primary-btn-fg); }\n.add-single button#addRandomBtn { background: transparent; border: 1px solid rgba(0,0,0,0.06); color: var(--fg); }\n.bulk-add textarea { width:100%; min-height:64px; margin-top:6px; padding:8px; border-radius:8px; border:1px solid rgba(0,0,0,0.06); background:var(--card); color:var(--fg); }\n.bulk-actions { display:flex; gap:8px; margin-top:8px; }\n.list-actions { display:flex; justify-content:space-between; align-items:center; gap:16px; flex-wrap:wrap; }\n.theme-select select { padding:8px; border-radius:8px; border:1px solid rgba(0,0,0,0.06); }\n.wheel-area { display:flex; gap:18px; align-items:start; flex-wrap:wrap; }\n.wheel-container { position: relative; width: 600px; height: 600px; max-width: 90vw; max-height: 90vw; display:flex; align-items:center; justify-content:center; background: transparent; }\n.pointer { position:absolute; top:6px; font-size:28px; transform: translateY(-50%); text-shadow: 0 2px 8px rgba(0,0,0,0.25); color: var(--accent); pointer-events:none; }\n.participants { width: 320px; max-width: 40vw; background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent); padding:12px; border-radius:10px; box-shadow: 0 6px 18px var(--shadow); }\n.participants h2 { margin-bottom:8px; font-size:1.05rem; }\n#nameList { list-style:none; max-height:420px; overflow:auto; display:block; }\n#nameList li { padding:8px; border-radius:6px; display:flex; justify-content:space-between; align-items:center; gap:8px; margin-bottom:8px; background: var(--card); border:1px solid rgba(0,0,0,0.04); }\n#nameList li button { background: transparent; border: none; color: var(--muted); cursor:pointer; }\n.result { margin-top:18px; padding:12px; border-radius:8px; background: var(--card); text-align:center; box-shadow: 0 6px 18px var(--shadow); }\n.result .winnerName { font-size:1.4rem; font-weight:700; margin:8px 0; color: var(--accent); }\n/* Buttons */\nbutton { cursor:pointer; padding:8px 12px; border-radius:8px; border:1px solid rgba(0,0,0,0.06); background: transparent; color:var(--fg); }\nbutton.primary { background: var(--primary-btn-bg); color: var(--primary-btn-fg); border: none; }\n/* Responsive */\n@media (max-width: 900px) {\n  .wheel-area { flex-direction:column; align-items:center; }\n  .participants { width: 100%; max-width: 100%; }\n}\n/* Wheel canvas scaling helper */\n#wheelCanvas { border-radius:50%; box-shadow: 0 12px 26px rgba(0,0,0,0.12); background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.02), transparent); }\n\n/* Toast / temporary message styles (used by showMessage) */\n.tmp-toast {\n  position: fixed;\n  left: 50%;\n  transform: translateX(-50%);\n  top: 18px;\n  background: rgba(0,0,0,0.85);\n  color: #fff;\n  padding: 8px 12px;\n  border-radius: 6px;\n  z-index: 9999;\n  transition: opacity 0.25s, transform 0.25s;\n  opacity: 1;\n  pointer-events: none;\n  font-size: 0.95rem;\n  box-shadow: 0 6px 18px rgba(0,0,0,0.18);\n}\n.tmp-toast.success { background: rgba(56, 198, 123, 0.95); }\n.tmp-toast.warn    { background: rgba(255, 159, 67, 0.95); color: #2b1500; }\n.tmp-toast.info    { background: rgba(12, 74, 255, 0.95); }\n\n/* Winner highlight for participants list */\n#nameList li.winner {\n  outline: 3px solid rgba(255,215,0,0.15);\n  box-shadow: 0 6px 18px rgba(255,215,0,0.06);\n  transform: scale(1.01);\n}\n\n\nscript.js\njs\n/* \nDOCSTRING\nScript for the Random Winner Wheel.\nContains the Wheel class to draw and spin the canvas-based wheel and UI glue code to manage names and themes.\n*/\n/* Main JavaScript - Wheel + UI logic */\n(() =&gt; {\n  // Utilities\n  function rand(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }\n  function easeOutCubic(t) { return 1 - Math.pow(1 - t, 3); }\n  // Color palettes for themes (will be used to paint wheel segments)\n  const THEME_PALETTES = {\n    light: [\'#FF8A80\',\'#FFD180\',\'#FFF59D\',\'#C8E6C9\',\'#80DEEA\',\'#A7FFEB\',\'#B39DDB\',\'#90CAF9\'],\n    dark: [\'#ff6b6b\',\'#ffd166\',\'#faff8e\',\'#b9f6ca\',\'#4dd0e1\',\'#80cbc4\',\'#b388ff\',\'#64b5f6\'],\n    neon: [\'#ff2d95\',\'#7cff01\',\'#00ffff\',\'#ffdd00\',\'#ff6a00\',\'#00ff9e\',\'#ff00ff\',\'#47ffa2\'],\n    pastel: [\'#ffdbe9\',\'#fff0b3\',\'#d1ffd6\',\'#cfefff\',\'#e7dfff\',\'#ffd6e7\',\'#fbe7d6\',\'#e6f7ff\'],\n    retro: [\'#ffb86b\',\'#ffd3a8\',\'#f3e2a9\',\'#b8e0d2\',\'#c0b9ff\',\'#ffb6c1\',\'#f6c49f\',\'#c3d69b\']\n  };\n  // Wheel class\n  class Wheel {\n    /*\n    Manage wheel: drawing, recalculating segments, spinning animation, and determining winner.\n    */\n    constructor(canvas, options = {}) {\n      this.canvas = canvas;\n      this.ctx = canvas.getContext(\'2d\');\n      this.names = [];\n      this.rotation = 0; // radians\n      this.isSpinning = false;\n      this.frame = null;\n      this.onResult = options.onResult || function() {};\n      this.theme = options.theme || \'light\';\n      this.padAngle = 0.02; // radians padding between segments\n      this.textColor = \'#111\';\n      this._devicePixelRatioFix();\n      window.addEventListener(\'resize\', () =&gt; { this._devicePixelRatioFix(); this.draw(); });\n    }\n    _devicePixelRatioFix() {\n      const dpr = window.devicePixelRatio || 1;\n      const rect = this.canvas.getBoundingClientRect();\n      // If rect has zero size (canvas not yet laid out), use current width/height attributes as fallback\n      const width = rect.width || (this.canvas.width / dpr);\n      const height = rect.height || (this.canvas.height / dpr);\n      this.canvas.width = width * dpr;\n      this.canvas.height = height * dpr;\n      this.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n      this.centerX = width / 2;\n      this.centerY = height / 2;\n      this.radius = Math.min(width, height) / 2 - 18;\n    }\n    setTheme(themeId) { this.theme = themeId; this.draw(); }\n    setNames(names) {\n      this.names = names.slice();\n      this.draw();\n    }\n    addName(name) {\n      this.names.push(name);\n      this.draw();\n    }\n    removeName(index) {\n      if (index &gt;= 0 &amp;&amp; index &lt; this.names.length) {\n        this.names.splice(index,1);\n        this.draw();\n      }\n    }\n    clearNames() {\n      this.names = [];\n      this.draw();\n    }\n    draw() {\n      const ctx = this.ctx;\n      const w = this.canvas.width / (window.devicePixelRatio || 1);\n      const h = this.canvas.height / (window.devicePixelRatio || 1);\n      ctx.clearRect(0,0,w,h);\n      ctx.save();\n      ctx.translate(this.centerX, this.centerY);\n      ctx.rotate(this.rotation);\n      // draw segments\n      const count = Math.max(this.names.length, 1);\n      const palette = THEME_PALETTES[this.theme] || THEME_PALETTES.light;\n      for (let i = 0; i &lt; count; i++) {\n        const start = (i / count) * Math.PI * 2;\n        const end = ((i + 1) / count) * Math.PI * 2;\n        ctx.beginPath();\n        ctx.moveTo(0,0);\n        ctx.arc(0,0,this.radius, start + this.padAngle, end - this.padAngle, false);\n        ctx.closePath();\n        const color = palette[i % palette.length];\n        ctx.fillStyle = color;\n        ctx.fill();\n        ctx.strokeStyle = (i % 2 === 0) ? \'rgba(0,0,0,0.06)\' : \'rgba(0,0,0,0.03)\';\n        ctx.lineWidth = 1;\n        ctx.stroke();\n        // draw text label\n        const mid = (start + end) / 2;\n        ctx.save();\n        ctx.rotate(mid);\n        ctx.translate(this.radius * 0.6, 0);\n        ctx.rotate(Math.PI/2);\n        ctx.fillStyle = getTextColor(color);\n        ctx.font = `${Math.max(12, Math.min(22, this.radius / 8))}px sans-serif`;\n        ctx.textAlign = \'center\';\n        ctx.textBaseline = \'middle\';\n        const label = (this.names.length === 0) ? \'Add names\' : this.names[i % this.names.length];\n        wrapFillText(ctx, label, 0, 0, this.radius * 0.5, 16);\n        ctx.restore();\n      }\n      // draw center circle\n      ctx.beginPath();\n      ctx.arc(0,0, this.radius * 0.16, 0, Math.PI*2);\n      ctx.fillStyle = \'rgba(255,255,255,0.9)\';\n      ctx.fill();\n      ctx.strokeStyle = \'rgba(0,0,0,0.06)\';\n      ctx.stroke();\n      ctx.restore();\n      // draw outer ring (pointer side neutral)\n      ctx.beginPath();\n      ctx.arc(this.centerX, this.centerY, this.radius + 10, 0, Math.PI*2);\n      ctx.strokeStyle = \'rgba(0,0,0,0.03)\';\n      ctx.lineWidth = 2;\n      ctx.stroke();\n    }\n    spin() {\n      if (this.isSpinning || this.names.length === 0) return;\n      this.isSpinning = true;\n      const count = this.names.length;\n      // Determine random winner index to land on:\n      const winnerIndex = rand(0, count - 1);\n      // Calculate final rotation so that winner segment lines up with pointer at top (pointer at canvas top - rotation must align)\n      // Our pointer is at the top (canvas 0 angle). The segment mid-angle for index i (without rotation) is ((i + 0.5)/count)*2pi\n      const segmentMid = ((winnerIndex + 0.5) / count) * Math.PI * 2;\n      // We want segmentMid + rotation_final == -Math.PI/2 (so it points at the top pointer), so rotation_final = -Math.PI/2 - segmentMid + 2pi*N\n      const extraTurns = rand(5, 8); // full spins\n      const rotationFinal = -Math.PI/2 - segmentMid + extraTurns * Math.PI * 2;\n      const startRotation = this.rotation % (Math.PI * 2);\n      const delta = rotationFinal - startRotation;\n      const duration = 4000 + Math.random() * 1500; // ms\n      const startTime = performance.now();\n      const animate = (now) =&gt; {\n        const elapsed = now - startTime;\n        const t = Math.min(elapsed / duration, 1);\n        const eased = easeOutCubic(t);\n        this.rotation = startRotation + delta * eased;\n        this.draw();\n        if (t &lt; 1) {\n          this.frame = requestAnimationFrame(animate);\n        } else {\n          this.isSpinning = false;\n          // Normalize rotation within 0..2pi\n          this.rotation = ((this.rotation % (Math.PI*2)) + Math.PI*2) % (Math.PI*2);\n          this.draw();\n          // Compute final winner index again from rotation\n          // finalAngle: the angle of the segment at pointer (0 at right, +counterclockwise). We compute a normalized angle that maps to segment index.\n          const finalAngle = ((-this.rotation - Math.PI/2) % (Math.PI*2) + Math.PI*2) % (Math.PI*2);\n          const resultingIndex = Math.floor((finalAngle / (Math.PI*2)) * count) % count;\n          const winner = this.names[resultingIndex];\n          this.onResult({ index: resultingIndex, name: winner });\n        }\n      };\n      this.frame = requestAnimationFrame(animate);\n    }\n  }\n  // Helper: pick readable text color for a background\n  function getTextColor(hex) {\n    // remove # and convert\n    const h = hex.replace(\'#\',\'\');\n    const r = parseInt(h.substring(0,2),16);\n    const g = parseInt(h.substring(2,4),16);\n    const b = parseInt(h.substring(4,6),16);\n    // luminance\n    const lum = (0.299*r + 0.587*g + 0.114*b) / 255;\n    return lum &gt; 0.65 ? \'#111\' : \'#fff\';\n  }\n  // Helper: wrap text within a given width (draws multi-line if necessary)\n  function wrapFillText(ctx, text, x, y, maxWidth, lineHeight) {\n    const words = (text || \'\').split(/\\s+/);\n    if (words.length === 0) return;\n    let line = \'\';\n    const lines = [];\n    for (let n = 0; n &lt; words.length; n++) {\n      const testLine = line ? line + \' \' + words[n] : words[n];\n      const metrics = ctx.measureText(testLine);\n      if (metrics.width &gt; maxWidth &amp;&amp; line) {\n        lines.push(line);\n        line = words[n];\n      } else {\n        line = testLine;\n      }\n    }\n    if (line) lines.push(line);\n    // If still too many lines, just draw what\'s possible (we rely on font size)\n    for (let i=0;i&lt;lines.length;i++){\n      ctx.fillText(lines[i], x, y + (i - (lines.length-1)/2) * lineHeight);\n    }\n  }\n  // UI glue\n  document.addEventListener(\'DOMContentLoaded\', () =&gt; {\n    const canvas = document.getElementById(\'wheelCanvas\');\n    const wheel = new Wheel(canvas, { theme: \'light\', onResult: onWinner });\n    const nameInput = document.getElementById(\'nameInput\');\n    const addBtn = document.getElementById(\'addBtn\');\n    const addRandomBtn = document.getElementById(\'addRandomBtn\');\n    const bulkInput = document.getElementById(\'bulkInput\');\n    const bulkAddBtn = document.getElementById(\'bulkAddBtn\');\n    const clearBulkBtn = document.getElementById(\'clearBulkBtn\');\n    const nameList = document.getElementById(\'nameList\');\n    const countSpan = document.getElementById(\'count\');\n    const spinBtn = document.getElementById(\'spinBtn\');\n    const rerollBtn = document.getElementById(\'rerollBtn\');\n    const clearNamesBtn = document.getElementById(\'clearNamesBtn\');\n    const themeSelect = document.getElementById(\'themeSelect\');\n    const resultSection = document.getElementById(\'result\');\n    const winnerNameDiv = document.getElementById(\'winnerName\');\n    const exportBtn = document.getElementById(\'exportBtn\');\n    const importBtn = document.getElementById(\'importBtn\');\n    const importFile = document.getElementById(\'importFile\');\n    // Initial draw\n    wheel.draw();\n    function updateUI() {\n      const names = wheel.names;\n      countSpan.textContent = names.length;\n      renderNameList();\n    }\n    function renderNameList() {\n      nameList.innerHTML = \'\';\n      wheel.names.forEach((n, i) =&gt; {\n        const li = document.createElement(\'li\');\n        const span = document.createElement(\'span\');\n        span.textContent = n;\n        li.appendChild(span);\n        const btn = document.createElement(\'button\');\n        btn.title = \'Remove\';\n        btn.setAttribute(\'aria-label\', `Remove ${n}`);\n        btn.innerHTML = \'✕\';\n        btn.addEventListener(\'click\', () =&gt; {\n          wheel.removeName(i);\n          updateUI();\n        });\n        li.appendChild(btn);\n        nameList.appendChild(li);\n      });\n    }\n    function addNameFromInput() {\n      const v = nameInput.value.trim();\n      if (!v) { showMessage(\'Please enter a name.\', \'warn\'); return; }\n      wheel.addName(v);\n      nameInput.value = \'\';\n      updateUI();\n    }\n    addBtn.addEventListener(\'click\', addNameFromInput);\n    nameInput.addEventListener(\'keydown\', (e) =&gt; { if (e.key === \'Enter\') addNameFromInput(); });\n    addRandomBtn.addEventListener(\'click\', () =&gt; {\n      const samples = [\'Alex\',\'Jordan\',\'Taylor\',\'Sam\',\'Jamie\',\'Casey\',\'Morgan\',\'Riley\',\'Avery\',\'Dana\'];\n      const count = rand(3,6);\n      for (let i=0;i&lt;count;i++) wheel.addName(samples[rand(0,samples.length-1)] + (rand(1,100)));\n      updateUI();\n    });\n    bulkAddBtn.addEventListener(\'click\', () =&gt; {\n      const text = bulkInput.value.trim();\n      if (!text) { showMessage(\'Bulk input is empty.\', \'warn\'); return; }\n      const parsed = text.split(/[\\n,;]+/).map(s =&gt; s.trim()).filter(s =&gt; s);\n      parsed.forEach(p =&gt; wheel.addName(p));\n      bulkInput.value = \'\';\n      updateUI();\n      showMessage(`Added ${parsed.length} names.`, \'info\');\n    });\n    clearBulkBtn.addEventListener(\'click\', () =&gt; { bulkInput.value = \'\'; });\n    spinBtn.addEventListener(\'click\', () =&gt; {\n      if (wheel.names.length === 0) { showMessage(\'Add at least one name to spin.\', \'warn\'); return; }\n      resultSection.hidden = true;\n      winnerNameDiv.textContent = \'\';\n      wheel.spin();\n      spinBtn.disabled = true;\n      const checkFinish = setInterval(() =&gt; {\n        if (!wheel.isSpinning) {\n          clearInterval(checkFinish);\n          spinBtn.disabled = false;\n        }\n      }, 200);\n    });\n    rerollBtn.addEventListener(\'click\', () =&gt; {\n      resultSection.hidden = true;\n      wheel.spin();\n    });\n    clearNamesBtn.addEventListener(\'click\', () =&gt; {\n      if (confirm(\'Clear all names?\')) {\n        wheel.clearNames();\n        updateUI();\n      }\n    });\n    themeSelect.addEventListener(\'change\', (e) =&gt; {\n      const t = e.target.value;\n      document.body.className = \'theme-\' + t;\n      wheel.setTheme(t);\n    });\n    function onWinner(result) {\n      winnerNameDiv.textContent = result.name || \'—\';\n      resultSection.hidden = false;\n      // Flash the winner item in the list (if still present)\n      const items = Array.from(nameList.children);\n      items.forEach((li, idx) =&gt; { li.classList.toggle(\'winner\', idx === result.index); });\n      showMessage(`Winner: ${result.name}`, \'success\', 4000);\n    }\n    // Simple message area\n    function showMessage(text, type = \'info\', duration = 2200) {\n      // create small toast\n      const t = document.createElement(\'div\');\n      t.className = \'tmp-toast \' + type;\n      t.textContent = text;\n      document.body.appendChild(t);\n      // Force reflow to pick up transitions\n      window.getComputedStyle(t).opacity;\n      setTimeout(()=&gt; { t.style.opacity = \'0\'; t.style.transform = \'translateY(-10px)\'; }, duration - 300);\n      setTimeout(()=&gt; { try { t.remove(); } catch(e){} }, duration);\n    }\n    // Export/import CSV\n    exportBtn.addEventListener(\'click\', () =&gt; {\n      if (wheel.names.length === 0) { showMessage(\'No names to export.\', \'warn\'); return; }\n      const csv = wheel.names.map(n =&gt; `"${(n||\'\').replace(/"/g,\'""\')}"`).join(\'\\n\');\n      const blob = new Blob([csv], { type: \'text/csv\' });\n      const url = URL.createObjectURL(blob);\n      const a = document.createElement(\'a\');\n      a.href = url;\n      a.download = \'participants.csv\';\n      document.body.appendChild(a);\n      a.click();\n      a.remove();\n      URL.revokeObjectURL(url);\n      showMessage(\'Exported CSV\', \'info\');\n    });\n    importBtn.addEventListener(\'click\', () =&gt; { importFile.click(); });\n    importFile.addEventListener(\'change\', (e) =&gt; {\n      const file = e.target.files[0];\n      if (!file) return;\n      const reader = new FileReader();\n      reader.onload = (ev) =&gt; {\n        const txt = ev.target.result;\n        const lines = txt.split(/\\r?\\n/).map(s =&gt; s.trim()).filter(s =&gt; s);\n        // basic CSV unquote\n        const parsed = lines.map(l =&gt; {\n          // simple CSV single-column parse: handle quoted fields\n          if (l.startsWith(\'"\') &amp;&amp; l.endsWith(\'"\')) {\n            return l.slice(1,-1).replace(/""/g,\'"\');\n          }\n          return l;\n        });\n        parsed.forEach(p =&gt; wheel.addName(p));\n        updateUI();\n        showMessage(`Imported ${parsed.length} names`, \'info\');\n      };\n      reader.readAsText(file);\n      importFile.value = \'\';\n    });\n    // Initial sample (optional)\n    // wheel.addName(\'Alice\'); wheel.addName(\'Bob\'); wheel.addName(\'Charlie\');\n    updateUI();\n    // (Optional) keyboard shortcuts\n    window.addEventListener(\'keydown\', (e) =&gt; {\n      if ((e.ctrlKey || e.metaKey) &amp;&amp; e.key.toLowerCase() === \'k\') {\n        e.preventDefault();\n        nameInput.focus();\n      }\n      if (e.key === \' \') {\n        // space triggers spin if not focusing an input\n        if (document.activeElement.tagName !== \'INPUT\' &amp;&amp; document.activeElement.tagName !== \'TEXTAREA\') {\n          e.preventDefault();\n          spinBtn.click();\n        }\n      }\n    });\n  });\n})(); \n', 'cycle_index': 2, 'task': '[Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes. Do it in HTML, CSS, and JavaScript.]', 'modality': 'website', 'ideas': '', 'language': ' JavaScript', 'codes': 'index.html\nhtml\n&lt;!--\nDOCSTRING\nThis is the main HTML file for the Random Winner Wheel.\nIt contains the structure: input fields to add names, a canvas for the wheel,\ncontrols (spin, clear, bulk add), theme selector, and placeholders for CSS/JS.\n--&gt;\n&lt;!doctype html&gt;\n&lt;html lang="en"&gt;\n&lt;head&gt;\n  &lt;meta charset="utf-8" /&gt;\n  &lt;meta name="viewport" content="width=device-width,initial-scale=1" /&gt;\n  &lt;title&gt;Random Winner Wheel&lt;/title&gt;\n  &lt;link rel="stylesheet" href="styles.css"&gt;\n&lt;/head&gt;\n&lt;body class="theme-light"&gt;\n  &lt;header&gt;\n    &lt;h1&gt;Random Winner Wheel&lt;/h1&gt;\n    &lt;p&gt;Enter participant names, choose a theme, and spin to pick a winner.&lt;/p&gt;\n  &lt;/header&gt;\n  &lt;main&gt;\n    &lt;section class="controls"&gt;\n      &lt;div class="add-single"&gt;\n        &lt;input id="nameInput" type="text" placeholder="Enter a name and press Add" aria-label="Name input" /&gt;\n        &lt;button id="addBtn"&gt;Add&lt;/button&gt;\n        &lt;button id="addRandomBtn" title="Add a few sample random names"&gt;Add Sample&lt;/button&gt;\n      &lt;/div&gt;\n      &lt;div class="bulk-add"&gt;\n        &lt;label for="bulkInput"&gt;Bulk add (comma, newline or semicolon separated):&lt;/label&gt;\n        &lt;textarea id="bulkInput" placeholder="Alice, Bob, Charlie"&gt;&lt;/textarea&gt;\n        &lt;div class="bulk-actions"&gt;\n          &lt;button id="bulkAddBtn"&gt;Bulk Add&lt;/button&gt;\n          &lt;button id="clearBulkBtn"&gt;Clear Bulk&lt;/button&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;\n      &lt;div class="list-actions"&gt;\n        &lt;div class="theme-select"&gt;\n          &lt;label for="themeSelect"&gt;Theme:&lt;/label&gt;\n          &lt;select id="themeSelect"&gt;\n            &lt;option value="light"&gt;Light&lt;/option&gt;\n            &lt;option value="dark"&gt;Dark&lt;/option&gt;\n            &lt;option value="neon"&gt;Neon&lt;/option&gt;\n            &lt;option value="pastel"&gt;Pastel&lt;/option&gt;\n            &lt;option value="retro"&gt;Retro&lt;/option&gt;\n          &lt;/select&gt;\n        &lt;/div&gt;\n        &lt;div class="wheel-controls"&gt;\n          &lt;button id="spinBtn" class="primary"&gt;Spin&lt;/button&gt;\n          &lt;button id="clearNamesBtn"&gt;Clear Names&lt;/button&gt;\n          &lt;button id="exportBtn"&gt;Export CSV&lt;/button&gt;\n          &lt;input id="importFile" type="file" accept=".csv,text/csv" style="display:none"&gt;\n          &lt;button id="importBtn"&gt;Import CSV&lt;/button&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;\n    &lt;/section&gt;\n    &lt;section class="wheel-area"&gt;\n      &lt;div class="wheel-container"&gt;\n        &lt;canvas id="wheelCanvas" width="600" height="600" aria-label="Spinning wheel"&gt;&lt;/canvas&gt;\n        &lt;div class="pointer" aria-hidden="true"&gt;▼&lt;/div&gt;\n      &lt;/div&gt;\n      &lt;aside class="participants"&gt;\n        &lt;h2&gt;Participants (&lt;span id="count"&gt;0&lt;/span&gt;)&lt;/h2&gt;\n        &lt;ul id="nameList" aria-live="polite"&gt;&lt;/ul&gt;\n      &lt;/aside&gt;\n    &lt;/section&gt;\n    &lt;section class="result" id="result" aria-live="polite" hidden&gt;\n      &lt;h2&gt;Winner&lt;/h2&gt;\n      &lt;div id="winnerName" class="winnerName"&gt;&lt;/div&gt;\n      &lt;button id="rerollBtn"&gt;Spin Again&lt;/button&gt;\n    &lt;/section&gt;\n  &lt;/main&gt;\n  &lt;footer&gt;\n    &lt;small&gt;Built with HTML, CSS, and JavaScript. Themes change both UI and wheel colors.&lt;/small&gt;\n  &lt;/footer&gt;\n  &lt;script src="script.js"&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\n\nstyles.css\ncss\n/*\nDOCSTRING\nStylesheet for the Random Winner Wheel.\nDefines layout, themes, wheel container sizing, animations, and toast styles.\n*/\n/* Reset &amp; base */\n* { box-sizing: border-box; margin: 0; padding: 0; }\nhtml,body { height: 100%; font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; background: var(--bg); color: var(--fg); }\n:root {\n  --bg: #f7f8fb;\n  --fg: #222;\n  --muted: #666;\n  --accent: #2b8cff;\n  --card: #ffffff;\n  --primary-btn-bg: var(--accent);\n  --primary-btn-fg: #fff;\n  --shadow: rgba(15,15,15,0.08);\n}\n/* Themes */\nbody.theme-light {\n  --bg: #f7f8fb;\n  --fg: #222;\n  --muted: #5b6170;\n  --accent: #2b8cff;\n  --card: #fff;\n  --wheel-seq: 0;\n}\nbody.theme-dark {\n  --bg: #0f1724;\n  --fg: #e6eef8;\n  --muted: #a9b1c2;\n  --accent: #7c5cff;\n  --card: #0b1220;\n}\nbody.theme-neon {\n  --bg: #0a0a0f;\n  --fg: #e9f9ff;\n  --muted: #a6f3ff;\n  --accent: #39ff14;\n  --card: #09101a;\n}\nbody.theme-pastel {\n  --bg: #fffaf6;\n  --fg: #3c3a3a;\n  --muted: #8d8a8a;\n  --accent: #ff7aa2;\n  --card: #fff;\n}\nbody.theme-retro {\n  --bg: #fff6e7;\n  --fg: #402b2b;\n  --muted: #856e6e;\n  --accent: #ffb86b;\n  --card: #fff0e6;\n}\n/* Layout */\nheader { padding: 18px 24px; text-align: center; background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent); }\nheader h1 { font-size: 1.5rem; margin-bottom: 6px; }\nmain { padding: 18px; max-width: 1100px; margin: 0 auto; }\n.controls { display: grid; gap: 12px; margin-bottom: 18px; }\n.add-single { display:flex; gap:8px; }\n.add-single input[type="text"] { flex:1; padding:10px; border-radius:8px; border:1px solid rgba(0,0,0,0.08); background:var(--card); color:var(--fg); }\n.add-single button { padding:10px 12px; border-radius:8px; border: none; cursor:pointer; background: var(--primary-btn-bg); color: var(--primary-btn-fg); }\n.add-single button#addRandomBtn { background: transparent; border: 1px solid rgba(0,0,0,0.06); color: var(--fg); }\n.bulk-add textarea { width:100%; min-height:64px; margin-top:6px; padding:8px; border-radius:8px; border:1px solid rgba(0,0,0,0.06); background:var(--card); color:var(--fg); }\n.bulk-actions { display:flex; gap:8px; margin-top:8px; }\n.list-actions { display:flex; justify-content:space-between; align-items:center; gap:16px; flex-wrap:wrap; }\n.theme-select select { padding:8px; border-radius:8px; border:1px solid rgba(0,0,0,0.06); }\n.wheel-area { display:flex; gap:18px; align-items:start; flex-wrap:wrap; }\n.wheel-container { position: relative; width: 600px; height: 600px; max-width: 90vw; max-height: 90vw; display:flex; align-items:center; justify-content:center; background: transparent; }\n.pointer { position:absolute; top:6px; font-size:28px; transform: translateY(-50%); text-shadow: 0 2px 8px rgba(0,0,0,0.25); color: var(--accent); pointer-events:none; }\n.participants { width: 320px; max-width: 40vw; background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent); padding:12px; border-radius:10px; box-shadow: 0 6px 18px var(--shadow); }\n.participants h2 { margin-bottom:8px; font-size:1.05rem; }\n#nameList { list-style:none; max-height:420px; overflow:auto; display:block; }\n#nameList li { padding:8px; border-radius:6px; display:flex; justify-content:space-between; align-items:center; gap:8px; margin-bottom:8px; background: var(--card); border:1px solid rgba(0,0,0,0.04); }\n#nameList li button { background: transparent; border: none; color: var(--muted); cursor:pointer; }\n.result { margin-top:18px; padding:12px; border-radius:8px; background: var(--card); text-align:center; box-shadow: 0 6px 18px var(--shadow); }\n.result .winnerName { font-size:1.4rem; font-weight:700; margin:8px 0; color: var(--accent); }\n/* Buttons */\nbutton { cursor:pointer; padding:8px 12px; border-radius:8px; border:1px solid rgba(0,0,0,0.06); background: transparent; color:var(--fg); }\nbutton.primary { background: var(--primary-btn-bg); color: var(--primary-btn-fg); border: none; }\n/* Responsive */\n@media (max-width: 900px) {\n  .wheel-area { flex-direction:column; align-items:center; }\n  .participants { width: 100%; max-width: 100%; }\n}\n/* Wheel canvas scaling helper */\n#wheelCanvas { border-radius:50%; box-shadow: 0 12px 26px rgba(0,0,0,0.12); background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.02), transparent); }\n/* Toast / temporary message styles (used by showMessage) */\n.tmp-toast {\n  position: fixed;\n  left: 50%;\n  transform: translateX(-50%);\n  top: 18px;\n  background: rgba(0,0,0,0.85);\n  color: #fff;\n  padding: 8px 12px;\n  border-radius: 6px;\n  z-index: 9999;\n  transition: opacity 0.25s, transform 0.25s;\n  opacity: 1;\n  pointer-events: none;\n  font-size: 0.95rem;\n  box-shadow: 0 6px 18px rgba(0,0,0,0.18);\n}\n.tmp-toast.success { background: rgba(56, 198, 123, 0.95); }\n.tmp-toast.warn    { background: rgba(255, 159, 67, 0.95); color: #2b1500; }\n.tmp-toast.info    { background: rgba(12, 74, 255, 0.95); }\n/* Winner highlight for participants list */\n#nameList li.winner {\n  outline: 3px solid rgba(255,215,0,0.15);\n  box-shadow: 0 6px 18px rgba(255,215,0,0.06);\n  transform: scale(1.01);\n}\n\n\nscript.js\njs\n/* \nDOCSTRING\nScript for the Random Winner Wheel.\nContains the Wheel class to draw and spin the canvas-based wheel and UI glue code to manage names and themes.\n*/\n/* Main JavaScript - Wheel + UI logic */\n(() =&gt; {\n  // Utilities\n  function rand(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }\n  function easeOutCubic(t) { return 1 - Math.pow(1 - t, 3); }\n  // Color palettes for themes (will be used to paint wheel segments)\n  const THEME_PALETTES = {\n    light: [\'#FF8A80\',\'#FFD180\',\'#FFF59D\',\'#C8E6C9\',\'#80DEEA\',\'#A7FFEB\',\'#B39DDB\',\'#90CAF9\'],\n    dark: [\'#ff6b6b\',\'#ffd166\',\'#faff8e\',\'#b9f6ca\',\'#4dd0e1\',\'#80cbc4\',\'#b388ff\',\'#64b5f6\'],\n    neon: [\'#ff2d95\',\'#7cff01\',\'#00ffff\',\'#ffdd00\',\'#ff6a00\',\'#00ff9e\',\'#ff00ff\',\'#47ffa2\'],\n    pastel: [\'#ffdbe9\',\'#fff0b3\',\'#d1ffd6\',\'#cfefff\',\'#e7dfff\',\'#ffd6e7\',\'#fbe7d6\',\'#e6f7ff\'],\n    retro: [\'#ffb86b\',\'#ffd3a8\',\'#f3e2a9\',\'#b8e0d2\',\'#c0b9ff\',\'#ffb6c1\',\'#f6c49f\',\'#c3d69b\']\n  };\n  // Wheel class\n  class Wheel {\n    /*\n    Manage wheel: drawing, recalculating segments, spinning animation, and determining winner.\n    */\n    constructor(canvas, options = {}) {\n      this.canvas = canvas;\n      this.ctx = canvas.getContext(\'2d\');\n      this.names = [];\n      this.rotation = 0; // radians\n      this.isSpinning = false;\n      this.frame = null;\n      this.onResult = options.onResult || function() {};\n      this.theme = options.theme || \'light\';\n      this.padAngle = 0.02; // radians padding between segments\n      this.textColor = \'#111\';\n      this._devicePixelRatioFix();\n      window.addEventListener(\'resize\', () =&gt; { this._devicePixelRatioFix(); this.draw(); });\n    }\n    _devicePixelRatioFix() {\n      const dpr = window.devicePixelRatio || 1;\n      const rect = this.canvas.getBoundingClientRect();\n      // If rect has zero size (canvas not yet laid out), use current width/height attributes as fallback\n      const width = rect.width || (this.canvas.width / dpr);\n      const height = rect.height || (this.canvas.height / dpr);\n      this.canvas.width = width * dpr;\n      this.canvas.height = height * dpr;\n      this.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n      this.centerX = width / 2;\n      this.centerY = height / 2;\n      this.radius = Math.min(width, height) / 2 - 18;\n    }\n    setTheme(themeId) { this.theme = themeId; this.draw(); }\n    setNames(names) {\n      this.names = names.slice();\n      this.draw();\n    }\n    addName(name) {\n      this.names.push(name);\n      this.draw();\n    }\n    removeName(index) {\n      if (index &gt;= 0 &amp;&amp; index &lt; this.names.length) {\n        this.names.splice(index,1);\n        this.draw();\n      }\n    }\n    clearNames() {\n      this.names = [];\n      this.draw();\n    }\n    draw() {\n      const ctx = this.ctx;\n      const w = this.canvas.width / (window.devicePixelRatio || 1);\n      const h = this.canvas.height / (window.devicePixelRatio || 1);\n      ctx.clearRect(0,0,w,h);\n      ctx.save();\n      ctx.translate(this.centerX, this.centerY);\n      ctx.rotate(this.rotation);\n      // draw segments\n      const count = Math.max(this.names.length, 1);\n      const palette = THEME_PALETTES[this.theme] || THEME_PALETTES.light;\n      for (let i = 0; i &lt; count; i++) {\n        const start = (i / count) * Math.PI * 2;\n        const end = ((i + 1) / count) * Math.PI * 2;\n        ctx.beginPath();\n        ctx.moveTo(0,0);\n        ctx.arc(0,0,this.radius, start + this.padAngle, end - this.padAngle, false);\n        ctx.closePath();\n        const color = palette[i % palette.length];\n        ctx.fillStyle = color;\n        ctx.fill();\n        ctx.strokeStyle = (i % 2 === 0) ? \'rgba(0,0,0,0.06)\' : \'rgba(0,0,0,0.03)\';\n        ctx.lineWidth = 1;\n        ctx.stroke();\n        // draw text label\n        const mid = (start + end) / 2;\n        ctx.save();\n        ctx.rotate(mid);\n        ctx.translate(this.radius * 0.6, 0);\n        ctx.rotate(Math.PI/2);\n        ctx.fillStyle = getTextColor(color);\n        ctx.font = `${Math.max(12, Math.min(22, this.radius / 8))}px sans-serif`;\n        ctx.textAlign = \'center\';\n        ctx.textBaseline = \'middle\';\n        const label = (this.names.length === 0) ? \'Add names\' : this.names[i % this.names.length];\n        wrapFillText(ctx, label, 0, 0, this.radius * 0.5, 16);\n        ctx.restore();\n      }\n      // draw center circle\n      ctx.beginPath();\n      ctx.arc(0,0, this.radius * 0.16, 0, Math.PI*2);\n      ctx.fillStyle = \'rgba(255,255,255,0.9)\';\n      ctx.fill();\n      ctx.strokeStyle = \'rgba(0,0,0,0.06)\';\n      ctx.stroke();\n      ctx.restore();\n      // draw outer ring (pointer side neutral)\n      ctx.beginPath();\n      ctx.arc(this.centerX, this.centerY, this.radius + 10, 0, Math.PI*2);\n      ctx.strokeStyle = \'rgba(0,0,0,0.03)\';\n      ctx.lineWidth = 2;\n      ctx.stroke();\n    }\n    spin() {\n      if (this.isSpinning || this.names.length === 0) return;\n      this.isSpinning = true;\n      const count = this.names.length;\n      // Determine random winner index to land on:\n      const winnerIndex = rand(0, count - 1);\n      // Calculate final rotation so that winner segment lines up with pointer at top (pointer at canvas top - rotation must align)\n      // Our pointer is at the top (canvas 0 angle). The segment mid-angle for index i (without rotation) is ((i + 0.5)/count)*2pi\n      const segmentMid = ((winnerIndex + 0.5) / count) * Math.PI * 2;\n      // We want segmentMid + rotation_final == -Math.PI/2 (so it points at the top pointer), so rotation_final = -Math.PI/2 - segmentMid + 2pi*N\n      const extraTurns = rand(5, 8); // full spins\n      const rotationFinal = -Math.PI/2 - segmentMid + extraTurns * Math.PI * 2;\n      const startRotation = this.rotation % (Math.PI * 2);\n      const delta = rotationFinal - startRotation;\n      const duration = 4000 + Math.random() * 1500; // ms\n      const startTime = performance.now();\n      const animate = (now) =&gt; {\n        const elapsed = now - startTime;\n        const t = Math.min(elapsed / duration, 1);\n        const eased = easeOutCubic(t);\n        this.rotation = startRotation + delta * eased;\n        this.draw();\n        if (t &lt; 1) {\n          this.frame = requestAnimationFrame(animate);\n        } else {\n          this.isSpinning = false;\n          // Normalize rotation within 0..2pi\n          this.rotation = ((this.rotation % (Math.PI*2)) + Math.PI*2) % (Math.PI*2);\n          this.draw();\n          // Compute final winner index again from rotation\n          // finalAngle: the angle of the segment at pointer (0 at right, +counterclockwise). We compute a normalized angle that maps to segment index.\n          const finalAngle = ((-this.rotation - Math.PI/2) % (Math.PI*2) + Math.PI*2) % (Math.PI*2);\n          const resultingIndex = Math.floor((finalAngle / (Math.PI*2)) * count) % count;\n          const winner = this.names[resultingIndex];\n          this.onResult({ index: resultingIndex, name: winner });\n        }\n      };\n      this.frame = requestAnimationFrame(animate);\n    }\n  }\n  // Helper: pick readable text color for a background\n  function getTextColor(hex) {\n    // remove # and convert\n    const h = hex.replace(\'#\',\'\');\n    const r = parseInt(h.substring(0,2),16);\n    const g = parseInt(h.substring(2,4),16);\n    const b = parseInt(h.substring(4,6),16);\n    // luminance\n    const lum = (0.299*r + 0.587*g + 0.114*b) / 255;\n    return lum &gt; 0.65 ? \'#111\' : \'#fff\';\n  }\n  // Helper: wrap text within a given width (draws multi-line if necessary)\n  function wrapFillText(ctx, text, x, y, maxWidth, lineHeight) {\n    const words = (text || \'\').split(/\\s+/);\n    if (words.length === 0) return;\n    let line = \'\';\n    const lines = [];\n    for (let n = 0; n &lt; words.length; n++) {\n      const testLine = line ? line + \' \' + words[n] : words[n];\n      const metrics = ctx.measureText(testLine);\n      if (metrics.width &gt; maxWidth &amp;&amp; line) {\n        lines.push(line);\n        line = words[n];\n      } else {\n        line = testLine;\n      }\n    }\n    if (line) lines.push(line);\n    // If still too many lines, just draw what\'s possible (we rely on font size)\n    for (let i=0;i&lt;lines.length;i++){\n      ctx.fillText(lines[i], x, y + (i - (lines.length-1)/2) * lineHeight);\n    }\n  }\n  // UI glue\n  document.addEventListener(\'DOMContentLoaded\', () =&gt; {\n    const canvas = document.getElementById(\'wheelCanvas\');\n    const wheel = new Wheel(canvas, { theme: \'light\', onResult: onWinner });\n    const nameInput = document.getElementById(\'nameInput\');\n    const addBtn = document.getElementById(\'addBtn\');\n    const addRandomBtn = document.getElementById(\'addRandomBtn\');\n    const bulkInput = document.getElementById(\'bulkInput\');\n    const bulkAddBtn = document.getElementById(\'bulkAddBtn\');\n    const clearBulkBtn = document.getElementById(\'clearBulkBtn\');\n    const nameList = document.getElementById(\'nameList\');\n    const countSpan = document.getElementById(\'count\');\n    const spinBtn = document.getElementById(\'spinBtn\');\n    const rerollBtn = document.getElementById(\'rerollBtn\');\n    const clearNamesBtn = document.getElementById(\'clearNamesBtn\');\n    const themeSelect = document.getElementById(\'themeSelect\');\n    const resultSection = document.getElementById(\'result\');\n    const winnerNameDiv = document.getElementById(\'winnerName\');\n    const exportBtn = document.getElementById(\'exportBtn\');\n    const importBtn = document.getElementById(\'importBtn\');\n    const importFile = document.getElementById(\'importFile\');\n    // Initial draw\n    wheel.draw();\n    function updateUI() {\n      const names = wheel.names;\n      countSpan.textContent = names.length;\n      renderNameList();\n    }\n    function renderNameList() {\n      nameList.innerHTML = \'\';\n      wheel.names.forEach((n, i) =&gt; {\n        const li = document.createElement(\'li\');\n        const span = document.createElement(\'span\');\n        span.textContent = n;\n        li.appendChild(span);\n        const btn = document.createElement(\'button\');\n        btn.title = \'Remove\';\n        btn.setAttribute(\'aria-label\', `Remove ${n}`);\n        btn.innerHTML = \'✕\';\n        btn.addEventListener(\'click\', () =&gt; {\n          wheel.removeName(i);\n          updateUI();\n        });\n        li.appendChild(btn);\n        nameList.appendChild(li);\n      });\n    }\n    function addNameFromInput() {\n      const v = nameInput.value.trim();\n      if (!v) { showMessage(\'Please enter a name.\', \'warn\'); return; }\n      wheel.addName(v);\n      nameInput.value = \'\';\n      updateUI();\n    }\n    addBtn.addEventListener(\'click\', addNameFromInput);\n    nameInput.addEventListener(\'keydown\', (e) =&gt; { if (e.key === \'Enter\') addNameFromInput(); });\n    addRandomBtn.addEventListener(\'click\', () =&gt; {\n      const samples = [\'Alex\',\'Jordan\',\'Taylor\',\'Sam\',\'Jamie\',\'Casey\',\'Morgan\',\'Riley\',\'Avery\',\'Dana\'];\n      const count = rand(3,6);\n      for (let i=0;i&lt;count;i++) wheel.addName(samples[rand(0,samples.length-1)] + (rand(1,100)));\n      updateUI();\n    });\n    bulkAddBtn.addEventListener(\'click\', () =&gt; {\n      const text = bulkInput.value.trim();\n      if (!text) { showMessage(\'Bulk input is empty.\', \'warn\'); return; }\n      const parsed = text.split(/[\\n,;]+/).map(s =&gt; s.trim()).filter(s =&gt; s);\n      parsed.forEach(p =&gt; wheel.addName(p));\n      bulkInput.value = \'\';\n      updateUI();\n      showMessage(`Added ${parsed.length} names.`, \'info\');\n    });\n    clearBulkBtn.addEventListener(\'click\', () =&gt; { bulkInput.value = \'\'; });\n    spinBtn.addEventListener(\'click\', () =&gt; {\n      if (wheel.names.length === 0) { showMessage(\'Add at least one name to spin.\', \'warn\'); return; }\n      resultSection.hidden = true;\n      winnerNameDiv.textContent = \'\';\n      wheel.spin();\n      spinBtn.disabled = true;\n      const checkFinish = setInterval(() =&gt; {\n        if (!wheel.isSpinning) {\n          clearInterval(checkFinish);\n          spinBtn.disabled = false;\n        }\n      }, 200);\n    });\n    rerollBtn.addEventListener(\'click\', () =&gt; {\n      resultSection.hidden = true;\n      wheel.spin();\n    });\n    clearNamesBtn.addEventListener(\'click\', () =&gt; {\n      if (confirm(\'Clear all names?\')) {\n        wheel.clearNames();\n        updateUI();\n      }\n    });\n    themeSelect.addEventListener(\'change\', (e) =&gt; {\n      const t = e.target.value;\n      document.body.className = \'theme-\' + t;\n      wheel.setTheme(t);\n    });\n    function onWinner(result) {\n      winnerNameDiv.textContent = result.name || \'—\';\n      resultSection.hidden = false;\n      // Flash the winner item in the list (if still present)\n      const items = Array.from(nameList.children);\n      items.forEach((li, idx) =&gt; { li.classList.toggle(\'winner\', idx === result.index); });\n      showMessage(`Winner: ${result.name}`, \'success\', 4000);\n    }\n    // Simple message area\n    function showMessage(text, type = \'info\', duration = 2200) {\n      // create small toast\n      const t = document.createElement(\'div\');\n      t.className = \'tmp-toast \' + type;\n      t.textContent = text;\n      document.body.appendChild(t);\n      // Force reflow to pick up transitions\n      window.getComputedStyle(t).opacity;\n      setTimeout(()=&gt; { t.style.opacity = \'0\'; t.style.transform = \'translateY(-10px)\'; }, duration - 300);\n      setTimeout(()=&gt; { try { t.remove(); } catch(e){} }, duration);\n    }\n    // Export/import CSV\n    exportBtn.addEventListener(\'click\', () =&gt; {\n      if (wheel.names.length === 0) { showMessage(\'No names to export.\', \'warn\'); return; }\n      const csv = wheel.names.map(n =&gt; `"${(n||\'\').replace(/"/g,\'""\')}"`).join(\'\\n\');\n      const blob = new Blob([csv], { type: \'text/csv\' });\n      const url = URL.createObjectURL(blob);\n      const a = document.createElement(\'a\');\n      a.href = url;\n      a.download = \'participants.csv\';\n      document.body.appendChild(a);\n      a.click();\n      a.remove();\n      URL.revokeObjectURL(url);\n      showMessage(\'Exported CSV\', \'info\');\n    });\n    importBtn.addEventListener(\'click\', () =&gt; { importFile.click(); });\n    importFile.addEventListener(\'change\', (e) =&gt; {\n      const file = e.target.files[0];\n      if (!file) return;\n      const reader = new FileReader();\n      reader.onload = (ev) =&gt; {\n        const txt = ev.target.result;\n        const lines = txt.split(/\\r?\\n/).map(s =&gt; s.trim()).filter(s =&gt; s);\n        // basic CSV unquote\n        const parsed = lines.map(l =&gt; {\n          // simple CSV single-column parse: handle quoted fields\n          if (l.startsWith(\'"\') &amp;&amp; l.endsWith(\'"\')) {\n            return l.slice(1,-1).replace(/""/g,\'"\');\n          }\n          return l;\n        });\n        parsed.forEach(p =&gt; wheel.addName(p));\n        updateUI();\n        showMessage(`Imported ${parsed.length} names`, \'info\');\n      };\n      reader.readAsText(file);\n      importFile.value = \'\';\n    });\n    // Initial sample (optional)\n    // wheel.addName(\'Alice\'); wheel.addName(\'Bob\'); wheel.addName(\'Charlie\');\n    updateUI();\n    // (Optional) keyboard shortcuts\n    window.addEventListener(\'keydown\', (e) =&gt; {\n      if ((e.ctrlKey || e.metaKey) &amp;&amp; e.key.toLowerCase() === \'k\') {\n        e.preventDefault();\n        nameInput.focus();\n      }\n      if (e.key === \' \') {\n        // space triggers spin if not focusing an input\n        if (document.activeElement.tagName !== \'INPUT\' &amp;&amp; document.activeElement.tagName !== \'TEXTAREA\') {\n          e.preventDefault();\n          spinBtn.click();\n        }\n      }\n    });\n  });\n})(); \n\n\n', 'images': '', 'comments': ' Remove the Python-style triple-quote docstring wrappers present at the top of your HTML, CSS and JS files — they break parsing/loading of the site.\n\nWhy this is highest priority:\n- Each file (index.html, styles.css, script.js) starts with literal lines containing three single quotes (\'\'\') surrounding a "DOCSTRING" block. Those triple-quote lines are not valid tokens in HTML/CSS/JS and will cause syntax errors or make the browser ignore/stop parsing the files. The app will fail to run (no script execution, CSS not applied, HTML may contain stray text).\n- Fixing these simple invalid tokens is required before any other runtime or UX fixes can be verified.\n\nHow to fix (exact steps):\n\n1) index.html\n- Remove the lines that look like \'\'\' immediately before and after the HTML comment block.\n- Keep the HTML comment, or convert it into a normal HTML comment only. The file should begin with &lt;!doctype html&gt;.\n\nExample change:\nCurrent top of file:\n\'\'\'\n\n\'\'\'\n&lt;!doctype html&gt;\n\nReplace with:\n\n&lt;!doctype html&gt;\n\n2) styles.css\n- Remove the leading and trailing \'\'\' lines.\n- Convert the "DOCSTRING" block to a proper CSS comment / ... / or remove it.\n\nExample change:\nCurrent top:\n\'\'\'\nDOCSTRING\nStylesheet for the Random Winner Wheel.\nDefines layout, themes, wheel container sizing, and animations.\n\'\'\'\n/ Reset &amp; base /\n...\n\nReplace with:\n/ DOCSTRING\n   Stylesheet for the Random Winner Wheel.\n   Defines layout, themes, wheel container sizing, and animations.\n/\n / Reset &amp; base /\n...\n\n3) script.js\n- Remove the leading/trailing \'\'\' lines.\n- Convert the DOCSTRING block to a JS comment (/ ... /) or use // comments.\n\nExample change:\nCurrent top:\n\'\'\'\nDOCSTRING\nScript for the Random Winner Wheel.\nContains the Wheel class to draw and spin the canvas-based wheel and UI glue code to manage names and themes.\n\'\'\'\n/ Main JavaScript - Wheel + UI logic /\n(() =&gt; {\n\nReplace with:\n/ DOCSTRING\n   Script for the Random Winner Wheel.\n   Contains the Wheel class to draw and spin the canvas-based wheel and UI glue code to manage names and themes.\n/\n/ Main JavaScript - Wheel + UI logic /\n(() =&gt; {\n\n4) (Recommended but lower priority) Add CSS rules for the toast messages inserted by showMessage\n- Your showMessage creates elements with class "tmp-toast" and type classes like "info", "warn", "success" but no CSS exists for these. Add minimal styling so messages are visible, e.g.:\n\n/ add near end of styles.css /\n.tmp-toast {\n  position: fixed;\n  left: 50%;\n  transform: translateX(-50%);\n  top: 18px;\n  background: rgba(0,0,0,0.85);\n  color: #fff;\n  padding: 8px 12px;\n  border-radius: 6px;\n  z-index: 9999;\n  transition: opacity 0.25s, transform 0.25s;\n  opacity: 1;\n  pointer-events: none;\n}\n.tmp-toast.success { background: rgba(56, 198, 123, 0.95); }\n.tmp-toast.warn    { background: rgba(255, 159, 67, 0.95); }\n.tmp-toast.info    { background: rgba(12, 74, 255, 0.95); }\n\nWhy include the toast CSS: after fixing the syntax errors you will want visible feedback for users (error/warn/info messages).\n\nAfter you remove those triple-quote lines and adjust the comments as shown, reload and re-test the page. If other runtime issues remain (e.g., pointer alignment, winner-index calculation edge-cases, or UX enhancements like better CSV parsing), I can run through a prioritized list of additional improvements.'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_3_5_TURBO |

[2025-17-09 13:41:30 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Code Reviewer |
| **user_role_name** | Programmer |
| **assistant_role_prompt** | {chatdev_prompt} You are Code Reviewer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. You can help programmers to assess source codes for software troubleshooting, fix bugs to increase code quality and robustness, and offer proposals to improve the source codes. Here is a new customer's task: {task}. To complete the task, you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Programmer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. You can write/create computer software or applications by providing a specific programming language to the computer. You have extensive computing and coding experience in many varieties of programming languages and platforms, such as Python, Java, C, C++, HTML, CSS, JavaScript, XML, SQL, PHP, etc,. Here is a new customer's task: {task}. To complete the task, you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **task_prompt** | [Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes. Do it in HTML, CSS, and JavaScript.] |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_3_5_TURBO |
| **background_prompt** | ChatDev is a software company powered by multiple intelligent agents, such as chief executive officer, chief human resources officer, chief product officer, chief technology officer, etc, with a multi-agent organizational structure and the mission of 'changing the digital world through programming'. |

[2025-17-09 13:41:30 INFO] Programmer: **[Start Chat]**

[ChatDev is a software company powered by multiple intelligent agents, such as chief executive officer, chief human resources officer, chief product officer, chief technology officer, etc, with a multi-agent organizational structure and the mission of 'changing the digital world through programming'.
You are Code Reviewer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer.
You can help programmers to assess source codes for software troubleshooting, fix bugs to increase code quality and robustness, and offer proposals to improve the source codes.
Here is a new customer's task: [Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes. Do it in HTML, CSS, and JavaScript.].
To complete the task, you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]

According to the new user's task and our software designs: 
Task: "[Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes. Do it in HTML, CSS, and JavaScript.]".
Modality: "website".
Programming Language: " JavaScript"
Ideas: ""
Codes:
"index.html
```html
<!--
DOCSTRING
This is the main HTML file for the Random Winner Wheel.
It contains the structure: input fields to add names, a canvas for the wheel,
controls (spin, clear, bulk add), theme selector, and placeholders for CSS/JS.
-->
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Random Winner Wheel</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body class="theme-light">
  <header>
    <h1>Random Winner Wheel</h1>
    <p>Enter participant names, choose a theme, and spin to pick a winner.</p>
  </header>
  <main>
    <section class="controls">
      <div class="add-single">
        <input id="nameInput" type="text" placeholder="Enter a name and press Add" aria-label="Name input" />
        <button id="addBtn">Add</button>
        <button id="addRandomBtn" title="Add a few sample random names">Add Sample</button>
      </div>
      <div class="bulk-add">
        <label for="bulkInput">Bulk add (comma, newline or semicolon separated):</label>
        <textarea id="bulkInput" placeholder="Alice, Bob, Charlie"></textarea>
        <div class="bulk-actions">
          <button id="bulkAddBtn">Bulk Add</button>
          <button id="clearBulkBtn">Clear Bulk</button>
        </div>
      </div>
      <div class="list-actions">
        <div class="theme-select">
          <label for="themeSelect">Theme:</label>
          <select id="themeSelect">
            <option value="light">Light</option>
            <option value="dark">Dark</option>
            <option value="neon">Neon</option>
            <option value="pastel">Pastel</option>
            <option value="retro">Retro</option>
          </select>
        </div>
        <div class="wheel-controls">
          <button id="spinBtn" class="primary">Spin</button>
          <button id="clearNamesBtn">Clear Names</button>
          <button id="exportBtn">Export CSV</button>
          <input id="importFile" type="file" accept=".csv,text/csv" style="display:none">
          <button id="importBtn">Import CSV</button>
        </div>
      </div>
    </section>
    <section class="wheel-area">
      <div class="wheel-container">
        <canvas id="wheelCanvas" width="600" height="600" aria-label="Spinning wheel"></canvas>
        <div class="pointer" aria-hidden="true">▼</div>
      </div>
      <aside class="participants">
        <h2>Participants (<span id="count">0</span>)</h2>
        <ul id="nameList" aria-live="polite"></ul>
      </aside>
    </section>
    <section class="result" id="result" aria-live="polite" hidden>
      <h2>Winner</h2>
      <div id="winnerName" class="winnerName"></div>
      <button id="rerollBtn">Spin Again</button>
    </section>
  </main>
  <footer>
    <small>Built with HTML, CSS, and JavaScript. Themes change both UI and wheel colors.</small>
  </footer>
  <script src="script.js"></script>
</body>
</html>
```

styles.css
```css
/*
DOCSTRING
Stylesheet for the Random Winner Wheel.
Defines layout, themes, wheel container sizing, animations, and toast styles.
*/
/* Reset & base */
* { box-sizing: border-box; margin: 0; padding: 0; }
html,body { height: 100%; font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; background: var(--bg); color: var(--fg); }
:root {
  --bg: #f7f8fb;
  --fg: #222;
  --muted: #666;
  --accent: #2b8cff;
  --card: #ffffff;
  --primary-btn-bg: var(--accent);
  --primary-btn-fg: #fff;
  --shadow: rgba(15,15,15,0.08);
}
/* Themes */
body.theme-light {
  --bg: #f7f8fb;
  --fg: #222;
  --muted: #5b6170;
  --accent: #2b8cff;
  --card: #fff;
  --wheel-seq: 0;
}
body.theme-dark {
  --bg: #0f1724;
  --fg: #e6eef8;
  --muted: #a9b1c2;
  --accent: #7c5cff;
  --card: #0b1220;
}
body.theme-neon {
  --bg: #0a0a0f;
  --fg: #e9f9ff;
  --muted: #a6f3ff;
  --accent: #39ff14;
  --card: #09101a;
}
body.theme-pastel {
  --bg: #fffaf6;
  --fg: #3c3a3a;
  --muted: #8d8a8a;
  --accent: #ff7aa2;
  --card: #fff;
}
body.theme-retro {
  --bg: #fff6e7;
  --fg: #402b2b;
  --muted: #856e6e;
  --accent: #ffb86b;
  --card: #fff0e6;
}
/* Layout */
header { padding: 18px 24px; text-align: center; background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent); }
header h1 { font-size: 1.5rem; margin-bottom: 6px; }
main { padding: 18px; max-width: 1100px; margin: 0 auto; }
.controls { display: grid; gap: 12px; margin-bottom: 18px; }
.add-single { display:flex; gap:8px; }
.add-single input[type="text"] { flex:1; padding:10px; border-radius:8px; border:1px solid rgba(0,0,0,0.08); background:var(--card); color:var(--fg); }
.add-single button { padding:10px 12px; border-radius:8px; border: none; cursor:pointer; background: var(--primary-btn-bg); color: var(--primary-btn-fg); }
.add-single button#addRandomBtn { background: transparent; border: 1px solid rgba(0,0,0,0.06); color: var(--fg); }
.bulk-add textarea { width:100%; min-height:64px; margin-top:6px; padding:8px; border-radius:8px; border:1px solid rgba(0,0,0,0.06); background:var(--card); color:var(--fg); }
.bulk-actions { display:flex; gap:8px; margin-top:8px; }
.list-actions { display:flex; justify-content:space-between; align-items:center; gap:16px; flex-wrap:wrap; }
.theme-select select { padding:8px; border-radius:8px; border:1px solid rgba(0,0,0,0.06); }
.wheel-area { display:flex; gap:18px; align-items:start; flex-wrap:wrap; }
.wheel-container { position: relative; width: 600px; height: 600px; max-width: 90vw; max-height: 90vw; display:flex; align-items:center; justify-content:center; background: transparent; }
.pointer { position:absolute; top:6px; font-size:28px; transform: translateY(-50%); text-shadow: 0 2px 8px rgba(0,0,0,0.25); color: var(--accent); pointer-events:none; }
.participants { width: 320px; max-width: 40vw; background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent); padding:12px; border-radius:10px; box-shadow: 0 6px 18px var(--shadow); }
.participants h2 { margin-bottom:8px; font-size:1.05rem; }
#nameList { list-style:none; max-height:420px; overflow:auto; display:block; }
#nameList li { padding:8px; border-radius:6px; display:flex; justify-content:space-between; align-items:center; gap:8px; margin-bottom:8px; background: var(--card); border:1px solid rgba(0,0,0,0.04); }
#nameList li button { background: transparent; border: none; color: var(--muted); cursor:pointer; }
.result { margin-top:18px; padding:12px; border-radius:8px; background: var(--card); text-align:center; box-shadow: 0 6px 18px var(--shadow); }
.result .winnerName { font-size:1.4rem; font-weight:700; margin:8px 0; color: var(--accent); }
/* Buttons */
button { cursor:pointer; padding:8px 12px; border-radius:8px; border:1px solid rgba(0,0,0,0.06); background: transparent; color:var(--fg); }
button.primary { background: var(--primary-btn-bg); color: var(--primary-btn-fg); border: none; }
/* Responsive */
@media (max-width: 900px) {
  .wheel-area { flex-direction:column; align-items:center; }
  .participants { width: 100%; max-width: 100%; }
}
/* Wheel canvas scaling helper */
#wheelCanvas { border-radius:50%; box-shadow: 0 12px 26px rgba(0,0,0,0.12); background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.02), transparent); }
/* Toast / temporary message styles (used by showMessage) */
.tmp-toast {
  position: fixed;
  left: 50%;
  transform: translateX(-50%);
  top: 18px;
  background: rgba(0,0,0,0.85);
  color: #fff;
  padding: 8px 12px;
  border-radius: 6px;
  z-index: 9999;
  transition: opacity 0.25s, transform 0.25s;
  opacity: 1;
  pointer-events: none;
  font-size: 0.95rem;
  box-shadow: 0 6px 18px rgba(0,0,0,0.18);
}
.tmp-toast.success { background: rgba(56, 198, 123, 0.95); }
.tmp-toast.warn    { background: rgba(255, 159, 67, 0.95); color: #2b1500; }
.tmp-toast.info    { background: rgba(12, 74, 255, 0.95); }
/* Winner highlight for participants list */
#nameList li.winner {
  outline: 3px solid rgba(255,215,0,0.15);
  box-shadow: 0 6px 18px rgba(255,215,0,0.06);
  transform: scale(1.01);
}
```

script.js
```js
/* 
DOCSTRING
Script for the Random Winner Wheel.
Contains the Wheel class to draw and spin the canvas-based wheel and UI glue code to manage names and themes.
*/
/* Main JavaScript - Wheel + UI logic */
(() => {
  // Utilities
  function rand(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }
  function easeOutCubic(t) { return 1 - Math.pow(1 - t, 3); }
  // Color palettes for themes (will be used to paint wheel segments)
  const THEME_PALETTES = {
    light: ['#FF8A80','#FFD180','#FFF59D','#C8E6C9','#80DEEA','#A7FFEB','#B39DDB','#90CAF9'],
    dark: ['#ff6b6b','#ffd166','#faff8e','#b9f6ca','#4dd0e1','#80cbc4','#b388ff','#64b5f6'],
    neon: ['#ff2d95','#7cff01','#00ffff','#ffdd00','#ff6a00','#00ff9e','#ff00ff','#47ffa2'],
    pastel: ['#ffdbe9','#fff0b3','#d1ffd6','#cfefff','#e7dfff','#ffd6e7','#fbe7d6','#e6f7ff'],
    retro: ['#ffb86b','#ffd3a8','#f3e2a9','#b8e0d2','#c0b9ff','#ffb6c1','#f6c49f','#c3d69b']
  };
  // Wheel class
  class Wheel {
    /*
    Manage wheel: drawing, recalculating segments, spinning animation, and determining winner.
    */
    constructor(canvas, options = {}) {
      this.canvas = canvas;
      this.ctx = canvas.getContext('2d');
      this.names = [];
      this.rotation = 0; // radians
      this.isSpinning = false;
      this.frame = null;
      this.onResult = options.onResult || function() {};
      this.theme = options.theme || 'light';
      this.padAngle = 0.02; // radians padding between segments
      this.textColor = '#111';
      this._devicePixelRatioFix();
      window.addEventListener('resize', () => { this._devicePixelRatioFix(); this.draw(); });
    }
    _devicePixelRatioFix() {
      const dpr = window.devicePixelRatio || 1;
      const rect = this.canvas.getBoundingClientRect();
      // If rect has zero size (canvas not yet laid out), use current width/height attributes as fallback
      const width = rect.width || (this.canvas.width / dpr);
      const height = rect.height || (this.canvas.height / dpr);
      this.canvas.width = width * dpr;
      this.canvas.height = height * dpr;
      this.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      this.centerX = width / 2;
      this.centerY = height / 2;
      this.radius = Math.min(width, height) / 2 - 18;
    }
    setTheme(themeId) { this.theme = themeId; this.draw(); }
    setNames(names) {
      this.names = names.slice();
      this.draw();
    }
    addName(name) {
      this.names.push(name);
      this.draw();
    }
    removeName(index) {
      if (index >= 0 && index < this.names.length) {
        this.names.splice(index,1);
        this.draw();
      }
    }
    clearNames() {
      this.names = [];
      this.draw();
    }
    draw() {
      const ctx = this.ctx;
      const w = this.canvas.width / (window.devicePixelRatio || 1);
      const h = this.canvas.height / (window.devicePixelRatio || 1);
      ctx.clearRect(0,0,w,h);
      ctx.save();
      ctx.translate(this.centerX, this.centerY);
      ctx.rotate(this.rotation);
      // draw segments
      const count = Math.max(this.names.length, 1);
      const palette = THEME_PALETTES[this.theme] || THEME_PALETTES.light;
      for (let i = 0; i < count; i++) {
        const start = (i / count) * Math.PI * 2;
        const end = ((i + 1) / count) * Math.PI * 2;
        ctx.beginPath();
        ctx.moveTo(0,0);
        ctx.arc(0,0,this.radius, start + this.padAngle, end - this.padAngle, false);
        ctx.closePath();
        const color = palette[i % palette.length];
        ctx.fillStyle = color;
        ctx.fill();
        ctx.strokeStyle = (i % 2 === 0) ? 'rgba(0,0,0,0.06)' : 'rgba(0,0,0,0.03)';
        ctx.lineWidth = 1;
        ctx.stroke();
        // draw text label
        const mid = (start + end) / 2;
        ctx.save();
        ctx.rotate(mid);
        ctx.translate(this.radius * 0.6, 0);
        ctx.rotate(Math.PI/2);
        ctx.fillStyle = getTextColor(color);
        ctx.font = `${Math.max(12, Math.min(22, this.radius / 8))}px sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        const label = (this.names.length === 0) ? 'Add names' : this.names[i % this.names.length];
        wrapFillText(ctx, label, 0, 0, this.radius * 0.5, 16);
        ctx.restore();
      }
      // draw center circle
      ctx.beginPath();
      ctx.arc(0,0, this.radius * 0.16, 0, Math.PI*2);
      ctx.fillStyle = 'rgba(255,255,255,0.9)';
      ctx.fill();
      ctx.strokeStyle = 'rgba(0,0,0,0.06)';
      ctx.stroke();
      ctx.restore();
      // draw outer ring (pointer side neutral)
      ctx.beginPath();
      ctx.arc(this.centerX, this.centerY, this.radius + 10, 0, Math.PI*2);
      ctx.strokeStyle = 'rgba(0,0,0,0.03)';
      ctx.lineWidth = 2;
      ctx.stroke();
    }
    spin() {
      if (this.isSpinning || this.names.length === 0) return;
      this.isSpinning = true;
      const count = this.names.length;
      // Determine random winner index to land on:
      const winnerIndex = rand(0, count - 1);
      // Calculate final rotation so that winner segment lines up with pointer at top (pointer at canvas top - rotation must align)
      // Our pointer is at the top (canvas 0 angle). The segment mid-angle for index i (without rotation) is ((i + 0.5)/count)*2pi
      const segmentMid = ((winnerIndex + 0.5) / count) * Math.PI * 2;
      // We want segmentMid + rotation_final == -Math.PI/2 (so it points at the top pointer), so rotation_final = -Math.PI/2 - segmentMid + 2pi*N
      const extraTurns = rand(5, 8); // full spins
      const rotationFinal = -Math.PI/2 - segmentMid + extraTurns * Math.PI * 2;
      const startRotation = this.rotation % (Math.PI * 2);
      const delta = rotationFinal - startRotation;
      const duration = 4000 + Math.random() * 1500; // ms
      const startTime = performance.now();
      const animate = (now) => {
        const elapsed = now - startTime;
        const t = Math.min(elapsed / duration, 1);
        const eased = easeOutCubic(t);
        this.rotation = startRotation + delta * eased;
        this.draw();
        if (t < 1) {
          this.frame = requestAnimationFrame(animate);
        } else {
          this.isSpinning = false;
          // Normalize rotation within 0..2pi
          this.rotation = ((this.rotation % (Math.PI*2)) + Math.PI*2) % (Math.PI*2);
          this.draw();
          // Compute final winner index again from rotation
          // finalAngle: the angle of the segment at pointer (0 at right, +counterclockwise). We compute a normalized angle that maps to segment index.
          const finalAngle = ((-this.rotation - Math.PI/2) % (Math.PI*2) + Math.PI*2) % (Math.PI*2);
          const resultingIndex = Math.floor((finalAngle / (Math.PI*2)) * count) % count;
          const winner = this.names[resultingIndex];
          this.onResult({ index: resultingIndex, name: winner });
        }
      };
      this.frame = requestAnimationFrame(animate);
    }
  }
  // Helper: pick readable text color for a background
  function getTextColor(hex) {
    // remove # and convert
    const h = hex.replace('#','');
    const r = parseInt(h.substring(0,2),16);
    const g = parseInt(h.substring(2,4),16);
    const b = parseInt(h.substring(4,6),16);
    // luminance
    const lum = (0.299*r + 0.587*g + 0.114*b) / 255;
    return lum > 0.65 ? '#111' : '#fff';
  }
  // Helper: wrap text within a given width (draws multi-line if necessary)
  function wrapFillText(ctx, text, x, y, maxWidth, lineHeight) {
    const words = (text || '').split(/\s+/);
    if (words.length === 0) return;
    let line = '';
    const lines = [];
    for (let n = 0; n < words.length; n++) {
      const testLine = line ? line + ' ' + words[n] : words[n];
      const metrics = ctx.measureText(testLine);
      if (metrics.width > maxWidth && line) {
        lines.push(line);
        line = words[n];
      } else {
        line = testLine;
      }
    }
    if (line) lines.push(line);
    // If still too many lines, just draw what's possible (we rely on font size)
    for (let i=0;i<lines.length;i++){
      ctx.fillText(lines[i], x, y + (i - (lines.length-1)/2) * lineHeight);
    }
  }
  // UI glue
  document.addEventListener('DOMContentLoaded', () => {
    const canvas = document.getElementById('wheelCanvas');
    const wheel = new Wheel(canvas, { theme: 'light', onResult: onWinner });
    const nameInput = document.getElementById('nameInput');
    const addBtn = document.getElementById('addBtn');
    const addRandomBtn = document.getElementById('addRandomBtn');
    const bulkInput = document.getElementById('bulkInput');
    const bulkAddBtn = document.getElementById('bulkAddBtn');
    const clearBulkBtn = document.getElementById('clearBulkBtn');
    const nameList = document.getElementById('nameList');
    const countSpan = document.getElementById('count');
    const spinBtn = document.getElementById('spinBtn');
    const rerollBtn = document.getElementById('rerollBtn');
    const clearNamesBtn = document.getElementById('clearNamesBtn');
    const themeSelect = document.getElementById('themeSelect');
    const resultSection = document.getElementById('result');
    const winnerNameDiv = document.getElementById('winnerName');
    const exportBtn = document.getElementById('exportBtn');
    const importBtn = document.getElementById('importBtn');
    const importFile = document.getElementById('importFile');
    // Initial draw
    wheel.draw();
    function updateUI() {
      const names = wheel.names;
      countSpan.textContent = names.length;
      renderNameList();
    }
    function renderNameList() {
      nameList.innerHTML = '';
      wheel.names.forEach((n, i) => {
        const li = document.createElement('li');
        const span = document.createElement('span');
        span.textContent = n;
        li.appendChild(span);
        const btn = document.createElement('button');
        btn.title = 'Remove';
        btn.setAttribute('aria-label', `Remove ${n}`);
        btn.innerHTML = '✕';
        btn.addEventListener('click', () => {
          wheel.removeName(i);
          updateUI();
        });
        li.appendChild(btn);
        nameList.appendChild(li);
      });
    }
    function addNameFromInput() {
      const v = nameInput.value.trim();
      if (!v) { showMessage('Please enter a name.', 'warn'); return; }
      wheel.addName(v);
      nameInput.value = '';
      updateUI();
    }
    addBtn.addEventListener('click', addNameFromInput);
    nameInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') addNameFromInput(); });
    addRandomBtn.addEventListener('click', () => {
      const samples = ['Alex','Jordan','Taylor','Sam','Jamie','Casey','Morgan','Riley','Avery','Dana'];
      const count = rand(3,6);
      for (let i=0;i<count;i++) wheel.addName(samples[rand(0,samples.length-1)] + (rand(1,100)));
      updateUI();
    });
    bulkAddBtn.addEventListener('click', () => {
      const text = bulkInput.value.trim();
      if (!text) { showMessage('Bulk input is empty.', 'warn'); return; }
      const parsed = text.split(/[\n,;]+/).map(s => s.trim()).filter(s => s);
      parsed.forEach(p => wheel.addName(p));
      bulkInput.value = '';
      updateUI();
      showMessage(`Added ${parsed.length} names.`, 'info');
    });
    clearBulkBtn.addEventListener('click', () => { bulkInput.value = ''; });
    spinBtn.addEventListener('click', () => {
      if (wheel.names.length === 0) { showMessage('Add at least one name to spin.', 'warn'); return; }
      resultSection.hidden = true;
      winnerNameDiv.textContent = '';
      wheel.spin();
      spinBtn.disabled = true;
      const checkFinish = setInterval(() => {
        if (!wheel.isSpinning) {
          clearInterval(checkFinish);
          spinBtn.disabled = false;
        }
      }, 200);
    });
    rerollBtn.addEventListener('click', () => {
      resultSection.hidden = true;
      wheel.spin();
    });
    clearNamesBtn.addEventListener('click', () => {
      if (confirm('Clear all names?')) {
        wheel.clearNames();
        updateUI();
      }
    });
    themeSelect.addEventListener('change', (e) => {
      const t = e.target.value;
      document.body.className = 'theme-' + t;
      wheel.setTheme(t);
    });
    function onWinner(result) {
      winnerNameDiv.textContent = result.name || '—';
      resultSection.hidden = false;
      // Flash the winner item in the list (if still present)
      const items = Array.from(nameList.children);
      items.forEach((li, idx) => { li.classList.toggle('winner', idx === result.index); });
      showMessage(`Winner: ${result.name}`, 'success', 4000);
    }
    // Simple message area
    function showMessage(text, type = 'info', duration = 2200) {
      // create small toast
      const t = document.createElement('div');
      t.className = 'tmp-toast ' + type;
      t.textContent = text;
      document.body.appendChild(t);
      // Force reflow to pick up transitions
      window.getComputedStyle(t).opacity;
      setTimeout(()=> { t.style.opacity = '0'; t.style.transform = 'translateY(-10px)'; }, duration - 300);
      setTimeout(()=> { try { t.remove(); } catch(e){} }, duration);
    }
    // Export/import CSV
    exportBtn.addEventListener('click', () => {
      if (wheel.names.length === 0) { showMessage('No names to export.', 'warn'); return; }
      const csv = wheel.names.map(n => `"${(n||'').replace(/"/g,'""')}"`).join('\n');
      const blob = new Blob([csv], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'participants.csv';
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
      showMessage('Exported CSV', 'info');
    });
    importBtn.addEventListener('click', () => { importFile.click(); });
    importFile.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (ev) => {
        const txt = ev.target.result;
        const lines = txt.split(/\r?\n/).map(s => s.trim()).filter(s => s);
        // basic CSV unquote
        const parsed = lines.map(l => {
          // simple CSV single-column parse: handle quoted fields
          if (l.startsWith('"') && l.endsWith('"')) {
            return l.slice(1,-1).replace(/""/g,'"');
          }
          return l;
        });
        parsed.forEach(p => wheel.addName(p));
        updateUI();
        showMessage(`Imported ${parsed.length} names`, 'info');
      };
      reader.readAsText(file);
      importFile.value = '';
    });
    // Initial sample (optional)
    // wheel.addName('Alice'); wheel.addName('Bob'); wheel.addName('Charlie');
    updateUI();
    // (Optional) keyboard shortcuts
    window.addEventListener('keydown', (e) => {
      if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'k') {
        e.preventDefault();
        nameInput.focus();
      }
      if (e.key === ' ') {
        // space triggers spin if not focusing an input
        if (document.activeElement.tagName !== 'INPUT' && document.activeElement.tagName !== 'TEXTAREA') {
          e.preventDefault();
          spinBtn.click();
        }
      }
    });
  });
})(); 
```

"
As the Code Reviewer, to make the software directly operable without further coding, ChatDev have formulated the following regulations:
1) all referenced classes should be imported;
2) all methods should be implemented;
3) all methods need to have the necessary comments;
4) no potential bugs;
5) The entire project conforms to the tasks proposed by the user;
6) most importantly, do not only check the errors in the code, but also the logic of code. Make sure that user can interact with generated software without losing any feature in the requirement;
Now, you should check the above regulations one by one and review the codes in detail, propose one comment with the highest priority about the codes, and give me instructions on how to fix. Tell me your comment with the highest priority and corresponding suggestions on revision. If the codes are perfect and you have no comment on them, return only one line like "<INFO> Finished".

[2025-17-09 13:42:27 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2025-17-09 13:42:27 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 7056
completion_tokens: 3005
total_tokens: 10061
cost: $-1.000000


[2025-17-09 13:42:27 INFO] Code Reviewer: **Code Reviewer<->Programmer on : CodeReviewComment, turn 0**

[ChatDev is a software company powered by multiple intelligent agents, such as chief executive officer, chief human resources officer, chief product officer, chief technology officer, etc, with a multi-agent organizational structure and the mission of 'changing the digital world through programming'.
You are Programmer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer.
You can write/create computer software or applications by providing a specific programming language to the computer. You have extensive computing and coding experience in many varieties of programming languages and platforms, such as Python, Java, C, C++, HTML, CSS, JavaScript, XML, SQL, PHP, etc,.
Here is a new customer's task: [Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes. Do it in HTML, CSS, and JavaScript.].
To complete the task, you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]

<PRIORITY> Fix pointer alignment so the visual pointer actually sits over the wheel center (highest priority)

Why: the spin logic aligns a winning segment to the top/center of the wheel (math uses -Math.PI/2). However the .pointer element in CSS is not horizontally centered — it only has top:6px and transform: translateY(-50%). That places the pointer near the top-left of the wheel container instead of top-center. Users will see the pointer off-center and may be confused because the wheel rotates to point at the top-center but the visible pointer isn't there. This breaks the main UX (the pointer must accurately indicate the selected segment).

How to fix: center the pointer horizontally, keep it visually above the wheel, and ensure it has a higher stacking order than the canvas. Replace (or update) the .pointer CSS rule with the following:

/* Replace existing .pointer rule with this */
.pointer {
  position: absolute;
  top: 8px;               /* vertical offset from top of wheel container */
  left: 50%;              /* center horizontally */
  transform: translate(-50%, -50%); /* truly center at top middle */
  font-size: 28px;
  z-index: 10;            /* ensure it's above the canvas */
  color: var(--accent);
  pointer-events: none;
  text-shadow: 0 2px 8px rgba(0,0,0,0.25);
}

Optional improvement (sharper pointer): instead of a glyph, use a small CSS triangle so it's visually clear. Example:

.pointer {
  position: absolute;
  top: 8px;
  left: 50%;
  transform: translateX(-50%);
  width: 0;
  height: 0;
  border-left: 10px solid transparent;
  border-right: 10px solid transparent;
  border-bottom: 16px solid var(--accent);
  z-index: 10;
  pointer-events: none;
}

Steps to apply:
1. Edit styles.css and replace the existing .pointer rule with one of the options above.
2. Reload the page and verify the pointer is centered over the wheel and the winners line up precisely under the pointer.

Why this is the top priority: the visual pointer's position directly contradicts the wheel's spin logic; fixing this restores the core user experience (clear, accurate winner indication) without any other code changes.

[2025-17-09 13:42:27 INFO] **[Seminar Conclusion]**:

 <PRIORITY> Fix pointer alignment so the visual pointer actually sits over the wheel center (highest priority)

Why: the spin logic aligns a winning segment to the top/center of the wheel (math uses -Math.PI/2). However the .pointer element in CSS is not horizontally centered — it only has top:6px and transform: translateY(-50%). That places the pointer near the top-left of the wheel container instead of top-center. Users will see the pointer off-center and may be confused because the wheel rotates to point at the top-center but the visible pointer isn't there. This breaks the main UX (the pointer must accurately indicate the selected segment).

How to fix: center the pointer horizontally, keep it visually above the wheel, and ensure it has a higher stacking order than the canvas. Replace (or update) the .pointer CSS rule with the following:

/* Replace existing .pointer rule with this */
.pointer {
  position: absolute;
  top: 8px;               /* vertical offset from top of wheel container */
  left: 50%;              /* center horizontally */
  transform: translate(-50%, -50%); /* truly center at top middle */
  font-size: 28px;
  z-index: 10;            /* ensure it's above the canvas */
  color: var(--accent);
  pointer-events: none;
  text-shadow: 0 2px 8px rgba(0,0,0,0.25);
}

Optional improvement (sharper pointer): instead of a glyph, use a small CSS triangle so it's visually clear. Example:

.pointer {
  position: absolute;
  top: 8px;
  left: 50%;
  transform: translateX(-50%);
  width: 0;
  height: 0;
  border-left: 10px solid transparent;
  border-right: 10px solid transparent;
  border-bottom: 16px solid var(--accent);
  z-index: 10;
  pointer-events: none;
}

Steps to apply:
1. Edit styles.css and replace the existing .pointer rule with one of the options above.
2. Reload the page and verify the pointer is centered over the wheel and the winners line up precisely under the pointer.

Why this is the top priority: the visual pointer's position directly contradicts the wheel's spin logic; fixing this restores the core user experience (clear, accurate winner indication) without any other code changes.

[2025-17-09 13:42:27 INFO] **[Execute Detail]**

execute SimplePhase:[CodeReviewModification] in ComposedPhase:[CodeReview], cycle 2

[2025-17-09 13:42:27 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | [Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes. Do it in HTML, CSS, and JavaScript.] |
| **need_reflect** | False |
| **assistant_role_name** | Programmer |
| **user_role_name** | Code Reviewer |
| **phase_prompt** | According to the new user's task, our designed product modality, languages and ideas, our developed first-edition source codes are listed below:  Task: "{task}". Modality: "{modality}". Programming Language: "{language}" Ideas: "{ideas}" Codes:  "{codes}" Comments on Codes: "{comments}" In the software, each file must strictly follow a markdown code block format, where the following tokens must be replaced such that "FILENAME" is the lowercase file name including the file extension, "LANGUAGE" in the programming language, "DOCSTRING" is a string literal specified in source code that is used to document a specific segment of code, and "CODE" is the original code. Format: FILENAME LANGUAGE ''' DOCSTRING ''' CODE As the {assistant_role}, to satisfy the new user's demand and make the software creative, executive and robust, you should modify corresponding codes according to the comments. Then, output the full and complete codes with all bugs fixed based on the comments. Return all codes strictly following the required format. |
| **phase_name** | CodeReviewModification |
| **assistant_role_prompt** | {chatdev_prompt} You are Programmer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. You can write/create computer software or applications by providing a specific programming language to the computer. You have extensive computing and coding experience in many varieties of programming languages and platforms, such as Python, Java, C, C++, HTML, CSS, JavaScript, XML, SQL, PHP, etc,. Here is a new customer's task: {task}. To complete the task, you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Code Reviewer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. You can help programmers to assess source codes for software troubleshooting, fix bugs to increase code quality and robustness, and offer proposals to improve the source codes. Here is a new customer's task: {task}. To complete the task, you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': 'index.html\nhtml\n&lt;!--\nDOCSTRING\nThis is the main HTML file for the Random Winner Wheel.\nIt contains the structure: input fields to add names, a canvas for the wheel,\ncontrols (spin, clear, bulk add), theme selector, and placeholders for CSS/JS.\n--&gt;\n&lt;!doctype html&gt;\n&lt;html lang="en"&gt;\n&lt;head&gt;\n  &lt;meta charset="utf-8" /&gt;\n  &lt;meta name="viewport" content="width=device-width,initial-scale=1" /&gt;\n  &lt;title&gt;Random Winner Wheel&lt;/title&gt;\n  &lt;link rel="stylesheet" href="styles.css"&gt;\n&lt;/head&gt;\n&lt;body class="theme-light"&gt;\n  &lt;header&gt;\n    &lt;h1&gt;Random Winner Wheel&lt;/h1&gt;\n    &lt;p&gt;Enter participant names, choose a theme, and spin to pick a winner.&lt;/p&gt;\n  &lt;/header&gt;\n  &lt;main&gt;\n    &lt;section class="controls"&gt;\n      &lt;div class="add-single"&gt;\n        &lt;input id="nameInput" type="text" placeholder="Enter a name and press Add" aria-label="Name input" /&gt;\n        &lt;button id="addBtn"&gt;Add&lt;/button&gt;\n        &lt;button id="addRandomBtn" title="Add a few sample random names"&gt;Add Sample&lt;/button&gt;\n      &lt;/div&gt;\n      &lt;div class="bulk-add"&gt;\n        &lt;label for="bulkInput"&gt;Bulk add (comma, newline or semicolon separated):&lt;/label&gt;\n        &lt;textarea id="bulkInput" placeholder="Alice, Bob, Charlie"&gt;&lt;/textarea&gt;\n        &lt;div class="bulk-actions"&gt;\n          &lt;button id="bulkAddBtn"&gt;Bulk Add&lt;/button&gt;\n          &lt;button id="clearBulkBtn"&gt;Clear Bulk&lt;/button&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;\n      &lt;div class="list-actions"&gt;\n        &lt;div class="theme-select"&gt;\n          &lt;label for="themeSelect"&gt;Theme:&lt;/label&gt;\n          &lt;select id="themeSelect"&gt;\n            &lt;option value="light"&gt;Light&lt;/option&gt;\n            &lt;option value="dark"&gt;Dark&lt;/option&gt;\n            &lt;option value="neon"&gt;Neon&lt;/option&gt;\n            &lt;option value="pastel"&gt;Pastel&lt;/option&gt;\n            &lt;option value="retro"&gt;Retro&lt;/option&gt;\n          &lt;/select&gt;\n        &lt;/div&gt;\n        &lt;div class="wheel-controls"&gt;\n          &lt;button id="spinBtn" class="primary"&gt;Spin&lt;/button&gt;\n          &lt;button id="clearNamesBtn"&gt;Clear Names&lt;/button&gt;\n          &lt;button id="exportBtn"&gt;Export CSV&lt;/button&gt;\n          &lt;input id="importFile" type="file" accept=".csv,text/csv" style="display:none"&gt;\n          &lt;button id="importBtn"&gt;Import CSV&lt;/button&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;\n    &lt;/section&gt;\n    &lt;section class="wheel-area"&gt;\n      &lt;div class="wheel-container"&gt;\n        &lt;canvas id="wheelCanvas" width="600" height="600" aria-label="Spinning wheel"&gt;&lt;/canvas&gt;\n        &lt;div class="pointer" aria-hidden="true"&gt;▼&lt;/div&gt;\n      &lt;/div&gt;\n      &lt;aside class="participants"&gt;\n        &lt;h2&gt;Participants (&lt;span id="count"&gt;0&lt;/span&gt;)&lt;/h2&gt;\n        &lt;ul id="nameList" aria-live="polite"&gt;&lt;/ul&gt;\n      &lt;/aside&gt;\n    &lt;/section&gt;\n    &lt;section class="result" id="result" aria-live="polite" hidden&gt;\n      &lt;h2&gt;Winner&lt;/h2&gt;\n      &lt;div id="winnerName" class="winnerName"&gt;&lt;/div&gt;\n      &lt;button id="rerollBtn"&gt;Spin Again&lt;/button&gt;\n    &lt;/section&gt;\n  &lt;/main&gt;\n  &lt;footer&gt;\n    &lt;small&gt;Built with HTML, CSS, and JavaScript. Themes change both UI and wheel colors.&lt;/small&gt;\n  &lt;/footer&gt;\n  &lt;script src="script.js"&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\n\nstyles.css\ncss\n/*\nDOCSTRING\nStylesheet for the Random Winner Wheel.\nDefines layout, themes, wheel container sizing, animations, and toast styles.\n*/\n/* Reset &amp; base */\n* { box-sizing: border-box; margin: 0; padding: 0; }\nhtml,body { height: 100%; font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; background: var(--bg); color: var(--fg); }\n:root {\n  --bg: #f7f8fb;\n  --fg: #222;\n  --muted: #666;\n  --accent: #2b8cff;\n  --card: #ffffff;\n  --primary-btn-bg: var(--accent);\n  --primary-btn-fg: #fff;\n  --shadow: rgba(15,15,15,0.08);\n}\n/* Themes */\nbody.theme-light {\n  --bg: #f7f8fb;\n  --fg: #222;\n  --muted: #5b6170;\n  --accent: #2b8cff;\n  --card: #fff;\n  --wheel-seq: 0;\n}\nbody.theme-dark {\n  --bg: #0f1724;\n  --fg: #e6eef8;\n  --muted: #a9b1c2;\n  --accent: #7c5cff;\n  --card: #0b1220;\n}\nbody.theme-neon {\n  --bg: #0a0a0f;\n  --fg: #e9f9ff;\n  --muted: #a6f3ff;\n  --accent: #39ff14;\n  --card: #09101a;\n}\nbody.theme-pastel {\n  --bg: #fffaf6;\n  --fg: #3c3a3a;\n  --muted: #8d8a8a;\n  --accent: #ff7aa2;\n  --card: #fff;\n}\nbody.theme-retro {\n  --bg: #fff6e7;\n  --fg: #402b2b;\n  --muted: #856e6e;\n  --accent: #ffb86b;\n  --card: #fff0e6;\n}\n/* Layout */\nheader { padding: 18px 24px; text-align: center; background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent); }\nheader h1 { font-size: 1.5rem; margin-bottom: 6px; }\nmain { padding: 18px; max-width: 1100px; margin: 0 auto; }\n.controls { display: grid; gap: 12px; margin-bottom: 18px; }\n.add-single { display:flex; gap:8px; }\n.add-single input[type="text"] { flex:1; padding:10px; border-radius:8px; border:1px solid rgba(0,0,0,0.08); background:var(--card); color:var(--fg); }\n.add-single button { padding:10px 12px; border-radius:8px; border: none; cursor:pointer; background: var(--primary-btn-bg); color: var(--primary-btn-fg); }\n.add-single button#addRandomBtn { background: transparent; border: 1px solid rgba(0,0,0,0.06); color: var(--fg); }\n.bulk-add textarea { width:100%; min-height:64px; margin-top:6px; padding:8px; border-radius:8px; border:1px solid rgba(0,0,0,0.06); background:var(--card); color:var(--fg); }\n.bulk-actions { display:flex; gap:8px; margin-top:8px; }\n.list-actions { display:flex; justify-content:space-between; align-items:center; gap:16px; flex-wrap:wrap; }\n.theme-select select { padding:8px; border-radius:8px; border:1px solid rgba(0,0,0,0.06); }\n.wheel-area { display:flex; gap:18px; align-items:start; flex-wrap:wrap; }\n.wheel-container { position: relative; width: 600px; height: 600px; max-width: 90vw; max-height: 90vw; display:flex; align-items:center; justify-content:center; background: transparent; }\n.pointer { position:absolute; top:6px; font-size:28px; transform: translateY(-50%); text-shadow: 0 2px 8px rgba(0,0,0,0.25); color: var(--accent); pointer-events:none; }\n.participants { width: 320px; max-width: 40vw; background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent); padding:12px; border-radius:10px; box-shadow: 0 6px 18px var(--shadow); }\n.participants h2 { margin-bottom:8px; font-size:1.05rem; }\n#nameList { list-style:none; max-height:420px; overflow:auto; display:block; }\n#nameList li { padding:8px; border-radius:6px; display:flex; justify-content:space-between; align-items:center; gap:8px; margin-bottom:8px; background: var(--card); border:1px solid rgba(0,0,0,0.04); }\n#nameList li button { background: transparent; border: none; color: var(--muted); cursor:pointer; }\n.result { margin-top:18px; padding:12px; border-radius:8px; background: var(--card); text-align:center; box-shadow: 0 6px 18px var(--shadow); }\n.result .winnerName { font-size:1.4rem; font-weight:700; margin:8px 0; color: var(--accent); }\n/* Buttons */\nbutton { cursor:pointer; padding:8px 12px; border-radius:8px; border:1px solid rgba(0,0,0,0.06); background: transparent; color:var(--fg); }\nbutton.primary { background: var(--primary-btn-bg); color: var(--primary-btn-fg); border: none; }\n/* Responsive */\n@media (max-width: 900px) {\n  .wheel-area { flex-direction:column; align-items:center; }\n  .participants { width: 100%; max-width: 100%; }\n}\n/* Wheel canvas scaling helper */\n#wheelCanvas { border-radius:50%; box-shadow: 0 12px 26px rgba(0,0,0,0.12); background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.02), transparent); }\n\n/* Toast / temporary message styles (used by showMessage) */\n.tmp-toast {\n  position: fixed;\n  left: 50%;\n  transform: translateX(-50%);\n  top: 18px;\n  background: rgba(0,0,0,0.85);\n  color: #fff;\n  padding: 8px 12px;\n  border-radius: 6px;\n  z-index: 9999;\n  transition: opacity 0.25s, transform 0.25s;\n  opacity: 1;\n  pointer-events: none;\n  font-size: 0.95rem;\n  box-shadow: 0 6px 18px rgba(0,0,0,0.18);\n}\n.tmp-toast.success { background: rgba(56, 198, 123, 0.95); }\n.tmp-toast.warn    { background: rgba(255, 159, 67, 0.95); color: #2b1500; }\n.tmp-toast.info    { background: rgba(12, 74, 255, 0.95); }\n\n/* Winner highlight for participants list */\n#nameList li.winner {\n  outline: 3px solid rgba(255,215,0,0.15);\n  box-shadow: 0 6px 18px rgba(255,215,0,0.06);\n  transform: scale(1.01);\n}\n\n\nscript.js\njs\n/* \nDOCSTRING\nScript for the Random Winner Wheel.\nContains the Wheel class to draw and spin the canvas-based wheel and UI glue code to manage names and themes.\n*/\n/* Main JavaScript - Wheel + UI logic */\n(() =&gt; {\n  // Utilities\n  function rand(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }\n  function easeOutCubic(t) { return 1 - Math.pow(1 - t, 3); }\n  // Color palettes for themes (will be used to paint wheel segments)\n  const THEME_PALETTES = {\n    light: [\'#FF8A80\',\'#FFD180\',\'#FFF59D\',\'#C8E6C9\',\'#80DEEA\',\'#A7FFEB\',\'#B39DDB\',\'#90CAF9\'],\n    dark: [\'#ff6b6b\',\'#ffd166\',\'#faff8e\',\'#b9f6ca\',\'#4dd0e1\',\'#80cbc4\',\'#b388ff\',\'#64b5f6\'],\n    neon: [\'#ff2d95\',\'#7cff01\',\'#00ffff\',\'#ffdd00\',\'#ff6a00\',\'#00ff9e\',\'#ff00ff\',\'#47ffa2\'],\n    pastel: [\'#ffdbe9\',\'#fff0b3\',\'#d1ffd6\',\'#cfefff\',\'#e7dfff\',\'#ffd6e7\',\'#fbe7d6\',\'#e6f7ff\'],\n    retro: [\'#ffb86b\',\'#ffd3a8\',\'#f3e2a9\',\'#b8e0d2\',\'#c0b9ff\',\'#ffb6c1\',\'#f6c49f\',\'#c3d69b\']\n  };\n  // Wheel class\n  class Wheel {\n    /*\n    Manage wheel: drawing, recalculating segments, spinning animation, and determining winner.\n    */\n    constructor(canvas, options = {}) {\n      this.canvas = canvas;\n      this.ctx = canvas.getContext(\'2d\');\n      this.names = [];\n      this.rotation = 0; // radians\n      this.isSpinning = false;\n      this.frame = null;\n      this.onResult = options.onResult || function() {};\n      this.theme = options.theme || \'light\';\n      this.padAngle = 0.02; // radians padding between segments\n      this.textColor = \'#111\';\n      this._devicePixelRatioFix();\n      window.addEventListener(\'resize\', () =&gt; { this._devicePixelRatioFix(); this.draw(); });\n    }\n    _devicePixelRatioFix() {\n      const dpr = window.devicePixelRatio || 1;\n      const rect = this.canvas.getBoundingClientRect();\n      // If rect has zero size (canvas not yet laid out), use current width/height attributes as fallback\n      const width = rect.width || (this.canvas.width / dpr);\n      const height = rect.height || (this.canvas.height / dpr);\n      this.canvas.width = width * dpr;\n      this.canvas.height = height * dpr;\n      this.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n      this.centerX = width / 2;\n      this.centerY = height / 2;\n      this.radius = Math.min(width, height) / 2 - 18;\n    }\n    setTheme(themeId) { this.theme = themeId; this.draw(); }\n    setNames(names) {\n      this.names = names.slice();\n      this.draw();\n    }\n    addName(name) {\n      this.names.push(name);\n      this.draw();\n    }\n    removeName(index) {\n      if (index &gt;= 0 &amp;&amp; index &lt; this.names.length) {\n        this.names.splice(index,1);\n        this.draw();\n      }\n    }\n    clearNames() {\n      this.names = [];\n      this.draw();\n    }\n    draw() {\n      const ctx = this.ctx;\n      const w = this.canvas.width / (window.devicePixelRatio || 1);\n      const h = this.canvas.height / (window.devicePixelRatio || 1);\n      ctx.clearRect(0,0,w,h);\n      ctx.save();\n      ctx.translate(this.centerX, this.centerY);\n      ctx.rotate(this.rotation);\n      // draw segments\n      const count = Math.max(this.names.length, 1);\n      const palette = THEME_PALETTES[this.theme] || THEME_PALETTES.light;\n      for (let i = 0; i &lt; count; i++) {\n        const start = (i / count) * Math.PI * 2;\n        const end = ((i + 1) / count) * Math.PI * 2;\n        ctx.beginPath();\n        ctx.moveTo(0,0);\n        ctx.arc(0,0,this.radius, start + this.padAngle, end - this.padAngle, false);\n        ctx.closePath();\n        const color = palette[i % palette.length];\n        ctx.fillStyle = color;\n        ctx.fill();\n        ctx.strokeStyle = (i % 2 === 0) ? \'rgba(0,0,0,0.06)\' : \'rgba(0,0,0,0.03)\';\n        ctx.lineWidth = 1;\n        ctx.stroke();\n        // draw text label\n        const mid = (start + end) / 2;\n        ctx.save();\n        ctx.rotate(mid);\n        ctx.translate(this.radius * 0.6, 0);\n        ctx.rotate(Math.PI/2);\n        ctx.fillStyle = getTextColor(color);\n        ctx.font = `${Math.max(12, Math.min(22, this.radius / 8))}px sans-serif`;\n        ctx.textAlign = \'center\';\n        ctx.textBaseline = \'middle\';\n        const label = (this.names.length === 0) ? \'Add names\' : this.names[i % this.names.length];\n        wrapFillText(ctx, label, 0, 0, this.radius * 0.5, 16);\n        ctx.restore();\n      }\n      // draw center circle\n      ctx.beginPath();\n      ctx.arc(0,0, this.radius * 0.16, 0, Math.PI*2);\n      ctx.fillStyle = \'rgba(255,255,255,0.9)\';\n      ctx.fill();\n      ctx.strokeStyle = \'rgba(0,0,0,0.06)\';\n      ctx.stroke();\n      ctx.restore();\n      // draw outer ring (pointer side neutral)\n      ctx.beginPath();\n      ctx.arc(this.centerX, this.centerY, this.radius + 10, 0, Math.PI*2);\n      ctx.strokeStyle = \'rgba(0,0,0,0.03)\';\n      ctx.lineWidth = 2;\n      ctx.stroke();\n    }\n    spin() {\n      if (this.isSpinning || this.names.length === 0) return;\n      this.isSpinning = true;\n      const count = this.names.length;\n      // Determine random winner index to land on:\n      const winnerIndex = rand(0, count - 1);\n      // Calculate final rotation so that winner segment lines up with pointer at top (pointer at canvas top - rotation must align)\n      // Our pointer is at the top (canvas 0 angle). The segment mid-angle for index i (without rotation) is ((i + 0.5)/count)*2pi\n      const segmentMid = ((winnerIndex + 0.5) / count) * Math.PI * 2;\n      // We want segmentMid + rotation_final == -Math.PI/2 (so it points at the top pointer), so rotation_final = -Math.PI/2 - segmentMid + 2pi*N\n      const extraTurns = rand(5, 8); // full spins\n      const rotationFinal = -Math.PI/2 - segmentMid + extraTurns * Math.PI * 2;\n      const startRotation = this.rotation % (Math.PI * 2);\n      const delta = rotationFinal - startRotation;\n      const duration = 4000 + Math.random() * 1500; // ms\n      const startTime = performance.now();\n      const animate = (now) =&gt; {\n        const elapsed = now - startTime;\n        const t = Math.min(elapsed / duration, 1);\n        const eased = easeOutCubic(t);\n        this.rotation = startRotation + delta * eased;\n        this.draw();\n        if (t &lt; 1) {\n          this.frame = requestAnimationFrame(animate);\n        } else {\n          this.isSpinning = false;\n          // Normalize rotation within 0..2pi\n          this.rotation = ((this.rotation % (Math.PI*2)) + Math.PI*2) % (Math.PI*2);\n          this.draw();\n          // Compute final winner index again from rotation\n          // finalAngle: the angle of the segment at pointer (0 at right, +counterclockwise). We compute a normalized angle that maps to segment index.\n          const finalAngle = ((-this.rotation - Math.PI/2) % (Math.PI*2) + Math.PI*2) % (Math.PI*2);\n          const resultingIndex = Math.floor((finalAngle / (Math.PI*2)) * count) % count;\n          const winner = this.names[resultingIndex];\n          this.onResult({ index: resultingIndex, name: winner });\n        }\n      };\n      this.frame = requestAnimationFrame(animate);\n    }\n  }\n  // Helper: pick readable text color for a background\n  function getTextColor(hex) {\n    // remove # and convert\n    const h = hex.replace(\'#\',\'\');\n    const r = parseInt(h.substring(0,2),16);\n    const g = parseInt(h.substring(2,4),16);\n    const b = parseInt(h.substring(4,6),16);\n    // luminance\n    const lum = (0.299*r + 0.587*g + 0.114*b) / 255;\n    return lum &gt; 0.65 ? \'#111\' : \'#fff\';\n  }\n  // Helper: wrap text within a given width (draws multi-line if necessary)\n  function wrapFillText(ctx, text, x, y, maxWidth, lineHeight) {\n    const words = (text || \'\').split(/\\s+/);\n    if (words.length === 0) return;\n    let line = \'\';\n    const lines = [];\n    for (let n = 0; n &lt; words.length; n++) {\n      const testLine = line ? line + \' \' + words[n] : words[n];\n      const metrics = ctx.measureText(testLine);\n      if (metrics.width &gt; maxWidth &amp;&amp; line) {\n        lines.push(line);\n        line = words[n];\n      } else {\n        line = testLine;\n      }\n    }\n    if (line) lines.push(line);\n    // If still too many lines, just draw what\'s possible (we rely on font size)\n    for (let i=0;i&lt;lines.length;i++){\n      ctx.fillText(lines[i], x, y + (i - (lines.length-1)/2) * lineHeight);\n    }\n  }\n  // UI glue\n  document.addEventListener(\'DOMContentLoaded\', () =&gt; {\n    const canvas = document.getElementById(\'wheelCanvas\');\n    const wheel = new Wheel(canvas, { theme: \'light\', onResult: onWinner });\n    const nameInput = document.getElementById(\'nameInput\');\n    const addBtn = document.getElementById(\'addBtn\');\n    const addRandomBtn = document.getElementById(\'addRandomBtn\');\n    const bulkInput = document.getElementById(\'bulkInput\');\n    const bulkAddBtn = document.getElementById(\'bulkAddBtn\');\n    const clearBulkBtn = document.getElementById(\'clearBulkBtn\');\n    const nameList = document.getElementById(\'nameList\');\n    const countSpan = document.getElementById(\'count\');\n    const spinBtn = document.getElementById(\'spinBtn\');\n    const rerollBtn = document.getElementById(\'rerollBtn\');\n    const clearNamesBtn = document.getElementById(\'clearNamesBtn\');\n    const themeSelect = document.getElementById(\'themeSelect\');\n    const resultSection = document.getElementById(\'result\');\n    const winnerNameDiv = document.getElementById(\'winnerName\');\n    const exportBtn = document.getElementById(\'exportBtn\');\n    const importBtn = document.getElementById(\'importBtn\');\n    const importFile = document.getElementById(\'importFile\');\n    // Initial draw\n    wheel.draw();\n    function updateUI() {\n      const names = wheel.names;\n      countSpan.textContent = names.length;\n      renderNameList();\n    }\n    function renderNameList() {\n      nameList.innerHTML = \'\';\n      wheel.names.forEach((n, i) =&gt; {\n        const li = document.createElement(\'li\');\n        const span = document.createElement(\'span\');\n        span.textContent = n;\n        li.appendChild(span);\n        const btn = document.createElement(\'button\');\n        btn.title = \'Remove\';\n        btn.setAttribute(\'aria-label\', `Remove ${n}`);\n        btn.innerHTML = \'✕\';\n        btn.addEventListener(\'click\', () =&gt; {\n          wheel.removeName(i);\n          updateUI();\n        });\n        li.appendChild(btn);\n        nameList.appendChild(li);\n      });\n    }\n    function addNameFromInput() {\n      const v = nameInput.value.trim();\n      if (!v) { showMessage(\'Please enter a name.\', \'warn\'); return; }\n      wheel.addName(v);\n      nameInput.value = \'\';\n      updateUI();\n    }\n    addBtn.addEventListener(\'click\', addNameFromInput);\n    nameInput.addEventListener(\'keydown\', (e) =&gt; { if (e.key === \'Enter\') addNameFromInput(); });\n    addRandomBtn.addEventListener(\'click\', () =&gt; {\n      const samples = [\'Alex\',\'Jordan\',\'Taylor\',\'Sam\',\'Jamie\',\'Casey\',\'Morgan\',\'Riley\',\'Avery\',\'Dana\'];\n      const count = rand(3,6);\n      for (let i=0;i&lt;count;i++) wheel.addName(samples[rand(0,samples.length-1)] + (rand(1,100)));\n      updateUI();\n    });\n    bulkAddBtn.addEventListener(\'click\', () =&gt; {\n      const text = bulkInput.value.trim();\n      if (!text) { showMessage(\'Bulk input is empty.\', \'warn\'); return; }\n      const parsed = text.split(/[\\n,;]+/).map(s =&gt; s.trim()).filter(s =&gt; s);\n      parsed.forEach(p =&gt; wheel.addName(p));\n      bulkInput.value = \'\';\n      updateUI();\n      showMessage(`Added ${parsed.length} names.`, \'info\');\n    });\n    clearBulkBtn.addEventListener(\'click\', () =&gt; { bulkInput.value = \'\'; });\n    spinBtn.addEventListener(\'click\', () =&gt; {\n      if (wheel.names.length === 0) { showMessage(\'Add at least one name to spin.\', \'warn\'); return; }\n      resultSection.hidden = true;\n      winnerNameDiv.textContent = \'\';\n      wheel.spin();\n      spinBtn.disabled = true;\n      const checkFinish = setInterval(() =&gt; {\n        if (!wheel.isSpinning) {\n          clearInterval(checkFinish);\n          spinBtn.disabled = false;\n        }\n      }, 200);\n    });\n    rerollBtn.addEventListener(\'click\', () =&gt; {\n      resultSection.hidden = true;\n      wheel.spin();\n    });\n    clearNamesBtn.addEventListener(\'click\', () =&gt; {\n      if (confirm(\'Clear all names?\')) {\n        wheel.clearNames();\n        updateUI();\n      }\n    });\n    themeSelect.addEventListener(\'change\', (e) =&gt; {\n      const t = e.target.value;\n      document.body.className = \'theme-\' + t;\n      wheel.setTheme(t);\n    });\n    function onWinner(result) {\n      winnerNameDiv.textContent = result.name || \'—\';\n      resultSection.hidden = false;\n      // Flash the winner item in the list (if still present)\n      const items = Array.from(nameList.children);\n      items.forEach((li, idx) =&gt; { li.classList.toggle(\'winner\', idx === result.index); });\n      showMessage(`Winner: ${result.name}`, \'success\', 4000);\n    }\n    // Simple message area\n    function showMessage(text, type = \'info\', duration = 2200) {\n      // create small toast\n      const t = document.createElement(\'div\');\n      t.className = \'tmp-toast \' + type;\n      t.textContent = text;\n      document.body.appendChild(t);\n      // Force reflow to pick up transitions\n      window.getComputedStyle(t).opacity;\n      setTimeout(()=&gt; { t.style.opacity = \'0\'; t.style.transform = \'translateY(-10px)\'; }, duration - 300);\n      setTimeout(()=&gt; { try { t.remove(); } catch(e){} }, duration);\n    }\n    // Export/import CSV\n    exportBtn.addEventListener(\'click\', () =&gt; {\n      if (wheel.names.length === 0) { showMessage(\'No names to export.\', \'warn\'); return; }\n      const csv = wheel.names.map(n =&gt; `"${(n||\'\').replace(/"/g,\'""\')}"`).join(\'\\n\');\n      const blob = new Blob([csv], { type: \'text/csv\' });\n      const url = URL.createObjectURL(blob);\n      const a = document.createElement(\'a\');\n      a.href = url;\n      a.download = \'participants.csv\';\n      document.body.appendChild(a);\n      a.click();\n      a.remove();\n      URL.revokeObjectURL(url);\n      showMessage(\'Exported CSV\', \'info\');\n    });\n    importBtn.addEventListener(\'click\', () =&gt; { importFile.click(); });\n    importFile.addEventListener(\'change\', (e) =&gt; {\n      const file = e.target.files[0];\n      if (!file) return;\n      const reader = new FileReader();\n      reader.onload = (ev) =&gt; {\n        const txt = ev.target.result;\n        const lines = txt.split(/\\r?\\n/).map(s =&gt; s.trim()).filter(s =&gt; s);\n        // basic CSV unquote\n        const parsed = lines.map(l =&gt; {\n          // simple CSV single-column parse: handle quoted fields\n          if (l.startsWith(\'"\') &amp;&amp; l.endsWith(\'"\')) {\n            return l.slice(1,-1).replace(/""/g,\'"\');\n          }\n          return l;\n        });\n        parsed.forEach(p =&gt; wheel.addName(p));\n        updateUI();\n        showMessage(`Imported ${parsed.length} names`, \'info\');\n      };\n      reader.readAsText(file);\n      importFile.value = \'\';\n    });\n    // Initial sample (optional)\n    // wheel.addName(\'Alice\'); wheel.addName(\'Bob\'); wheel.addName(\'Charlie\');\n    updateUI();\n    // (Optional) keyboard shortcuts\n    window.addEventListener(\'keydown\', (e) =&gt; {\n      if ((e.ctrlKey || e.metaKey) &amp;&amp; e.key.toLowerCase() === \'k\') {\n        e.preventDefault();\n        nameInput.focus();\n      }\n      if (e.key === \' \') {\n        // space triggers spin if not focusing an input\n        if (document.activeElement.tagName !== \'INPUT\' &amp;&amp; document.activeElement.tagName !== \'TEXTAREA\') {\n          e.preventDefault();\n          spinBtn.click();\n        }\n      }\n    });\n  });\n})(); \n', 'cycle_index': 2, 'task': '[Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes. Do it in HTML, CSS, and JavaScript.]', 'modality': 'website', 'ideas': '', 'language': ' JavaScript', 'codes': 'index.html\nhtml\n&lt;!--\nDOCSTRING\nThis is the main HTML file for the Random Winner Wheel.\nIt contains the structure: input fields to add names, a canvas for the wheel,\ncontrols (spin, clear, bulk add), theme selector, and placeholders for CSS/JS.\n--&gt;\n&lt;!doctype html&gt;\n&lt;html lang="en"&gt;\n&lt;head&gt;\n  &lt;meta charset="utf-8" /&gt;\n  &lt;meta name="viewport" content="width=device-width,initial-scale=1" /&gt;\n  &lt;title&gt;Random Winner Wheel&lt;/title&gt;\n  &lt;link rel="stylesheet" href="styles.css"&gt;\n&lt;/head&gt;\n&lt;body class="theme-light"&gt;\n  &lt;header&gt;\n    &lt;h1&gt;Random Winner Wheel&lt;/h1&gt;\n    &lt;p&gt;Enter participant names, choose a theme, and spin to pick a winner.&lt;/p&gt;\n  &lt;/header&gt;\n  &lt;main&gt;\n    &lt;section class="controls"&gt;\n      &lt;div class="add-single"&gt;\n        &lt;input id="nameInput" type="text" placeholder="Enter a name and press Add" aria-label="Name input" /&gt;\n        &lt;button id="addBtn"&gt;Add&lt;/button&gt;\n        &lt;button id="addRandomBtn" title="Add a few sample random names"&gt;Add Sample&lt;/button&gt;\n      &lt;/div&gt;\n      &lt;div class="bulk-add"&gt;\n        &lt;label for="bulkInput"&gt;Bulk add (comma, newline or semicolon separated):&lt;/label&gt;\n        &lt;textarea id="bulkInput" placeholder="Alice, Bob, Charlie"&gt;&lt;/textarea&gt;\n        &lt;div class="bulk-actions"&gt;\n          &lt;button id="bulkAddBtn"&gt;Bulk Add&lt;/button&gt;\n          &lt;button id="clearBulkBtn"&gt;Clear Bulk&lt;/button&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;\n      &lt;div class="list-actions"&gt;\n        &lt;div class="theme-select"&gt;\n          &lt;label for="themeSelect"&gt;Theme:&lt;/label&gt;\n          &lt;select id="themeSelect"&gt;\n            &lt;option value="light"&gt;Light&lt;/option&gt;\n            &lt;option value="dark"&gt;Dark&lt;/option&gt;\n            &lt;option value="neon"&gt;Neon&lt;/option&gt;\n            &lt;option value="pastel"&gt;Pastel&lt;/option&gt;\n            &lt;option value="retro"&gt;Retro&lt;/option&gt;\n          &lt;/select&gt;\n        &lt;/div&gt;\n        &lt;div class="wheel-controls"&gt;\n          &lt;button id="spinBtn" class="primary"&gt;Spin&lt;/button&gt;\n          &lt;button id="clearNamesBtn"&gt;Clear Names&lt;/button&gt;\n          &lt;button id="exportBtn"&gt;Export CSV&lt;/button&gt;\n          &lt;input id="importFile" type="file" accept=".csv,text/csv" style="display:none"&gt;\n          &lt;button id="importBtn"&gt;Import CSV&lt;/button&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;\n    &lt;/section&gt;\n    &lt;section class="wheel-area"&gt;\n      &lt;div class="wheel-container"&gt;\n        &lt;canvas id="wheelCanvas" width="600" height="600" aria-label="Spinning wheel"&gt;&lt;/canvas&gt;\n        &lt;div class="pointer" aria-hidden="true"&gt;▼&lt;/div&gt;\n      &lt;/div&gt;\n      &lt;aside class="participants"&gt;\n        &lt;h2&gt;Participants (&lt;span id="count"&gt;0&lt;/span&gt;)&lt;/h2&gt;\n        &lt;ul id="nameList" aria-live="polite"&gt;&lt;/ul&gt;\n      &lt;/aside&gt;\n    &lt;/section&gt;\n    &lt;section class="result" id="result" aria-live="polite" hidden&gt;\n      &lt;h2&gt;Winner&lt;/h2&gt;\n      &lt;div id="winnerName" class="winnerName"&gt;&lt;/div&gt;\n      &lt;button id="rerollBtn"&gt;Spin Again&lt;/button&gt;\n    &lt;/section&gt;\n  &lt;/main&gt;\n  &lt;footer&gt;\n    &lt;small&gt;Built with HTML, CSS, and JavaScript. Themes change both UI and wheel colors.&lt;/small&gt;\n  &lt;/footer&gt;\n  &lt;script src="script.js"&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\n\nstyles.css\ncss\n/*\nDOCSTRING\nStylesheet for the Random Winner Wheel.\nDefines layout, themes, wheel container sizing, animations, and toast styles.\n*/\n/* Reset &amp; base */\n* { box-sizing: border-box; margin: 0; padding: 0; }\nhtml,body { height: 100%; font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; background: var(--bg); color: var(--fg); }\n:root {\n  --bg: #f7f8fb;\n  --fg: #222;\n  --muted: #666;\n  --accent: #2b8cff;\n  --card: #ffffff;\n  --primary-btn-bg: var(--accent);\n  --primary-btn-fg: #fff;\n  --shadow: rgba(15,15,15,0.08);\n}\n/* Themes */\nbody.theme-light {\n  --bg: #f7f8fb;\n  --fg: #222;\n  --muted: #5b6170;\n  --accent: #2b8cff;\n  --card: #fff;\n  --wheel-seq: 0;\n}\nbody.theme-dark {\n  --bg: #0f1724;\n  --fg: #e6eef8;\n  --muted: #a9b1c2;\n  --accent: #7c5cff;\n  --card: #0b1220;\n}\nbody.theme-neon {\n  --bg: #0a0a0f;\n  --fg: #e9f9ff;\n  --muted: #a6f3ff;\n  --accent: #39ff14;\n  --card: #09101a;\n}\nbody.theme-pastel {\n  --bg: #fffaf6;\n  --fg: #3c3a3a;\n  --muted: #8d8a8a;\n  --accent: #ff7aa2;\n  --card: #fff;\n}\nbody.theme-retro {\n  --bg: #fff6e7;\n  --fg: #402b2b;\n  --muted: #856e6e;\n  --accent: #ffb86b;\n  --card: #fff0e6;\n}\n/* Layout */\nheader { padding: 18px 24px; text-align: center; background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent); }\nheader h1 { font-size: 1.5rem; margin-bottom: 6px; }\nmain { padding: 18px; max-width: 1100px; margin: 0 auto; }\n.controls { display: grid; gap: 12px; margin-bottom: 18px; }\n.add-single { display:flex; gap:8px; }\n.add-single input[type="text"] { flex:1; padding:10px; border-radius:8px; border:1px solid rgba(0,0,0,0.08); background:var(--card); color:var(--fg); }\n.add-single button { padding:10px 12px; border-radius:8px; border: none; cursor:pointer; background: var(--primary-btn-bg); color: var(--primary-btn-fg); }\n.add-single button#addRandomBtn { background: transparent; border: 1px solid rgba(0,0,0,0.06); color: var(--fg); }\n.bulk-add textarea { width:100%; min-height:64px; margin-top:6px; padding:8px; border-radius:8px; border:1px solid rgba(0,0,0,0.06); background:var(--card); color:var(--fg); }\n.bulk-actions { display:flex; gap:8px; margin-top:8px; }\n.list-actions { display:flex; justify-content:space-between; align-items:center; gap:16px; flex-wrap:wrap; }\n.theme-select select { padding:8px; border-radius:8px; border:1px solid rgba(0,0,0,0.06); }\n.wheel-area { display:flex; gap:18px; align-items:start; flex-wrap:wrap; }\n.wheel-container { position: relative; width: 600px; height: 600px; max-width: 90vw; max-height: 90vw; display:flex; align-items:center; justify-content:center; background: transparent; }\n.pointer { position:absolute; top:6px; font-size:28px; transform: translateY(-50%); text-shadow: 0 2px 8px rgba(0,0,0,0.25); color: var(--accent); pointer-events:none; }\n.participants { width: 320px; max-width: 40vw; background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent); padding:12px; border-radius:10px; box-shadow: 0 6px 18px var(--shadow); }\n.participants h2 { margin-bottom:8px; font-size:1.05rem; }\n#nameList { list-style:none; max-height:420px; overflow:auto; display:block; }\n#nameList li { padding:8px; border-radius:6px; display:flex; justify-content:space-between; align-items:center; gap:8px; margin-bottom:8px; background: var(--card); border:1px solid rgba(0,0,0,0.04); }\n#nameList li button { background: transparent; border: none; color: var(--muted); cursor:pointer; }\n.result { margin-top:18px; padding:12px; border-radius:8px; background: var(--card); text-align:center; box-shadow: 0 6px 18px var(--shadow); }\n.result .winnerName { font-size:1.4rem; font-weight:700; margin:8px 0; color: var(--accent); }\n/* Buttons */\nbutton { cursor:pointer; padding:8px 12px; border-radius:8px; border:1px solid rgba(0,0,0,0.06); background: transparent; color:var(--fg); }\nbutton.primary { background: var(--primary-btn-bg); color: var(--primary-btn-fg); border: none; }\n/* Responsive */\n@media (max-width: 900px) {\n  .wheel-area { flex-direction:column; align-items:center; }\n  .participants { width: 100%; max-width: 100%; }\n}\n/* Wheel canvas scaling helper */\n#wheelCanvas { border-radius:50%; box-shadow: 0 12px 26px rgba(0,0,0,0.12); background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.02), transparent); }\n/* Toast / temporary message styles (used by showMessage) */\n.tmp-toast {\n  position: fixed;\n  left: 50%;\n  transform: translateX(-50%);\n  top: 18px;\n  background: rgba(0,0,0,0.85);\n  color: #fff;\n  padding: 8px 12px;\n  border-radius: 6px;\n  z-index: 9999;\n  transition: opacity 0.25s, transform 0.25s;\n  opacity: 1;\n  pointer-events: none;\n  font-size: 0.95rem;\n  box-shadow: 0 6px 18px rgba(0,0,0,0.18);\n}\n.tmp-toast.success { background: rgba(56, 198, 123, 0.95); }\n.tmp-toast.warn    { background: rgba(255, 159, 67, 0.95); color: #2b1500; }\n.tmp-toast.info    { background: rgba(12, 74, 255, 0.95); }\n/* Winner highlight for participants list */\n#nameList li.winner {\n  outline: 3px solid rgba(255,215,0,0.15);\n  box-shadow: 0 6px 18px rgba(255,215,0,0.06);\n  transform: scale(1.01);\n}\n\n\nscript.js\njs\n/* \nDOCSTRING\nScript for the Random Winner Wheel.\nContains the Wheel class to draw and spin the canvas-based wheel and UI glue code to manage names and themes.\n*/\n/* Main JavaScript - Wheel + UI logic */\n(() =&gt; {\n  // Utilities\n  function rand(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }\n  function easeOutCubic(t) { return 1 - Math.pow(1 - t, 3); }\n  // Color palettes for themes (will be used to paint wheel segments)\n  const THEME_PALETTES = {\n    light: [\'#FF8A80\',\'#FFD180\',\'#FFF59D\',\'#C8E6C9\',\'#80DEEA\',\'#A7FFEB\',\'#B39DDB\',\'#90CAF9\'],\n    dark: [\'#ff6b6b\',\'#ffd166\',\'#faff8e\',\'#b9f6ca\',\'#4dd0e1\',\'#80cbc4\',\'#b388ff\',\'#64b5f6\'],\n    neon: [\'#ff2d95\',\'#7cff01\',\'#00ffff\',\'#ffdd00\',\'#ff6a00\',\'#00ff9e\',\'#ff00ff\',\'#47ffa2\'],\n    pastel: [\'#ffdbe9\',\'#fff0b3\',\'#d1ffd6\',\'#cfefff\',\'#e7dfff\',\'#ffd6e7\',\'#fbe7d6\',\'#e6f7ff\'],\n    retro: [\'#ffb86b\',\'#ffd3a8\',\'#f3e2a9\',\'#b8e0d2\',\'#c0b9ff\',\'#ffb6c1\',\'#f6c49f\',\'#c3d69b\']\n  };\n  // Wheel class\n  class Wheel {\n    /*\n    Manage wheel: drawing, recalculating segments, spinning animation, and determining winner.\n    */\n    constructor(canvas, options = {}) {\n      this.canvas = canvas;\n      this.ctx = canvas.getContext(\'2d\');\n      this.names = [];\n      this.rotation = 0; // radians\n      this.isSpinning = false;\n      this.frame = null;\n      this.onResult = options.onResult || function() {};\n      this.theme = options.theme || \'light\';\n      this.padAngle = 0.02; // radians padding between segments\n      this.textColor = \'#111\';\n      this._devicePixelRatioFix();\n      window.addEventListener(\'resize\', () =&gt; { this._devicePixelRatioFix(); this.draw(); });\n    }\n    _devicePixelRatioFix() {\n      const dpr = window.devicePixelRatio || 1;\n      const rect = this.canvas.getBoundingClientRect();\n      // If rect has zero size (canvas not yet laid out), use current width/height attributes as fallback\n      const width = rect.width || (this.canvas.width / dpr);\n      const height = rect.height || (this.canvas.height / dpr);\n      this.canvas.width = width * dpr;\n      this.canvas.height = height * dpr;\n      this.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n      this.centerX = width / 2;\n      this.centerY = height / 2;\n      this.radius = Math.min(width, height) / 2 - 18;\n    }\n    setTheme(themeId) { this.theme = themeId; this.draw(); }\n    setNames(names) {\n      this.names = names.slice();\n      this.draw();\n    }\n    addName(name) {\n      this.names.push(name);\n      this.draw();\n    }\n    removeName(index) {\n      if (index &gt;= 0 &amp;&amp; index &lt; this.names.length) {\n        this.names.splice(index,1);\n        this.draw();\n      }\n    }\n    clearNames() {\n      this.names = [];\n      this.draw();\n    }\n    draw() {\n      const ctx = this.ctx;\n      const w = this.canvas.width / (window.devicePixelRatio || 1);\n      const h = this.canvas.height / (window.devicePixelRatio || 1);\n      ctx.clearRect(0,0,w,h);\n      ctx.save();\n      ctx.translate(this.centerX, this.centerY);\n      ctx.rotate(this.rotation);\n      // draw segments\n      const count = Math.max(this.names.length, 1);\n      const palette = THEME_PALETTES[this.theme] || THEME_PALETTES.light;\n      for (let i = 0; i &lt; count; i++) {\n        const start = (i / count) * Math.PI * 2;\n        const end = ((i + 1) / count) * Math.PI * 2;\n        ctx.beginPath();\n        ctx.moveTo(0,0);\n        ctx.arc(0,0,this.radius, start + this.padAngle, end - this.padAngle, false);\n        ctx.closePath();\n        const color = palette[i % palette.length];\n        ctx.fillStyle = color;\n        ctx.fill();\n        ctx.strokeStyle = (i % 2 === 0) ? \'rgba(0,0,0,0.06)\' : \'rgba(0,0,0,0.03)\';\n        ctx.lineWidth = 1;\n        ctx.stroke();\n        // draw text label\n        const mid = (start + end) / 2;\n        ctx.save();\n        ctx.rotate(mid);\n        ctx.translate(this.radius * 0.6, 0);\n        ctx.rotate(Math.PI/2);\n        ctx.fillStyle = getTextColor(color);\n        ctx.font = `${Math.max(12, Math.min(22, this.radius / 8))}px sans-serif`;\n        ctx.textAlign = \'center\';\n        ctx.textBaseline = \'middle\';\n        const label = (this.names.length === 0) ? \'Add names\' : this.names[i % this.names.length];\n        wrapFillText(ctx, label, 0, 0, this.radius * 0.5, 16);\n        ctx.restore();\n      }\n      // draw center circle\n      ctx.beginPath();\n      ctx.arc(0,0, this.radius * 0.16, 0, Math.PI*2);\n      ctx.fillStyle = \'rgba(255,255,255,0.9)\';\n      ctx.fill();\n      ctx.strokeStyle = \'rgba(0,0,0,0.06)\';\n      ctx.stroke();\n      ctx.restore();\n      // draw outer ring (pointer side neutral)\n      ctx.beginPath();\n      ctx.arc(this.centerX, this.centerY, this.radius + 10, 0, Math.PI*2);\n      ctx.strokeStyle = \'rgba(0,0,0,0.03)\';\n      ctx.lineWidth = 2;\n      ctx.stroke();\n    }\n    spin() {\n      if (this.isSpinning || this.names.length === 0) return;\n      this.isSpinning = true;\n      const count = this.names.length;\n      // Determine random winner index to land on:\n      const winnerIndex = rand(0, count - 1);\n      // Calculate final rotation so that winner segment lines up with pointer at top (pointer at canvas top - rotation must align)\n      // Our pointer is at the top (canvas 0 angle). The segment mid-angle for index i (without rotation) is ((i + 0.5)/count)*2pi\n      const segmentMid = ((winnerIndex + 0.5) / count) * Math.PI * 2;\n      // We want segmentMid + rotation_final == -Math.PI/2 (so it points at the top pointer), so rotation_final = -Math.PI/2 - segmentMid + 2pi*N\n      const extraTurns = rand(5, 8); // full spins\n      const rotationFinal = -Math.PI/2 - segmentMid + extraTurns * Math.PI * 2;\n      const startRotation = this.rotation % (Math.PI * 2);\n      const delta = rotationFinal - startRotation;\n      const duration = 4000 + Math.random() * 1500; // ms\n      const startTime = performance.now();\n      const animate = (now) =&gt; {\n        const elapsed = now - startTime;\n        const t = Math.min(elapsed / duration, 1);\n        const eased = easeOutCubic(t);\n        this.rotation = startRotation + delta * eased;\n        this.draw();\n        if (t &lt; 1) {\n          this.frame = requestAnimationFrame(animate);\n        } else {\n          this.isSpinning = false;\n          // Normalize rotation within 0..2pi\n          this.rotation = ((this.rotation % (Math.PI*2)) + Math.PI*2) % (Math.PI*2);\n          this.draw();\n          // Compute final winner index again from rotation\n          // finalAngle: the angle of the segment at pointer (0 at right, +counterclockwise). We compute a normalized angle that maps to segment index.\n          const finalAngle = ((-this.rotation - Math.PI/2) % (Math.PI*2) + Math.PI*2) % (Math.PI*2);\n          const resultingIndex = Math.floor((finalAngle / (Math.PI*2)) * count) % count;\n          const winner = this.names[resultingIndex];\n          this.onResult({ index: resultingIndex, name: winner });\n        }\n      };\n      this.frame = requestAnimationFrame(animate);\n    }\n  }\n  // Helper: pick readable text color for a background\n  function getTextColor(hex) {\n    // remove # and convert\n    const h = hex.replace(\'#\',\'\');\n    const r = parseInt(h.substring(0,2),16);\n    const g = parseInt(h.substring(2,4),16);\n    const b = parseInt(h.substring(4,6),16);\n    // luminance\n    const lum = (0.299*r + 0.587*g + 0.114*b) / 255;\n    return lum &gt; 0.65 ? \'#111\' : \'#fff\';\n  }\n  // Helper: wrap text within a given width (draws multi-line if necessary)\n  function wrapFillText(ctx, text, x, y, maxWidth, lineHeight) {\n    const words = (text || \'\').split(/\\s+/);\n    if (words.length === 0) return;\n    let line = \'\';\n    const lines = [];\n    for (let n = 0; n &lt; words.length; n++) {\n      const testLine = line ? line + \' \' + words[n] : words[n];\n      const metrics = ctx.measureText(testLine);\n      if (metrics.width &gt; maxWidth &amp;&amp; line) {\n        lines.push(line);\n        line = words[n];\n      } else {\n        line = testLine;\n      }\n    }\n    if (line) lines.push(line);\n    // If still too many lines, just draw what\'s possible (we rely on font size)\n    for (let i=0;i&lt;lines.length;i++){\n      ctx.fillText(lines[i], x, y + (i - (lines.length-1)/2) * lineHeight);\n    }\n  }\n  // UI glue\n  document.addEventListener(\'DOMContentLoaded\', () =&gt; {\n    const canvas = document.getElementById(\'wheelCanvas\');\n    const wheel = new Wheel(canvas, { theme: \'light\', onResult: onWinner });\n    const nameInput = document.getElementById(\'nameInput\');\n    const addBtn = document.getElementById(\'addBtn\');\n    const addRandomBtn = document.getElementById(\'addRandomBtn\');\n    const bulkInput = document.getElementById(\'bulkInput\');\n    const bulkAddBtn = document.getElementById(\'bulkAddBtn\');\n    const clearBulkBtn = document.getElementById(\'clearBulkBtn\');\n    const nameList = document.getElementById(\'nameList\');\n    const countSpan = document.getElementById(\'count\');\n    const spinBtn = document.getElementById(\'spinBtn\');\n    const rerollBtn = document.getElementById(\'rerollBtn\');\n    const clearNamesBtn = document.getElementById(\'clearNamesBtn\');\n    const themeSelect = document.getElementById(\'themeSelect\');\n    const resultSection = document.getElementById(\'result\');\n    const winnerNameDiv = document.getElementById(\'winnerName\');\n    const exportBtn = document.getElementById(\'exportBtn\');\n    const importBtn = document.getElementById(\'importBtn\');\n    const importFile = document.getElementById(\'importFile\');\n    // Initial draw\n    wheel.draw();\n    function updateUI() {\n      const names = wheel.names;\n      countSpan.textContent = names.length;\n      renderNameList();\n    }\n    function renderNameList() {\n      nameList.innerHTML = \'\';\n      wheel.names.forEach((n, i) =&gt; {\n        const li = document.createElement(\'li\');\n        const span = document.createElement(\'span\');\n        span.textContent = n;\n        li.appendChild(span);\n        const btn = document.createElement(\'button\');\n        btn.title = \'Remove\';\n        btn.setAttribute(\'aria-label\', `Remove ${n}`);\n        btn.innerHTML = \'✕\';\n        btn.addEventListener(\'click\', () =&gt; {\n          wheel.removeName(i);\n          updateUI();\n        });\n        li.appendChild(btn);\n        nameList.appendChild(li);\n      });\n    }\n    function addNameFromInput() {\n      const v = nameInput.value.trim();\n      if (!v) { showMessage(\'Please enter a name.\', \'warn\'); return; }\n      wheel.addName(v);\n      nameInput.value = \'\';\n      updateUI();\n    }\n    addBtn.addEventListener(\'click\', addNameFromInput);\n    nameInput.addEventListener(\'keydown\', (e) =&gt; { if (e.key === \'Enter\') addNameFromInput(); });\n    addRandomBtn.addEventListener(\'click\', () =&gt; {\n      const samples = [\'Alex\',\'Jordan\',\'Taylor\',\'Sam\',\'Jamie\',\'Casey\',\'Morgan\',\'Riley\',\'Avery\',\'Dana\'];\n      const count = rand(3,6);\n      for (let i=0;i&lt;count;i++) wheel.addName(samples[rand(0,samples.length-1)] + (rand(1,100)));\n      updateUI();\n    });\n    bulkAddBtn.addEventListener(\'click\', () =&gt; {\n      const text = bulkInput.value.trim();\n      if (!text) { showMessage(\'Bulk input is empty.\', \'warn\'); return; }\n      const parsed = text.split(/[\\n,;]+/).map(s =&gt; s.trim()).filter(s =&gt; s);\n      parsed.forEach(p =&gt; wheel.addName(p));\n      bulkInput.value = \'\';\n      updateUI();\n      showMessage(`Added ${parsed.length} names.`, \'info\');\n    });\n    clearBulkBtn.addEventListener(\'click\', () =&gt; { bulkInput.value = \'\'; });\n    spinBtn.addEventListener(\'click\', () =&gt; {\n      if (wheel.names.length === 0) { showMessage(\'Add at least one name to spin.\', \'warn\'); return; }\n      resultSection.hidden = true;\n      winnerNameDiv.textContent = \'\';\n      wheel.spin();\n      spinBtn.disabled = true;\n      const checkFinish = setInterval(() =&gt; {\n        if (!wheel.isSpinning) {\n          clearInterval(checkFinish);\n          spinBtn.disabled = false;\n        }\n      }, 200);\n    });\n    rerollBtn.addEventListener(\'click\', () =&gt; {\n      resultSection.hidden = true;\n      wheel.spin();\n    });\n    clearNamesBtn.addEventListener(\'click\', () =&gt; {\n      if (confirm(\'Clear all names?\')) {\n        wheel.clearNames();\n        updateUI();\n      }\n    });\n    themeSelect.addEventListener(\'change\', (e) =&gt; {\n      const t = e.target.value;\n      document.body.className = \'theme-\' + t;\n      wheel.setTheme(t);\n    });\n    function onWinner(result) {\n      winnerNameDiv.textContent = result.name || \'—\';\n      resultSection.hidden = false;\n      // Flash the winner item in the list (if still present)\n      const items = Array.from(nameList.children);\n      items.forEach((li, idx) =&gt; { li.classList.toggle(\'winner\', idx === result.index); });\n      showMessage(`Winner: ${result.name}`, \'success\', 4000);\n    }\n    // Simple message area\n    function showMessage(text, type = \'info\', duration = 2200) {\n      // create small toast\n      const t = document.createElement(\'div\');\n      t.className = \'tmp-toast \' + type;\n      t.textContent = text;\n      document.body.appendChild(t);\n      // Force reflow to pick up transitions\n      window.getComputedStyle(t).opacity;\n      setTimeout(()=&gt; { t.style.opacity = \'0\'; t.style.transform = \'translateY(-10px)\'; }, duration - 300);\n      setTimeout(()=&gt; { try { t.remove(); } catch(e){} }, duration);\n    }\n    // Export/import CSV\n    exportBtn.addEventListener(\'click\', () =&gt; {\n      if (wheel.names.length === 0) { showMessage(\'No names to export.\', \'warn\'); return; }\n      const csv = wheel.names.map(n =&gt; `"${(n||\'\').replace(/"/g,\'""\')}"`).join(\'\\n\');\n      const blob = new Blob([csv], { type: \'text/csv\' });\n      const url = URL.createObjectURL(blob);\n      const a = document.createElement(\'a\');\n      a.href = url;\n      a.download = \'participants.csv\';\n      document.body.appendChild(a);\n      a.click();\n      a.remove();\n      URL.revokeObjectURL(url);\n      showMessage(\'Exported CSV\', \'info\');\n    });\n    importBtn.addEventListener(\'click\', () =&gt; { importFile.click(); });\n    importFile.addEventListener(\'change\', (e) =&gt; {\n      const file = e.target.files[0];\n      if (!file) return;\n      const reader = new FileReader();\n      reader.onload = (ev) =&gt; {\n        const txt = ev.target.result;\n        const lines = txt.split(/\\r?\\n/).map(s =&gt; s.trim()).filter(s =&gt; s);\n        // basic CSV unquote\n        const parsed = lines.map(l =&gt; {\n          // simple CSV single-column parse: handle quoted fields\n          if (l.startsWith(\'"\') &amp;&amp; l.endsWith(\'"\')) {\n            return l.slice(1,-1).replace(/""/g,\'"\');\n          }\n          return l;\n        });\n        parsed.forEach(p =&gt; wheel.addName(p));\n        updateUI();\n        showMessage(`Imported ${parsed.length} names`, \'info\');\n      };\n      reader.readAsText(file);\n      importFile.value = \'\';\n    });\n    // Initial sample (optional)\n    // wheel.addName(\'Alice\'); wheel.addName(\'Bob\'); wheel.addName(\'Charlie\');\n    updateUI();\n    // (Optional) keyboard shortcuts\n    window.addEventListener(\'keydown\', (e) =&gt; {\n      if ((e.ctrlKey || e.metaKey) &amp;&amp; e.key.toLowerCase() === \'k\') {\n        e.preventDefault();\n        nameInput.focus();\n      }\n      if (e.key === \' \') {\n        // space triggers spin if not focusing an input\n        if (document.activeElement.tagName !== \'INPUT\' &amp;&amp; document.activeElement.tagName !== \'TEXTAREA\') {\n          e.preventDefault();\n          spinBtn.click();\n        }\n      }\n    });\n  });\n})(); \n\n\n', 'images': '', 'comments': " Fix pointer alignment so the visual pointer actually sits over the wheel center (highest priority)\n\nWhy: the spin logic aligns a winning segment to the top/center of the wheel (math uses -Math.PI/2). However the .pointer element in CSS is not horizontally centered — it only has top:6px and transform: translateY(-50%). That places the pointer near the top-left of the wheel container instead of top-center. Users will see the pointer off-center and may be confused because the wheel rotates to point at the top-center but the visible pointer isn't there. This breaks the main UX (the pointer must accurately indicate the selected segment).\n\nHow to fix: center the pointer horizontally, keep it visually above the wheel, and ensure it has a higher stacking order than the canvas. Replace (or update) the .pointer CSS rule with the following:\n\n/ Replace existing .pointer rule with this /\n.pointer {\n  position: absolute;\n  top: 8px;               / vertical offset from top of wheel container /\n  left: 50%;              / center horizontally /\n  transform: translate(-50%, -50%); / truly center at top middle /\n  font-size: 28px;\n  z-index: 10;            / ensure it's above the canvas /\n  color: var(--accent);\n  pointer-events: none;\n  text-shadow: 0 2px 8px rgba(0,0,0,0.25);\n}\n\nOptional improvement (sharper pointer): instead of a glyph, use a small CSS triangle so it's visually clear. Example:\n\n.pointer {\n  position: absolute;\n  top: 8px;\n  left: 50%;\n  transform: translateX(-50%);\n  width: 0;\n  height: 0;\n  border-left: 10px solid transparent;\n  border-right: 10px solid transparent;\n  border-bottom: 16px solid var(--accent);\n  z-index: 10;\n  pointer-events: none;\n}\n\nSteps to apply:\n1. Edit styles.css and replace the existing .pointer rule with one of the options above.\n2. Reload the page and verify the pointer is centered over the wheel and the winners line up precisely under the pointer.\n\nWhy this is the top priority: the visual pointer's position directly contradicts the wheel's spin logic; fixing this restores the core user experience (clear, accurate winner indication) without any other code changes."} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_3_5_TURBO |

[2025-17-09 13:42:27 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Programmer |
| **user_role_name** | Code Reviewer |
| **assistant_role_prompt** | {chatdev_prompt} You are Programmer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. You can write/create computer software or applications by providing a specific programming language to the computer. You have extensive computing and coding experience in many varieties of programming languages and platforms, such as Python, Java, C, C++, HTML, CSS, JavaScript, XML, SQL, PHP, etc,. Here is a new customer's task: {task}. To complete the task, you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Code Reviewer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. You can help programmers to assess source codes for software troubleshooting, fix bugs to increase code quality and robustness, and offer proposals to improve the source codes. Here is a new customer's task: {task}. To complete the task, you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **task_prompt** | [Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes. Do it in HTML, CSS, and JavaScript.] |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_3_5_TURBO |
| **background_prompt** | ChatDev is a software company powered by multiple intelligent agents, such as chief executive officer, chief human resources officer, chief product officer, chief technology officer, etc, with a multi-agent organizational structure and the mission of 'changing the digital world through programming'. |

[2025-17-09 13:42:27 INFO] Code Reviewer: **[Start Chat]**

[ChatDev is a software company powered by multiple intelligent agents, such as chief executive officer, chief human resources officer, chief product officer, chief technology officer, etc, with a multi-agent organizational structure and the mission of 'changing the digital world through programming'.
You are Programmer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer.
You can write/create computer software or applications by providing a specific programming language to the computer. You have extensive computing and coding experience in many varieties of programming languages and platforms, such as Python, Java, C, C++, HTML, CSS, JavaScript, XML, SQL, PHP, etc,.
Here is a new customer's task: [Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes. Do it in HTML, CSS, and JavaScript.].
To complete the task, you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]

According to the new user's task, our designed product modality, languages and ideas, our developed first-edition source codes are listed below: 
Task: "[Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes. Do it in HTML, CSS, and JavaScript.]".
Modality: "website".
Programming Language: " JavaScript"
Ideas: ""
Codes: 
"index.html
```html
<!--
DOCSTRING
This is the main HTML file for the Random Winner Wheel.
It contains the structure: input fields to add names, a canvas for the wheel,
controls (spin, clear, bulk add), theme selector, and placeholders for CSS/JS.
-->
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Random Winner Wheel</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body class="theme-light">
  <header>
    <h1>Random Winner Wheel</h1>
    <p>Enter participant names, choose a theme, and spin to pick a winner.</p>
  </header>
  <main>
    <section class="controls">
      <div class="add-single">
        <input id="nameInput" type="text" placeholder="Enter a name and press Add" aria-label="Name input" />
        <button id="addBtn">Add</button>
        <button id="addRandomBtn" title="Add a few sample random names">Add Sample</button>
      </div>
      <div class="bulk-add">
        <label for="bulkInput">Bulk add (comma, newline or semicolon separated):</label>
        <textarea id="bulkInput" placeholder="Alice, Bob, Charlie"></textarea>
        <div class="bulk-actions">
          <button id="bulkAddBtn">Bulk Add</button>
          <button id="clearBulkBtn">Clear Bulk</button>
        </div>
      </div>
      <div class="list-actions">
        <div class="theme-select">
          <label for="themeSelect">Theme:</label>
          <select id="themeSelect">
            <option value="light">Light</option>
            <option value="dark">Dark</option>
            <option value="neon">Neon</option>
            <option value="pastel">Pastel</option>
            <option value="retro">Retro</option>
          </select>
        </div>
        <div class="wheel-controls">
          <button id="spinBtn" class="primary">Spin</button>
          <button id="clearNamesBtn">Clear Names</button>
          <button id="exportBtn">Export CSV</button>
          <input id="importFile" type="file" accept=".csv,text/csv" style="display:none">
          <button id="importBtn">Import CSV</button>
        </div>
      </div>
    </section>
    <section class="wheel-area">
      <div class="wheel-container">
        <canvas id="wheelCanvas" width="600" height="600" aria-label="Spinning wheel"></canvas>
        <div class="pointer" aria-hidden="true">▼</div>
      </div>
      <aside class="participants">
        <h2>Participants (<span id="count">0</span>)</h2>
        <ul id="nameList" aria-live="polite"></ul>
      </aside>
    </section>
    <section class="result" id="result" aria-live="polite" hidden>
      <h2>Winner</h2>
      <div id="winnerName" class="winnerName"></div>
      <button id="rerollBtn">Spin Again</button>
    </section>
  </main>
  <footer>
    <small>Built with HTML, CSS, and JavaScript. Themes change both UI and wheel colors.</small>
  </footer>
  <script src="script.js"></script>
</body>
</html>
```

styles.css
```css
/*
DOCSTRING
Stylesheet for the Random Winner Wheel.
Defines layout, themes, wheel container sizing, animations, and toast styles.
*/
/* Reset & base */
* { box-sizing: border-box; margin: 0; padding: 0; }
html,body { height: 100%; font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; background: var(--bg); color: var(--fg); }
:root {
  --bg: #f7f8fb;
  --fg: #222;
  --muted: #666;
  --accent: #2b8cff;
  --card: #ffffff;
  --primary-btn-bg: var(--accent);
  --primary-btn-fg: #fff;
  --shadow: rgba(15,15,15,0.08);
}
/* Themes */
body.theme-light {
  --bg: #f7f8fb;
  --fg: #222;
  --muted: #5b6170;
  --accent: #2b8cff;
  --card: #fff;
  --wheel-seq: 0;
}
body.theme-dark {
  --bg: #0f1724;
  --fg: #e6eef8;
  --muted: #a9b1c2;
  --accent: #7c5cff;
  --card: #0b1220;
}
body.theme-neon {
  --bg: #0a0a0f;
  --fg: #e9f9ff;
  --muted: #a6f3ff;
  --accent: #39ff14;
  --card: #09101a;
}
body.theme-pastel {
  --bg: #fffaf6;
  --fg: #3c3a3a;
  --muted: #8d8a8a;
  --accent: #ff7aa2;
  --card: #fff;
}
body.theme-retro {
  --bg: #fff6e7;
  --fg: #402b2b;
  --muted: #856e6e;
  --accent: #ffb86b;
  --card: #fff0e6;
}
/* Layout */
header { padding: 18px 24px; text-align: center; background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent); }
header h1 { font-size: 1.5rem; margin-bottom: 6px; }
main { padding: 18px; max-width: 1100px; margin: 0 auto; }
.controls { display: grid; gap: 12px; margin-bottom: 18px; }
.add-single { display:flex; gap:8px; }
.add-single input[type="text"] { flex:1; padding:10px; border-radius:8px; border:1px solid rgba(0,0,0,0.08); background:var(--card); color:var(--fg); }
.add-single button { padding:10px 12px; border-radius:8px; border: none; cursor:pointer; background: var(--primary-btn-bg); color: var(--primary-btn-fg); }
.add-single button#addRandomBtn { background: transparent; border: 1px solid rgba(0,0,0,0.06); color: var(--fg); }
.bulk-add textarea { width:100%; min-height:64px; margin-top:6px; padding:8px; border-radius:8px; border:1px solid rgba(0,0,0,0.06); background:var(--card); color:var(--fg); }
.bulk-actions { display:flex; gap:8px; margin-top:8px; }
.list-actions { display:flex; justify-content:space-between; align-items:center; gap:16px; flex-wrap:wrap; }
.theme-select select { padding:8px; border-radius:8px; border:1px solid rgba(0,0,0,0.06); }
.wheel-area { display:flex; gap:18px; align-items:start; flex-wrap:wrap; }
.wheel-container { position: relative; width: 600px; height: 600px; max-width: 90vw; max-height: 90vw; display:flex; align-items:center; justify-content:center; background: transparent; }
.pointer { position:absolute; top:6px; font-size:28px; transform: translateY(-50%); text-shadow: 0 2px 8px rgba(0,0,0,0.25); color: var(--accent); pointer-events:none; }
.participants { width: 320px; max-width: 40vw; background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent); padding:12px; border-radius:10px; box-shadow: 0 6px 18px var(--shadow); }
.participants h2 { margin-bottom:8px; font-size:1.05rem; }
#nameList { list-style:none; max-height:420px; overflow:auto; display:block; }
#nameList li { padding:8px; border-radius:6px; display:flex; justify-content:space-between; align-items:center; gap:8px; margin-bottom:8px; background: var(--card); border:1px solid rgba(0,0,0,0.04); }
#nameList li button { background: transparent; border: none; color: var(--muted); cursor:pointer; }
.result { margin-top:18px; padding:12px; border-radius:8px; background: var(--card); text-align:center; box-shadow: 0 6px 18px var(--shadow); }
.result .winnerName { font-size:1.4rem; font-weight:700; margin:8px 0; color: var(--accent); }
/* Buttons */
button { cursor:pointer; padding:8px 12px; border-radius:8px; border:1px solid rgba(0,0,0,0.06); background: transparent; color:var(--fg); }
button.primary { background: var(--primary-btn-bg); color: var(--primary-btn-fg); border: none; }
/* Responsive */
@media (max-width: 900px) {
  .wheel-area { flex-direction:column; align-items:center; }
  .participants { width: 100%; max-width: 100%; }
}
/* Wheel canvas scaling helper */
#wheelCanvas { border-radius:50%; box-shadow: 0 12px 26px rgba(0,0,0,0.12); background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.02), transparent); }
/* Toast / temporary message styles (used by showMessage) */
.tmp-toast {
  position: fixed;
  left: 50%;
  transform: translateX(-50%);
  top: 18px;
  background: rgba(0,0,0,0.85);
  color: #fff;
  padding: 8px 12px;
  border-radius: 6px;
  z-index: 9999;
  transition: opacity 0.25s, transform 0.25s;
  opacity: 1;
  pointer-events: none;
  font-size: 0.95rem;
  box-shadow: 0 6px 18px rgba(0,0,0,0.18);
}
.tmp-toast.success { background: rgba(56, 198, 123, 0.95); }
.tmp-toast.warn    { background: rgba(255, 159, 67, 0.95); color: #2b1500; }
.tmp-toast.info    { background: rgba(12, 74, 255, 0.95); }
/* Winner highlight for participants list */
#nameList li.winner {
  outline: 3px solid rgba(255,215,0,0.15);
  box-shadow: 0 6px 18px rgba(255,215,0,0.06);
  transform: scale(1.01);
}
```

script.js
```js
/* 
DOCSTRING
Script for the Random Winner Wheel.
Contains the Wheel class to draw and spin the canvas-based wheel and UI glue code to manage names and themes.
*/
/* Main JavaScript - Wheel + UI logic */
(() => {
  // Utilities
  function rand(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }
  function easeOutCubic(t) { return 1 - Math.pow(1 - t, 3); }
  // Color palettes for themes (will be used to paint wheel segments)
  const THEME_PALETTES = {
    light: ['#FF8A80','#FFD180','#FFF59D','#C8E6C9','#80DEEA','#A7FFEB','#B39DDB','#90CAF9'],
    dark: ['#ff6b6b','#ffd166','#faff8e','#b9f6ca','#4dd0e1','#80cbc4','#b388ff','#64b5f6'],
    neon: ['#ff2d95','#7cff01','#00ffff','#ffdd00','#ff6a00','#00ff9e','#ff00ff','#47ffa2'],
    pastel: ['#ffdbe9','#fff0b3','#d1ffd6','#cfefff','#e7dfff','#ffd6e7','#fbe7d6','#e6f7ff'],
    retro: ['#ffb86b','#ffd3a8','#f3e2a9','#b8e0d2','#c0b9ff','#ffb6c1','#f6c49f','#c3d69b']
  };
  // Wheel class
  class Wheel {
    /*
    Manage wheel: drawing, recalculating segments, spinning animation, and determining winner.
    */
    constructor(canvas, options = {}) {
      this.canvas = canvas;
      this.ctx = canvas.getContext('2d');
      this.names = [];
      this.rotation = 0; // radians
      this.isSpinning = false;
      this.frame = null;
      this.onResult = options.onResult || function() {};
      this.theme = options.theme || 'light';
      this.padAngle = 0.02; // radians padding between segments
      this.textColor = '#111';
      this._devicePixelRatioFix();
      window.addEventListener('resize', () => { this._devicePixelRatioFix(); this.draw(); });
    }
    _devicePixelRatioFix() {
      const dpr = window.devicePixelRatio || 1;
      const rect = this.canvas.getBoundingClientRect();
      // If rect has zero size (canvas not yet laid out), use current width/height attributes as fallback
      const width = rect.width || (this.canvas.width / dpr);
      const height = rect.height || (this.canvas.height / dpr);
      this.canvas.width = width * dpr;
      this.canvas.height = height * dpr;
      this.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      this.centerX = width / 2;
      this.centerY = height / 2;
      this.radius = Math.min(width, height) / 2 - 18;
    }
    setTheme(themeId) { this.theme = themeId; this.draw(); }
    setNames(names) {
      this.names = names.slice();
      this.draw();
    }
    addName(name) {
      this.names.push(name);
      this.draw();
    }
    removeName(index) {
      if (index >= 0 && index < this.names.length) {
        this.names.splice(index,1);
        this.draw();
      }
    }
    clearNames() {
      this.names = [];
      this.draw();
    }
    draw() {
      const ctx = this.ctx;
      const w = this.canvas.width / (window.devicePixelRatio || 1);
      const h = this.canvas.height / (window.devicePixelRatio || 1);
      ctx.clearRect(0,0,w,h);
      ctx.save();
      ctx.translate(this.centerX, this.centerY);
      ctx.rotate(this.rotation);
      // draw segments
      const count = Math.max(this.names.length, 1);
      const palette = THEME_PALETTES[this.theme] || THEME_PALETTES.light;
      for (let i = 0; i < count; i++) {
        const start = (i / count) * Math.PI * 2;
        const end = ((i + 1) / count) * Math.PI * 2;
        ctx.beginPath();
        ctx.moveTo(0,0);
        ctx.arc(0,0,this.radius, start + this.padAngle, end - this.padAngle, false);
        ctx.closePath();
        const color = palette[i % palette.length];
        ctx.fillStyle = color;
        ctx.fill();
        ctx.strokeStyle = (i % 2 === 0) ? 'rgba(0,0,0,0.06)' : 'rgba(0,0,0,0.03)';
        ctx.lineWidth = 1;
        ctx.stroke();
        // draw text label
        const mid = (start + end) / 2;
        ctx.save();
        ctx.rotate(mid);
        ctx.translate(this.radius * 0.6, 0);
        ctx.rotate(Math.PI/2);
        ctx.fillStyle = getTextColor(color);
        ctx.font = `${Math.max(12, Math.min(22, this.radius / 8))}px sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        const label = (this.names.length === 0) ? 'Add names' : this.names[i % this.names.length];
        wrapFillText(ctx, label, 0, 0, this.radius * 0.5, 16);
        ctx.restore();
      }
      // draw center circle
      ctx.beginPath();
      ctx.arc(0,0, this.radius * 0.16, 0, Math.PI*2);
      ctx.fillStyle = 'rgba(255,255,255,0.9)';
      ctx.fill();
      ctx.strokeStyle = 'rgba(0,0,0,0.06)';
      ctx.stroke();
      ctx.restore();
      // draw outer ring (pointer side neutral)
      ctx.beginPath();
      ctx.arc(this.centerX, this.centerY, this.radius + 10, 0, Math.PI*2);
      ctx.strokeStyle = 'rgba(0,0,0,0.03)';
      ctx.lineWidth = 2;
      ctx.stroke();
    }
    spin() {
      if (this.isSpinning || this.names.length === 0) return;
      this.isSpinning = true;
      const count = this.names.length;
      // Determine random winner index to land on:
      const winnerIndex = rand(0, count - 1);
      // Calculate final rotation so that winner segment lines up with pointer at top (pointer at canvas top - rotation must align)
      // Our pointer is at the top (canvas 0 angle). The segment mid-angle for index i (without rotation) is ((i + 0.5)/count)*2pi
      const segmentMid = ((winnerIndex + 0.5) / count) * Math.PI * 2;
      // We want segmentMid + rotation_final == -Math.PI/2 (so it points at the top pointer), so rotation_final = -Math.PI/2 - segmentMid + 2pi*N
      const extraTurns = rand(5, 8); // full spins
      const rotationFinal = -Math.PI/2 - segmentMid + extraTurns * Math.PI * 2;
      const startRotation = this.rotation % (Math.PI * 2);
      const delta = rotationFinal - startRotation;
      const duration = 4000 + Math.random() * 1500; // ms
      const startTime = performance.now();
      const animate = (now) => {
        const elapsed = now - startTime;
        const t = Math.min(elapsed / duration, 1);
        const eased = easeOutCubic(t);
        this.rotation = startRotation + delta * eased;
        this.draw();
        if (t < 1) {
          this.frame = requestAnimationFrame(animate);
        } else {
          this.isSpinning = false;
          // Normalize rotation within 0..2pi
          this.rotation = ((this.rotation % (Math.PI*2)) + Math.PI*2) % (Math.PI*2);
          this.draw();
          // Compute final winner index again from rotation
          // finalAngle: the angle of the segment at pointer (0 at right, +counterclockwise). We compute a normalized angle that maps to segment index.
          const finalAngle = ((-this.rotation - Math.PI/2) % (Math.PI*2) + Math.PI*2) % (Math.PI*2);
          const resultingIndex = Math.floor((finalAngle / (Math.PI*2)) * count) % count;
          const winner = this.names[resultingIndex];
          this.onResult({ index: resultingIndex, name: winner });
        }
      };
      this.frame = requestAnimationFrame(animate);
    }
  }
  // Helper: pick readable text color for a background
  function getTextColor(hex) {
    // remove # and convert
    const h = hex.replace('#','');
    const r = parseInt(h.substring(0,2),16);
    const g = parseInt(h.substring(2,4),16);
    const b = parseInt(h.substring(4,6),16);
    // luminance
    const lum = (0.299*r + 0.587*g + 0.114*b) / 255;
    return lum > 0.65 ? '#111' : '#fff';
  }
  // Helper: wrap text within a given width (draws multi-line if necessary)
  function wrapFillText(ctx, text, x, y, maxWidth, lineHeight) {
    const words = (text || '').split(/\s+/);
    if (words.length === 0) return;
    let line = '';
    const lines = [];
    for (let n = 0; n < words.length; n++) {
      const testLine = line ? line + ' ' + words[n] : words[n];
      const metrics = ctx.measureText(testLine);
      if (metrics.width > maxWidth && line) {
        lines.push(line);
        line = words[n];
      } else {
        line = testLine;
      }
    }
    if (line) lines.push(line);
    // If still too many lines, just draw what's possible (we rely on font size)
    for (let i=0;i<lines.length;i++){
      ctx.fillText(lines[i], x, y + (i - (lines.length-1)/2) * lineHeight);
    }
  }
  // UI glue
  document.addEventListener('DOMContentLoaded', () => {
    const canvas = document.getElementById('wheelCanvas');
    const wheel = new Wheel(canvas, { theme: 'light', onResult: onWinner });
    const nameInput = document.getElementById('nameInput');
    const addBtn = document.getElementById('addBtn');
    const addRandomBtn = document.getElementById('addRandomBtn');
    const bulkInput = document.getElementById('bulkInput');
    const bulkAddBtn = document.getElementById('bulkAddBtn');
    const clearBulkBtn = document.getElementById('clearBulkBtn');
    const nameList = document.getElementById('nameList');
    const countSpan = document.getElementById('count');
    const spinBtn = document.getElementById('spinBtn');
    const rerollBtn = document.getElementById('rerollBtn');
    const clearNamesBtn = document.getElementById('clearNamesBtn');
    const themeSelect = document.getElementById('themeSelect');
    const resultSection = document.getElementById('result');
    const winnerNameDiv = document.getElementById('winnerName');
    const exportBtn = document.getElementById('exportBtn');
    const importBtn = document.getElementById('importBtn');
    const importFile = document.getElementById('importFile');
    // Initial draw
    wheel.draw();
    function updateUI() {
      const names = wheel.names;
      countSpan.textContent = names.length;
      renderNameList();
    }
    function renderNameList() {
      nameList.innerHTML = '';
      wheel.names.forEach((n, i) => {
        const li = document.createElement('li');
        const span = document.createElement('span');
        span.textContent = n;
        li.appendChild(span);
        const btn = document.createElement('button');
        btn.title = 'Remove';
        btn.setAttribute('aria-label', `Remove ${n}`);
        btn.innerHTML = '✕';
        btn.addEventListener('click', () => {
          wheel.removeName(i);
          updateUI();
        });
        li.appendChild(btn);
        nameList.appendChild(li);
      });
    }
    function addNameFromInput() {
      const v = nameInput.value.trim();
      if (!v) { showMessage('Please enter a name.', 'warn'); return; }
      wheel.addName(v);
      nameInput.value = '';
      updateUI();
    }
    addBtn.addEventListener('click', addNameFromInput);
    nameInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') addNameFromInput(); });
    addRandomBtn.addEventListener('click', () => {
      const samples = ['Alex','Jordan','Taylor','Sam','Jamie','Casey','Morgan','Riley','Avery','Dana'];
      const count = rand(3,6);
      for (let i=0;i<count;i++) wheel.addName(samples[rand(0,samples.length-1)] + (rand(1,100)));
      updateUI();
    });
    bulkAddBtn.addEventListener('click', () => {
      const text = bulkInput.value.trim();
      if (!text) { showMessage('Bulk input is empty.', 'warn'); return; }
      const parsed = text.split(/[\n,;]+/).map(s => s.trim()).filter(s => s);
      parsed.forEach(p => wheel.addName(p));
      bulkInput.value = '';
      updateUI();
      showMessage(`Added ${parsed.length} names.`, 'info');
    });
    clearBulkBtn.addEventListener('click', () => { bulkInput.value = ''; });
    spinBtn.addEventListener('click', () => {
      if (wheel.names.length === 0) { showMessage('Add at least one name to spin.', 'warn'); return; }
      resultSection.hidden = true;
      winnerNameDiv.textContent = '';
      wheel.spin();
      spinBtn.disabled = true;
      const checkFinish = setInterval(() => {
        if (!wheel.isSpinning) {
          clearInterval(checkFinish);
          spinBtn.disabled = false;
        }
      }, 200);
    });
    rerollBtn.addEventListener('click', () => {
      resultSection.hidden = true;
      wheel.spin();
    });
    clearNamesBtn.addEventListener('click', () => {
      if (confirm('Clear all names?')) {
        wheel.clearNames();
        updateUI();
      }
    });
    themeSelect.addEventListener('change', (e) => {
      const t = e.target.value;
      document.body.className = 'theme-' + t;
      wheel.setTheme(t);
    });
    function onWinner(result) {
      winnerNameDiv.textContent = result.name || '—';
      resultSection.hidden = false;
      // Flash the winner item in the list (if still present)
      const items = Array.from(nameList.children);
      items.forEach((li, idx) => { li.classList.toggle('winner', idx === result.index); });
      showMessage(`Winner: ${result.name}`, 'success', 4000);
    }
    // Simple message area
    function showMessage(text, type = 'info', duration = 2200) {
      // create small toast
      const t = document.createElement('div');
      t.className = 'tmp-toast ' + type;
      t.textContent = text;
      document.body.appendChild(t);
      // Force reflow to pick up transitions
      window.getComputedStyle(t).opacity;
      setTimeout(()=> { t.style.opacity = '0'; t.style.transform = 'translateY(-10px)'; }, duration - 300);
      setTimeout(()=> { try { t.remove(); } catch(e){} }, duration);
    }
    // Export/import CSV
    exportBtn.addEventListener('click', () => {
      if (wheel.names.length === 0) { showMessage('No names to export.', 'warn'); return; }
      const csv = wheel.names.map(n => `"${(n||'').replace(/"/g,'""')}"`).join('\n');
      const blob = new Blob([csv], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'participants.csv';
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
      showMessage('Exported CSV', 'info');
    });
    importBtn.addEventListener('click', () => { importFile.click(); });
    importFile.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (ev) => {
        const txt = ev.target.result;
        const lines = txt.split(/\r?\n/).map(s => s.trim()).filter(s => s);
        // basic CSV unquote
        const parsed = lines.map(l => {
          // simple CSV single-column parse: handle quoted fields
          if (l.startsWith('"') && l.endsWith('"')) {
            return l.slice(1,-1).replace(/""/g,'"');
          }
          return l;
        });
        parsed.forEach(p => wheel.addName(p));
        updateUI();
        showMessage(`Imported ${parsed.length} names`, 'info');
      };
      reader.readAsText(file);
      importFile.value = '';
    });
    // Initial sample (optional)
    // wheel.addName('Alice'); wheel.addName('Bob'); wheel.addName('Charlie');
    updateUI();
    // (Optional) keyboard shortcuts
    window.addEventListener('keydown', (e) => {
      if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'k') {
        e.preventDefault();
        nameInput.focus();
      }
      if (e.key === ' ') {
        // space triggers spin if not focusing an input
        if (document.activeElement.tagName !== 'INPUT' && document.activeElement.tagName !== 'TEXTAREA') {
          e.preventDefault();
          spinBtn.click();
        }
      }
    });
  });
})(); 
```

"
Comments on Codes:
"<PRIORITY> Fix pointer alignment so the visual pointer actually sits over the wheel center (highest priority)

Why: the spin logic aligns a winning segment to the top/center of the wheel (math uses -Math.PI/2). However the .pointer element in CSS is not horizontally centered — it only has top:6px and transform: translateY(-50%). That places the pointer near the top-left of the wheel container instead of top-center. Users will see the pointer off-center and may be confused because the wheel rotates to point at the top-center but the visible pointer isn't there. This breaks the main UX (the pointer must accurately indicate the selected segment).

How to fix: center the pointer horizontally, keep it visually above the wheel, and ensure it has a higher stacking order than the canvas. Replace (or update) the .pointer CSS rule with the following:

/* Replace existing .pointer rule with this */
.pointer {
  position: absolute;
  top: 8px;               /* vertical offset from top of wheel container */
  left: 50%;              /* center horizontally */
  transform: translate(-50%, -50%); /* truly center at top middle */
  font-size: 28px;
  z-index: 10;            /* ensure it's above the canvas */
  color: var(--accent);
  pointer-events: none;
  text-shadow: 0 2px 8px rgba(0,0,0,0.25);
}

Optional improvement (sharper pointer): instead of a glyph, use a small CSS triangle so it's visually clear. Example:

.pointer {
  position: absolute;
  top: 8px;
  left: 50%;
  transform: translateX(-50%);
  width: 0;
  height: 0;
  border-left: 10px solid transparent;
  border-right: 10px solid transparent;
  border-bottom: 16px solid var(--accent);
  z-index: 10;
  pointer-events: none;
}

Steps to apply:
1. Edit styles.css and replace the existing .pointer rule with one of the options above.
2. Reload the page and verify the pointer is centered over the wheel and the winners line up precisely under the pointer.

Why this is the top priority: the visual pointer's position directly contradicts the wheel's spin logic; fixing this restores the core user experience (clear, accurate winner indication) without any other code changes."
In the software, each file must strictly follow a markdown code block format, where the following tokens must be replaced such that "FILENAME" is the lowercase file name including the file extension, "LANGUAGE" in the programming language, "DOCSTRING" is a string literal specified in source code that is used to document a specific segment of code, and "CODE" is the original code. Format:
FILENAME
```LANGUAGE
'''
DOCSTRING
'''
CODE
```
As the Programmer, to satisfy the new user's demand and make the software creative, executive and robust, you should modify corresponding codes according to the comments. Then, output the full and complete codes with all bugs fixed based on the comments. Return all codes strictly following the required format.

[2025-17-09 13:44:49 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2025-17-09 13:44:49 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 7573
completion_tokens: 8000
total_tokens: 15573
cost: $-1.000000


[2025-17-09 13:44:49 INFO] Programmer: **Programmer<->Code Reviewer on : CodeReviewModification, turn 0**

[ChatDev is a software company powered by multiple intelligent agents, such as chief executive officer, chief human resources officer, chief product officer, chief technology officer, etc, with a multi-agent organizational structure and the mission of 'changing the digital world through programming'.
You are Code Reviewer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer.
You can help programmers to assess source codes for software troubleshooting, fix bugs to increase code quality and robustness, and offer proposals to improve the source codes.
Here is a new customer's task: [Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes. Do it in HTML, CSS, and JavaScript.].
To complete the task, you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]

index.html
```html
'''
DOCSTRING
This is the main HTML file for the Random Winner Wheel.
It contains the structure: input fields to add names, a canvas for the wheel,
controls (spin, clear, bulk add), theme selector, and placeholders for CSS/JS.
'''
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Random Winner Wheel</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body class="theme-light">
  <header>
    <h1>Random Winner Wheel</h1>
    <p>Enter participant names, choose a theme, and spin to pick a winner.</p>
  </header>
  <main>
    <section class="controls">
      <div class="add-single">
        <input id="nameInput" type="text" placeholder="Enter a name and press Add" aria-label="Name input" />
        <button id="addBtn">Add</button>
        <button id="addRandomBtn" title="Add a few sample random names">Add Sample</button>
      </div>
      <div class="bulk-add">
        <label for="bulkInput">Bulk add (comma, newline or semicolon separated):</label>
        <textarea id="bulkInput" placeholder="Alice, Bob, Charlie"></textarea>
        <div class="bulk-actions">
          <button id="bulkAddBtn">Bulk Add</button>
          <button id="clearBulkBtn">Clear Bulk</button>
        </div>
      </div>
      <div class="list-actions">
        <div class="theme-select">
          <label for="themeSelect">Theme:</label>
          <select id="themeSelect">
            <option value="light">Light</option>
            <option value="dark">Dark</option>
            <option value="neon">Neon</option>
            <option value="pastel">Pastel</option>
            <option value="retro">Retro</option>
          </select>
        </div>
        <div class="wheel-controls">
          <button id="spinBtn" class="primary">Spin</button>
          <button id="clearNamesBtn">Clear Names</button>
          <button id="exportBtn">Export CSV</button>
          <input id="importFile" type="file" accept=".csv,text/csv" style="display:none">
          <button id="importBtn">Import CSV</button>
        </div>
      </div>
    </section>
    <section class="wheel-area">
      <div class="wheel-container">
        <canvas id="wheelCanvas" width="600" height="600" aria-label="Spinning wheel"></canvas>
        <div class="pointer" aria-hidden="true">▼</div>
      </div>
      <aside class="participants">
        <h2>Participants (<span id="count">0</span>)</h2>
        <ul id="nameList" aria-live="polite"></ul>
      </aside>
    </section>
    <section class="result" id="result" aria-live="polite" hidden>
      <h2>Winner</h2>
      <div id="winnerName" class="winnerName"></div>
      <button id="rerollBtn">Spin Again</button>
    </section>
  </main>
  <footer>
    <small>Built with HTML, CSS, and JavaScript. Themes change both UI and wheel colors.</small>
  </footer>
  <script src="script.js"></script>
</body>
</html>
```

styles.css
```css
'''
DOCSTRING
Stylesheet for the Random Winner Wheel.
Defines layout, themes, wheel container sizing, animations, and toast styles.
'''
/* Reset & base */
* { box-sizing: border-box; margin: 0; padding: 0; }
html,body { height: 100%; font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; background: var(--bg); color: var(--fg); }
:root {
  --bg: #f7f8fb;
  --fg: #222;
  --muted: #666;
  --accent: #2b8cff;
  --card: #ffffff;
  --primary-btn-bg: var(--accent);
  --primary-btn-fg: #fff;
  --shadow: rgba(15,15,15,0.08);
}
/* Themes */
body.theme-light {
  --bg: #f7f8fb;
  --fg: #222;
  --muted: #5b6170;
  --accent: #2b8cff;
  --card: #fff;
  --wheel-seq: 0;
}
body.theme-dark {
  --bg: #0f1724;
  --fg: #e6eef8;
  --muted: #a9b1c2;
  --accent: #7c5cff;
  --card: #0b1220;
}
body.theme-neon {
  --bg: #0a0a0f;
  --fg: #e9f9ff;
  --muted: #a6f3ff;
  --accent: #39ff14;
  --card: #09101a;
}
body.theme-pastel {
  --bg: #fffaf6;
  --fg: #3c3a3a;
  --muted: #8d8a8a;
  --accent: #ff7aa2;
  --card: #fff;
}
body.theme-retro {
  --bg: #fff6e7;
  --fg: #402b2b;
  --muted: #856e6e;
  --accent: #ffb86b;
  --card: #fff0e6;
}
/* Layout */
header { padding: 18px 24px; text-align: center; background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent); }
header h1 { font-size: 1.5rem; margin-bottom: 6px; }
main { padding: 18px; max-width: 1100px; margin: 0 auto; }
.controls { display: grid; gap: 12px; margin-bottom: 18px; }
.add-single { display:flex; gap:8px; }
.add-single input[type="text"] { flex:1; padding:10px; border-radius:8px; border:1px solid rgba(0,0,0,0.08); background:var(--card); color:var(--fg); }
.add-single button { padding:10px 12px; border-radius:8px; border: none; cursor:pointer; background: var(--primary-btn-bg); color: var(--primary-btn-fg); }
.add-single button#addRandomBtn { background: transparent; border: 1px solid rgba(0,0,0,0.06); color: var(--fg); }
.bulk-add textarea { width:100%; min-height:64px; margin-top:6px; padding:8px; border-radius:8px; border:1px solid rgba(0,0,0,0.06); background:var(--card); color:var(--fg); }
.bulk-actions { display:flex; gap:8px; margin-top:8px; }
.list-actions { display:flex; justify-content:space-between; align-items:center; gap:16px; flex-wrap:wrap; }
.theme-select select { padding:8px; border-radius:8px; border:1px solid rgba(0,0,0,0.06); }
.wheel-area { display:flex; gap:18px; align-items:start; flex-wrap:wrap; }
.wheel-container { position: relative; width: 600px; height: 600px; max-width: 90vw; max-height: 90vw; display:flex; align-items:center; justify-content:center; background: transparent; }
.pointer {
  /* Centered triangular pointer positioned above the wheel.
     This ensures the visual pointer aligns with the wheel math (top-center).
     Hides the fallback glyph in the HTML and draws a sharp triangle instead. */
  position: absolute;
  top: 8px;               /* vertical offset from top of wheel container */
  left: 50%;              /* center horizontally */
  transform: translateX(-50%); /* center on the X axis */
  width: 0;
  height: 0;
  border-left: 12px solid transparent;
  border-right: 12px solid transparent;
  border-bottom: 18px solid var(--accent);
  z-index: 10;            /* ensure it's above the canvas */
  pointer-events: none;
  /* hide textual glyph fallback content (the ▼ in HTML) */
  font-size: 0;
  line-height: 0;
  text-indent: -9999px;
}
/* Participants panel and wheel styles */
.participants { width: 320px; max-width: 40vw; background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent); padding:12px; border-radius:10px; box-shadow: 0 6px 18px var(--shadow); }
.participants h2 { margin-bottom:8px; font-size:1.05rem; }
#nameList { list-style:none; max-height:420px; overflow:auto; display:block; }
#nameList li { padding:8px; border-radius:6px; display:flex; justify-content:space-between; align-items:center; gap:8px; margin-bottom:8px; background: var(--card); border:1px solid rgba(0,0,0,0.04); }
#nameList li button { background: transparent; border: none; color: var(--muted); cursor:pointer; }
.result { margin-top:18px; padding:12px; border-radius:8px; background: var(--card); text-align:center; box-shadow: 0 6px 18px var(--shadow); }
.result .winnerName { font-size:1.4rem; font-weight:700; margin:8px 0; color: var(--accent); }
/* Buttons */
button { cursor:pointer; padding:8px 12px; border-radius:8px; border:1px solid rgba(0,0,0,0.06); background: transparent; color:var(--fg); }
button.primary { background: var(--primary-btn-bg); color: var(--primary-btn-fg); border: none; }
/* Responsive */
@media (max-width: 900px) {
  .wheel-area { flex-direction:column; align-items:center; }
  .participants { width: 100%; max-width: 100%; }
}
/* Wheel canvas scaling helper */
#wheelCanvas { border-radius:50%; box-shadow: 0 12px 26px rgba(0,0,0,0.12); background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.02), transparent); }
/* Toast / temporary message styles (used by showMessage) */
.tmp-toast {
  position: fixed;
  left: 50%;
  transform: translateX(-50%);
  top: 18px;
  background: rgba(0,0,0,0.85);
  color: #fff;
  padding: 8px 12px;
  border-radius: 6px;
  z-index: 9999;
  transition: opacity 0.25s, transform 0.25s;
  opacity: 1;
  pointer-events: none;
  font-size: 0.95rem;
  box-shadow: 0 6px 18px rgba(0,0,0,0.18);
}
.tmp-toast.success { background: rgba(56, 198, 123, 0.95); }
.tmp-toast.warn    { background: rgba(255, 159, 67, 0.95); color: #2b1500; }
.tmp-toast.info    { background: rgba(12, 74, 255, 0.95); }
/* Winner highlight for participants list */
#nameList li.winner {
  outline: 3px solid rgba(255,215,0,0.15);
  box-shadow: 0 6px 18px rgba(255,215,0,0.06);
  transform: scale(1.01);
}
```

script.js
```javascript
'''
DOCSTRING
Script for the Random Winner Wheel.
Contains the Wheel class to draw and spin the canvas-based wheel and UI glue code to manage names and themes.
'''
/* 
DOCSTRING
Script for the Random Winner Wheel.
Contains the Wheel class to draw and spin the canvas-based wheel and UI glue code to manage names and themes.
*/
/* Main JavaScript - Wheel + UI logic */
(() => {
  // Utilities
  function rand(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }
  function easeOutCubic(t) { return 1 - Math.pow(1 - t, 3); }
  // Color palettes for themes (will be used to paint wheel segments)
  const THEME_PALETTES = {
    light: ['#FF8A80','#FFD180','#FFF59D','#C8E6C9','#80DEEA','#A7FFEB','#B39DDB','#90CAF9'],
    dark: ['#ff6b6b','#ffd166','#faff8e','#b9f6ca','#4dd0e1','#80cbc4','#b388ff','#64b5f6'],
    neon: ['#ff2d95','#7cff01','#00ffff','#ffdd00','#ff6a00','#00ff9e','#ff00ff','#47ffa2'],
    pastel: ['#ffdbe9','#fff0b3','#d1ffd6','#cfefff','#e7dfff','#ffd6e7','#fbe7d6','#e6f7ff'],
    retro: ['#ffb86b','#ffd3a8','#f3e2a9','#b8e0d2','#c0b9ff','#ffb6c1','#f6c49f','#c3d69b']
  };
  // Wheel class
  class Wheel {
    /*
    Manage wheel: drawing, recalculating segments, spinning animation, and determining winner.
    */
    constructor(canvas, options = {}) {
      this.canvas = canvas;
      this.ctx = canvas.getContext('2d');
      this.names = [];
      this.rotation = 0; // radians
      this.isSpinning = false;
      this.frame = null;
      this.onResult = options.onResult || function() {};
      this.theme = options.theme || 'light';
      this.padAngle = 0.02; // radians padding between segments
      this.textColor = '#111';
      this._devicePixelRatioFix();
      window.addEventListener('resize', () => { this._devicePixelRatioFix(); this.draw(); });
    }
    _devicePixelRatioFix() {
      const dpr = window.devicePixelRatio || 1;
      const rect = this.canvas.getBoundingClientRect();
      // If rect has zero size (canvas not yet laid out), use current width/height attributes as fallback
      const width = rect.width || (this.canvas.width / dpr);
      const height = rect.height || (this.canvas.height / dpr);
      this.canvas.width = width * dpr;
      this.canvas.height = height * dpr;
      this.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      this.centerX = width / 2;
      this.centerY = height / 2;
      this.radius = Math.min(width, height) / 2 - 18;
    }
    setTheme(themeId) { this.theme = themeId; this.draw(); }
    setNames(names) {
      this.names = names.slice();
      this.draw();
    }
    addName(name) {
      this.names.push(name);
      this.draw();
    }
    removeName(index) {
      if (index >= 0 && index < this.names.length) {
        this.names.splice(index,1);
        this.draw();
      }
    }
    clearNames() {
      this.names = [];
      this.draw();
    }
    draw() {
      const ctx = this.ctx;
      const w = this.canvas.width / (window.devicePixelRatio || 1);
      const h = this.canvas.height / (window.devicePixelRatio || 1);
      ctx.clearRect(0,0,w,h);
      ctx.save();
      ctx.translate(this.centerX, this.centerY);
      ctx.rotate(this.rotation);
      // draw segments
      const count = Math.max(this.names.length, 1);
      const palette = THEME_PALETTES[this.theme] || THEME_PALETTES.light;
      for (let i = 0; i < count; i++) {
        const start = (i / count) * Math.PI * 2;
        const end = ((i + 1) / count) * Math.PI * 2;
        ctx.beginPath();
        ctx.moveTo(0,0);
        ctx.arc(0,0,this.radius, start + this.padAngle, end - this.padAngle, false);
        ctx.closePath();
        const color = palette[i % palette.length];
        ctx.fillStyle = color;
        ctx.fill();
        ctx.strokeStyle = (i % 2 === 0) ? 'rgba(0,0,0,0.06)' : 'rgba(0,0,0,0.03)';
        ctx.lineWidth = 1;
        ctx.stroke();
        // draw text label
        const mid = (start + end) / 2;
        ctx.save();
        ctx.rotate(mid);
        ctx.translate(this.radius * 0.6, 0);
        ctx.rotate(Math.PI/2);
        ctx.fillStyle = getTextColor(color);
        ctx.font = `${Math.max(12, Math.min(22, this.radius / 8))}px sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        const label = (this.names.length === 0) ? 'Add names' : this.names[i % this.names.length];
        wrapFillText(ctx, label, 0, 0, this.radius * 0.5, 16);
        ctx.restore();
      }
      // draw center circle
      ctx.beginPath();
      ctx.arc(0,0, this.radius * 0.16, 0, Math.PI*2);
      ctx.fillStyle = 'rgba(255,255,255,0.9)';
      ctx.fill();
      ctx.strokeStyle = 'rgba(0,0,0,0.06)';
      ctx.stroke();
      ctx.restore();
      // draw outer ring (pointer side neutral)
      ctx.beginPath();
      ctx.arc(this.centerX, this.centerY, this.radius + 10, 0, Math.PI*2);
      ctx.strokeStyle = 'rgba(0,0,0,0.03)';
      ctx.lineWidth = 2;
      ctx.stroke();
    }
    spin() {
      if (this.isSpinning || this.names.length === 0) return;
      this.isSpinning = true;
      const count = this.names.length;
      // Determine random winner index to land on:
      const winnerIndex = rand(0, count - 1);
      // Calculate final rotation so that winner segment lines up with pointer at top (pointer at canvas top - rotation must align)
      // Our pointer is at the top (canvas 0 angle). The segment mid-angle for index i (without rotation) is ((i + 0.5)/count)*2pi
      const segmentMid = ((winnerIndex + 0.5) / count) * Math.PI * 2;
      // We want segmentMid + rotation_final == -Math.PI/2 (so it points at the top pointer), so rotation_final = -Math.PI/2 - segmentMid + 2pi*N
      const extraTurns = rand(5, 8); // full spins
      const rotationFinal = -Math.PI/2 - segmentMid + extraTurns * Math.PI * 2;
      const startRotation = this.rotation % (Math.PI * 2);
      const delta = rotationFinal - startRotation;
      const duration = 4000 + Math.random() * 1500; // ms
      const startTime = performance.now();
      const animate = (now) => {
        const elapsed = now - startTime;
        const t = Math.min(elapsed / duration, 1);
        const eased = easeOutCubic(t);
        this.rotation = startRotation + delta * eased;
        this.draw();
        if (t < 1) {
          this.frame = requestAnimationFrame(animate);
        } else {
          this.isSpinning = false;
          // Normalize rotation within 0..2pi
          this.rotation = ((this.rotation % (Math.PI*2)) + Math.PI*2) % (Math.PI*2);
          this.draw();
          // Compute final winner index again from rotation
          // finalAngle: the angle of the segment at pointer (0 at right, +counterclockwise). We compute a normalized angle that maps to segment index.
          const finalAngle = ((-this.rotation - Math.PI/2) % (Math.PI*2) + Math.PI*2) % (Math.PI*2);
          const resultingIndex = Math.floor((finalAngle / (Math.PI*2)) * count) % count;
          const winner = this.names[resultingIndex];
          this.onResult({ index: resultingIndex, name: winner });
        }
      };
      this.frame = requestAnimationFrame(animate);
    }
  }
  // Helper: pick readable text color for a background
  function getTextColor(hex) {
    // remove # and convert
    const h = hex.replace('#','');
    const r = parseInt(h.substring(0,2),16);
    const g = parseInt(h.substring(2,4),16);
    const b = parseInt(h.substring(4,6),16);
    // luminance
    const lum = (0.299*r + 0.587*g + 0.114*b) / 255;
    return lum > 0.65 ? '#111' : '#fff';
  }
  // Helper: wrap text within a given width (draws multi-line if necessary)
  function wrapFillText(ctx, text, x, y, maxWidth, lineHeight) {
    const words = (text || '').split(/\s+/);
    if (words.length === 0) return;
    let line = '';
    const lines = [];
    for (let n = 0; n < words.length; n++) {
      const testLine = line ? line + ' ' + words[n] : words[n];
      const metrics = ctx.measureText(testLine);
      if (metrics.width > maxWidth && line) {
        lines.push(line);
        line = words[n];
      } else {
        line = testLine;
      }
    }
    if (line) lines.push(line);
    // If still too many lines, just draw what's possible (we rely on font size)
    for (let i=0;i<lines.length;i++){
      ctx.fillText(lines[i], x, y + (i - (lines.length-1)/2) * lineHeight);
    }
  }
  // UI glue
  document.addEventListener('DOMContentLoaded', () => {
    const canvas = document.getElementById('wheelCanvas');
    const wheel = new Wheel(canvas, { theme: 'light', onResult: onWinner });
    const nameInput = document.getElementById('nameInput');
    const addBtn = document.getElementById('addBtn');
    const addRandomBtn = document.getElementById('addRandomBtn');
    const bulkInput = document.getElementById('bulkInput');
    const bulkAddBtn = document.getElementById('bulkAddBtn');
    const clearBulkBtn = document.getElementById('clearBulkBtn');
    const nameList = document.getElementById('nameList');
    const countSpan = document.getElementById('count');
    const spinBtn = document.getElementById('spinBtn');
    const rerollBtn = document.getElementById('rerollBtn');
    const clearNamesBtn = document.getElementById('clearNamesBtn');
    const themeSelect = document.getElementById('themeSelect');
    const resultSection = document.getElementById('result');
    const winnerNameDiv = document.getElementById('winnerName');
    const exportBtn = document.getElementById('exportBtn');
    const importBtn = document.getElementById('importBtn');
    const importFile = document.getElementById('importFile');
    // Initial draw
    wheel.draw();
    function updateUI() {
      const names = wheel.names;
      countSpan.textContent = names.length;
      renderNameList();
    }
    function renderNameList() {
      nameList.innerHTML = '';
      wheel.names.forEach((n, i) => {
        const li = document.createElement('li');
        const span = document.createElement('span');
        span.textContent = n;
        li.appendChild(span);
        const btn = document.createElement('button');
        btn.title = 'Remove';
        btn.setAttribute('aria-label', `Remove ${n}`);
        btn.innerHTML = '✕';
        btn.addEventListener('click', () => {
          wheel.removeName(i);
          updateUI();
        });
        li.appendChild(btn);
        nameList.appendChild(li);
      });
    }
    function addNameFromInput() {
      const v = nameInput.value.trim();
      if (!v) { showMessage('Please enter a name.', 'warn'); return; }
      wheel.addName(v);
      nameInput.value = '';
      updateUI();
    }
    addBtn.addEventListener('click', addNameFromInput);
    nameInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') addNameFromInput(); });
    addRandomBtn.addEventListener('click', () => {
      const samples = ['Alex','Jordan','Taylor','Sam','Jamie','Casey','Morgan','Riley','Avery','Dana'];
      const count = rand(3,6);
      for (let i=0;i<count;i++) wheel.addName(samples[rand(0,samples.length-1)] + (rand(1,100)));
      updateUI();
    });
    bulkAddBtn.addEventListener('click', () => {
      const text = bulkInput.value.trim();
      if (!text) { showMessage('Bulk input is empty.', 'warn'); return; }
      const parsed = text.split(/[\n,;]+/).map(s => s.trim()).filter(s => s);
      parsed.forEach(p => wheel.addName(p));
      bulkInput.value = '';
      updateUI();
      showMessage(`Added ${parsed.length} names.`, 'info');
    });
    clearBulkBtn.addEventListener('click', () => { bulkInput.value = ''; });
    spinBtn.addEventListener('click', () => {
      if (wheel.names.length === 0) { showMessage('Add at least one name to spin.', 'warn'); return; }
      resultSection.hidden = true;
      winnerNameDiv.textContent = '';
      wheel.spin();
      spinBtn.disabled = true;
      const checkFinish = setInterval(() => {
        if (!wheel.isSpinning) {
          clearInterval(checkFinish);
          spinBtn.disabled = false;
        }
      }, 200);
    });
    rerollBtn.addEventListener('click', () => {
      resultSection.hidden = true;
      wheel.spin();
    });
    clearNamesBtn.addEventListener('click', () => {
      if (confirm('Clear all names?')) {
        wheel.clearNames();
        updateUI();
      }
    });
    themeSelect.addEventListener('change', (e) => {
      const t = e.target.value;
      document.body.className = 'theme-' + t;
      wheel.setTheme(t);
    });
    function onWinner(result) {
      winnerNameDiv.textContent = result.name || '—';
      resultSection.hidden = false;
      // Flash the winner item in the list (if still present)
      const items = Array.from(nameList.children);
      items.forEach((li, idx) => { li.classList.toggle('winner', idx === result.index); });
      showMessage(`Winner: ${result.name}`, 'success', 4000);
    }
    // Simple message area
    function showMessage(text, type = 'info', duration = 2200) {
      // create small toast
      const t = document.createElement('div');
      t.className = 'tmp-toast ' + type;
      t.textContent = text;
      document.body.appendChild(t);
      // Force reflow to pick up transitions
      window.getComputedStyle(t).opacity;
      setTimeout(()=> { t.style.opacity = '0'; t.style.transform = 'translateY(-10px)'; }, duration - 300);
      setTimeout(()=> { try { t.remove(); } catch(e){} }, duration);
    }
    // Export/import CSV
    exportBtn.addEventListener('click', () => {
      if (wheel.names.length === 0) { showMessage('No names to export.', 'warn'); return; }
      const csv = wheel.names.map(n => `"${(n||'').replace(/"/g,'""')}"`).join('\n');
      const blob = new Blob([csv], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'participants.csv';
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
      showMessage('Exported CSV', 'info');
    });
    importBtn.addEventListener('click', () => { importFile.click(); });
    importFile.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (ev) => {
        const txt = ev.target.result;
        const lines = txt.split(/\r?\n/).map(s => s.trim()).filter(s => s);
        // basic CSV unquote
        const parsed = lines.map(l => {
          // simple CSV single-column parse: handle quoted fields
          if (l.startsWith('"') && l.endsWith('"')) {
            return l.slice(1,-1).replace(/""/g,'"');
          }
          return l;
        });
        parsed.forEach(p => wheel.addName(p));
        updateUI();
        showMessage(`Imported ${parsed.length} names`, 'info');
      };
      reader.readAsText(file);
      importFile.value = '';
    });
    // Initial sample (optional)
    // wheel.addName('Alice'); wheel.addName('Bob'); wheel.addName('Charlie');
    updateUI();
    // (Optional) keyboard shortcuts
    window.addEventListener('keydown', (e) => {
      if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'k') {
        e.preventDefault();
        nameInput.focus();
      }
      if (e.key === ' ') {
        // space triggers spin if not focusing an input
        if (document.activeElement.tagName !== 'INPUT' && document.activeElement.tagName !== 'TEXTAREA') {
          e.preventDefault();
          spinBtn.click();
        }
      }
    });
  });
})(); 
```

[2025-17-09 13:44:49 INFO] **[Seminar Conclusion]**:

 index.html
```html
'''
DOCSTRING
This is the main HTML file for the Random Winner Wheel.
It contains the structure: input fields to add names, a canvas for the wheel,
controls (spin, clear, bulk add), theme selector, and placeholders for CSS/JS.
'''
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Random Winner Wheel</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body class="theme-light">
  <header>
    <h1>Random Winner Wheel</h1>
    <p>Enter participant names, choose a theme, and spin to pick a winner.</p>
  </header>
  <main>
    <section class="controls">
      <div class="add-single">
        <input id="nameInput" type="text" placeholder="Enter a name and press Add" aria-label="Name input" />
        <button id="addBtn">Add</button>
        <button id="addRandomBtn" title="Add a few sample random names">Add Sample</button>
      </div>
      <div class="bulk-add">
        <label for="bulkInput">Bulk add (comma, newline or semicolon separated):</label>
        <textarea id="bulkInput" placeholder="Alice, Bob, Charlie"></textarea>
        <div class="bulk-actions">
          <button id="bulkAddBtn">Bulk Add</button>
          <button id="clearBulkBtn">Clear Bulk</button>
        </div>
      </div>
      <div class="list-actions">
        <div class="theme-select">
          <label for="themeSelect">Theme:</label>
          <select id="themeSelect">
            <option value="light">Light</option>
            <option value="dark">Dark</option>
            <option value="neon">Neon</option>
            <option value="pastel">Pastel</option>
            <option value="retro">Retro</option>
          </select>
        </div>
        <div class="wheel-controls">
          <button id="spinBtn" class="primary">Spin</button>
          <button id="clearNamesBtn">Clear Names</button>
          <button id="exportBtn">Export CSV</button>
          <input id="importFile" type="file" accept=".csv,text/csv" style="display:none">
          <button id="importBtn">Import CSV</button>
        </div>
      </div>
    </section>
    <section class="wheel-area">
      <div class="wheel-container">
        <canvas id="wheelCanvas" width="600" height="600" aria-label="Spinning wheel"></canvas>
        <div class="pointer" aria-hidden="true">▼</div>
      </div>
      <aside class="participants">
        <h2>Participants (<span id="count">0</span>)</h2>
        <ul id="nameList" aria-live="polite"></ul>
      </aside>
    </section>
    <section class="result" id="result" aria-live="polite" hidden>
      <h2>Winner</h2>
      <div id="winnerName" class="winnerName"></div>
      <button id="rerollBtn">Spin Again</button>
    </section>
  </main>
  <footer>
    <small>Built with HTML, CSS, and JavaScript. Themes change both UI and wheel colors.</small>
  </footer>
  <script src="script.js"></script>
</body>
</html>
```

styles.css
```css
'''
DOCSTRING
Stylesheet for the Random Winner Wheel.
Defines layout, themes, wheel container sizing, animations, and toast styles.
'''
/* Reset & base */
* { box-sizing: border-box; margin: 0; padding: 0; }
html,body { height: 100%; font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; background: var(--bg); color: var(--fg); }
:root {
  --bg: #f7f8fb;
  --fg: #222;
  --muted: #666;
  --accent: #2b8cff;
  --card: #ffffff;
  --primary-btn-bg: var(--accent);
  --primary-btn-fg: #fff;
  --shadow: rgba(15,15,15,0.08);
}
/* Themes */
body.theme-light {
  --bg: #f7f8fb;
  --fg: #222;
  --muted: #5b6170;
  --accent: #2b8cff;
  --card: #fff;
  --wheel-seq: 0;
}
body.theme-dark {
  --bg: #0f1724;
  --fg: #e6eef8;
  --muted: #a9b1c2;
  --accent: #7c5cff;
  --card: #0b1220;
}
body.theme-neon {
  --bg: #0a0a0f;
  --fg: #e9f9ff;
  --muted: #a6f3ff;
  --accent: #39ff14;
  --card: #09101a;
}
body.theme-pastel {
  --bg: #fffaf6;
  --fg: #3c3a3a;
  --muted: #8d8a8a;
  --accent: #ff7aa2;
  --card: #fff;
}
body.theme-retro {
  --bg: #fff6e7;
  --fg: #402b2b;
  --muted: #856e6e;
  --accent: #ffb86b;
  --card: #fff0e6;
}
/* Layout */
header { padding: 18px 24px; text-align: center; background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent); }
header h1 { font-size: 1.5rem; margin-bottom: 6px; }
main { padding: 18px; max-width: 1100px; margin: 0 auto; }
.controls { display: grid; gap: 12px; margin-bottom: 18px; }
.add-single { display:flex; gap:8px; }
.add-single input[type="text"] { flex:1; padding:10px; border-radius:8px; border:1px solid rgba(0,0,0,0.08); background:var(--card); color:var(--fg); }
.add-single button { padding:10px 12px; border-radius:8px; border: none; cursor:pointer; background: var(--primary-btn-bg); color: var(--primary-btn-fg); }
.add-single button#addRandomBtn { background: transparent; border: 1px solid rgba(0,0,0,0.06); color: var(--fg); }
.bulk-add textarea { width:100%; min-height:64px; margin-top:6px; padding:8px; border-radius:8px; border:1px solid rgba(0,0,0,0.06); background:var(--card); color:var(--fg); }
.bulk-actions { display:flex; gap:8px; margin-top:8px; }
.list-actions { display:flex; justify-content:space-between; align-items:center; gap:16px; flex-wrap:wrap; }
.theme-select select { padding:8px; border-radius:8px; border:1px solid rgba(0,0,0,0.06); }
.wheel-area { display:flex; gap:18px; align-items:start; flex-wrap:wrap; }
.wheel-container { position: relative; width: 600px; height: 600px; max-width: 90vw; max-height: 90vw; display:flex; align-items:center; justify-content:center; background: transparent; }
.pointer {
  /* Centered triangular pointer positioned above the wheel.
     This ensures the visual pointer aligns with the wheel math (top-center).
     Hides the fallback glyph in the HTML and draws a sharp triangle instead. */
  position: absolute;
  top: 8px;               /* vertical offset from top of wheel container */
  left: 50%;              /* center horizontally */
  transform: translateX(-50%); /* center on the X axis */
  width: 0;
  height: 0;
  border-left: 12px solid transparent;
  border-right: 12px solid transparent;
  border-bottom: 18px solid var(--accent);
  z-index: 10;            /* ensure it's above the canvas */
  pointer-events: none;
  /* hide textual glyph fallback content (the ▼ in HTML) */
  font-size: 0;
  line-height: 0;
  text-indent: -9999px;
}
/* Participants panel and wheel styles */
.participants { width: 320px; max-width: 40vw; background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent); padding:12px; border-radius:10px; box-shadow: 0 6px 18px var(--shadow); }
.participants h2 { margin-bottom:8px; font-size:1.05rem; }
#nameList { list-style:none; max-height:420px; overflow:auto; display:block; }
#nameList li { padding:8px; border-radius:6px; display:flex; justify-content:space-between; align-items:center; gap:8px; margin-bottom:8px; background: var(--card); border:1px solid rgba(0,0,0,0.04); }
#nameList li button { background: transparent; border: none; color: var(--muted); cursor:pointer; }
.result { margin-top:18px; padding:12px; border-radius:8px; background: var(--card); text-align:center; box-shadow: 0 6px 18px var(--shadow); }
.result .winnerName { font-size:1.4rem; font-weight:700; margin:8px 0; color: var(--accent); }
/* Buttons */
button { cursor:pointer; padding:8px 12px; border-radius:8px; border:1px solid rgba(0,0,0,0.06); background: transparent; color:var(--fg); }
button.primary { background: var(--primary-btn-bg); color: var(--primary-btn-fg); border: none; }
/* Responsive */
@media (max-width: 900px) {
  .wheel-area { flex-direction:column; align-items:center; }
  .participants { width: 100%; max-width: 100%; }
}
/* Wheel canvas scaling helper */
#wheelCanvas { border-radius:50%; box-shadow: 0 12px 26px rgba(0,0,0,0.12); background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.02), transparent); }
/* Toast / temporary message styles (used by showMessage) */
.tmp-toast {
  position: fixed;
  left: 50%;
  transform: translateX(-50%);
  top: 18px;
  background: rgba(0,0,0,0.85);
  color: #fff;
  padding: 8px 12px;
  border-radius: 6px;
  z-index: 9999;
  transition: opacity 0.25s, transform 0.25s;
  opacity: 1;
  pointer-events: none;
  font-size: 0.95rem;
  box-shadow: 0 6px 18px rgba(0,0,0,0.18);
}
.tmp-toast.success { background: rgba(56, 198, 123, 0.95); }
.tmp-toast.warn    { background: rgba(255, 159, 67, 0.95); color: #2b1500; }
.tmp-toast.info    { background: rgba(12, 74, 255, 0.95); }
/* Winner highlight for participants list */
#nameList li.winner {
  outline: 3px solid rgba(255,215,0,0.15);
  box-shadow: 0 6px 18px rgba(255,215,0,0.06);
  transform: scale(1.01);
}
```

script.js
```javascript
'''
DOCSTRING
Script for the Random Winner Wheel.
Contains the Wheel class to draw and spin the canvas-based wheel and UI glue code to manage names and themes.
'''
/* 
DOCSTRING
Script for the Random Winner Wheel.
Contains the Wheel class to draw and spin the canvas-based wheel and UI glue code to manage names and themes.
*/
/* Main JavaScript - Wheel + UI logic */
(() => {
  // Utilities
  function rand(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }
  function easeOutCubic(t) { return 1 - Math.pow(1 - t, 3); }
  // Color palettes for themes (will be used to paint wheel segments)
  const THEME_PALETTES = {
    light: ['#FF8A80','#FFD180','#FFF59D','#C8E6C9','#80DEEA','#A7FFEB','#B39DDB','#90CAF9'],
    dark: ['#ff6b6b','#ffd166','#faff8e','#b9f6ca','#4dd0e1','#80cbc4','#b388ff','#64b5f6'],
    neon: ['#ff2d95','#7cff01','#00ffff','#ffdd00','#ff6a00','#00ff9e','#ff00ff','#47ffa2'],
    pastel: ['#ffdbe9','#fff0b3','#d1ffd6','#cfefff','#e7dfff','#ffd6e7','#fbe7d6','#e6f7ff'],
    retro: ['#ffb86b','#ffd3a8','#f3e2a9','#b8e0d2','#c0b9ff','#ffb6c1','#f6c49f','#c3d69b']
  };
  // Wheel class
  class Wheel {
    /*
    Manage wheel: drawing, recalculating segments, spinning animation, and determining winner.
    */
    constructor(canvas, options = {}) {
      this.canvas = canvas;
      this.ctx = canvas.getContext('2d');
      this.names = [];
      this.rotation = 0; // radians
      this.isSpinning = false;
      this.frame = null;
      this.onResult = options.onResult || function() {};
      this.theme = options.theme || 'light';
      this.padAngle = 0.02; // radians padding between segments
      this.textColor = '#111';
      this._devicePixelRatioFix();
      window.addEventListener('resize', () => { this._devicePixelRatioFix(); this.draw(); });
    }
    _devicePixelRatioFix() {
      const dpr = window.devicePixelRatio || 1;
      const rect = this.canvas.getBoundingClientRect();
      // If rect has zero size (canvas not yet laid out), use current width/height attributes as fallback
      const width = rect.width || (this.canvas.width / dpr);
      const height = rect.height || (this.canvas.height / dpr);
      this.canvas.width = width * dpr;
      this.canvas.height = height * dpr;
      this.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      this.centerX = width / 2;
      this.centerY = height / 2;
      this.radius = Math.min(width, height) / 2 - 18;
    }
    setTheme(themeId) { this.theme = themeId; this.draw(); }
    setNames(names) {
      this.names = names.slice();
      this.draw();
    }
    addName(name) {
      this.names.push(name);
      this.draw();
    }
    removeName(index) {
      if (index >= 0 && index < this.names.length) {
        this.names.splice(index,1);
        this.draw();
      }
    }
    clearNames() {
      this.names = [];
      this.draw();
    }
    draw() {
      const ctx = this.ctx;
      const w = this.canvas.width / (window.devicePixelRatio || 1);
      const h = this.canvas.height / (window.devicePixelRatio || 1);
      ctx.clearRect(0,0,w,h);
      ctx.save();
      ctx.translate(this.centerX, this.centerY);
      ctx.rotate(this.rotation);
      // draw segments
      const count = Math.max(this.names.length, 1);
      const palette = THEME_PALETTES[this.theme] || THEME_PALETTES.light;
      for (let i = 0; i < count; i++) {
        const start = (i / count) * Math.PI * 2;
        const end = ((i + 1) / count) * Math.PI * 2;
        ctx.beginPath();
        ctx.moveTo(0,0);
        ctx.arc(0,0,this.radius, start + this.padAngle, end - this.padAngle, false);
        ctx.closePath();
        const color = palette[i % palette.length];
        ctx.fillStyle = color;
        ctx.fill();
        ctx.strokeStyle = (i % 2 === 0) ? 'rgba(0,0,0,0.06)' : 'rgba(0,0,0,0.03)';
        ctx.lineWidth = 1;
        ctx.stroke();
        // draw text label
        const mid = (start + end) / 2;
        ctx.save();
        ctx.rotate(mid);
        ctx.translate(this.radius * 0.6, 0);
        ctx.rotate(Math.PI/2);
        ctx.fillStyle = getTextColor(color);
        ctx.font = `${Math.max(12, Math.min(22, this.radius / 8))}px sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        const label = (this.names.length === 0) ? 'Add names' : this.names[i % this.names.length];
        wrapFillText(ctx, label, 0, 0, this.radius * 0.5, 16);
        ctx.restore();
      }
      // draw center circle
      ctx.beginPath();
      ctx.arc(0,0, this.radius * 0.16, 0, Math.PI*2);
      ctx.fillStyle = 'rgba(255,255,255,0.9)';
      ctx.fill();
      ctx.strokeStyle = 'rgba(0,0,0,0.06)';
      ctx.stroke();
      ctx.restore();
      // draw outer ring (pointer side neutral)
      ctx.beginPath();
      ctx.arc(this.centerX, this.centerY, this.radius + 10, 0, Math.PI*2);
      ctx.strokeStyle = 'rgba(0,0,0,0.03)';
      ctx.lineWidth = 2;
      ctx.stroke();
    }
    spin() {
      if (this.isSpinning || this.names.length === 0) return;
      this.isSpinning = true;
      const count = this.names.length;
      // Determine random winner index to land on:
      const winnerIndex = rand(0, count - 1);
      // Calculate final rotation so that winner segment lines up with pointer at top (pointer at canvas top - rotation must align)
      // Our pointer is at the top (canvas 0 angle). The segment mid-angle for index i (without rotation) is ((i + 0.5)/count)*2pi
      const segmentMid = ((winnerIndex + 0.5) / count) * Math.PI * 2;
      // We want segmentMid + rotation_final == -Math.PI/2 (so it points at the top pointer), so rotation_final = -Math.PI/2 - segmentMid + 2pi*N
      const extraTurns = rand(5, 8); // full spins
      const rotationFinal = -Math.PI/2 - segmentMid + extraTurns * Math.PI * 2;
      const startRotation = this.rotation % (Math.PI * 2);
      const delta = rotationFinal - startRotation;
      const duration = 4000 + Math.random() * 1500; // ms
      const startTime = performance.now();
      const animate = (now) => {
        const elapsed = now - startTime;
        const t = Math.min(elapsed / duration, 1);
        const eased = easeOutCubic(t);
        this.rotation = startRotation + delta * eased;
        this.draw();
        if (t < 1) {
          this.frame = requestAnimationFrame(animate);
        } else {
          this.isSpinning = false;
          // Normalize rotation within 0..2pi
          this.rotation = ((this.rotation % (Math.PI*2)) + Math.PI*2) % (Math.PI*2);
          this.draw();
          // Compute final winner index again from rotation
          // finalAngle: the angle of the segment at pointer (0 at right, +counterclockwise). We compute a normalized angle that maps to segment index.
          const finalAngle = ((-this.rotation - Math.PI/2) % (Math.PI*2) + Math.PI*2) % (Math.PI*2);
          const resultingIndex = Math.floor((finalAngle / (Math.PI*2)) * count) % count;
          const winner = this.names[resultingIndex];
          this.onResult({ index: resultingIndex, name: winner });
        }
      };
      this.frame = requestAnimationFrame(animate);
    }
  }
  // Helper: pick readable text color for a background
  function getTextColor(hex) {
    // remove # and convert
    const h = hex.replace('#','');
    const r = parseInt(h.substring(0,2),16);
    const g = parseInt(h.substring(2,4),16);
    const b = parseInt(h.substring(4,6),16);
    // luminance
    const lum = (0.299*r + 0.587*g + 0.114*b) / 255;
    return lum > 0.65 ? '#111' : '#fff';
  }
  // Helper: wrap text within a given width (draws multi-line if necessary)
  function wrapFillText(ctx, text, x, y, maxWidth, lineHeight) {
    const words = (text || '').split(/\s+/);
    if (words.length === 0) return;
    let line = '';
    const lines = [];
    for (let n = 0; n < words.length; n++) {
      const testLine = line ? line + ' ' + words[n] : words[n];
      const metrics = ctx.measureText(testLine);
      if (metrics.width > maxWidth && line) {
        lines.push(line);
        line = words[n];
      } else {
        line = testLine;
      }
    }
    if (line) lines.push(line);
    // If still too many lines, just draw what's possible (we rely on font size)
    for (let i=0;i<lines.length;i++){
      ctx.fillText(lines[i], x, y + (i - (lines.length-1)/2) * lineHeight);
    }
  }
  // UI glue
  document.addEventListener('DOMContentLoaded', () => {
    const canvas = document.getElementById('wheelCanvas');
    const wheel = new Wheel(canvas, { theme: 'light', onResult: onWinner });
    const nameInput = document.getElementById('nameInput');
    const addBtn = document.getElementById('addBtn');
    const addRandomBtn = document.getElementById('addRandomBtn');
    const bulkInput = document.getElementById('bulkInput');
    const bulkAddBtn = document.getElementById('bulkAddBtn');
    const clearBulkBtn = document.getElementById('clearBulkBtn');
    const nameList = document.getElementById('nameList');
    const countSpan = document.getElementById('count');
    const spinBtn = document.getElementById('spinBtn');
    const rerollBtn = document.getElementById('rerollBtn');
    const clearNamesBtn = document.getElementById('clearNamesBtn');
    const themeSelect = document.getElementById('themeSelect');
    const resultSection = document.getElementById('result');
    const winnerNameDiv = document.getElementById('winnerName');
    const exportBtn = document.getElementById('exportBtn');
    const importBtn = document.getElementById('importBtn');
    const importFile = document.getElementById('importFile');
    // Initial draw
    wheel.draw();
    function updateUI() {
      const names = wheel.names;
      countSpan.textContent = names.length;
      renderNameList();
    }
    function renderNameList() {
      nameList.innerHTML = '';
      wheel.names.forEach((n, i) => {
        const li = document.createElement('li');
        const span = document.createElement('span');
        span.textContent = n;
        li.appendChild(span);
        const btn = document.createElement('button');
        btn.title = 'Remove';
        btn.setAttribute('aria-label', `Remove ${n}`);
        btn.innerHTML = '✕';
        btn.addEventListener('click', () => {
          wheel.removeName(i);
          updateUI();
        });
        li.appendChild(btn);
        nameList.appendChild(li);
      });
    }
    function addNameFromInput() {
      const v = nameInput.value.trim();
      if (!v) { showMessage('Please enter a name.', 'warn'); return; }
      wheel.addName(v);
      nameInput.value = '';
      updateUI();
    }
    addBtn.addEventListener('click', addNameFromInput);
    nameInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') addNameFromInput(); });
    addRandomBtn.addEventListener('click', () => {
      const samples = ['Alex','Jordan','Taylor','Sam','Jamie','Casey','Morgan','Riley','Avery','Dana'];
      const count = rand(3,6);
      for (let i=0;i<count;i++) wheel.addName(samples[rand(0,samples.length-1)] + (rand(1,100)));
      updateUI();
    });
    bulkAddBtn.addEventListener('click', () => {
      const text = bulkInput.value.trim();
      if (!text) { showMessage('Bulk input is empty.', 'warn'); return; }
      const parsed = text.split(/[\n,;]+/).map(s => s.trim()).filter(s => s);
      parsed.forEach(p => wheel.addName(p));
      bulkInput.value = '';
      updateUI();
      showMessage(`Added ${parsed.length} names.`, 'info');
    });
    clearBulkBtn.addEventListener('click', () => { bulkInput.value = ''; });
    spinBtn.addEventListener('click', () => {
      if (wheel.names.length === 0) { showMessage('Add at least one name to spin.', 'warn'); return; }
      resultSection.hidden = true;
      winnerNameDiv.textContent = '';
      wheel.spin();
      spinBtn.disabled = true;
      const checkFinish = setInterval(() => {
        if (!wheel.isSpinning) {
          clearInterval(checkFinish);
          spinBtn.disabled = false;
        }
      }, 200);
    });
    rerollBtn.addEventListener('click', () => {
      resultSection.hidden = true;
      wheel.spin();
    });
    clearNamesBtn.addEventListener('click', () => {
      if (confirm('Clear all names?')) {
        wheel.clearNames();
        updateUI();
      }
    });
    themeSelect.addEventListener('change', (e) => {
      const t = e.target.value;
      document.body.className = 'theme-' + t;
      wheel.setTheme(t);
    });
    function onWinner(result) {
      winnerNameDiv.textContent = result.name || '—';
      resultSection.hidden = false;
      // Flash the winner item in the list (if still present)
      const items = Array.from(nameList.children);
      items.forEach((li, idx) => { li.classList.toggle('winner', idx === result.index); });
      showMessage(`Winner: ${result.name}`, 'success', 4000);
    }
    // Simple message area
    function showMessage(text, type = 'info', duration = 2200) {
      // create small toast
      const t = document.createElement('div');
      t.className = 'tmp-toast ' + type;
      t.textContent = text;
      document.body.appendChild(t);
      // Force reflow to pick up transitions
      window.getComputedStyle(t).opacity;
      setTimeout(()=> { t.style.opacity = '0'; t.style.transform = 'translateY(-10px)'; }, duration - 300);
      setTimeout(()=> { try { t.remove(); } catch(e){} }, duration);
    }
    // Export/import CSV
    exportBtn.addEventListener('click', () => {
      if (wheel.names.length === 0) { showMessage('No names to export.', 'warn'); return; }
      const csv = wheel.names.map(n => `"${(n||'').replace(/"/g,'""')}"`).join('\n');
      const blob = new Blob([csv], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'participants.csv';
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
      showMessage('Exported CSV', 'info');
    });
    importBtn.addEventListener('click', () => { importFile.click(); });
    importFile.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (ev) => {
        const txt = ev.target.result;
        const lines = txt.split(/\r?\n/).map(s => s.trim()).filter(s => s);
        // basic CSV unquote
        const parsed = lines.map(l => {
          // simple CSV single-column parse: handle quoted fields
          if (l.startsWith('"') && l.endsWith('"')) {
            return l.slice(1,-1).replace(/""/g,'"');
          }
          return l;
        });
        parsed.forEach(p => wheel.addName(p));
        updateUI();
        showMessage(`Imported ${parsed.length} names`, 'info');
      };
      reader.readAsText(file);
      importFile.value = '';
    });
    // Initial sample (optional)
    // wheel.addName('Alice'); wheel.addName('Bob'); wheel.addName('Charlie');
    updateUI();
    // (Optional) keyboard shortcuts
    window.addEventListener('keydown', (e) => {
      if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'k') {
        e.preventDefault();
        nameInput.focus();
      }
      if (e.key === ' ') {
        // space triggers spin if not focusing an input
        if (document.activeElement.tagName !== 'INPUT' && document.activeElement.tagName !== 'TEXTAREA') {
          e.preventDefault();
          spinBtn.click();
        }
      }
    });
  });
})(); 
```

[2025-17-09 13:44:49 INFO] **[Update Codes]**

index.html updated.


```
'''

'''
--- Old
+++ New
@@ -1,9 +1,9 @@
-<!--
+'''
 DOCSTRING
 This is the main HTML file for the Random Winner Wheel.
 It contains the structure: input fields to add names, a canvas for the wheel,
 controls (spin, clear, bulk add), theme selector, and placeholders for CSS/JS.
--->
+'''
 <!doctype html>
 <html lang="en">
 <head>
```

[2025-17-09 13:44:49 INFO] **[Update Codes]**

styles.css updated.


```
'''

'''
--- Old
+++ New
@@ -1,8 +1,8 @@
-/*
+'''
 DOCSTRING
 Stylesheet for the Random Winner Wheel.
 Defines layout, themes, wheel container sizing, animations, and toast styles.
-*/
+'''
 /* Reset & base */
 * { box-sizing: border-box; margin: 0; padding: 0; }
 html,body { height: 100%; font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; background: var(--bg); color: var(--fg); }
@@ -68,7 +68,27 @@
 .theme-select select { padding:8px; border-radius:8px; border:1px solid rgba(0,0,0,0.06); }
 .wheel-area { display:flex; gap:18px; align-items:start; flex-wrap:wrap; }
 .wheel-container { position: relative; width: 600px; height: 600px; max-width: 90vw; max-height: 90vw; display:flex; align-items:center; justify-content:center; background: transparent; }
-.pointer { position:absolute; top:6px; font-size:28px; transform: translateY(-50%); text-shadow: 0 2px 8px rgba(0,0,0,0.25); color: var(--accent); pointer-events:none; }
+.pointer {
+  /* Centered triangular pointer positioned above the wheel.
+     This ensures the visual pointer aligns with the wheel math (top-center).
+     Hides the fallback glyph in the HTML and draws a sharp triangle instead. */
+  position: absolute;
+  top: 8px;               /* vertical offset from top of wheel container */
+  left: 50%;              /* center horizontally */
+  transform: translateX(-50%); /* center on the X axis */
+  width: 0;
+  height: 0;
+  border-left: 12px solid transparent;
+  border-right: 12px solid transparent;
+  border-bottom: 18px solid var(--accent);
+  z-index: 10;            /* ensure it's above the canvas */
+  pointer-events: none;
+  /* hide textual glyph fallback content (the ▼ in HTML) */
+  font-size: 0;
+  line-height: 0;
+  text-indent: -9999px;
+}
+/* Participants panel and wheel styles */
 .participants { width: 320px; max-width: 40vw; background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent); padding:12px; border-radius:10px; box-shadow: 0 6px 18px var(--shadow); }
 .participants h2 { margin-bottom:8px; font-size:1.05rem; }
 #nameList { list-style:none; max-height:420px; overflow:auto; display:block; }
```

[2025-17-09 13:44:49 INFO] **[Update Codes]**

script.js updated.


```
'''

'''
--- Old
+++ New
@@ -1,3 +1,8 @@
+'''
+DOCSTRING
+Script for the Random Winner Wheel.
+Contains the Wheel class to draw and spin the canvas-based wheel and UI glue code to manage names and themes.
+'''
 /* 
 DOCSTRING
 Script for the Random Winner Wheel.
```

[2025-17-09 13:44:49 INFO] **[Software Info]**:

 

💰**cost**=$0.060415

🔨**version_updates**=-1

📃**num_code_files**=0

🏞**num_png_files**=0

📚**num_doc_files**=7

📃**code_lines**=0

📋**env_lines**=-1

📒**manual_lines**=-1

🗣**num_utterances**=15

🤔**num_self_reflections**=0

❓**num_prompt_tokens**=30823

❗**num_completion_tokens**=30002

🌟**num_total_tokens**=60825

[2025-17-09 13:44:49 INFO] **[Execute Detail]**

execute SimplePhase:[CodeReviewComment] in ComposedPhase:[CodeReview], cycle 3

[2025-17-09 13:44:49 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | [Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes. Do it in HTML, CSS, and JavaScript.] |
| **need_reflect** | False |
| **assistant_role_name** | Code Reviewer |
| **user_role_name** | Programmer |
| **phase_prompt** | According to the new user's task and our software designs:  Task: "{task}". Modality: "{modality}". Programming Language: "{language}" Ideas: "{ideas}" Codes: "{codes}" As the {assistant_role}, to make the software directly operable without further coding, ChatDev have formulated the following regulations: 1) all referenced classes should be imported; 2) all methods should be implemented; 3) all methods need to have the necessary comments; 4) no potential bugs; 5) The entire project conforms to the tasks proposed by the user; 6) most importantly, do not only check the errors in the code, but also the logic of code. Make sure that user can interact with generated software without losing any feature in the requirement; Now, you should check the above regulations one by one and review the codes in detail, propose one comment with the highest priority about the codes, and give me instructions on how to fix. Tell me your comment with the highest priority and corresponding suggestions on revision. If the codes are perfect and you have no comment on them, return only one line like " Finished". |
| **phase_name** | CodeReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Code Reviewer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. You can help programmers to assess source codes for software troubleshooting, fix bugs to increase code quality and robustness, and offer proposals to improve the source codes. Here is a new customer's task: {task}. To complete the task, you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Programmer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. You can write/create computer software or applications by providing a specific programming language to the computer. You have extensive computing and coding experience in many varieties of programming languages and platforms, such as Python, Java, C, C++, HTML, CSS, JavaScript, XML, SQL, PHP, etc,. Here is a new customer's task: {task}. To complete the task, you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': 'index.html\nhtml\n\'\'\'\nDOCSTRING\nThis is the main HTML file for the Random Winner Wheel.\nIt contains the structure: input fields to add names, a canvas for the wheel,\ncontrols (spin, clear, bulk add), theme selector, and placeholders for CSS/JS.\n\'\'\'\n&lt;!doctype html&gt;\n&lt;html lang="en"&gt;\n&lt;head&gt;\n  &lt;meta charset="utf-8" /&gt;\n  &lt;meta name="viewport" content="width=device-width,initial-scale=1" /&gt;\n  &lt;title&gt;Random Winner Wheel&lt;/title&gt;\n  &lt;link rel="stylesheet" href="styles.css"&gt;\n&lt;/head&gt;\n&lt;body class="theme-light"&gt;\n  &lt;header&gt;\n    &lt;h1&gt;Random Winner Wheel&lt;/h1&gt;\n    &lt;p&gt;Enter participant names, choose a theme, and spin to pick a winner.&lt;/p&gt;\n  &lt;/header&gt;\n  &lt;main&gt;\n    &lt;section class="controls"&gt;\n      &lt;div class="add-single"&gt;\n        &lt;input id="nameInput" type="text" placeholder="Enter a name and press Add" aria-label="Name input" /&gt;\n        &lt;button id="addBtn"&gt;Add&lt;/button&gt;\n        &lt;button id="addRandomBtn" title="Add a few sample random names"&gt;Add Sample&lt;/button&gt;\n      &lt;/div&gt;\n      &lt;div class="bulk-add"&gt;\n        &lt;label for="bulkInput"&gt;Bulk add (comma, newline or semicolon separated):&lt;/label&gt;\n        &lt;textarea id="bulkInput" placeholder="Alice, Bob, Charlie"&gt;&lt;/textarea&gt;\n        &lt;div class="bulk-actions"&gt;\n          &lt;button id="bulkAddBtn"&gt;Bulk Add&lt;/button&gt;\n          &lt;button id="clearBulkBtn"&gt;Clear Bulk&lt;/button&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;\n      &lt;div class="list-actions"&gt;\n        &lt;div class="theme-select"&gt;\n          &lt;label for="themeSelect"&gt;Theme:&lt;/label&gt;\n          &lt;select id="themeSelect"&gt;\n            &lt;option value="light"&gt;Light&lt;/option&gt;\n            &lt;option value="dark"&gt;Dark&lt;/option&gt;\n            &lt;option value="neon"&gt;Neon&lt;/option&gt;\n            &lt;option value="pastel"&gt;Pastel&lt;/option&gt;\n            &lt;option value="retro"&gt;Retro&lt;/option&gt;\n          &lt;/select&gt;\n        &lt;/div&gt;\n        &lt;div class="wheel-controls"&gt;\n          &lt;button id="spinBtn" class="primary"&gt;Spin&lt;/button&gt;\n          &lt;button id="clearNamesBtn"&gt;Clear Names&lt;/button&gt;\n          &lt;button id="exportBtn"&gt;Export CSV&lt;/button&gt;\n          &lt;input id="importFile" type="file" accept=".csv,text/csv" style="display:none"&gt;\n          &lt;button id="importBtn"&gt;Import CSV&lt;/button&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;\n    &lt;/section&gt;\n    &lt;section class="wheel-area"&gt;\n      &lt;div class="wheel-container"&gt;\n        &lt;canvas id="wheelCanvas" width="600" height="600" aria-label="Spinning wheel"&gt;&lt;/canvas&gt;\n        &lt;div class="pointer" aria-hidden="true"&gt;▼&lt;/div&gt;\n      &lt;/div&gt;\n      &lt;aside class="participants"&gt;\n        &lt;h2&gt;Participants (&lt;span id="count"&gt;0&lt;/span&gt;)&lt;/h2&gt;\n        &lt;ul id="nameList" aria-live="polite"&gt;&lt;/ul&gt;\n      &lt;/aside&gt;\n    &lt;/section&gt;\n    &lt;section class="result" id="result" aria-live="polite" hidden&gt;\n      &lt;h2&gt;Winner&lt;/h2&gt;\n      &lt;div id="winnerName" class="winnerName"&gt;&lt;/div&gt;\n      &lt;button id="rerollBtn"&gt;Spin Again&lt;/button&gt;\n    &lt;/section&gt;\n  &lt;/main&gt;\n  &lt;footer&gt;\n    &lt;small&gt;Built with HTML, CSS, and JavaScript. Themes change both UI and wheel colors.&lt;/small&gt;\n  &lt;/footer&gt;\n  &lt;script src="script.js"&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\n\nstyles.css\ncss\n\'\'\'\nDOCSTRING\nStylesheet for the Random Winner Wheel.\nDefines layout, themes, wheel container sizing, animations, and toast styles.\n\'\'\'\n/* Reset &amp; base */\n* { box-sizing: border-box; margin: 0; padding: 0; }\nhtml,body { height: 100%; font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; background: var(--bg); color: var(--fg); }\n:root {\n  --bg: #f7f8fb;\n  --fg: #222;\n  --muted: #666;\n  --accent: #2b8cff;\n  --card: #ffffff;\n  --primary-btn-bg: var(--accent);\n  --primary-btn-fg: #fff;\n  --shadow: rgba(15,15,15,0.08);\n}\n/* Themes */\nbody.theme-light {\n  --bg: #f7f8fb;\n  --fg: #222;\n  --muted: #5b6170;\n  --accent: #2b8cff;\n  --card: #fff;\n  --wheel-seq: 0;\n}\nbody.theme-dark {\n  --bg: #0f1724;\n  --fg: #e6eef8;\n  --muted: #a9b1c2;\n  --accent: #7c5cff;\n  --card: #0b1220;\n}\nbody.theme-neon {\n  --bg: #0a0a0f;\n  --fg: #e9f9ff;\n  --muted: #a6f3ff;\n  --accent: #39ff14;\n  --card: #09101a;\n}\nbody.theme-pastel {\n  --bg: #fffaf6;\n  --fg: #3c3a3a;\n  --muted: #8d8a8a;\n  --accent: #ff7aa2;\n  --card: #fff;\n}\nbody.theme-retro {\n  --bg: #fff6e7;\n  --fg: #402b2b;\n  --muted: #856e6e;\n  --accent: #ffb86b;\n  --card: #fff0e6;\n}\n/* Layout */\nheader { padding: 18px 24px; text-align: center; background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent); }\nheader h1 { font-size: 1.5rem; margin-bottom: 6px; }\nmain { padding: 18px; max-width: 1100px; margin: 0 auto; }\n.controls { display: grid; gap: 12px; margin-bottom: 18px; }\n.add-single { display:flex; gap:8px; }\n.add-single input[type="text"] { flex:1; padding:10px; border-radius:8px; border:1px solid rgba(0,0,0,0.08); background:var(--card); color:var(--fg); }\n.add-single button { padding:10px 12px; border-radius:8px; border: none; cursor:pointer; background: var(--primary-btn-bg); color: var(--primary-btn-fg); }\n.add-single button#addRandomBtn { background: transparent; border: 1px solid rgba(0,0,0,0.06); color: var(--fg); }\n.bulk-add textarea { width:100%; min-height:64px; margin-top:6px; padding:8px; border-radius:8px; border:1px solid rgba(0,0,0,0.06); background:var(--card); color:var(--fg); }\n.bulk-actions { display:flex; gap:8px; margin-top:8px; }\n.list-actions { display:flex; justify-content:space-between; align-items:center; gap:16px; flex-wrap:wrap; }\n.theme-select select { padding:8px; border-radius:8px; border:1px solid rgba(0,0,0,0.06); }\n.wheel-area { display:flex; gap:18px; align-items:start; flex-wrap:wrap; }\n.wheel-container { position: relative; width: 600px; height: 600px; max-width: 90vw; max-height: 90vw; display:flex; align-items:center; justify-content:center; background: transparent; }\n.pointer {\n  /* Centered triangular pointer positioned above the wheel.\n     This ensures the visual pointer aligns with the wheel math (top-center).\n     Hides the fallback glyph in the HTML and draws a sharp triangle instead. */\n  position: absolute;\n  top: 8px;               /* vertical offset from top of wheel container */\n  left: 50%;              /* center horizontally */\n  transform: translateX(-50%); /* center on the X axis */\n  width: 0;\n  height: 0;\n  border-left: 12px solid transparent;\n  border-right: 12px solid transparent;\n  border-bottom: 18px solid var(--accent);\n  z-index: 10;            /* ensure it\'s above the canvas */\n  pointer-events: none;\n  /* hide textual glyph fallback content (the ▼ in HTML) */\n  font-size: 0;\n  line-height: 0;\n  text-indent: -9999px;\n}\n/* Participants panel and wheel styles */\n.participants { width: 320px; max-width: 40vw; background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent); padding:12px; border-radius:10px; box-shadow: 0 6px 18px var(--shadow); }\n.participants h2 { margin-bottom:8px; font-size:1.05rem; }\n#nameList { list-style:none; max-height:420px; overflow:auto; display:block; }\n#nameList li { padding:8px; border-radius:6px; display:flex; justify-content:space-between; align-items:center; gap:8px; margin-bottom:8px; background: var(--card); border:1px solid rgba(0,0,0,0.04); }\n#nameList li button { background: transparent; border: none; color: var(--muted); cursor:pointer; }\n.result { margin-top:18px; padding:12px; border-radius:8px; background: var(--card); text-align:center; box-shadow: 0 6px 18px var(--shadow); }\n.result .winnerName { font-size:1.4rem; font-weight:700; margin:8px 0; color: var(--accent); }\n/* Buttons */\nbutton { cursor:pointer; padding:8px 12px; border-radius:8px; border:1px solid rgba(0,0,0,0.06); background: transparent; color:var(--fg); }\nbutton.primary { background: var(--primary-btn-bg); color: var(--primary-btn-fg); border: none; }\n/* Responsive */\n@media (max-width: 900px) {\n  .wheel-area { flex-direction:column; align-items:center; }\n  .participants { width: 100%; max-width: 100%; }\n}\n/* Wheel canvas scaling helper */\n#wheelCanvas { border-radius:50%; box-shadow: 0 12px 26px rgba(0,0,0,0.12); background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.02), transparent); }\n/* Toast / temporary message styles (used by showMessage) */\n.tmp-toast {\n  position: fixed;\n  left: 50%;\n  transform: translateX(-50%);\n  top: 18px;\n  background: rgba(0,0,0,0.85);\n  color: #fff;\n  padding: 8px 12px;\n  border-radius: 6px;\n  z-index: 9999;\n  transition: opacity 0.25s, transform 0.25s;\n  opacity: 1;\n  pointer-events: none;\n  font-size: 0.95rem;\n  box-shadow: 0 6px 18px rgba(0,0,0,0.18);\n}\n.tmp-toast.success { background: rgba(56, 198, 123, 0.95); }\n.tmp-toast.warn    { background: rgba(255, 159, 67, 0.95); color: #2b1500; }\n.tmp-toast.info    { background: rgba(12, 74, 255, 0.95); }\n/* Winner highlight for participants list */\n#nameList li.winner {\n  outline: 3px solid rgba(255,215,0,0.15);\n  box-shadow: 0 6px 18px rgba(255,215,0,0.06);\n  transform: scale(1.01);\n}\n\n\nscript.js\njavascript\n\'\'\'\nDOCSTRING\nScript for the Random Winner Wheel.\nContains the Wheel class to draw and spin the canvas-based wheel and UI glue code to manage names and themes.\n\'\'\'\n/* \nDOCSTRING\nScript for the Random Winner Wheel.\nContains the Wheel class to draw and spin the canvas-based wheel and UI glue code to manage names and themes.\n*/\n/* Main JavaScript - Wheel + UI logic */\n(() =&gt; {\n  // Utilities\n  function rand(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }\n  function easeOutCubic(t) { return 1 - Math.pow(1 - t, 3); }\n  // Color palettes for themes (will be used to paint wheel segments)\n  const THEME_PALETTES = {\n    light: [\'#FF8A80\',\'#FFD180\',\'#FFF59D\',\'#C8E6C9\',\'#80DEEA\',\'#A7FFEB\',\'#B39DDB\',\'#90CAF9\'],\n    dark: [\'#ff6b6b\',\'#ffd166\',\'#faff8e\',\'#b9f6ca\',\'#4dd0e1\',\'#80cbc4\',\'#b388ff\',\'#64b5f6\'],\n    neon: [\'#ff2d95\',\'#7cff01\',\'#00ffff\',\'#ffdd00\',\'#ff6a00\',\'#00ff9e\',\'#ff00ff\',\'#47ffa2\'],\n    pastel: [\'#ffdbe9\',\'#fff0b3\',\'#d1ffd6\',\'#cfefff\',\'#e7dfff\',\'#ffd6e7\',\'#fbe7d6\',\'#e6f7ff\'],\n    retro: [\'#ffb86b\',\'#ffd3a8\',\'#f3e2a9\',\'#b8e0d2\',\'#c0b9ff\',\'#ffb6c1\',\'#f6c49f\',\'#c3d69b\']\n  };\n  // Wheel class\n  class Wheel {\n    /*\n    Manage wheel: drawing, recalculating segments, spinning animation, and determining winner.\n    */\n    constructor(canvas, options = {}) {\n      this.canvas = canvas;\n      this.ctx = canvas.getContext(\'2d\');\n      this.names = [];\n      this.rotation = 0; // radians\n      this.isSpinning = false;\n      this.frame = null;\n      this.onResult = options.onResult || function() {};\n      this.theme = options.theme || \'light\';\n      this.padAngle = 0.02; // radians padding between segments\n      this.textColor = \'#111\';\n      this._devicePixelRatioFix();\n      window.addEventListener(\'resize\', () =&gt; { this._devicePixelRatioFix(); this.draw(); });\n    }\n    _devicePixelRatioFix() {\n      const dpr = window.devicePixelRatio || 1;\n      const rect = this.canvas.getBoundingClientRect();\n      // If rect has zero size (canvas not yet laid out), use current width/height attributes as fallback\n      const width = rect.width || (this.canvas.width / dpr);\n      const height = rect.height || (this.canvas.height / dpr);\n      this.canvas.width = width * dpr;\n      this.canvas.height = height * dpr;\n      this.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n      this.centerX = width / 2;\n      this.centerY = height / 2;\n      this.radius = Math.min(width, height) / 2 - 18;\n    }\n    setTheme(themeId) { this.theme = themeId; this.draw(); }\n    setNames(names) {\n      this.names = names.slice();\n      this.draw();\n    }\n    addName(name) {\n      this.names.push(name);\n      this.draw();\n    }\n    removeName(index) {\n      if (index &gt;= 0 &amp;&amp; index &lt; this.names.length) {\n        this.names.splice(index,1);\n        this.draw();\n      }\n    }\n    clearNames() {\n      this.names = [];\n      this.draw();\n    }\n    draw() {\n      const ctx = this.ctx;\n      const w = this.canvas.width / (window.devicePixelRatio || 1);\n      const h = this.canvas.height / (window.devicePixelRatio || 1);\n      ctx.clearRect(0,0,w,h);\n      ctx.save();\n      ctx.translate(this.centerX, this.centerY);\n      ctx.rotate(this.rotation);\n      // draw segments\n      const count = Math.max(this.names.length, 1);\n      const palette = THEME_PALETTES[this.theme] || THEME_PALETTES.light;\n      for (let i = 0; i &lt; count; i++) {\n        const start = (i / count) * Math.PI * 2;\n        const end = ((i + 1) / count) * Math.PI * 2;\n        ctx.beginPath();\n        ctx.moveTo(0,0);\n        ctx.arc(0,0,this.radius, start + this.padAngle, end - this.padAngle, false);\n        ctx.closePath();\n        const color = palette[i % palette.length];\n        ctx.fillStyle = color;\n        ctx.fill();\n        ctx.strokeStyle = (i % 2 === 0) ? \'rgba(0,0,0,0.06)\' : \'rgba(0,0,0,0.03)\';\n        ctx.lineWidth = 1;\n        ctx.stroke();\n        // draw text label\n        const mid = (start + end) / 2;\n        ctx.save();\n        ctx.rotate(mid);\n        ctx.translate(this.radius * 0.6, 0);\n        ctx.rotate(Math.PI/2);\n        ctx.fillStyle = getTextColor(color);\n        ctx.font = `${Math.max(12, Math.min(22, this.radius / 8))}px sans-serif`;\n        ctx.textAlign = \'center\';\n        ctx.textBaseline = \'middle\';\n        const label = (this.names.length === 0) ? \'Add names\' : this.names[i % this.names.length];\n        wrapFillText(ctx, label, 0, 0, this.radius * 0.5, 16);\n        ctx.restore();\n      }\n      // draw center circle\n      ctx.beginPath();\n      ctx.arc(0,0, this.radius * 0.16, 0, Math.PI*2);\n      ctx.fillStyle = \'rgba(255,255,255,0.9)\';\n      ctx.fill();\n      ctx.strokeStyle = \'rgba(0,0,0,0.06)\';\n      ctx.stroke();\n      ctx.restore();\n      // draw outer ring (pointer side neutral)\n      ctx.beginPath();\n      ctx.arc(this.centerX, this.centerY, this.radius + 10, 0, Math.PI*2);\n      ctx.strokeStyle = \'rgba(0,0,0,0.03)\';\n      ctx.lineWidth = 2;\n      ctx.stroke();\n    }\n    spin() {\n      if (this.isSpinning || this.names.length === 0) return;\n      this.isSpinning = true;\n      const count = this.names.length;\n      // Determine random winner index to land on:\n      const winnerIndex = rand(0, count - 1);\n      // Calculate final rotation so that winner segment lines up with pointer at top (pointer at canvas top - rotation must align)\n      // Our pointer is at the top (canvas 0 angle). The segment mid-angle for index i (without rotation) is ((i + 0.5)/count)*2pi\n      const segmentMid = ((winnerIndex + 0.5) / count) * Math.PI * 2;\n      // We want segmentMid + rotation_final == -Math.PI/2 (so it points at the top pointer), so rotation_final = -Math.PI/2 - segmentMid + 2pi*N\n      const extraTurns = rand(5, 8); // full spins\n      const rotationFinal = -Math.PI/2 - segmentMid + extraTurns * Math.PI * 2;\n      const startRotation = this.rotation % (Math.PI * 2);\n      const delta = rotationFinal - startRotation;\n      const duration = 4000 + Math.random() * 1500; // ms\n      const startTime = performance.now();\n      const animate = (now) =&gt; {\n        const elapsed = now - startTime;\n        const t = Math.min(elapsed / duration, 1);\n        const eased = easeOutCubic(t);\n        this.rotation = startRotation + delta * eased;\n        this.draw();\n        if (t &lt; 1) {\n          this.frame = requestAnimationFrame(animate);\n        } else {\n          this.isSpinning = false;\n          // Normalize rotation within 0..2pi\n          this.rotation = ((this.rotation % (Math.PI*2)) + Math.PI*2) % (Math.PI*2);\n          this.draw();\n          // Compute final winner index again from rotation\n          // finalAngle: the angle of the segment at pointer (0 at right, +counterclockwise). We compute a normalized angle that maps to segment index.\n          const finalAngle = ((-this.rotation - Math.PI/2) % (Math.PI*2) + Math.PI*2) % (Math.PI*2);\n          const resultingIndex = Math.floor((finalAngle / (Math.PI*2)) * count) % count;\n          const winner = this.names[resultingIndex];\n          this.onResult({ index: resultingIndex, name: winner });\n        }\n      };\n      this.frame = requestAnimationFrame(animate);\n    }\n  }\n  // Helper: pick readable text color for a background\n  function getTextColor(hex) {\n    // remove # and convert\n    const h = hex.replace(\'#\',\'\');\n    const r = parseInt(h.substring(0,2),16);\n    const g = parseInt(h.substring(2,4),16);\n    const b = parseInt(h.substring(4,6),16);\n    // luminance\n    const lum = (0.299*r + 0.587*g + 0.114*b) / 255;\n    return lum &gt; 0.65 ? \'#111\' : \'#fff\';\n  }\n  // Helper: wrap text within a given width (draws multi-line if necessary)\n  function wrapFillText(ctx, text, x, y, maxWidth, lineHeight) {\n    const words = (text || \'\').split(/\\s+/);\n    if (words.length === 0) return;\n    let line = \'\';\n    const lines = [];\n    for (let n = 0; n &lt; words.length; n++) {\n      const testLine = line ? line + \' \' + words[n] : words[n];\n      const metrics = ctx.measureText(testLine);\n      if (metrics.width &gt; maxWidth &amp;&amp; line) {\n        lines.push(line);\n        line = words[n];\n      } else {\n        line = testLine;\n      }\n    }\n    if (line) lines.push(line);\n    // If still too many lines, just draw what\'s possible (we rely on font size)\n    for (let i=0;i&lt;lines.length;i++){\n      ctx.fillText(lines[i], x, y + (i - (lines.length-1)/2) * lineHeight);\n    }\n  }\n  // UI glue\n  document.addEventListener(\'DOMContentLoaded\', () =&gt; {\n    const canvas = document.getElementById(\'wheelCanvas\');\n    const wheel = new Wheel(canvas, { theme: \'light\', onResult: onWinner });\n    const nameInput = document.getElementById(\'nameInput\');\n    const addBtn = document.getElementById(\'addBtn\');\n    const addRandomBtn = document.getElementById(\'addRandomBtn\');\n    const bulkInput = document.getElementById(\'bulkInput\');\n    const bulkAddBtn = document.getElementById(\'bulkAddBtn\');\n    const clearBulkBtn = document.getElementById(\'clearBulkBtn\');\n    const nameList = document.getElementById(\'nameList\');\n    const countSpan = document.getElementById(\'count\');\n    const spinBtn = document.getElementById(\'spinBtn\');\n    const rerollBtn = document.getElementById(\'rerollBtn\');\n    const clearNamesBtn = document.getElementById(\'clearNamesBtn\');\n    const themeSelect = document.getElementById(\'themeSelect\');\n    const resultSection = document.getElementById(\'result\');\n    const winnerNameDiv = document.getElementById(\'winnerName\');\n    const exportBtn = document.getElementById(\'exportBtn\');\n    const importBtn = document.getElementById(\'importBtn\');\n    const importFile = document.getElementById(\'importFile\');\n    // Initial draw\n    wheel.draw();\n    function updateUI() {\n      const names = wheel.names;\n      countSpan.textContent = names.length;\n      renderNameList();\n    }\n    function renderNameList() {\n      nameList.innerHTML = \'\';\n      wheel.names.forEach((n, i) =&gt; {\n        const li = document.createElement(\'li\');\n        const span = document.createElement(\'span\');\n        span.textContent = n;\n        li.appendChild(span);\n        const btn = document.createElement(\'button\');\n        btn.title = \'Remove\';\n        btn.setAttribute(\'aria-label\', `Remove ${n}`);\n        btn.innerHTML = \'✕\';\n        btn.addEventListener(\'click\', () =&gt; {\n          wheel.removeName(i);\n          updateUI();\n        });\n        li.appendChild(btn);\n        nameList.appendChild(li);\n      });\n    }\n    function addNameFromInput() {\n      const v = nameInput.value.trim();\n      if (!v) { showMessage(\'Please enter a name.\', \'warn\'); return; }\n      wheel.addName(v);\n      nameInput.value = \'\';\n      updateUI();\n    }\n    addBtn.addEventListener(\'click\', addNameFromInput);\n    nameInput.addEventListener(\'keydown\', (e) =&gt; { if (e.key === \'Enter\') addNameFromInput(); });\n    addRandomBtn.addEventListener(\'click\', () =&gt; {\n      const samples = [\'Alex\',\'Jordan\',\'Taylor\',\'Sam\',\'Jamie\',\'Casey\',\'Morgan\',\'Riley\',\'Avery\',\'Dana\'];\n      const count = rand(3,6);\n      for (let i=0;i&lt;count;i++) wheel.addName(samples[rand(0,samples.length-1)] + (rand(1,100)));\n      updateUI();\n    });\n    bulkAddBtn.addEventListener(\'click\', () =&gt; {\n      const text = bulkInput.value.trim();\n      if (!text) { showMessage(\'Bulk input is empty.\', \'warn\'); return; }\n      const parsed = text.split(/[\\n,;]+/).map(s =&gt; s.trim()).filter(s =&gt; s);\n      parsed.forEach(p =&gt; wheel.addName(p));\n      bulkInput.value = \'\';\n      updateUI();\n      showMessage(`Added ${parsed.length} names.`, \'info\');\n    });\n    clearBulkBtn.addEventListener(\'click\', () =&gt; { bulkInput.value = \'\'; });\n    spinBtn.addEventListener(\'click\', () =&gt; {\n      if (wheel.names.length === 0) { showMessage(\'Add at least one name to spin.\', \'warn\'); return; }\n      resultSection.hidden = true;\n      winnerNameDiv.textContent = \'\';\n      wheel.spin();\n      spinBtn.disabled = true;\n      const checkFinish = setInterval(() =&gt; {\n        if (!wheel.isSpinning) {\n          clearInterval(checkFinish);\n          spinBtn.disabled = false;\n        }\n      }, 200);\n    });\n    rerollBtn.addEventListener(\'click\', () =&gt; {\n      resultSection.hidden = true;\n      wheel.spin();\n    });\n    clearNamesBtn.addEventListener(\'click\', () =&gt; {\n      if (confirm(\'Clear all names?\')) {\n        wheel.clearNames();\n        updateUI();\n      }\n    });\n    themeSelect.addEventListener(\'change\', (e) =&gt; {\n      const t = e.target.value;\n      document.body.className = \'theme-\' + t;\n      wheel.setTheme(t);\n    });\n    function onWinner(result) {\n      winnerNameDiv.textContent = result.name || \'—\';\n      resultSection.hidden = false;\n      // Flash the winner item in the list (if still present)\n      const items = Array.from(nameList.children);\n      items.forEach((li, idx) =&gt; { li.classList.toggle(\'winner\', idx === result.index); });\n      showMessage(`Winner: ${result.name}`, \'success\', 4000);\n    }\n    // Simple message area\n    function showMessage(text, type = \'info\', duration = 2200) {\n      // create small toast\n      const t = document.createElement(\'div\');\n      t.className = \'tmp-toast \' + type;\n      t.textContent = text;\n      document.body.appendChild(t);\n      // Force reflow to pick up transitions\n      window.getComputedStyle(t).opacity;\n      setTimeout(()=&gt; { t.style.opacity = \'0\'; t.style.transform = \'translateY(-10px)\'; }, duration - 300);\n      setTimeout(()=&gt; { try { t.remove(); } catch(e){} }, duration);\n    }\n    // Export/import CSV\n    exportBtn.addEventListener(\'click\', () =&gt; {\n      if (wheel.names.length === 0) { showMessage(\'No names to export.\', \'warn\'); return; }\n      const csv = wheel.names.map(n =&gt; `"${(n||\'\').replace(/"/g,\'""\')}"`).join(\'\\n\');\n      const blob = new Blob([csv], { type: \'text/csv\' });\n      const url = URL.createObjectURL(blob);\n      const a = document.createElement(\'a\');\n      a.href = url;\n      a.download = \'participants.csv\';\n      document.body.appendChild(a);\n      a.click();\n      a.remove();\n      URL.revokeObjectURL(url);\n      showMessage(\'Exported CSV\', \'info\');\n    });\n    importBtn.addEventListener(\'click\', () =&gt; { importFile.click(); });\n    importFile.addEventListener(\'change\', (e) =&gt; {\n      const file = e.target.files[0];\n      if (!file) return;\n      const reader = new FileReader();\n      reader.onload = (ev) =&gt; {\n        const txt = ev.target.result;\n        const lines = txt.split(/\\r?\\n/).map(s =&gt; s.trim()).filter(s =&gt; s);\n        // basic CSV unquote\n        const parsed = lines.map(l =&gt; {\n          // simple CSV single-column parse: handle quoted fields\n          if (l.startsWith(\'"\') &amp;&amp; l.endsWith(\'"\')) {\n            return l.slice(1,-1).replace(/""/g,\'"\');\n          }\n          return l;\n        });\n        parsed.forEach(p =&gt; wheel.addName(p));\n        updateUI();\n        showMessage(`Imported ${parsed.length} names`, \'info\');\n      };\n      reader.readAsText(file);\n      importFile.value = \'\';\n    });\n    // Initial sample (optional)\n    // wheel.addName(\'Alice\'); wheel.addName(\'Bob\'); wheel.addName(\'Charlie\');\n    updateUI();\n    // (Optional) keyboard shortcuts\n    window.addEventListener(\'keydown\', (e) =&gt; {\n      if ((e.ctrlKey || e.metaKey) &amp;&amp; e.key.toLowerCase() === \'k\') {\n        e.preventDefault();\n        nameInput.focus();\n      }\n      if (e.key === \' \') {\n        // space triggers spin if not focusing an input\n        if (document.activeElement.tagName !== \'INPUT\' &amp;&amp; document.activeElement.tagName !== \'TEXTAREA\') {\n          e.preventDefault();\n          spinBtn.click();\n        }\n      }\n    });\n  });\n})(); \n', 'cycle_index': 3, 'task': '[Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes. Do it in HTML, CSS, and JavaScript.]', 'modality': 'website', 'ideas': '', 'language': ' JavaScript', 'codes': 'index.html\nhtml\n\'\'\'\nDOCSTRING\nThis is the main HTML file for the Random Winner Wheel.\nIt contains the structure: input fields to add names, a canvas for the wheel,\ncontrols (spin, clear, bulk add), theme selector, and placeholders for CSS/JS.\n\'\'\'\n&lt;!doctype html&gt;\n&lt;html lang="en"&gt;\n&lt;head&gt;\n  &lt;meta charset="utf-8" /&gt;\n  &lt;meta name="viewport" content="width=device-width,initial-scale=1" /&gt;\n  &lt;title&gt;Random Winner Wheel&lt;/title&gt;\n  &lt;link rel="stylesheet" href="styles.css"&gt;\n&lt;/head&gt;\n&lt;body class="theme-light"&gt;\n  &lt;header&gt;\n    &lt;h1&gt;Random Winner Wheel&lt;/h1&gt;\n    &lt;p&gt;Enter participant names, choose a theme, and spin to pick a winner.&lt;/p&gt;\n  &lt;/header&gt;\n  &lt;main&gt;\n    &lt;section class="controls"&gt;\n      &lt;div class="add-single"&gt;\n        &lt;input id="nameInput" type="text" placeholder="Enter a name and press Add" aria-label="Name input" /&gt;\n        &lt;button id="addBtn"&gt;Add&lt;/button&gt;\n        &lt;button id="addRandomBtn" title="Add a few sample random names"&gt;Add Sample&lt;/button&gt;\n      &lt;/div&gt;\n      &lt;div class="bulk-add"&gt;\n        &lt;label for="bulkInput"&gt;Bulk add (comma, newline or semicolon separated):&lt;/label&gt;\n        &lt;textarea id="bulkInput" placeholder="Alice, Bob, Charlie"&gt;&lt;/textarea&gt;\n        &lt;div class="bulk-actions"&gt;\n          &lt;button id="bulkAddBtn"&gt;Bulk Add&lt;/button&gt;\n          &lt;button id="clearBulkBtn"&gt;Clear Bulk&lt;/button&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;\n      &lt;div class="list-actions"&gt;\n        &lt;div class="theme-select"&gt;\n          &lt;label for="themeSelect"&gt;Theme:&lt;/label&gt;\n          &lt;select id="themeSelect"&gt;\n            &lt;option value="light"&gt;Light&lt;/option&gt;\n            &lt;option value="dark"&gt;Dark&lt;/option&gt;\n            &lt;option value="neon"&gt;Neon&lt;/option&gt;\n            &lt;option value="pastel"&gt;Pastel&lt;/option&gt;\n            &lt;option value="retro"&gt;Retro&lt;/option&gt;\n          &lt;/select&gt;\n        &lt;/div&gt;\n        &lt;div class="wheel-controls"&gt;\n          &lt;button id="spinBtn" class="primary"&gt;Spin&lt;/button&gt;\n          &lt;button id="clearNamesBtn"&gt;Clear Names&lt;/button&gt;\n          &lt;button id="exportBtn"&gt;Export CSV&lt;/button&gt;\n          &lt;input id="importFile" type="file" accept=".csv,text/csv" style="display:none"&gt;\n          &lt;button id="importBtn"&gt;Import CSV&lt;/button&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;\n    &lt;/section&gt;\n    &lt;section class="wheel-area"&gt;\n      &lt;div class="wheel-container"&gt;\n        &lt;canvas id="wheelCanvas" width="600" height="600" aria-label="Spinning wheel"&gt;&lt;/canvas&gt;\n        &lt;div class="pointer" aria-hidden="true"&gt;▼&lt;/div&gt;\n      &lt;/div&gt;\n      &lt;aside class="participants"&gt;\n        &lt;h2&gt;Participants (&lt;span id="count"&gt;0&lt;/span&gt;)&lt;/h2&gt;\n        &lt;ul id="nameList" aria-live="polite"&gt;&lt;/ul&gt;\n      &lt;/aside&gt;\n    &lt;/section&gt;\n    &lt;section class="result" id="result" aria-live="polite" hidden&gt;\n      &lt;h2&gt;Winner&lt;/h2&gt;\n      &lt;div id="winnerName" class="winnerName"&gt;&lt;/div&gt;\n      &lt;button id="rerollBtn"&gt;Spin Again&lt;/button&gt;\n    &lt;/section&gt;\n  &lt;/main&gt;\n  &lt;footer&gt;\n    &lt;small&gt;Built with HTML, CSS, and JavaScript. Themes change both UI and wheel colors.&lt;/small&gt;\n  &lt;/footer&gt;\n  &lt;script src="script.js"&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\n\nstyles.css\ncss\n\'\'\'\nDOCSTRING\nStylesheet for the Random Winner Wheel.\nDefines layout, themes, wheel container sizing, animations, and toast styles.\n\'\'\'\n/* Reset &amp; base */\n* { box-sizing: border-box; margin: 0; padding: 0; }\nhtml,body { height: 100%; font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; background: var(--bg); color: var(--fg); }\n:root {\n  --bg: #f7f8fb;\n  --fg: #222;\n  --muted: #666;\n  --accent: #2b8cff;\n  --card: #ffffff;\n  --primary-btn-bg: var(--accent);\n  --primary-btn-fg: #fff;\n  --shadow: rgba(15,15,15,0.08);\n}\n/* Themes */\nbody.theme-light {\n  --bg: #f7f8fb;\n  --fg: #222;\n  --muted: #5b6170;\n  --accent: #2b8cff;\n  --card: #fff;\n  --wheel-seq: 0;\n}\nbody.theme-dark {\n  --bg: #0f1724;\n  --fg: #e6eef8;\n  --muted: #a9b1c2;\n  --accent: #7c5cff;\n  --card: #0b1220;\n}\nbody.theme-neon {\n  --bg: #0a0a0f;\n  --fg: #e9f9ff;\n  --muted: #a6f3ff;\n  --accent: #39ff14;\n  --card: #09101a;\n}\nbody.theme-pastel {\n  --bg: #fffaf6;\n  --fg: #3c3a3a;\n  --muted: #8d8a8a;\n  --accent: #ff7aa2;\n  --card: #fff;\n}\nbody.theme-retro {\n  --bg: #fff6e7;\n  --fg: #402b2b;\n  --muted: #856e6e;\n  --accent: #ffb86b;\n  --card: #fff0e6;\n}\n/* Layout */\nheader { padding: 18px 24px; text-align: center; background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent); }\nheader h1 { font-size: 1.5rem; margin-bottom: 6px; }\nmain { padding: 18px; max-width: 1100px; margin: 0 auto; }\n.controls { display: grid; gap: 12px; margin-bottom: 18px; }\n.add-single { display:flex; gap:8px; }\n.add-single input[type="text"] { flex:1; padding:10px; border-radius:8px; border:1px solid rgba(0,0,0,0.08); background:var(--card); color:var(--fg); }\n.add-single button { padding:10px 12px; border-radius:8px; border: none; cursor:pointer; background: var(--primary-btn-bg); color: var(--primary-btn-fg); }\n.add-single button#addRandomBtn { background: transparent; border: 1px solid rgba(0,0,0,0.06); color: var(--fg); }\n.bulk-add textarea { width:100%; min-height:64px; margin-top:6px; padding:8px; border-radius:8px; border:1px solid rgba(0,0,0,0.06); background:var(--card); color:var(--fg); }\n.bulk-actions { display:flex; gap:8px; margin-top:8px; }\n.list-actions { display:flex; justify-content:space-between; align-items:center; gap:16px; flex-wrap:wrap; }\n.theme-select select { padding:8px; border-radius:8px; border:1px solid rgba(0,0,0,0.06); }\n.wheel-area { display:flex; gap:18px; align-items:start; flex-wrap:wrap; }\n.wheel-container { position: relative; width: 600px; height: 600px; max-width: 90vw; max-height: 90vw; display:flex; align-items:center; justify-content:center; background: transparent; }\n.pointer {\n  /* Centered triangular pointer positioned above the wheel.\n     This ensures the visual pointer aligns with the wheel math (top-center).\n     Hides the fallback glyph in the HTML and draws a sharp triangle instead. */\n  position: absolute;\n  top: 8px;               /* vertical offset from top of wheel container */\n  left: 50%;              /* center horizontally */\n  transform: translateX(-50%); /* center on the X axis */\n  width: 0;\n  height: 0;\n  border-left: 12px solid transparent;\n  border-right: 12px solid transparent;\n  border-bottom: 18px solid var(--accent);\n  z-index: 10;            /* ensure it\'s above the canvas */\n  pointer-events: none;\n  /* hide textual glyph fallback content (the ▼ in HTML) */\n  font-size: 0;\n  line-height: 0;\n  text-indent: -9999px;\n}\n/* Participants panel and wheel styles */\n.participants { width: 320px; max-width: 40vw; background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent); padding:12px; border-radius:10px; box-shadow: 0 6px 18px var(--shadow); }\n.participants h2 { margin-bottom:8px; font-size:1.05rem; }\n#nameList { list-style:none; max-height:420px; overflow:auto; display:block; }\n#nameList li { padding:8px; border-radius:6px; display:flex; justify-content:space-between; align-items:center; gap:8px; margin-bottom:8px; background: var(--card); border:1px solid rgba(0,0,0,0.04); }\n#nameList li button { background: transparent; border: none; color: var(--muted); cursor:pointer; }\n.result { margin-top:18px; padding:12px; border-radius:8px; background: var(--card); text-align:center; box-shadow: 0 6px 18px var(--shadow); }\n.result .winnerName { font-size:1.4rem; font-weight:700; margin:8px 0; color: var(--accent); }\n/* Buttons */\nbutton { cursor:pointer; padding:8px 12px; border-radius:8px; border:1px solid rgba(0,0,0,0.06); background: transparent; color:var(--fg); }\nbutton.primary { background: var(--primary-btn-bg); color: var(--primary-btn-fg); border: none; }\n/* Responsive */\n@media (max-width: 900px) {\n  .wheel-area { flex-direction:column; align-items:center; }\n  .participants { width: 100%; max-width: 100%; }\n}\n/* Wheel canvas scaling helper */\n#wheelCanvas { border-radius:50%; box-shadow: 0 12px 26px rgba(0,0,0,0.12); background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.02), transparent); }\n/* Toast / temporary message styles (used by showMessage) */\n.tmp-toast {\n  position: fixed;\n  left: 50%;\n  transform: translateX(-50%);\n  top: 18px;\n  background: rgba(0,0,0,0.85);\n  color: #fff;\n  padding: 8px 12px;\n  border-radius: 6px;\n  z-index: 9999;\n  transition: opacity 0.25s, transform 0.25s;\n  opacity: 1;\n  pointer-events: none;\n  font-size: 0.95rem;\n  box-shadow: 0 6px 18px rgba(0,0,0,0.18);\n}\n.tmp-toast.success { background: rgba(56, 198, 123, 0.95); }\n.tmp-toast.warn    { background: rgba(255, 159, 67, 0.95); color: #2b1500; }\n.tmp-toast.info    { background: rgba(12, 74, 255, 0.95); }\n/* Winner highlight for participants list */\n#nameList li.winner {\n  outline: 3px solid rgba(255,215,0,0.15);\n  box-shadow: 0 6px 18px rgba(255,215,0,0.06);\n  transform: scale(1.01);\n}\n\n\nscript.js\njs\n\'\'\'\nDOCSTRING\nScript for the Random Winner Wheel.\nContains the Wheel class to draw and spin the canvas-based wheel and UI glue code to manage names and themes.\n\'\'\'\n/* \nDOCSTRING\nScript for the Random Winner Wheel.\nContains the Wheel class to draw and spin the canvas-based wheel and UI glue code to manage names and themes.\n*/\n/* Main JavaScript - Wheel + UI logic */\n(() =&gt; {\n  // Utilities\n  function rand(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }\n  function easeOutCubic(t) { return 1 - Math.pow(1 - t, 3); }\n  // Color palettes for themes (will be used to paint wheel segments)\n  const THEME_PALETTES = {\n    light: [\'#FF8A80\',\'#FFD180\',\'#FFF59D\',\'#C8E6C9\',\'#80DEEA\',\'#A7FFEB\',\'#B39DDB\',\'#90CAF9\'],\n    dark: [\'#ff6b6b\',\'#ffd166\',\'#faff8e\',\'#b9f6ca\',\'#4dd0e1\',\'#80cbc4\',\'#b388ff\',\'#64b5f6\'],\n    neon: [\'#ff2d95\',\'#7cff01\',\'#00ffff\',\'#ffdd00\',\'#ff6a00\',\'#00ff9e\',\'#ff00ff\',\'#47ffa2\'],\n    pastel: [\'#ffdbe9\',\'#fff0b3\',\'#d1ffd6\',\'#cfefff\',\'#e7dfff\',\'#ffd6e7\',\'#fbe7d6\',\'#e6f7ff\'],\n    retro: [\'#ffb86b\',\'#ffd3a8\',\'#f3e2a9\',\'#b8e0d2\',\'#c0b9ff\',\'#ffb6c1\',\'#f6c49f\',\'#c3d69b\']\n  };\n  // Wheel class\n  class Wheel {\n    /*\n    Manage wheel: drawing, recalculating segments, spinning animation, and determining winner.\n    */\n    constructor(canvas, options = {}) {\n      this.canvas = canvas;\n      this.ctx = canvas.getContext(\'2d\');\n      this.names = [];\n      this.rotation = 0; // radians\n      this.isSpinning = false;\n      this.frame = null;\n      this.onResult = options.onResult || function() {};\n      this.theme = options.theme || \'light\';\n      this.padAngle = 0.02; // radians padding between segments\n      this.textColor = \'#111\';\n      this._devicePixelRatioFix();\n      window.addEventListener(\'resize\', () =&gt; { this._devicePixelRatioFix(); this.draw(); });\n    }\n    _devicePixelRatioFix() {\n      const dpr = window.devicePixelRatio || 1;\n      const rect = this.canvas.getBoundingClientRect();\n      // If rect has zero size (canvas not yet laid out), use current width/height attributes as fallback\n      const width = rect.width || (this.canvas.width / dpr);\n      const height = rect.height || (this.canvas.height / dpr);\n      this.canvas.width = width * dpr;\n      this.canvas.height = height * dpr;\n      this.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n      this.centerX = width / 2;\n      this.centerY = height / 2;\n      this.radius = Math.min(width, height) / 2 - 18;\n    }\n    setTheme(themeId) { this.theme = themeId; this.draw(); }\n    setNames(names) {\n      this.names = names.slice();\n      this.draw();\n    }\n    addName(name) {\n      this.names.push(name);\n      this.draw();\n    }\n    removeName(index) {\n      if (index &gt;= 0 &amp;&amp; index &lt; this.names.length) {\n        this.names.splice(index,1);\n        this.draw();\n      }\n    }\n    clearNames() {\n      this.names = [];\n      this.draw();\n    }\n    draw() {\n      const ctx = this.ctx;\n      const w = this.canvas.width / (window.devicePixelRatio || 1);\n      const h = this.canvas.height / (window.devicePixelRatio || 1);\n      ctx.clearRect(0,0,w,h);\n      ctx.save();\n      ctx.translate(this.centerX, this.centerY);\n      ctx.rotate(this.rotation);\n      // draw segments\n      const count = Math.max(this.names.length, 1);\n      const palette = THEME_PALETTES[this.theme] || THEME_PALETTES.light;\n      for (let i = 0; i &lt; count; i++) {\n        const start = (i / count) * Math.PI * 2;\n        const end = ((i + 1) / count) * Math.PI * 2;\n        ctx.beginPath();\n        ctx.moveTo(0,0);\n        ctx.arc(0,0,this.radius, start + this.padAngle, end - this.padAngle, false);\n        ctx.closePath();\n        const color = palette[i % palette.length];\n        ctx.fillStyle = color;\n        ctx.fill();\n        ctx.strokeStyle = (i % 2 === 0) ? \'rgba(0,0,0,0.06)\' : \'rgba(0,0,0,0.03)\';\n        ctx.lineWidth = 1;\n        ctx.stroke();\n        // draw text label\n        const mid = (start + end) / 2;\n        ctx.save();\n        ctx.rotate(mid);\n        ctx.translate(this.radius * 0.6, 0);\n        ctx.rotate(Math.PI/2);\n        ctx.fillStyle = getTextColor(color);\n        ctx.font = `${Math.max(12, Math.min(22, this.radius / 8))}px sans-serif`;\n        ctx.textAlign = \'center\';\n        ctx.textBaseline = \'middle\';\n        const label = (this.names.length === 0) ? \'Add names\' : this.names[i % this.names.length];\n        wrapFillText(ctx, label, 0, 0, this.radius * 0.5, 16);\n        ctx.restore();\n      }\n      // draw center circle\n      ctx.beginPath();\n      ctx.arc(0,0, this.radius * 0.16, 0, Math.PI*2);\n      ctx.fillStyle = \'rgba(255,255,255,0.9)\';\n      ctx.fill();\n      ctx.strokeStyle = \'rgba(0,0,0,0.06)\';\n      ctx.stroke();\n      ctx.restore();\n      // draw outer ring (pointer side neutral)\n      ctx.beginPath();\n      ctx.arc(this.centerX, this.centerY, this.radius + 10, 0, Math.PI*2);\n      ctx.strokeStyle = \'rgba(0,0,0,0.03)\';\n      ctx.lineWidth = 2;\n      ctx.stroke();\n    }\n    spin() {\n      if (this.isSpinning || this.names.length === 0) return;\n      this.isSpinning = true;\n      const count = this.names.length;\n      // Determine random winner index to land on:\n      const winnerIndex = rand(0, count - 1);\n      // Calculate final rotation so that winner segment lines up with pointer at top (pointer at canvas top - rotation must align)\n      // Our pointer is at the top (canvas 0 angle). The segment mid-angle for index i (without rotation) is ((i + 0.5)/count)*2pi\n      const segmentMid = ((winnerIndex + 0.5) / count) * Math.PI * 2;\n      // We want segmentMid + rotation_final == -Math.PI/2 (so it points at the top pointer), so rotation_final = -Math.PI/2 - segmentMid + 2pi*N\n      const extraTurns = rand(5, 8); // full spins\n      const rotationFinal = -Math.PI/2 - segmentMid + extraTurns * Math.PI * 2;\n      const startRotation = this.rotation % (Math.PI * 2);\n      const delta = rotationFinal - startRotation;\n      const duration = 4000 + Math.random() * 1500; // ms\n      const startTime = performance.now();\n      const animate = (now) =&gt; {\n        const elapsed = now - startTime;\n        const t = Math.min(elapsed / duration, 1);\n        const eased = easeOutCubic(t);\n        this.rotation = startRotation + delta * eased;\n        this.draw();\n        if (t &lt; 1) {\n          this.frame = requestAnimationFrame(animate);\n        } else {\n          this.isSpinning = false;\n          // Normalize rotation within 0..2pi\n          this.rotation = ((this.rotation % (Math.PI*2)) + Math.PI*2) % (Math.PI*2);\n          this.draw();\n          // Compute final winner index again from rotation\n          // finalAngle: the angle of the segment at pointer (0 at right, +counterclockwise). We compute a normalized angle that maps to segment index.\n          const finalAngle = ((-this.rotation - Math.PI/2) % (Math.PI*2) + Math.PI*2) % (Math.PI*2);\n          const resultingIndex = Math.floor((finalAngle / (Math.PI*2)) * count) % count;\n          const winner = this.names[resultingIndex];\n          this.onResult({ index: resultingIndex, name: winner });\n        }\n      };\n      this.frame = requestAnimationFrame(animate);\n    }\n  }\n  // Helper: pick readable text color for a background\n  function getTextColor(hex) {\n    // remove # and convert\n    const h = hex.replace(\'#\',\'\');\n    const r = parseInt(h.substring(0,2),16);\n    const g = parseInt(h.substring(2,4),16);\n    const b = parseInt(h.substring(4,6),16);\n    // luminance\n    const lum = (0.299*r + 0.587*g + 0.114*b) / 255;\n    return lum &gt; 0.65 ? \'#111\' : \'#fff\';\n  }\n  // Helper: wrap text within a given width (draws multi-line if necessary)\n  function wrapFillText(ctx, text, x, y, maxWidth, lineHeight) {\n    const words = (text || \'\').split(/\\s+/);\n    if (words.length === 0) return;\n    let line = \'\';\n    const lines = [];\n    for (let n = 0; n &lt; words.length; n++) {\n      const testLine = line ? line + \' \' + words[n] : words[n];\n      const metrics = ctx.measureText(testLine);\n      if (metrics.width &gt; maxWidth &amp;&amp; line) {\n        lines.push(line);\n        line = words[n];\n      } else {\n        line = testLine;\n      }\n    }\n    if (line) lines.push(line);\n    // If still too many lines, just draw what\'s possible (we rely on font size)\n    for (let i=0;i&lt;lines.length;i++){\n      ctx.fillText(lines[i], x, y + (i - (lines.length-1)/2) * lineHeight);\n    }\n  }\n  // UI glue\n  document.addEventListener(\'DOMContentLoaded\', () =&gt; {\n    const canvas = document.getElementById(\'wheelCanvas\');\n    const wheel = new Wheel(canvas, { theme: \'light\', onResult: onWinner });\n    const nameInput = document.getElementById(\'nameInput\');\n    const addBtn = document.getElementById(\'addBtn\');\n    const addRandomBtn = document.getElementById(\'addRandomBtn\');\n    const bulkInput = document.getElementById(\'bulkInput\');\n    const bulkAddBtn = document.getElementById(\'bulkAddBtn\');\n    const clearBulkBtn = document.getElementById(\'clearBulkBtn\');\n    const nameList = document.getElementById(\'nameList\');\n    const countSpan = document.getElementById(\'count\');\n    const spinBtn = document.getElementById(\'spinBtn\');\n    const rerollBtn = document.getElementById(\'rerollBtn\');\n    const clearNamesBtn = document.getElementById(\'clearNamesBtn\');\n    const themeSelect = document.getElementById(\'themeSelect\');\n    const resultSection = document.getElementById(\'result\');\n    const winnerNameDiv = document.getElementById(\'winnerName\');\n    const exportBtn = document.getElementById(\'exportBtn\');\n    const importBtn = document.getElementById(\'importBtn\');\n    const importFile = document.getElementById(\'importFile\');\n    // Initial draw\n    wheel.draw();\n    function updateUI() {\n      const names = wheel.names;\n      countSpan.textContent = names.length;\n      renderNameList();\n    }\n    function renderNameList() {\n      nameList.innerHTML = \'\';\n      wheel.names.forEach((n, i) =&gt; {\n        const li = document.createElement(\'li\');\n        const span = document.createElement(\'span\');\n        span.textContent = n;\n        li.appendChild(span);\n        const btn = document.createElement(\'button\');\n        btn.title = \'Remove\';\n        btn.setAttribute(\'aria-label\', `Remove ${n}`);\n        btn.innerHTML = \'✕\';\n        btn.addEventListener(\'click\', () =&gt; {\n          wheel.removeName(i);\n          updateUI();\n        });\n        li.appendChild(btn);\n        nameList.appendChild(li);\n      });\n    }\n    function addNameFromInput() {\n      const v = nameInput.value.trim();\n      if (!v) { showMessage(\'Please enter a name.\', \'warn\'); return; }\n      wheel.addName(v);\n      nameInput.value = \'\';\n      updateUI();\n    }\n    addBtn.addEventListener(\'click\', addNameFromInput);\n    nameInput.addEventListener(\'keydown\', (e) =&gt; { if (e.key === \'Enter\') addNameFromInput(); });\n    addRandomBtn.addEventListener(\'click\', () =&gt; {\n      const samples = [\'Alex\',\'Jordan\',\'Taylor\',\'Sam\',\'Jamie\',\'Casey\',\'Morgan\',\'Riley\',\'Avery\',\'Dana\'];\n      const count = rand(3,6);\n      for (let i=0;i&lt;count;i++) wheel.addName(samples[rand(0,samples.length-1)] + (rand(1,100)));\n      updateUI();\n    });\n    bulkAddBtn.addEventListener(\'click\', () =&gt; {\n      const text = bulkInput.value.trim();\n      if (!text) { showMessage(\'Bulk input is empty.\', \'warn\'); return; }\n      const parsed = text.split(/[\\n,;]+/).map(s =&gt; s.trim()).filter(s =&gt; s);\n      parsed.forEach(p =&gt; wheel.addName(p));\n      bulkInput.value = \'\';\n      updateUI();\n      showMessage(`Added ${parsed.length} names.`, \'info\');\n    });\n    clearBulkBtn.addEventListener(\'click\', () =&gt; { bulkInput.value = \'\'; });\n    spinBtn.addEventListener(\'click\', () =&gt; {\n      if (wheel.names.length === 0) { showMessage(\'Add at least one name to spin.\', \'warn\'); return; }\n      resultSection.hidden = true;\n      winnerNameDiv.textContent = \'\';\n      wheel.spin();\n      spinBtn.disabled = true;\n      const checkFinish = setInterval(() =&gt; {\n        if (!wheel.isSpinning) {\n          clearInterval(checkFinish);\n          spinBtn.disabled = false;\n        }\n      }, 200);\n    });\n    rerollBtn.addEventListener(\'click\', () =&gt; {\n      resultSection.hidden = true;\n      wheel.spin();\n    });\n    clearNamesBtn.addEventListener(\'click\', () =&gt; {\n      if (confirm(\'Clear all names?\')) {\n        wheel.clearNames();\n        updateUI();\n      }\n    });\n    themeSelect.addEventListener(\'change\', (e) =&gt; {\n      const t = e.target.value;\n      document.body.className = \'theme-\' + t;\n      wheel.setTheme(t);\n    });\n    function onWinner(result) {\n      winnerNameDiv.textContent = result.name || \'—\';\n      resultSection.hidden = false;\n      // Flash the winner item in the list (if still present)\n      const items = Array.from(nameList.children);\n      items.forEach((li, idx) =&gt; { li.classList.toggle(\'winner\', idx === result.index); });\n      showMessage(`Winner: ${result.name}`, \'success\', 4000);\n    }\n    // Simple message area\n    function showMessage(text, type = \'info\', duration = 2200) {\n      // create small toast\n      const t = document.createElement(\'div\');\n      t.className = \'tmp-toast \' + type;\n      t.textContent = text;\n      document.body.appendChild(t);\n      // Force reflow to pick up transitions\n      window.getComputedStyle(t).opacity;\n      setTimeout(()=&gt; { t.style.opacity = \'0\'; t.style.transform = \'translateY(-10px)\'; }, duration - 300);\n      setTimeout(()=&gt; { try { t.remove(); } catch(e){} }, duration);\n    }\n    // Export/import CSV\n    exportBtn.addEventListener(\'click\', () =&gt; {\n      if (wheel.names.length === 0) { showMessage(\'No names to export.\', \'warn\'); return; }\n      const csv = wheel.names.map(n =&gt; `"${(n||\'\').replace(/"/g,\'""\')}"`).join(\'\\n\');\n      const blob = new Blob([csv], { type: \'text/csv\' });\n      const url = URL.createObjectURL(blob);\n      const a = document.createElement(\'a\');\n      a.href = url;\n      a.download = \'participants.csv\';\n      document.body.appendChild(a);\n      a.click();\n      a.remove();\n      URL.revokeObjectURL(url);\n      showMessage(\'Exported CSV\', \'info\');\n    });\n    importBtn.addEventListener(\'click\', () =&gt; { importFile.click(); });\n    importFile.addEventListener(\'change\', (e) =&gt; {\n      const file = e.target.files[0];\n      if (!file) return;\n      const reader = new FileReader();\n      reader.onload = (ev) =&gt; {\n        const txt = ev.target.result;\n        const lines = txt.split(/\\r?\\n/).map(s =&gt; s.trim()).filter(s =&gt; s);\n        // basic CSV unquote\n        const parsed = lines.map(l =&gt; {\n          // simple CSV single-column parse: handle quoted fields\n          if (l.startsWith(\'"\') &amp;&amp; l.endsWith(\'"\')) {\n            return l.slice(1,-1).replace(/""/g,\'"\');\n          }\n          return l;\n        });\n        parsed.forEach(p =&gt; wheel.addName(p));\n        updateUI();\n        showMessage(`Imported ${parsed.length} names`, \'info\');\n      };\n      reader.readAsText(file);\n      importFile.value = \'\';\n    });\n    // Initial sample (optional)\n    // wheel.addName(\'Alice\'); wheel.addName(\'Bob\'); wheel.addName(\'Charlie\');\n    updateUI();\n    // (Optional) keyboard shortcuts\n    window.addEventListener(\'keydown\', (e) =&gt; {\n      if ((e.ctrlKey || e.metaKey) &amp;&amp; e.key.toLowerCase() === \'k\') {\n        e.preventDefault();\n        nameInput.focus();\n      }\n      if (e.key === \' \') {\n        // space triggers spin if not focusing an input\n        if (document.activeElement.tagName !== \'INPUT\' &amp;&amp; document.activeElement.tagName !== \'TEXTAREA\') {\n          e.preventDefault();\n          spinBtn.click();\n        }\n      }\n    });\n  });\n})(); \n\n\n', 'images': '', 'comments': " Fix pointer alignment so the visual pointer actually sits over the wheel center (highest priority)\n\nWhy: the spin logic aligns a winning segment to the top/center of the wheel (math uses -Math.PI/2). However the .pointer element in CSS is not horizontally centered — it only has top:6px and transform: translateY(-50%). That places the pointer near the top-left of the wheel container instead of top-center. Users will see the pointer off-center and may be confused because the wheel rotates to point at the top-center but the visible pointer isn't there. This breaks the main UX (the pointer must accurately indicate the selected segment).\n\nHow to fix: center the pointer horizontally, keep it visually above the wheel, and ensure it has a higher stacking order than the canvas. Replace (or update) the .pointer CSS rule with the following:\n\n/ Replace existing .pointer rule with this /\n.pointer {\n  position: absolute;\n  top: 8px;               / vertical offset from top of wheel container /\n  left: 50%;              / center horizontally /\n  transform: translate(-50%, -50%); / truly center at top middle /\n  font-size: 28px;\n  z-index: 10;            / ensure it's above the canvas /\n  color: var(--accent);\n  pointer-events: none;\n  text-shadow: 0 2px 8px rgba(0,0,0,0.25);\n}\n\nOptional improvement (sharper pointer): instead of a glyph, use a small CSS triangle so it's visually clear. Example:\n\n.pointer {\n  position: absolute;\n  top: 8px;\n  left: 50%;\n  transform: translateX(-50%);\n  width: 0;\n  height: 0;\n  border-left: 10px solid transparent;\n  border-right: 10px solid transparent;\n  border-bottom: 16px solid var(--accent);\n  z-index: 10;\n  pointer-events: none;\n}\n\nSteps to apply:\n1. Edit styles.css and replace the existing .pointer rule with one of the options above.\n2. Reload the page and verify the pointer is centered over the wheel and the winners line up precisely under the pointer.\n\nWhy this is the top priority: the visual pointer's position directly contradicts the wheel's spin logic; fixing this restores the core user experience (clear, accurate winner indication) without any other code changes."} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_3_5_TURBO |

[2025-17-09 13:44:49 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Code Reviewer |
| **user_role_name** | Programmer |
| **assistant_role_prompt** | {chatdev_prompt} You are Code Reviewer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. You can help programmers to assess source codes for software troubleshooting, fix bugs to increase code quality and robustness, and offer proposals to improve the source codes. Here is a new customer's task: {task}. To complete the task, you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Programmer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. You can write/create computer software or applications by providing a specific programming language to the computer. You have extensive computing and coding experience in many varieties of programming languages and platforms, such as Python, Java, C, C++, HTML, CSS, JavaScript, XML, SQL, PHP, etc,. Here is a new customer's task: {task}. To complete the task, you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **task_prompt** | [Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes. Do it in HTML, CSS, and JavaScript.] |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_3_5_TURBO |
| **background_prompt** | ChatDev is a software company powered by multiple intelligent agents, such as chief executive officer, chief human resources officer, chief product officer, chief technology officer, etc, with a multi-agent organizational structure and the mission of 'changing the digital world through programming'. |

[2025-17-09 13:44:49 INFO] Programmer: **[Start Chat]**

[ChatDev is a software company powered by multiple intelligent agents, such as chief executive officer, chief human resources officer, chief product officer, chief technology officer, etc, with a multi-agent organizational structure and the mission of 'changing the digital world through programming'.
You are Code Reviewer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer.
You can help programmers to assess source codes for software troubleshooting, fix bugs to increase code quality and robustness, and offer proposals to improve the source codes.
Here is a new customer's task: [Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes. Do it in HTML, CSS, and JavaScript.].
To complete the task, you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]

According to the new user's task and our software designs: 
Task: "[Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes. Do it in HTML, CSS, and JavaScript.]".
Modality: "website".
Programming Language: " JavaScript"
Ideas: ""
Codes:
"index.html
```html
'''
DOCSTRING
This is the main HTML file for the Random Winner Wheel.
It contains the structure: input fields to add names, a canvas for the wheel,
controls (spin, clear, bulk add), theme selector, and placeholders for CSS/JS.
'''
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Random Winner Wheel</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body class="theme-light">
  <header>
    <h1>Random Winner Wheel</h1>
    <p>Enter participant names, choose a theme, and spin to pick a winner.</p>
  </header>
  <main>
    <section class="controls">
      <div class="add-single">
        <input id="nameInput" type="text" placeholder="Enter a name and press Add" aria-label="Name input" />
        <button id="addBtn">Add</button>
        <button id="addRandomBtn" title="Add a few sample random names">Add Sample</button>
      </div>
      <div class="bulk-add">
        <label for="bulkInput">Bulk add (comma, newline or semicolon separated):</label>
        <textarea id="bulkInput" placeholder="Alice, Bob, Charlie"></textarea>
        <div class="bulk-actions">
          <button id="bulkAddBtn">Bulk Add</button>
          <button id="clearBulkBtn">Clear Bulk</button>
        </div>
      </div>
      <div class="list-actions">
        <div class="theme-select">
          <label for="themeSelect">Theme:</label>
          <select id="themeSelect">
            <option value="light">Light</option>
            <option value="dark">Dark</option>
            <option value="neon">Neon</option>
            <option value="pastel">Pastel</option>
            <option value="retro">Retro</option>
          </select>
        </div>
        <div class="wheel-controls">
          <button id="spinBtn" class="primary">Spin</button>
          <button id="clearNamesBtn">Clear Names</button>
          <button id="exportBtn">Export CSV</button>
          <input id="importFile" type="file" accept=".csv,text/csv" style="display:none">
          <button id="importBtn">Import CSV</button>
        </div>
      </div>
    </section>
    <section class="wheel-area">
      <div class="wheel-container">
        <canvas id="wheelCanvas" width="600" height="600" aria-label="Spinning wheel"></canvas>
        <div class="pointer" aria-hidden="true">▼</div>
      </div>
      <aside class="participants">
        <h2>Participants (<span id="count">0</span>)</h2>
        <ul id="nameList" aria-live="polite"></ul>
      </aside>
    </section>
    <section class="result" id="result" aria-live="polite" hidden>
      <h2>Winner</h2>
      <div id="winnerName" class="winnerName"></div>
      <button id="rerollBtn">Spin Again</button>
    </section>
  </main>
  <footer>
    <small>Built with HTML, CSS, and JavaScript. Themes change both UI and wheel colors.</small>
  </footer>
  <script src="script.js"></script>
</body>
</html>
```

styles.css
```css
'''
DOCSTRING
Stylesheet for the Random Winner Wheel.
Defines layout, themes, wheel container sizing, animations, and toast styles.
'''
/* Reset & base */
* { box-sizing: border-box; margin: 0; padding: 0; }
html,body { height: 100%; font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; background: var(--bg); color: var(--fg); }
:root {
  --bg: #f7f8fb;
  --fg: #222;
  --muted: #666;
  --accent: #2b8cff;
  --card: #ffffff;
  --primary-btn-bg: var(--accent);
  --primary-btn-fg: #fff;
  --shadow: rgba(15,15,15,0.08);
}
/* Themes */
body.theme-light {
  --bg: #f7f8fb;
  --fg: #222;
  --muted: #5b6170;
  --accent: #2b8cff;
  --card: #fff;
  --wheel-seq: 0;
}
body.theme-dark {
  --bg: #0f1724;
  --fg: #e6eef8;
  --muted: #a9b1c2;
  --accent: #7c5cff;
  --card: #0b1220;
}
body.theme-neon {
  --bg: #0a0a0f;
  --fg: #e9f9ff;
  --muted: #a6f3ff;
  --accent: #39ff14;
  --card: #09101a;
}
body.theme-pastel {
  --bg: #fffaf6;
  --fg: #3c3a3a;
  --muted: #8d8a8a;
  --accent: #ff7aa2;
  --card: #fff;
}
body.theme-retro {
  --bg: #fff6e7;
  --fg: #402b2b;
  --muted: #856e6e;
  --accent: #ffb86b;
  --card: #fff0e6;
}
/* Layout */
header { padding: 18px 24px; text-align: center; background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent); }
header h1 { font-size: 1.5rem; margin-bottom: 6px; }
main { padding: 18px; max-width: 1100px; margin: 0 auto; }
.controls { display: grid; gap: 12px; margin-bottom: 18px; }
.add-single { display:flex; gap:8px; }
.add-single input[type="text"] { flex:1; padding:10px; border-radius:8px; border:1px solid rgba(0,0,0,0.08); background:var(--card); color:var(--fg); }
.add-single button { padding:10px 12px; border-radius:8px; border: none; cursor:pointer; background: var(--primary-btn-bg); color: var(--primary-btn-fg); }
.add-single button#addRandomBtn { background: transparent; border: 1px solid rgba(0,0,0,0.06); color: var(--fg); }
.bulk-add textarea { width:100%; min-height:64px; margin-top:6px; padding:8px; border-radius:8px; border:1px solid rgba(0,0,0,0.06); background:var(--card); color:var(--fg); }
.bulk-actions { display:flex; gap:8px; margin-top:8px; }
.list-actions { display:flex; justify-content:space-between; align-items:center; gap:16px; flex-wrap:wrap; }
.theme-select select { padding:8px; border-radius:8px; border:1px solid rgba(0,0,0,0.06); }
.wheel-area { display:flex; gap:18px; align-items:start; flex-wrap:wrap; }
.wheel-container { position: relative; width: 600px; height: 600px; max-width: 90vw; max-height: 90vw; display:flex; align-items:center; justify-content:center; background: transparent; }
.pointer {
  /* Centered triangular pointer positioned above the wheel.
     This ensures the visual pointer aligns with the wheel math (top-center).
     Hides the fallback glyph in the HTML and draws a sharp triangle instead. */
  position: absolute;
  top: 8px;               /* vertical offset from top of wheel container */
  left: 50%;              /* center horizontally */
  transform: translateX(-50%); /* center on the X axis */
  width: 0;
  height: 0;
  border-left: 12px solid transparent;
  border-right: 12px solid transparent;
  border-bottom: 18px solid var(--accent);
  z-index: 10;            /* ensure it's above the canvas */
  pointer-events: none;
  /* hide textual glyph fallback content (the ▼ in HTML) */
  font-size: 0;
  line-height: 0;
  text-indent: -9999px;
}
/* Participants panel and wheel styles */
.participants { width: 320px; max-width: 40vw; background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent); padding:12px; border-radius:10px; box-shadow: 0 6px 18px var(--shadow); }
.participants h2 { margin-bottom:8px; font-size:1.05rem; }
#nameList { list-style:none; max-height:420px; overflow:auto; display:block; }
#nameList li { padding:8px; border-radius:6px; display:flex; justify-content:space-between; align-items:center; gap:8px; margin-bottom:8px; background: var(--card); border:1px solid rgba(0,0,0,0.04); }
#nameList li button { background: transparent; border: none; color: var(--muted); cursor:pointer; }
.result { margin-top:18px; padding:12px; border-radius:8px; background: var(--card); text-align:center; box-shadow: 0 6px 18px var(--shadow); }
.result .winnerName { font-size:1.4rem; font-weight:700; margin:8px 0; color: var(--accent); }
/* Buttons */
button { cursor:pointer; padding:8px 12px; border-radius:8px; border:1px solid rgba(0,0,0,0.06); background: transparent; color:var(--fg); }
button.primary { background: var(--primary-btn-bg); color: var(--primary-btn-fg); border: none; }
/* Responsive */
@media (max-width: 900px) {
  .wheel-area { flex-direction:column; align-items:center; }
  .participants { width: 100%; max-width: 100%; }
}
/* Wheel canvas scaling helper */
#wheelCanvas { border-radius:50%; box-shadow: 0 12px 26px rgba(0,0,0,0.12); background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.02), transparent); }
/* Toast / temporary message styles (used by showMessage) */
.tmp-toast {
  position: fixed;
  left: 50%;
  transform: translateX(-50%);
  top: 18px;
  background: rgba(0,0,0,0.85);
  color: #fff;
  padding: 8px 12px;
  border-radius: 6px;
  z-index: 9999;
  transition: opacity 0.25s, transform 0.25s;
  opacity: 1;
  pointer-events: none;
  font-size: 0.95rem;
  box-shadow: 0 6px 18px rgba(0,0,0,0.18);
}
.tmp-toast.success { background: rgba(56, 198, 123, 0.95); }
.tmp-toast.warn    { background: rgba(255, 159, 67, 0.95); color: #2b1500; }
.tmp-toast.info    { background: rgba(12, 74, 255, 0.95); }
/* Winner highlight for participants list */
#nameList li.winner {
  outline: 3px solid rgba(255,215,0,0.15);
  box-shadow: 0 6px 18px rgba(255,215,0,0.06);
  transform: scale(1.01);
}
```

script.js
```js
'''
DOCSTRING
Script for the Random Winner Wheel.
Contains the Wheel class to draw and spin the canvas-based wheel and UI glue code to manage names and themes.
'''
/* 
DOCSTRING
Script for the Random Winner Wheel.
Contains the Wheel class to draw and spin the canvas-based wheel and UI glue code to manage names and themes.
*/
/* Main JavaScript - Wheel + UI logic */
(() => {
  // Utilities
  function rand(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }
  function easeOutCubic(t) { return 1 - Math.pow(1 - t, 3); }
  // Color palettes for themes (will be used to paint wheel segments)
  const THEME_PALETTES = {
    light: ['#FF8A80','#FFD180','#FFF59D','#C8E6C9','#80DEEA','#A7FFEB','#B39DDB','#90CAF9'],
    dark: ['#ff6b6b','#ffd166','#faff8e','#b9f6ca','#4dd0e1','#80cbc4','#b388ff','#64b5f6'],
    neon: ['#ff2d95','#7cff01','#00ffff','#ffdd00','#ff6a00','#00ff9e','#ff00ff','#47ffa2'],
    pastel: ['#ffdbe9','#fff0b3','#d1ffd6','#cfefff','#e7dfff','#ffd6e7','#fbe7d6','#e6f7ff'],
    retro: ['#ffb86b','#ffd3a8','#f3e2a9','#b8e0d2','#c0b9ff','#ffb6c1','#f6c49f','#c3d69b']
  };
  // Wheel class
  class Wheel {
    /*
    Manage wheel: drawing, recalculating segments, spinning animation, and determining winner.
    */
    constructor(canvas, options = {}) {
      this.canvas = canvas;
      this.ctx = canvas.getContext('2d');
      this.names = [];
      this.rotation = 0; // radians
      this.isSpinning = false;
      this.frame = null;
      this.onResult = options.onResult || function() {};
      this.theme = options.theme || 'light';
      this.padAngle = 0.02; // radians padding between segments
      this.textColor = '#111';
      this._devicePixelRatioFix();
      window.addEventListener('resize', () => { this._devicePixelRatioFix(); this.draw(); });
    }
    _devicePixelRatioFix() {
      const dpr = window.devicePixelRatio || 1;
      const rect = this.canvas.getBoundingClientRect();
      // If rect has zero size (canvas not yet laid out), use current width/height attributes as fallback
      const width = rect.width || (this.canvas.width / dpr);
      const height = rect.height || (this.canvas.height / dpr);
      this.canvas.width = width * dpr;
      this.canvas.height = height * dpr;
      this.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      this.centerX = width / 2;
      this.centerY = height / 2;
      this.radius = Math.min(width, height) / 2 - 18;
    }
    setTheme(themeId) { this.theme = themeId; this.draw(); }
    setNames(names) {
      this.names = names.slice();
      this.draw();
    }
    addName(name) {
      this.names.push(name);
      this.draw();
    }
    removeName(index) {
      if (index >= 0 && index < this.names.length) {
        this.names.splice(index,1);
        this.draw();
      }
    }
    clearNames() {
      this.names = [];
      this.draw();
    }
    draw() {
      const ctx = this.ctx;
      const w = this.canvas.width / (window.devicePixelRatio || 1);
      const h = this.canvas.height / (window.devicePixelRatio || 1);
      ctx.clearRect(0,0,w,h);
      ctx.save();
      ctx.translate(this.centerX, this.centerY);
      ctx.rotate(this.rotation);
      // draw segments
      const count = Math.max(this.names.length, 1);
      const palette = THEME_PALETTES[this.theme] || THEME_PALETTES.light;
      for (let i = 0; i < count; i++) {
        const start = (i / count) * Math.PI * 2;
        const end = ((i + 1) / count) * Math.PI * 2;
        ctx.beginPath();
        ctx.moveTo(0,0);
        ctx.arc(0,0,this.radius, start + this.padAngle, end - this.padAngle, false);
        ctx.closePath();
        const color = palette[i % palette.length];
        ctx.fillStyle = color;
        ctx.fill();
        ctx.strokeStyle = (i % 2 === 0) ? 'rgba(0,0,0,0.06)' : 'rgba(0,0,0,0.03)';
        ctx.lineWidth = 1;
        ctx.stroke();
        // draw text label
        const mid = (start + end) / 2;
        ctx.save();
        ctx.rotate(mid);
        ctx.translate(this.radius * 0.6, 0);
        ctx.rotate(Math.PI/2);
        ctx.fillStyle = getTextColor(color);
        ctx.font = `${Math.max(12, Math.min(22, this.radius / 8))}px sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        const label = (this.names.length === 0) ? 'Add names' : this.names[i % this.names.length];
        wrapFillText(ctx, label, 0, 0, this.radius * 0.5, 16);
        ctx.restore();
      }
      // draw center circle
      ctx.beginPath();
      ctx.arc(0,0, this.radius * 0.16, 0, Math.PI*2);
      ctx.fillStyle = 'rgba(255,255,255,0.9)';
      ctx.fill();
      ctx.strokeStyle = 'rgba(0,0,0,0.06)';
      ctx.stroke();
      ctx.restore();
      // draw outer ring (pointer side neutral)
      ctx.beginPath();
      ctx.arc(this.centerX, this.centerY, this.radius + 10, 0, Math.PI*2);
      ctx.strokeStyle = 'rgba(0,0,0,0.03)';
      ctx.lineWidth = 2;
      ctx.stroke();
    }
    spin() {
      if (this.isSpinning || this.names.length === 0) return;
      this.isSpinning = true;
      const count = this.names.length;
      // Determine random winner index to land on:
      const winnerIndex = rand(0, count - 1);
      // Calculate final rotation so that winner segment lines up with pointer at top (pointer at canvas top - rotation must align)
      // Our pointer is at the top (canvas 0 angle). The segment mid-angle for index i (without rotation) is ((i + 0.5)/count)*2pi
      const segmentMid = ((winnerIndex + 0.5) / count) * Math.PI * 2;
      // We want segmentMid + rotation_final == -Math.PI/2 (so it points at the top pointer), so rotation_final = -Math.PI/2 - segmentMid + 2pi*N
      const extraTurns = rand(5, 8); // full spins
      const rotationFinal = -Math.PI/2 - segmentMid + extraTurns * Math.PI * 2;
      const startRotation = this.rotation % (Math.PI * 2);
      const delta = rotationFinal - startRotation;
      const duration = 4000 + Math.random() * 1500; // ms
      const startTime = performance.now();
      const animate = (now) => {
        const elapsed = now - startTime;
        const t = Math.min(elapsed / duration, 1);
        const eased = easeOutCubic(t);
        this.rotation = startRotation + delta * eased;
        this.draw();
        if (t < 1) {
          this.frame = requestAnimationFrame(animate);
        } else {
          this.isSpinning = false;
          // Normalize rotation within 0..2pi
          this.rotation = ((this.rotation % (Math.PI*2)) + Math.PI*2) % (Math.PI*2);
          this.draw();
          // Compute final winner index again from rotation
          // finalAngle: the angle of the segment at pointer (0 at right, +counterclockwise). We compute a normalized angle that maps to segment index.
          const finalAngle = ((-this.rotation - Math.PI/2) % (Math.PI*2) + Math.PI*2) % (Math.PI*2);
          const resultingIndex = Math.floor((finalAngle / (Math.PI*2)) * count) % count;
          const winner = this.names[resultingIndex];
          this.onResult({ index: resultingIndex, name: winner });
        }
      };
      this.frame = requestAnimationFrame(animate);
    }
  }
  // Helper: pick readable text color for a background
  function getTextColor(hex) {
    // remove # and convert
    const h = hex.replace('#','');
    const r = parseInt(h.substring(0,2),16);
    const g = parseInt(h.substring(2,4),16);
    const b = parseInt(h.substring(4,6),16);
    // luminance
    const lum = (0.299*r + 0.587*g + 0.114*b) / 255;
    return lum > 0.65 ? '#111' : '#fff';
  }
  // Helper: wrap text within a given width (draws multi-line if necessary)
  function wrapFillText(ctx, text, x, y, maxWidth, lineHeight) {
    const words = (text || '').split(/\s+/);
    if (words.length === 0) return;
    let line = '';
    const lines = [];
    for (let n = 0; n < words.length; n++) {
      const testLine = line ? line + ' ' + words[n] : words[n];
      const metrics = ctx.measureText(testLine);
      if (metrics.width > maxWidth && line) {
        lines.push(line);
        line = words[n];
      } else {
        line = testLine;
      }
    }
    if (line) lines.push(line);
    // If still too many lines, just draw what's possible (we rely on font size)
    for (let i=0;i<lines.length;i++){
      ctx.fillText(lines[i], x, y + (i - (lines.length-1)/2) * lineHeight);
    }
  }
  // UI glue
  document.addEventListener('DOMContentLoaded', () => {
    const canvas = document.getElementById('wheelCanvas');
    const wheel = new Wheel(canvas, { theme: 'light', onResult: onWinner });
    const nameInput = document.getElementById('nameInput');
    const addBtn = document.getElementById('addBtn');
    const addRandomBtn = document.getElementById('addRandomBtn');
    const bulkInput = document.getElementById('bulkInput');
    const bulkAddBtn = document.getElementById('bulkAddBtn');
    const clearBulkBtn = document.getElementById('clearBulkBtn');
    const nameList = document.getElementById('nameList');
    const countSpan = document.getElementById('count');
    const spinBtn = document.getElementById('spinBtn');
    const rerollBtn = document.getElementById('rerollBtn');
    const clearNamesBtn = document.getElementById('clearNamesBtn');
    const themeSelect = document.getElementById('themeSelect');
    const resultSection = document.getElementById('result');
    const winnerNameDiv = document.getElementById('winnerName');
    const exportBtn = document.getElementById('exportBtn');
    const importBtn = document.getElementById('importBtn');
    const importFile = document.getElementById('importFile');
    // Initial draw
    wheel.draw();
    function updateUI() {
      const names = wheel.names;
      countSpan.textContent = names.length;
      renderNameList();
    }
    function renderNameList() {
      nameList.innerHTML = '';
      wheel.names.forEach((n, i) => {
        const li = document.createElement('li');
        const span = document.createElement('span');
        span.textContent = n;
        li.appendChild(span);
        const btn = document.createElement('button');
        btn.title = 'Remove';
        btn.setAttribute('aria-label', `Remove ${n}`);
        btn.innerHTML = '✕';
        btn.addEventListener('click', () => {
          wheel.removeName(i);
          updateUI();
        });
        li.appendChild(btn);
        nameList.appendChild(li);
      });
    }
    function addNameFromInput() {
      const v = nameInput.value.trim();
      if (!v) { showMessage('Please enter a name.', 'warn'); return; }
      wheel.addName(v);
      nameInput.value = '';
      updateUI();
    }
    addBtn.addEventListener('click', addNameFromInput);
    nameInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') addNameFromInput(); });
    addRandomBtn.addEventListener('click', () => {
      const samples = ['Alex','Jordan','Taylor','Sam','Jamie','Casey','Morgan','Riley','Avery','Dana'];
      const count = rand(3,6);
      for (let i=0;i<count;i++) wheel.addName(samples[rand(0,samples.length-1)] + (rand(1,100)));
      updateUI();
    });
    bulkAddBtn.addEventListener('click', () => {
      const text = bulkInput.value.trim();
      if (!text) { showMessage('Bulk input is empty.', 'warn'); return; }
      const parsed = text.split(/[\n,;]+/).map(s => s.trim()).filter(s => s);
      parsed.forEach(p => wheel.addName(p));
      bulkInput.value = '';
      updateUI();
      showMessage(`Added ${parsed.length} names.`, 'info');
    });
    clearBulkBtn.addEventListener('click', () => { bulkInput.value = ''; });
    spinBtn.addEventListener('click', () => {
      if (wheel.names.length === 0) { showMessage('Add at least one name to spin.', 'warn'); return; }
      resultSection.hidden = true;
      winnerNameDiv.textContent = '';
      wheel.spin();
      spinBtn.disabled = true;
      const checkFinish = setInterval(() => {
        if (!wheel.isSpinning) {
          clearInterval(checkFinish);
          spinBtn.disabled = false;
        }
      }, 200);
    });
    rerollBtn.addEventListener('click', () => {
      resultSection.hidden = true;
      wheel.spin();
    });
    clearNamesBtn.addEventListener('click', () => {
      if (confirm('Clear all names?')) {
        wheel.clearNames();
        updateUI();
      }
    });
    themeSelect.addEventListener('change', (e) => {
      const t = e.target.value;
      document.body.className = 'theme-' + t;
      wheel.setTheme(t);
    });
    function onWinner(result) {
      winnerNameDiv.textContent = result.name || '—';
      resultSection.hidden = false;
      // Flash the winner item in the list (if still present)
      const items = Array.from(nameList.children);
      items.forEach((li, idx) => { li.classList.toggle('winner', idx === result.index); });
      showMessage(`Winner: ${result.name}`, 'success', 4000);
    }
    // Simple message area
    function showMessage(text, type = 'info', duration = 2200) {
      // create small toast
      const t = document.createElement('div');
      t.className = 'tmp-toast ' + type;
      t.textContent = text;
      document.body.appendChild(t);
      // Force reflow to pick up transitions
      window.getComputedStyle(t).opacity;
      setTimeout(()=> { t.style.opacity = '0'; t.style.transform = 'translateY(-10px)'; }, duration - 300);
      setTimeout(()=> { try { t.remove(); } catch(e){} }, duration);
    }
    // Export/import CSV
    exportBtn.addEventListener('click', () => {
      if (wheel.names.length === 0) { showMessage('No names to export.', 'warn'); return; }
      const csv = wheel.names.map(n => `"${(n||'').replace(/"/g,'""')}"`).join('\n');
      const blob = new Blob([csv], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'participants.csv';
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
      showMessage('Exported CSV', 'info');
    });
    importBtn.addEventListener('click', () => { importFile.click(); });
    importFile.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (ev) => {
        const txt = ev.target.result;
        const lines = txt.split(/\r?\n/).map(s => s.trim()).filter(s => s);
        // basic CSV unquote
        const parsed = lines.map(l => {
          // simple CSV single-column parse: handle quoted fields
          if (l.startsWith('"') && l.endsWith('"')) {
            return l.slice(1,-1).replace(/""/g,'"');
          }
          return l;
        });
        parsed.forEach(p => wheel.addName(p));
        updateUI();
        showMessage(`Imported ${parsed.length} names`, 'info');
      };
      reader.readAsText(file);
      importFile.value = '';
    });
    // Initial sample (optional)
    // wheel.addName('Alice'); wheel.addName('Bob'); wheel.addName('Charlie');
    updateUI();
    // (Optional) keyboard shortcuts
    window.addEventListener('keydown', (e) => {
      if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'k') {
        e.preventDefault();
        nameInput.focus();
      }
      if (e.key === ' ') {
        // space triggers spin if not focusing an input
        if (document.activeElement.tagName !== 'INPUT' && document.activeElement.tagName !== 'TEXTAREA') {
          e.preventDefault();
          spinBtn.click();
        }
      }
    });
  });
})(); 
```

"
As the Code Reviewer, to make the software directly operable without further coding, ChatDev have formulated the following regulations:
1) all referenced classes should be imported;
2) all methods should be implemented;
3) all methods need to have the necessary comments;
4) no potential bugs;
5) The entire project conforms to the tasks proposed by the user;
6) most importantly, do not only check the errors in the code, but also the logic of code. Make sure that user can interact with generated software without losing any feature in the requirement;
Now, you should check the above regulations one by one and review the codes in detail, propose one comment with the highest priority about the codes, and give me instructions on how to fix. Tell me your comment with the highest priority and corresponding suggestions on revision. If the codes are perfect and you have no comment on them, return only one line like "<INFO> Finished".

[2025-17-09 13:45:25 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2025-17-09 13:45:25 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 7237
completion_tokens: 1653
total_tokens: 8890
cost: $-1.000000


[2025-17-09 13:45:25 INFO] Code Reviewer: **Code Reviewer<->Programmer on : CodeReviewComment, turn 0**

[ChatDev is a software company powered by multiple intelligent agents, such as chief executive officer, chief human resources officer, chief product officer, chief technology officer, etc, with a multi-agent organizational structure and the mission of 'changing the digital world through programming'.
You are Programmer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer.
You can write/create computer software or applications by providing a specific programming language to the computer. You have extensive computing and coding experience in many varieties of programming languages and platforms, such as Python, Java, C, C++, HTML, CSS, JavaScript, XML, SQL, PHP, etc,.
Here is a new customer's task: [Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes. Do it in HTML, CSS, and JavaScript.].
To complete the task, you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]

<CRITICAL> The files contain literal Python-style triple-quoted DOCSTRING blocks (''' ... ''') at the top of index.html, styles.css and script.js. Those triple-single-quote lines are not valid HTML/CSS/JS and will break parsing — the site will fail to load or script/style will not be applied. Fix immediately by replacing them with proper comments or removing them.

Why this is highest priority:
- Browsers will try to interpret those lines as part of the document and will throw syntax errors (CSS/JS), so nothing else will work even if all logic is correct.

How to fix (step-by-step):
1. index.html
   - Remove the block that starts with '''DOCSTRING and ends with ''' (or convert it to an HTML comment).
   - Replace with an HTML comment if you want to keep the documentation. Example:
     <!--
       This is the main HTML file for the Random Winner Wheel.
       It contains the structure: input fields to add names, a canvas for the wheel,
       controls (spin, clear, bulk add), theme selector, and placeholders for CSS/JS.
     -->
   - Ensure the file begins with <!doctype html> (no stray quotes/characters before it).

2. styles.css
   - Remove the leading triple-quoted string and convert it to a CSS comment:
     /*
       Stylesheet for the Random Winner Wheel.
       Defines layout, themes, wheel container sizing, animations, and toast styles.
     */
   - Make sure no remaining ''' lines exist anywhere in the CSS.

3. script.js
   - Remove all '''DOCSTRING''' lines and any duplicated triple quotes. Replace them with JS block comments:
     /*
       Script for the Random Winner Wheel.
       Contains the Wheel class to draw and spin the canvas-based wheel and UI glue code to manage names and themes.
     */
   - There are two occurrences of identical docstrings at the top of the JS — keep just one proper comment block, remove duplicates.
   - Verify there are no stray single or triple quote lines that would create unterminated strings.

4. After replacing/removing:
   - Open the browser DevTools console and check for errors (SyntaxError, CSS parse errors).
   - Verify:
     - CSS is applied (themes change UI colors).
     - JS loads and console does not show parse errors.
     - UI buttons (Add, Bulk Add, Spin, Import/Export) function as expected.

Optional additional sanity checks (recommended):
- Search the whole project for any remaining ''' occurrences and remove them.
- Run the page locally (open index.html) and test:
  - Add names, bulk add, sample add.
  - Switch themes and confirm wheel color palette updates.
  - Spin and confirm winner appears and list highlights.
  - Export/import CSV works as expected.
- If you keep descriptive headers, prefer consistent comment style per file type (HTML <!-- -->, CSS /* */ and JS /* */ or //).

Implementing these replacements will resolve the critical syntax errors preventing the site from running.

[2025-17-09 13:45:25 INFO] **[Seminar Conclusion]**:

 <CRITICAL> The files contain literal Python-style triple-quoted DOCSTRING blocks (''' ... ''') at the top of index.html, styles.css and script.js. Those triple-single-quote lines are not valid HTML/CSS/JS and will break parsing — the site will fail to load or script/style will not be applied. Fix immediately by replacing them with proper comments or removing them.

Why this is highest priority:
- Browsers will try to interpret those lines as part of the document and will throw syntax errors (CSS/JS), so nothing else will work even if all logic is correct.

How to fix (step-by-step):
1. index.html
   - Remove the block that starts with '''DOCSTRING and ends with ''' (or convert it to an HTML comment).
   - Replace with an HTML comment if you want to keep the documentation. Example:
     <!--
       This is the main HTML file for the Random Winner Wheel.
       It contains the structure: input fields to add names, a canvas for the wheel,
       controls (spin, clear, bulk add), theme selector, and placeholders for CSS/JS.
     -->
   - Ensure the file begins with <!doctype html> (no stray quotes/characters before it).

2. styles.css
   - Remove the leading triple-quoted string and convert it to a CSS comment:
     /*
       Stylesheet for the Random Winner Wheel.
       Defines layout, themes, wheel container sizing, animations, and toast styles.
     */
   - Make sure no remaining ''' lines exist anywhere in the CSS.

3. script.js
   - Remove all '''DOCSTRING''' lines and any duplicated triple quotes. Replace them with JS block comments:
     /*
       Script for the Random Winner Wheel.
       Contains the Wheel class to draw and spin the canvas-based wheel and UI glue code to manage names and themes.
     */
   - There are two occurrences of identical docstrings at the top of the JS — keep just one proper comment block, remove duplicates.
   - Verify there are no stray single or triple quote lines that would create unterminated strings.

4. After replacing/removing:
   - Open the browser DevTools console and check for errors (SyntaxError, CSS parse errors).
   - Verify:
     - CSS is applied (themes change UI colors).
     - JS loads and console does not show parse errors.
     - UI buttons (Add, Bulk Add, Spin, Import/Export) function as expected.

Optional additional sanity checks (recommended):
- Search the whole project for any remaining ''' occurrences and remove them.
- Run the page locally (open index.html) and test:
  - Add names, bulk add, sample add.
  - Switch themes and confirm wheel color palette updates.
  - Spin and confirm winner appears and list highlights.
  - Export/import CSV works as expected.
- If you keep descriptive headers, prefer consistent comment style per file type (HTML <!-- -->, CSS /* */ and JS /* */ or //).

Implementing these replacements will resolve the critical syntax errors preventing the site from running.

[2025-17-09 13:45:25 INFO] **[Execute Detail]**

execute SimplePhase:[CodeReviewModification] in ComposedPhase:[CodeReview], cycle 3

[2025-17-09 13:45:25 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | [Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes. Do it in HTML, CSS, and JavaScript.] |
| **need_reflect** | False |
| **assistant_role_name** | Programmer |
| **user_role_name** | Code Reviewer |
| **phase_prompt** | According to the new user's task, our designed product modality, languages and ideas, our developed first-edition source codes are listed below:  Task: "{task}". Modality: "{modality}". Programming Language: "{language}" Ideas: "{ideas}" Codes:  "{codes}" Comments on Codes: "{comments}" In the software, each file must strictly follow a markdown code block format, where the following tokens must be replaced such that "FILENAME" is the lowercase file name including the file extension, "LANGUAGE" in the programming language, "DOCSTRING" is a string literal specified in source code that is used to document a specific segment of code, and "CODE" is the original code. Format: FILENAME LANGUAGE ''' DOCSTRING ''' CODE As the {assistant_role}, to satisfy the new user's demand and make the software creative, executive and robust, you should modify corresponding codes according to the comments. Then, output the full and complete codes with all bugs fixed based on the comments. Return all codes strictly following the required format. |
| **phase_name** | CodeReviewModification |
| **assistant_role_prompt** | {chatdev_prompt} You are Programmer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. You can write/create computer software or applications by providing a specific programming language to the computer. You have extensive computing and coding experience in many varieties of programming languages and platforms, such as Python, Java, C, C++, HTML, CSS, JavaScript, XML, SQL, PHP, etc,. Here is a new customer's task: {task}. To complete the task, you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Code Reviewer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. You can help programmers to assess source codes for software troubleshooting, fix bugs to increase code quality and robustness, and offer proposals to improve the source codes. Here is a new customer's task: {task}. To complete the task, you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': 'index.html\nhtml\n\'\'\'\nDOCSTRING\nThis is the main HTML file for the Random Winner Wheel.\nIt contains the structure: input fields to add names, a canvas for the wheel,\ncontrols (spin, clear, bulk add), theme selector, and placeholders for CSS/JS.\n\'\'\'\n&lt;!doctype html&gt;\n&lt;html lang="en"&gt;\n&lt;head&gt;\n  &lt;meta charset="utf-8" /&gt;\n  &lt;meta name="viewport" content="width=device-width,initial-scale=1" /&gt;\n  &lt;title&gt;Random Winner Wheel&lt;/title&gt;\n  &lt;link rel="stylesheet" href="styles.css"&gt;\n&lt;/head&gt;\n&lt;body class="theme-light"&gt;\n  &lt;header&gt;\n    &lt;h1&gt;Random Winner Wheel&lt;/h1&gt;\n    &lt;p&gt;Enter participant names, choose a theme, and spin to pick a winner.&lt;/p&gt;\n  &lt;/header&gt;\n  &lt;main&gt;\n    &lt;section class="controls"&gt;\n      &lt;div class="add-single"&gt;\n        &lt;input id="nameInput" type="text" placeholder="Enter a name and press Add" aria-label="Name input" /&gt;\n        &lt;button id="addBtn"&gt;Add&lt;/button&gt;\n        &lt;button id="addRandomBtn" title="Add a few sample random names"&gt;Add Sample&lt;/button&gt;\n      &lt;/div&gt;\n      &lt;div class="bulk-add"&gt;\n        &lt;label for="bulkInput"&gt;Bulk add (comma, newline or semicolon separated):&lt;/label&gt;\n        &lt;textarea id="bulkInput" placeholder="Alice, Bob, Charlie"&gt;&lt;/textarea&gt;\n        &lt;div class="bulk-actions"&gt;\n          &lt;button id="bulkAddBtn"&gt;Bulk Add&lt;/button&gt;\n          &lt;button id="clearBulkBtn"&gt;Clear Bulk&lt;/button&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;\n      &lt;div class="list-actions"&gt;\n        &lt;div class="theme-select"&gt;\n          &lt;label for="themeSelect"&gt;Theme:&lt;/label&gt;\n          &lt;select id="themeSelect"&gt;\n            &lt;option value="light"&gt;Light&lt;/option&gt;\n            &lt;option value="dark"&gt;Dark&lt;/option&gt;\n            &lt;option value="neon"&gt;Neon&lt;/option&gt;\n            &lt;option value="pastel"&gt;Pastel&lt;/option&gt;\n            &lt;option value="retro"&gt;Retro&lt;/option&gt;\n          &lt;/select&gt;\n        &lt;/div&gt;\n        &lt;div class="wheel-controls"&gt;\n          &lt;button id="spinBtn" class="primary"&gt;Spin&lt;/button&gt;\n          &lt;button id="clearNamesBtn"&gt;Clear Names&lt;/button&gt;\n          &lt;button id="exportBtn"&gt;Export CSV&lt;/button&gt;\n          &lt;input id="importFile" type="file" accept=".csv,text/csv" style="display:none"&gt;\n          &lt;button id="importBtn"&gt;Import CSV&lt;/button&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;\n    &lt;/section&gt;\n    &lt;section class="wheel-area"&gt;\n      &lt;div class="wheel-container"&gt;\n        &lt;canvas id="wheelCanvas" width="600" height="600" aria-label="Spinning wheel"&gt;&lt;/canvas&gt;\n        &lt;div class="pointer" aria-hidden="true"&gt;▼&lt;/div&gt;\n      &lt;/div&gt;\n      &lt;aside class="participants"&gt;\n        &lt;h2&gt;Participants (&lt;span id="count"&gt;0&lt;/span&gt;)&lt;/h2&gt;\n        &lt;ul id="nameList" aria-live="polite"&gt;&lt;/ul&gt;\n      &lt;/aside&gt;\n    &lt;/section&gt;\n    &lt;section class="result" id="result" aria-live="polite" hidden&gt;\n      &lt;h2&gt;Winner&lt;/h2&gt;\n      &lt;div id="winnerName" class="winnerName"&gt;&lt;/div&gt;\n      &lt;button id="rerollBtn"&gt;Spin Again&lt;/button&gt;\n    &lt;/section&gt;\n  &lt;/main&gt;\n  &lt;footer&gt;\n    &lt;small&gt;Built with HTML, CSS, and JavaScript. Themes change both UI and wheel colors.&lt;/small&gt;\n  &lt;/footer&gt;\n  &lt;script src="script.js"&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\n\nstyles.css\ncss\n\'\'\'\nDOCSTRING\nStylesheet for the Random Winner Wheel.\nDefines layout, themes, wheel container sizing, animations, and toast styles.\n\'\'\'\n/* Reset &amp; base */\n* { box-sizing: border-box; margin: 0; padding: 0; }\nhtml,body { height: 100%; font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; background: var(--bg); color: var(--fg); }\n:root {\n  --bg: #f7f8fb;\n  --fg: #222;\n  --muted: #666;\n  --accent: #2b8cff;\n  --card: #ffffff;\n  --primary-btn-bg: var(--accent);\n  --primary-btn-fg: #fff;\n  --shadow: rgba(15,15,15,0.08);\n}\n/* Themes */\nbody.theme-light {\n  --bg: #f7f8fb;\n  --fg: #222;\n  --muted: #5b6170;\n  --accent: #2b8cff;\n  --card: #fff;\n  --wheel-seq: 0;\n}\nbody.theme-dark {\n  --bg: #0f1724;\n  --fg: #e6eef8;\n  --muted: #a9b1c2;\n  --accent: #7c5cff;\n  --card: #0b1220;\n}\nbody.theme-neon {\n  --bg: #0a0a0f;\n  --fg: #e9f9ff;\n  --muted: #a6f3ff;\n  --accent: #39ff14;\n  --card: #09101a;\n}\nbody.theme-pastel {\n  --bg: #fffaf6;\n  --fg: #3c3a3a;\n  --muted: #8d8a8a;\n  --accent: #ff7aa2;\n  --card: #fff;\n}\nbody.theme-retro {\n  --bg: #fff6e7;\n  --fg: #402b2b;\n  --muted: #856e6e;\n  --accent: #ffb86b;\n  --card: #fff0e6;\n}\n/* Layout */\nheader { padding: 18px 24px; text-align: center; background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent); }\nheader h1 { font-size: 1.5rem; margin-bottom: 6px; }\nmain { padding: 18px; max-width: 1100px; margin: 0 auto; }\n.controls { display: grid; gap: 12px; margin-bottom: 18px; }\n.add-single { display:flex; gap:8px; }\n.add-single input[type="text"] { flex:1; padding:10px; border-radius:8px; border:1px solid rgba(0,0,0,0.08); background:var(--card); color:var(--fg); }\n.add-single button { padding:10px 12px; border-radius:8px; border: none; cursor:pointer; background: var(--primary-btn-bg); color: var(--primary-btn-fg); }\n.add-single button#addRandomBtn { background: transparent; border: 1px solid rgba(0,0,0,0.06); color: var(--fg); }\n.bulk-add textarea { width:100%; min-height:64px; margin-top:6px; padding:8px; border-radius:8px; border:1px solid rgba(0,0,0,0.06); background:var(--card); color:var(--fg); }\n.bulk-actions { display:flex; gap:8px; margin-top:8px; }\n.list-actions { display:flex; justify-content:space-between; align-items:center; gap:16px; flex-wrap:wrap; }\n.theme-select select { padding:8px; border-radius:8px; border:1px solid rgba(0,0,0,0.06); }\n.wheel-area { display:flex; gap:18px; align-items:start; flex-wrap:wrap; }\n.wheel-container { position: relative; width: 600px; height: 600px; max-width: 90vw; max-height: 90vw; display:flex; align-items:center; justify-content:center; background: transparent; }\n.pointer {\n  /* Centered triangular pointer positioned above the wheel.\n     This ensures the visual pointer aligns with the wheel math (top-center).\n     Hides the fallback glyph in the HTML and draws a sharp triangle instead. */\n  position: absolute;\n  top: 8px;               /* vertical offset from top of wheel container */\n  left: 50%;              /* center horizontally */\n  transform: translateX(-50%); /* center on the X axis */\n  width: 0;\n  height: 0;\n  border-left: 12px solid transparent;\n  border-right: 12px solid transparent;\n  border-bottom: 18px solid var(--accent);\n  z-index: 10;            /* ensure it\'s above the canvas */\n  pointer-events: none;\n  /* hide textual glyph fallback content (the ▼ in HTML) */\n  font-size: 0;\n  line-height: 0;\n  text-indent: -9999px;\n}\n/* Participants panel and wheel styles */\n.participants { width: 320px; max-width: 40vw; background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent); padding:12px; border-radius:10px; box-shadow: 0 6px 18px var(--shadow); }\n.participants h2 { margin-bottom:8px; font-size:1.05rem; }\n#nameList { list-style:none; max-height:420px; overflow:auto; display:block; }\n#nameList li { padding:8px; border-radius:6px; display:flex; justify-content:space-between; align-items:center; gap:8px; margin-bottom:8px; background: var(--card); border:1px solid rgba(0,0,0,0.04); }\n#nameList li button { background: transparent; border: none; color: var(--muted); cursor:pointer; }\n.result { margin-top:18px; padding:12px; border-radius:8px; background: var(--card); text-align:center; box-shadow: 0 6px 18px var(--shadow); }\n.result .winnerName { font-size:1.4rem; font-weight:700; margin:8px 0; color: var(--accent); }\n/* Buttons */\nbutton { cursor:pointer; padding:8px 12px; border-radius:8px; border:1px solid rgba(0,0,0,0.06); background: transparent; color:var(--fg); }\nbutton.primary { background: var(--primary-btn-bg); color: var(--primary-btn-fg); border: none; }\n/* Responsive */\n@media (max-width: 900px) {\n  .wheel-area { flex-direction:column; align-items:center; }\n  .participants { width: 100%; max-width: 100%; }\n}\n/* Wheel canvas scaling helper */\n#wheelCanvas { border-radius:50%; box-shadow: 0 12px 26px rgba(0,0,0,0.12); background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.02), transparent); }\n/* Toast / temporary message styles (used by showMessage) */\n.tmp-toast {\n  position: fixed;\n  left: 50%;\n  transform: translateX(-50%);\n  top: 18px;\n  background: rgba(0,0,0,0.85);\n  color: #fff;\n  padding: 8px 12px;\n  border-radius: 6px;\n  z-index: 9999;\n  transition: opacity 0.25s, transform 0.25s;\n  opacity: 1;\n  pointer-events: none;\n  font-size: 0.95rem;\n  box-shadow: 0 6px 18px rgba(0,0,0,0.18);\n}\n.tmp-toast.success { background: rgba(56, 198, 123, 0.95); }\n.tmp-toast.warn    { background: rgba(255, 159, 67, 0.95); color: #2b1500; }\n.tmp-toast.info    { background: rgba(12, 74, 255, 0.95); }\n/* Winner highlight for participants list */\n#nameList li.winner {\n  outline: 3px solid rgba(255,215,0,0.15);\n  box-shadow: 0 6px 18px rgba(255,215,0,0.06);\n  transform: scale(1.01);\n}\n\n\nscript.js\njavascript\n\'\'\'\nDOCSTRING\nScript for the Random Winner Wheel.\nContains the Wheel class to draw and spin the canvas-based wheel and UI glue code to manage names and themes.\n\'\'\'\n/* \nDOCSTRING\nScript for the Random Winner Wheel.\nContains the Wheel class to draw and spin the canvas-based wheel and UI glue code to manage names and themes.\n*/\n/* Main JavaScript - Wheel + UI logic */\n(() =&gt; {\n  // Utilities\n  function rand(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }\n  function easeOutCubic(t) { return 1 - Math.pow(1 - t, 3); }\n  // Color palettes for themes (will be used to paint wheel segments)\n  const THEME_PALETTES = {\n    light: [\'#FF8A80\',\'#FFD180\',\'#FFF59D\',\'#C8E6C9\',\'#80DEEA\',\'#A7FFEB\',\'#B39DDB\',\'#90CAF9\'],\n    dark: [\'#ff6b6b\',\'#ffd166\',\'#faff8e\',\'#b9f6ca\',\'#4dd0e1\',\'#80cbc4\',\'#b388ff\',\'#64b5f6\'],\n    neon: [\'#ff2d95\',\'#7cff01\',\'#00ffff\',\'#ffdd00\',\'#ff6a00\',\'#00ff9e\',\'#ff00ff\',\'#47ffa2\'],\n    pastel: [\'#ffdbe9\',\'#fff0b3\',\'#d1ffd6\',\'#cfefff\',\'#e7dfff\',\'#ffd6e7\',\'#fbe7d6\',\'#e6f7ff\'],\n    retro: [\'#ffb86b\',\'#ffd3a8\',\'#f3e2a9\',\'#b8e0d2\',\'#c0b9ff\',\'#ffb6c1\',\'#f6c49f\',\'#c3d69b\']\n  };\n  // Wheel class\n  class Wheel {\n    /*\n    Manage wheel: drawing, recalculating segments, spinning animation, and determining winner.\n    */\n    constructor(canvas, options = {}) {\n      this.canvas = canvas;\n      this.ctx = canvas.getContext(\'2d\');\n      this.names = [];\n      this.rotation = 0; // radians\n      this.isSpinning = false;\n      this.frame = null;\n      this.onResult = options.onResult || function() {};\n      this.theme = options.theme || \'light\';\n      this.padAngle = 0.02; // radians padding between segments\n      this.textColor = \'#111\';\n      this._devicePixelRatioFix();\n      window.addEventListener(\'resize\', () =&gt; { this._devicePixelRatioFix(); this.draw(); });\n    }\n    _devicePixelRatioFix() {\n      const dpr = window.devicePixelRatio || 1;\n      const rect = this.canvas.getBoundingClientRect();\n      // If rect has zero size (canvas not yet laid out), use current width/height attributes as fallback\n      const width = rect.width || (this.canvas.width / dpr);\n      const height = rect.height || (this.canvas.height / dpr);\n      this.canvas.width = width * dpr;\n      this.canvas.height = height * dpr;\n      this.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n      this.centerX = width / 2;\n      this.centerY = height / 2;\n      this.radius = Math.min(width, height) / 2 - 18;\n    }\n    setTheme(themeId) { this.theme = themeId; this.draw(); }\n    setNames(names) {\n      this.names = names.slice();\n      this.draw();\n    }\n    addName(name) {\n      this.names.push(name);\n      this.draw();\n    }\n    removeName(index) {\n      if (index &gt;= 0 &amp;&amp; index &lt; this.names.length) {\n        this.names.splice(index,1);\n        this.draw();\n      }\n    }\n    clearNames() {\n      this.names = [];\n      this.draw();\n    }\n    draw() {\n      const ctx = this.ctx;\n      const w = this.canvas.width / (window.devicePixelRatio || 1);\n      const h = this.canvas.height / (window.devicePixelRatio || 1);\n      ctx.clearRect(0,0,w,h);\n      ctx.save();\n      ctx.translate(this.centerX, this.centerY);\n      ctx.rotate(this.rotation);\n      // draw segments\n      const count = Math.max(this.names.length, 1);\n      const palette = THEME_PALETTES[this.theme] || THEME_PALETTES.light;\n      for (let i = 0; i &lt; count; i++) {\n        const start = (i / count) * Math.PI * 2;\n        const end = ((i + 1) / count) * Math.PI * 2;\n        ctx.beginPath();\n        ctx.moveTo(0,0);\n        ctx.arc(0,0,this.radius, start + this.padAngle, end - this.padAngle, false);\n        ctx.closePath();\n        const color = palette[i % palette.length];\n        ctx.fillStyle = color;\n        ctx.fill();\n        ctx.strokeStyle = (i % 2 === 0) ? \'rgba(0,0,0,0.06)\' : \'rgba(0,0,0,0.03)\';\n        ctx.lineWidth = 1;\n        ctx.stroke();\n        // draw text label\n        const mid = (start + end) / 2;\n        ctx.save();\n        ctx.rotate(mid);\n        ctx.translate(this.radius * 0.6, 0);\n        ctx.rotate(Math.PI/2);\n        ctx.fillStyle = getTextColor(color);\n        ctx.font = `${Math.max(12, Math.min(22, this.radius / 8))}px sans-serif`;\n        ctx.textAlign = \'center\';\n        ctx.textBaseline = \'middle\';\n        const label = (this.names.length === 0) ? \'Add names\' : this.names[i % this.names.length];\n        wrapFillText(ctx, label, 0, 0, this.radius * 0.5, 16);\n        ctx.restore();\n      }\n      // draw center circle\n      ctx.beginPath();\n      ctx.arc(0,0, this.radius * 0.16, 0, Math.PI*2);\n      ctx.fillStyle = \'rgba(255,255,255,0.9)\';\n      ctx.fill();\n      ctx.strokeStyle = \'rgba(0,0,0,0.06)\';\n      ctx.stroke();\n      ctx.restore();\n      // draw outer ring (pointer side neutral)\n      ctx.beginPath();\n      ctx.arc(this.centerX, this.centerY, this.radius + 10, 0, Math.PI*2);\n      ctx.strokeStyle = \'rgba(0,0,0,0.03)\';\n      ctx.lineWidth = 2;\n      ctx.stroke();\n    }\n    spin() {\n      if (this.isSpinning || this.names.length === 0) return;\n      this.isSpinning = true;\n      const count = this.names.length;\n      // Determine random winner index to land on:\n      const winnerIndex = rand(0, count - 1);\n      // Calculate final rotation so that winner segment lines up with pointer at top (pointer at canvas top - rotation must align)\n      // Our pointer is at the top (canvas 0 angle). The segment mid-angle for index i (without rotation) is ((i + 0.5)/count)*2pi\n      const segmentMid = ((winnerIndex + 0.5) / count) * Math.PI * 2;\n      // We want segmentMid + rotation_final == -Math.PI/2 (so it points at the top pointer), so rotation_final = -Math.PI/2 - segmentMid + 2pi*N\n      const extraTurns = rand(5, 8); // full spins\n      const rotationFinal = -Math.PI/2 - segmentMid + extraTurns * Math.PI * 2;\n      const startRotation = this.rotation % (Math.PI * 2);\n      const delta = rotationFinal - startRotation;\n      const duration = 4000 + Math.random() * 1500; // ms\n      const startTime = performance.now();\n      const animate = (now) =&gt; {\n        const elapsed = now - startTime;\n        const t = Math.min(elapsed / duration, 1);\n        const eased = easeOutCubic(t);\n        this.rotation = startRotation + delta * eased;\n        this.draw();\n        if (t &lt; 1) {\n          this.frame = requestAnimationFrame(animate);\n        } else {\n          this.isSpinning = false;\n          // Normalize rotation within 0..2pi\n          this.rotation = ((this.rotation % (Math.PI*2)) + Math.PI*2) % (Math.PI*2);\n          this.draw();\n          // Compute final winner index again from rotation\n          // finalAngle: the angle of the segment at pointer (0 at right, +counterclockwise). We compute a normalized angle that maps to segment index.\n          const finalAngle = ((-this.rotation - Math.PI/2) % (Math.PI*2) + Math.PI*2) % (Math.PI*2);\n          const resultingIndex = Math.floor((finalAngle / (Math.PI*2)) * count) % count;\n          const winner = this.names[resultingIndex];\n          this.onResult({ index: resultingIndex, name: winner });\n        }\n      };\n      this.frame = requestAnimationFrame(animate);\n    }\n  }\n  // Helper: pick readable text color for a background\n  function getTextColor(hex) {\n    // remove # and convert\n    const h = hex.replace(\'#\',\'\');\n    const r = parseInt(h.substring(0,2),16);\n    const g = parseInt(h.substring(2,4),16);\n    const b = parseInt(h.substring(4,6),16);\n    // luminance\n    const lum = (0.299*r + 0.587*g + 0.114*b) / 255;\n    return lum &gt; 0.65 ? \'#111\' : \'#fff\';\n  }\n  // Helper: wrap text within a given width (draws multi-line if necessary)\n  function wrapFillText(ctx, text, x, y, maxWidth, lineHeight) {\n    const words = (text || \'\').split(/\\s+/);\n    if (words.length === 0) return;\n    let line = \'\';\n    const lines = [];\n    for (let n = 0; n &lt; words.length; n++) {\n      const testLine = line ? line + \' \' + words[n] : words[n];\n      const metrics = ctx.measureText(testLine);\n      if (metrics.width &gt; maxWidth &amp;&amp; line) {\n        lines.push(line);\n        line = words[n];\n      } else {\n        line = testLine;\n      }\n    }\n    if (line) lines.push(line);\n    // If still too many lines, just draw what\'s possible (we rely on font size)\n    for (let i=0;i&lt;lines.length;i++){\n      ctx.fillText(lines[i], x, y + (i - (lines.length-1)/2) * lineHeight);\n    }\n  }\n  // UI glue\n  document.addEventListener(\'DOMContentLoaded\', () =&gt; {\n    const canvas = document.getElementById(\'wheelCanvas\');\n    const wheel = new Wheel(canvas, { theme: \'light\', onResult: onWinner });\n    const nameInput = document.getElementById(\'nameInput\');\n    const addBtn = document.getElementById(\'addBtn\');\n    const addRandomBtn = document.getElementById(\'addRandomBtn\');\n    const bulkInput = document.getElementById(\'bulkInput\');\n    const bulkAddBtn = document.getElementById(\'bulkAddBtn\');\n    const clearBulkBtn = document.getElementById(\'clearBulkBtn\');\n    const nameList = document.getElementById(\'nameList\');\n    const countSpan = document.getElementById(\'count\');\n    const spinBtn = document.getElementById(\'spinBtn\');\n    const rerollBtn = document.getElementById(\'rerollBtn\');\n    const clearNamesBtn = document.getElementById(\'clearNamesBtn\');\n    const themeSelect = document.getElementById(\'themeSelect\');\n    const resultSection = document.getElementById(\'result\');\n    const winnerNameDiv = document.getElementById(\'winnerName\');\n    const exportBtn = document.getElementById(\'exportBtn\');\n    const importBtn = document.getElementById(\'importBtn\');\n    const importFile = document.getElementById(\'importFile\');\n    // Initial draw\n    wheel.draw();\n    function updateUI() {\n      const names = wheel.names;\n      countSpan.textContent = names.length;\n      renderNameList();\n    }\n    function renderNameList() {\n      nameList.innerHTML = \'\';\n      wheel.names.forEach((n, i) =&gt; {\n        const li = document.createElement(\'li\');\n        const span = document.createElement(\'span\');\n        span.textContent = n;\n        li.appendChild(span);\n        const btn = document.createElement(\'button\');\n        btn.title = \'Remove\';\n        btn.setAttribute(\'aria-label\', `Remove ${n}`);\n        btn.innerHTML = \'✕\';\n        btn.addEventListener(\'click\', () =&gt; {\n          wheel.removeName(i);\n          updateUI();\n        });\n        li.appendChild(btn);\n        nameList.appendChild(li);\n      });\n    }\n    function addNameFromInput() {\n      const v = nameInput.value.trim();\n      if (!v) { showMessage(\'Please enter a name.\', \'warn\'); return; }\n      wheel.addName(v);\n      nameInput.value = \'\';\n      updateUI();\n    }\n    addBtn.addEventListener(\'click\', addNameFromInput);\n    nameInput.addEventListener(\'keydown\', (e) =&gt; { if (e.key === \'Enter\') addNameFromInput(); });\n    addRandomBtn.addEventListener(\'click\', () =&gt; {\n      const samples = [\'Alex\',\'Jordan\',\'Taylor\',\'Sam\',\'Jamie\',\'Casey\',\'Morgan\',\'Riley\',\'Avery\',\'Dana\'];\n      const count = rand(3,6);\n      for (let i=0;i&lt;count;i++) wheel.addName(samples[rand(0,samples.length-1)] + (rand(1,100)));\n      updateUI();\n    });\n    bulkAddBtn.addEventListener(\'click\', () =&gt; {\n      const text = bulkInput.value.trim();\n      if (!text) { showMessage(\'Bulk input is empty.\', \'warn\'); return; }\n      const parsed = text.split(/[\\n,;]+/).map(s =&gt; s.trim()).filter(s =&gt; s);\n      parsed.forEach(p =&gt; wheel.addName(p));\n      bulkInput.value = \'\';\n      updateUI();\n      showMessage(`Added ${parsed.length} names.`, \'info\');\n    });\n    clearBulkBtn.addEventListener(\'click\', () =&gt; { bulkInput.value = \'\'; });\n    spinBtn.addEventListener(\'click\', () =&gt; {\n      if (wheel.names.length === 0) { showMessage(\'Add at least one name to spin.\', \'warn\'); return; }\n      resultSection.hidden = true;\n      winnerNameDiv.textContent = \'\';\n      wheel.spin();\n      spinBtn.disabled = true;\n      const checkFinish = setInterval(() =&gt; {\n        if (!wheel.isSpinning) {\n          clearInterval(checkFinish);\n          spinBtn.disabled = false;\n        }\n      }, 200);\n    });\n    rerollBtn.addEventListener(\'click\', () =&gt; {\n      resultSection.hidden = true;\n      wheel.spin();\n    });\n    clearNamesBtn.addEventListener(\'click\', () =&gt; {\n      if (confirm(\'Clear all names?\')) {\n        wheel.clearNames();\n        updateUI();\n      }\n    });\n    themeSelect.addEventListener(\'change\', (e) =&gt; {\n      const t = e.target.value;\n      document.body.className = \'theme-\' + t;\n      wheel.setTheme(t);\n    });\n    function onWinner(result) {\n      winnerNameDiv.textContent = result.name || \'—\';\n      resultSection.hidden = false;\n      // Flash the winner item in the list (if still present)\n      const items = Array.from(nameList.children);\n      items.forEach((li, idx) =&gt; { li.classList.toggle(\'winner\', idx === result.index); });\n      showMessage(`Winner: ${result.name}`, \'success\', 4000);\n    }\n    // Simple message area\n    function showMessage(text, type = \'info\', duration = 2200) {\n      // create small toast\n      const t = document.createElement(\'div\');\n      t.className = \'tmp-toast \' + type;\n      t.textContent = text;\n      document.body.appendChild(t);\n      // Force reflow to pick up transitions\n      window.getComputedStyle(t).opacity;\n      setTimeout(()=&gt; { t.style.opacity = \'0\'; t.style.transform = \'translateY(-10px)\'; }, duration - 300);\n      setTimeout(()=&gt; { try { t.remove(); } catch(e){} }, duration);\n    }\n    // Export/import CSV\n    exportBtn.addEventListener(\'click\', () =&gt; {\n      if (wheel.names.length === 0) { showMessage(\'No names to export.\', \'warn\'); return; }\n      const csv = wheel.names.map(n =&gt; `"${(n||\'\').replace(/"/g,\'""\')}"`).join(\'\\n\');\n      const blob = new Blob([csv], { type: \'text/csv\' });\n      const url = URL.createObjectURL(blob);\n      const a = document.createElement(\'a\');\n      a.href = url;\n      a.download = \'participants.csv\';\n      document.body.appendChild(a);\n      a.click();\n      a.remove();\n      URL.revokeObjectURL(url);\n      showMessage(\'Exported CSV\', \'info\');\n    });\n    importBtn.addEventListener(\'click\', () =&gt; { importFile.click(); });\n    importFile.addEventListener(\'change\', (e) =&gt; {\n      const file = e.target.files[0];\n      if (!file) return;\n      const reader = new FileReader();\n      reader.onload = (ev) =&gt; {\n        const txt = ev.target.result;\n        const lines = txt.split(/\\r?\\n/).map(s =&gt; s.trim()).filter(s =&gt; s);\n        // basic CSV unquote\n        const parsed = lines.map(l =&gt; {\n          // simple CSV single-column parse: handle quoted fields\n          if (l.startsWith(\'"\') &amp;&amp; l.endsWith(\'"\')) {\n            return l.slice(1,-1).replace(/""/g,\'"\');\n          }\n          return l;\n        });\n        parsed.forEach(p =&gt; wheel.addName(p));\n        updateUI();\n        showMessage(`Imported ${parsed.length} names`, \'info\');\n      };\n      reader.readAsText(file);\n      importFile.value = \'\';\n    });\n    // Initial sample (optional)\n    // wheel.addName(\'Alice\'); wheel.addName(\'Bob\'); wheel.addName(\'Charlie\');\n    updateUI();\n    // (Optional) keyboard shortcuts\n    window.addEventListener(\'keydown\', (e) =&gt; {\n      if ((e.ctrlKey || e.metaKey) &amp;&amp; e.key.toLowerCase() === \'k\') {\n        e.preventDefault();\n        nameInput.focus();\n      }\n      if (e.key === \' \') {\n        // space triggers spin if not focusing an input\n        if (document.activeElement.tagName !== \'INPUT\' &amp;&amp; document.activeElement.tagName !== \'TEXTAREA\') {\n          e.preventDefault();\n          spinBtn.click();\n        }\n      }\n    });\n  });\n})(); \n', 'cycle_index': 3, 'task': '[Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes. Do it in HTML, CSS, and JavaScript.]', 'modality': 'website', 'ideas': '', 'language': ' JavaScript', 'codes': 'index.html\nhtml\n\'\'\'\nDOCSTRING\nThis is the main HTML file for the Random Winner Wheel.\nIt contains the structure: input fields to add names, a canvas for the wheel,\ncontrols (spin, clear, bulk add), theme selector, and placeholders for CSS/JS.\n\'\'\'\n&lt;!doctype html&gt;\n&lt;html lang="en"&gt;\n&lt;head&gt;\n  &lt;meta charset="utf-8" /&gt;\n  &lt;meta name="viewport" content="width=device-width,initial-scale=1" /&gt;\n  &lt;title&gt;Random Winner Wheel&lt;/title&gt;\n  &lt;link rel="stylesheet" href="styles.css"&gt;\n&lt;/head&gt;\n&lt;body class="theme-light"&gt;\n  &lt;header&gt;\n    &lt;h1&gt;Random Winner Wheel&lt;/h1&gt;\n    &lt;p&gt;Enter participant names, choose a theme, and spin to pick a winner.&lt;/p&gt;\n  &lt;/header&gt;\n  &lt;main&gt;\n    &lt;section class="controls"&gt;\n      &lt;div class="add-single"&gt;\n        &lt;input id="nameInput" type="text" placeholder="Enter a name and press Add" aria-label="Name input" /&gt;\n        &lt;button id="addBtn"&gt;Add&lt;/button&gt;\n        &lt;button id="addRandomBtn" title="Add a few sample random names"&gt;Add Sample&lt;/button&gt;\n      &lt;/div&gt;\n      &lt;div class="bulk-add"&gt;\n        &lt;label for="bulkInput"&gt;Bulk add (comma, newline or semicolon separated):&lt;/label&gt;\n        &lt;textarea id="bulkInput" placeholder="Alice, Bob, Charlie"&gt;&lt;/textarea&gt;\n        &lt;div class="bulk-actions"&gt;\n          &lt;button id="bulkAddBtn"&gt;Bulk Add&lt;/button&gt;\n          &lt;button id="clearBulkBtn"&gt;Clear Bulk&lt;/button&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;\n      &lt;div class="list-actions"&gt;\n        &lt;div class="theme-select"&gt;\n          &lt;label for="themeSelect"&gt;Theme:&lt;/label&gt;\n          &lt;select id="themeSelect"&gt;\n            &lt;option value="light"&gt;Light&lt;/option&gt;\n            &lt;option value="dark"&gt;Dark&lt;/option&gt;\n            &lt;option value="neon"&gt;Neon&lt;/option&gt;\n            &lt;option value="pastel"&gt;Pastel&lt;/option&gt;\n            &lt;option value="retro"&gt;Retro&lt;/option&gt;\n          &lt;/select&gt;\n        &lt;/div&gt;\n        &lt;div class="wheel-controls"&gt;\n          &lt;button id="spinBtn" class="primary"&gt;Spin&lt;/button&gt;\n          &lt;button id="clearNamesBtn"&gt;Clear Names&lt;/button&gt;\n          &lt;button id="exportBtn"&gt;Export CSV&lt;/button&gt;\n          &lt;input id="importFile" type="file" accept=".csv,text/csv" style="display:none"&gt;\n          &lt;button id="importBtn"&gt;Import CSV&lt;/button&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;\n    &lt;/section&gt;\n    &lt;section class="wheel-area"&gt;\n      &lt;div class="wheel-container"&gt;\n        &lt;canvas id="wheelCanvas" width="600" height="600" aria-label="Spinning wheel"&gt;&lt;/canvas&gt;\n        &lt;div class="pointer" aria-hidden="true"&gt;▼&lt;/div&gt;\n      &lt;/div&gt;\n      &lt;aside class="participants"&gt;\n        &lt;h2&gt;Participants (&lt;span id="count"&gt;0&lt;/span&gt;)&lt;/h2&gt;\n        &lt;ul id="nameList" aria-live="polite"&gt;&lt;/ul&gt;\n      &lt;/aside&gt;\n    &lt;/section&gt;\n    &lt;section class="result" id="result" aria-live="polite" hidden&gt;\n      &lt;h2&gt;Winner&lt;/h2&gt;\n      &lt;div id="winnerName" class="winnerName"&gt;&lt;/div&gt;\n      &lt;button id="rerollBtn"&gt;Spin Again&lt;/button&gt;\n    &lt;/section&gt;\n  &lt;/main&gt;\n  &lt;footer&gt;\n    &lt;small&gt;Built with HTML, CSS, and JavaScript. Themes change both UI and wheel colors.&lt;/small&gt;\n  &lt;/footer&gt;\n  &lt;script src="script.js"&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\n\nstyles.css\ncss\n\'\'\'\nDOCSTRING\nStylesheet for the Random Winner Wheel.\nDefines layout, themes, wheel container sizing, animations, and toast styles.\n\'\'\'\n/* Reset &amp; base */\n* { box-sizing: border-box; margin: 0; padding: 0; }\nhtml,body { height: 100%; font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; background: var(--bg); color: var(--fg); }\n:root {\n  --bg: #f7f8fb;\n  --fg: #222;\n  --muted: #666;\n  --accent: #2b8cff;\n  --card: #ffffff;\n  --primary-btn-bg: var(--accent);\n  --primary-btn-fg: #fff;\n  --shadow: rgba(15,15,15,0.08);\n}\n/* Themes */\nbody.theme-light {\n  --bg: #f7f8fb;\n  --fg: #222;\n  --muted: #5b6170;\n  --accent: #2b8cff;\n  --card: #fff;\n  --wheel-seq: 0;\n}\nbody.theme-dark {\n  --bg: #0f1724;\n  --fg: #e6eef8;\n  --muted: #a9b1c2;\n  --accent: #7c5cff;\n  --card: #0b1220;\n}\nbody.theme-neon {\n  --bg: #0a0a0f;\n  --fg: #e9f9ff;\n  --muted: #a6f3ff;\n  --accent: #39ff14;\n  --card: #09101a;\n}\nbody.theme-pastel {\n  --bg: #fffaf6;\n  --fg: #3c3a3a;\n  --muted: #8d8a8a;\n  --accent: #ff7aa2;\n  --card: #fff;\n}\nbody.theme-retro {\n  --bg: #fff6e7;\n  --fg: #402b2b;\n  --muted: #856e6e;\n  --accent: #ffb86b;\n  --card: #fff0e6;\n}\n/* Layout */\nheader { padding: 18px 24px; text-align: center; background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent); }\nheader h1 { font-size: 1.5rem; margin-bottom: 6px; }\nmain { padding: 18px; max-width: 1100px; margin: 0 auto; }\n.controls { display: grid; gap: 12px; margin-bottom: 18px; }\n.add-single { display:flex; gap:8px; }\n.add-single input[type="text"] { flex:1; padding:10px; border-radius:8px; border:1px solid rgba(0,0,0,0.08); background:var(--card); color:var(--fg); }\n.add-single button { padding:10px 12px; border-radius:8px; border: none; cursor:pointer; background: var(--primary-btn-bg); color: var(--primary-btn-fg); }\n.add-single button#addRandomBtn { background: transparent; border: 1px solid rgba(0,0,0,0.06); color: var(--fg); }\n.bulk-add textarea { width:100%; min-height:64px; margin-top:6px; padding:8px; border-radius:8px; border:1px solid rgba(0,0,0,0.06); background:var(--card); color:var(--fg); }\n.bulk-actions { display:flex; gap:8px; margin-top:8px; }\n.list-actions { display:flex; justify-content:space-between; align-items:center; gap:16px; flex-wrap:wrap; }\n.theme-select select { padding:8px; border-radius:8px; border:1px solid rgba(0,0,0,0.06); }\n.wheel-area { display:flex; gap:18px; align-items:start; flex-wrap:wrap; }\n.wheel-container { position: relative; width: 600px; height: 600px; max-width: 90vw; max-height: 90vw; display:flex; align-items:center; justify-content:center; background: transparent; }\n.pointer {\n  /* Centered triangular pointer positioned above the wheel.\n     This ensures the visual pointer aligns with the wheel math (top-center).\n     Hides the fallback glyph in the HTML and draws a sharp triangle instead. */\n  position: absolute;\n  top: 8px;               /* vertical offset from top of wheel container */\n  left: 50%;              /* center horizontally */\n  transform: translateX(-50%); /* center on the X axis */\n  width: 0;\n  height: 0;\n  border-left: 12px solid transparent;\n  border-right: 12px solid transparent;\n  border-bottom: 18px solid var(--accent);\n  z-index: 10;            /* ensure it\'s above the canvas */\n  pointer-events: none;\n  /* hide textual glyph fallback content (the ▼ in HTML) */\n  font-size: 0;\n  line-height: 0;\n  text-indent: -9999px;\n}\n/* Participants panel and wheel styles */\n.participants { width: 320px; max-width: 40vw; background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent); padding:12px; border-radius:10px; box-shadow: 0 6px 18px var(--shadow); }\n.participants h2 { margin-bottom:8px; font-size:1.05rem; }\n#nameList { list-style:none; max-height:420px; overflow:auto; display:block; }\n#nameList li { padding:8px; border-radius:6px; display:flex; justify-content:space-between; align-items:center; gap:8px; margin-bottom:8px; background: var(--card); border:1px solid rgba(0,0,0,0.04); }\n#nameList li button { background: transparent; border: none; color: var(--muted); cursor:pointer; }\n.result { margin-top:18px; padding:12px; border-radius:8px; background: var(--card); text-align:center; box-shadow: 0 6px 18px var(--shadow); }\n.result .winnerName { font-size:1.4rem; font-weight:700; margin:8px 0; color: var(--accent); }\n/* Buttons */\nbutton { cursor:pointer; padding:8px 12px; border-radius:8px; border:1px solid rgba(0,0,0,0.06); background: transparent; color:var(--fg); }\nbutton.primary { background: var(--primary-btn-bg); color: var(--primary-btn-fg); border: none; }\n/* Responsive */\n@media (max-width: 900px) {\n  .wheel-area { flex-direction:column; align-items:center; }\n  .participants { width: 100%; max-width: 100%; }\n}\n/* Wheel canvas scaling helper */\n#wheelCanvas { border-radius:50%; box-shadow: 0 12px 26px rgba(0,0,0,0.12); background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.02), transparent); }\n/* Toast / temporary message styles (used by showMessage) */\n.tmp-toast {\n  position: fixed;\n  left: 50%;\n  transform: translateX(-50%);\n  top: 18px;\n  background: rgba(0,0,0,0.85);\n  color: #fff;\n  padding: 8px 12px;\n  border-radius: 6px;\n  z-index: 9999;\n  transition: opacity 0.25s, transform 0.25s;\n  opacity: 1;\n  pointer-events: none;\n  font-size: 0.95rem;\n  box-shadow: 0 6px 18px rgba(0,0,0,0.18);\n}\n.tmp-toast.success { background: rgba(56, 198, 123, 0.95); }\n.tmp-toast.warn    { background: rgba(255, 159, 67, 0.95); color: #2b1500; }\n.tmp-toast.info    { background: rgba(12, 74, 255, 0.95); }\n/* Winner highlight for participants list */\n#nameList li.winner {\n  outline: 3px solid rgba(255,215,0,0.15);\n  box-shadow: 0 6px 18px rgba(255,215,0,0.06);\n  transform: scale(1.01);\n}\n\n\nscript.js\njs\n\'\'\'\nDOCSTRING\nScript for the Random Winner Wheel.\nContains the Wheel class to draw and spin the canvas-based wheel and UI glue code to manage names and themes.\n\'\'\'\n/* \nDOCSTRING\nScript for the Random Winner Wheel.\nContains the Wheel class to draw and spin the canvas-based wheel and UI glue code to manage names and themes.\n*/\n/* Main JavaScript - Wheel + UI logic */\n(() =&gt; {\n  // Utilities\n  function rand(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }\n  function easeOutCubic(t) { return 1 - Math.pow(1 - t, 3); }\n  // Color palettes for themes (will be used to paint wheel segments)\n  const THEME_PALETTES = {\n    light: [\'#FF8A80\',\'#FFD180\',\'#FFF59D\',\'#C8E6C9\',\'#80DEEA\',\'#A7FFEB\',\'#B39DDB\',\'#90CAF9\'],\n    dark: [\'#ff6b6b\',\'#ffd166\',\'#faff8e\',\'#b9f6ca\',\'#4dd0e1\',\'#80cbc4\',\'#b388ff\',\'#64b5f6\'],\n    neon: [\'#ff2d95\',\'#7cff01\',\'#00ffff\',\'#ffdd00\',\'#ff6a00\',\'#00ff9e\',\'#ff00ff\',\'#47ffa2\'],\n    pastel: [\'#ffdbe9\',\'#fff0b3\',\'#d1ffd6\',\'#cfefff\',\'#e7dfff\',\'#ffd6e7\',\'#fbe7d6\',\'#e6f7ff\'],\n    retro: [\'#ffb86b\',\'#ffd3a8\',\'#f3e2a9\',\'#b8e0d2\',\'#c0b9ff\',\'#ffb6c1\',\'#f6c49f\',\'#c3d69b\']\n  };\n  // Wheel class\n  class Wheel {\n    /*\n    Manage wheel: drawing, recalculating segments, spinning animation, and determining winner.\n    */\n    constructor(canvas, options = {}) {\n      this.canvas = canvas;\n      this.ctx = canvas.getContext(\'2d\');\n      this.names = [];\n      this.rotation = 0; // radians\n      this.isSpinning = false;\n      this.frame = null;\n      this.onResult = options.onResult || function() {};\n      this.theme = options.theme || \'light\';\n      this.padAngle = 0.02; // radians padding between segments\n      this.textColor = \'#111\';\n      this._devicePixelRatioFix();\n      window.addEventListener(\'resize\', () =&gt; { this._devicePixelRatioFix(); this.draw(); });\n    }\n    _devicePixelRatioFix() {\n      const dpr = window.devicePixelRatio || 1;\n      const rect = this.canvas.getBoundingClientRect();\n      // If rect has zero size (canvas not yet laid out), use current width/height attributes as fallback\n      const width = rect.width || (this.canvas.width / dpr);\n      const height = rect.height || (this.canvas.height / dpr);\n      this.canvas.width = width * dpr;\n      this.canvas.height = height * dpr;\n      this.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n      this.centerX = width / 2;\n      this.centerY = height / 2;\n      this.radius = Math.min(width, height) / 2 - 18;\n    }\n    setTheme(themeId) { this.theme = themeId; this.draw(); }\n    setNames(names) {\n      this.names = names.slice();\n      this.draw();\n    }\n    addName(name) {\n      this.names.push(name);\n      this.draw();\n    }\n    removeName(index) {\n      if (index &gt;= 0 &amp;&amp; index &lt; this.names.length) {\n        this.names.splice(index,1);\n        this.draw();\n      }\n    }\n    clearNames() {\n      this.names = [];\n      this.draw();\n    }\n    draw() {\n      const ctx = this.ctx;\n      const w = this.canvas.width / (window.devicePixelRatio || 1);\n      const h = this.canvas.height / (window.devicePixelRatio || 1);\n      ctx.clearRect(0,0,w,h);\n      ctx.save();\n      ctx.translate(this.centerX, this.centerY);\n      ctx.rotate(this.rotation);\n      // draw segments\n      const count = Math.max(this.names.length, 1);\n      const palette = THEME_PALETTES[this.theme] || THEME_PALETTES.light;\n      for (let i = 0; i &lt; count; i++) {\n        const start = (i / count) * Math.PI * 2;\n        const end = ((i + 1) / count) * Math.PI * 2;\n        ctx.beginPath();\n        ctx.moveTo(0,0);\n        ctx.arc(0,0,this.radius, start + this.padAngle, end - this.padAngle, false);\n        ctx.closePath();\n        const color = palette[i % palette.length];\n        ctx.fillStyle = color;\n        ctx.fill();\n        ctx.strokeStyle = (i % 2 === 0) ? \'rgba(0,0,0,0.06)\' : \'rgba(0,0,0,0.03)\';\n        ctx.lineWidth = 1;\n        ctx.stroke();\n        // draw text label\n        const mid = (start + end) / 2;\n        ctx.save();\n        ctx.rotate(mid);\n        ctx.translate(this.radius * 0.6, 0);\n        ctx.rotate(Math.PI/2);\n        ctx.fillStyle = getTextColor(color);\n        ctx.font = `${Math.max(12, Math.min(22, this.radius / 8))}px sans-serif`;\n        ctx.textAlign = \'center\';\n        ctx.textBaseline = \'middle\';\n        const label = (this.names.length === 0) ? \'Add names\' : this.names[i % this.names.length];\n        wrapFillText(ctx, label, 0, 0, this.radius * 0.5, 16);\n        ctx.restore();\n      }\n      // draw center circle\n      ctx.beginPath();\n      ctx.arc(0,0, this.radius * 0.16, 0, Math.PI*2);\n      ctx.fillStyle = \'rgba(255,255,255,0.9)\';\n      ctx.fill();\n      ctx.strokeStyle = \'rgba(0,0,0,0.06)\';\n      ctx.stroke();\n      ctx.restore();\n      // draw outer ring (pointer side neutral)\n      ctx.beginPath();\n      ctx.arc(this.centerX, this.centerY, this.radius + 10, 0, Math.PI*2);\n      ctx.strokeStyle = \'rgba(0,0,0,0.03)\';\n      ctx.lineWidth = 2;\n      ctx.stroke();\n    }\n    spin() {\n      if (this.isSpinning || this.names.length === 0) return;\n      this.isSpinning = true;\n      const count = this.names.length;\n      // Determine random winner index to land on:\n      const winnerIndex = rand(0, count - 1);\n      // Calculate final rotation so that winner segment lines up with pointer at top (pointer at canvas top - rotation must align)\n      // Our pointer is at the top (canvas 0 angle). The segment mid-angle for index i (without rotation) is ((i + 0.5)/count)*2pi\n      const segmentMid = ((winnerIndex + 0.5) / count) * Math.PI * 2;\n      // We want segmentMid + rotation_final == -Math.PI/2 (so it points at the top pointer), so rotation_final = -Math.PI/2 - segmentMid + 2pi*N\n      const extraTurns = rand(5, 8); // full spins\n      const rotationFinal = -Math.PI/2 - segmentMid + extraTurns * Math.PI * 2;\n      const startRotation = this.rotation % (Math.PI * 2);\n      const delta = rotationFinal - startRotation;\n      const duration = 4000 + Math.random() * 1500; // ms\n      const startTime = performance.now();\n      const animate = (now) =&gt; {\n        const elapsed = now - startTime;\n        const t = Math.min(elapsed / duration, 1);\n        const eased = easeOutCubic(t);\n        this.rotation = startRotation + delta * eased;\n        this.draw();\n        if (t &lt; 1) {\n          this.frame = requestAnimationFrame(animate);\n        } else {\n          this.isSpinning = false;\n          // Normalize rotation within 0..2pi\n          this.rotation = ((this.rotation % (Math.PI*2)) + Math.PI*2) % (Math.PI*2);\n          this.draw();\n          // Compute final winner index again from rotation\n          // finalAngle: the angle of the segment at pointer (0 at right, +counterclockwise). We compute a normalized angle that maps to segment index.\n          const finalAngle = ((-this.rotation - Math.PI/2) % (Math.PI*2) + Math.PI*2) % (Math.PI*2);\n          const resultingIndex = Math.floor((finalAngle / (Math.PI*2)) * count) % count;\n          const winner = this.names[resultingIndex];\n          this.onResult({ index: resultingIndex, name: winner });\n        }\n      };\n      this.frame = requestAnimationFrame(animate);\n    }\n  }\n  // Helper: pick readable text color for a background\n  function getTextColor(hex) {\n    // remove # and convert\n    const h = hex.replace(\'#\',\'\');\n    const r = parseInt(h.substring(0,2),16);\n    const g = parseInt(h.substring(2,4),16);\n    const b = parseInt(h.substring(4,6),16);\n    // luminance\n    const lum = (0.299*r + 0.587*g + 0.114*b) / 255;\n    return lum &gt; 0.65 ? \'#111\' : \'#fff\';\n  }\n  // Helper: wrap text within a given width (draws multi-line if necessary)\n  function wrapFillText(ctx, text, x, y, maxWidth, lineHeight) {\n    const words = (text || \'\').split(/\\s+/);\n    if (words.length === 0) return;\n    let line = \'\';\n    const lines = [];\n    for (let n = 0; n &lt; words.length; n++) {\n      const testLine = line ? line + \' \' + words[n] : words[n];\n      const metrics = ctx.measureText(testLine);\n      if (metrics.width &gt; maxWidth &amp;&amp; line) {\n        lines.push(line);\n        line = words[n];\n      } else {\n        line = testLine;\n      }\n    }\n    if (line) lines.push(line);\n    // If still too many lines, just draw what\'s possible (we rely on font size)\n    for (let i=0;i&lt;lines.length;i++){\n      ctx.fillText(lines[i], x, y + (i - (lines.length-1)/2) * lineHeight);\n    }\n  }\n  // UI glue\n  document.addEventListener(\'DOMContentLoaded\', () =&gt; {\n    const canvas = document.getElementById(\'wheelCanvas\');\n    const wheel = new Wheel(canvas, { theme: \'light\', onResult: onWinner });\n    const nameInput = document.getElementById(\'nameInput\');\n    const addBtn = document.getElementById(\'addBtn\');\n    const addRandomBtn = document.getElementById(\'addRandomBtn\');\n    const bulkInput = document.getElementById(\'bulkInput\');\n    const bulkAddBtn = document.getElementById(\'bulkAddBtn\');\n    const clearBulkBtn = document.getElementById(\'clearBulkBtn\');\n    const nameList = document.getElementById(\'nameList\');\n    const countSpan = document.getElementById(\'count\');\n    const spinBtn = document.getElementById(\'spinBtn\');\n    const rerollBtn = document.getElementById(\'rerollBtn\');\n    const clearNamesBtn = document.getElementById(\'clearNamesBtn\');\n    const themeSelect = document.getElementById(\'themeSelect\');\n    const resultSection = document.getElementById(\'result\');\n    const winnerNameDiv = document.getElementById(\'winnerName\');\n    const exportBtn = document.getElementById(\'exportBtn\');\n    const importBtn = document.getElementById(\'importBtn\');\n    const importFile = document.getElementById(\'importFile\');\n    // Initial draw\n    wheel.draw();\n    function updateUI() {\n      const names = wheel.names;\n      countSpan.textContent = names.length;\n      renderNameList();\n    }\n    function renderNameList() {\n      nameList.innerHTML = \'\';\n      wheel.names.forEach((n, i) =&gt; {\n        const li = document.createElement(\'li\');\n        const span = document.createElement(\'span\');\n        span.textContent = n;\n        li.appendChild(span);\n        const btn = document.createElement(\'button\');\n        btn.title = \'Remove\';\n        btn.setAttribute(\'aria-label\', `Remove ${n}`);\n        btn.innerHTML = \'✕\';\n        btn.addEventListener(\'click\', () =&gt; {\n          wheel.removeName(i);\n          updateUI();\n        });\n        li.appendChild(btn);\n        nameList.appendChild(li);\n      });\n    }\n    function addNameFromInput() {\n      const v = nameInput.value.trim();\n      if (!v) { showMessage(\'Please enter a name.\', \'warn\'); return; }\n      wheel.addName(v);\n      nameInput.value = \'\';\n      updateUI();\n    }\n    addBtn.addEventListener(\'click\', addNameFromInput);\n    nameInput.addEventListener(\'keydown\', (e) =&gt; { if (e.key === \'Enter\') addNameFromInput(); });\n    addRandomBtn.addEventListener(\'click\', () =&gt; {\n      const samples = [\'Alex\',\'Jordan\',\'Taylor\',\'Sam\',\'Jamie\',\'Casey\',\'Morgan\',\'Riley\',\'Avery\',\'Dana\'];\n      const count = rand(3,6);\n      for (let i=0;i&lt;count;i++) wheel.addName(samples[rand(0,samples.length-1)] + (rand(1,100)));\n      updateUI();\n    });\n    bulkAddBtn.addEventListener(\'click\', () =&gt; {\n      const text = bulkInput.value.trim();\n      if (!text) { showMessage(\'Bulk input is empty.\', \'warn\'); return; }\n      const parsed = text.split(/[\\n,;]+/).map(s =&gt; s.trim()).filter(s =&gt; s);\n      parsed.forEach(p =&gt; wheel.addName(p));\n      bulkInput.value = \'\';\n      updateUI();\n      showMessage(`Added ${parsed.length} names.`, \'info\');\n    });\n    clearBulkBtn.addEventListener(\'click\', () =&gt; { bulkInput.value = \'\'; });\n    spinBtn.addEventListener(\'click\', () =&gt; {\n      if (wheel.names.length === 0) { showMessage(\'Add at least one name to spin.\', \'warn\'); return; }\n      resultSection.hidden = true;\n      winnerNameDiv.textContent = \'\';\n      wheel.spin();\n      spinBtn.disabled = true;\n      const checkFinish = setInterval(() =&gt; {\n        if (!wheel.isSpinning) {\n          clearInterval(checkFinish);\n          spinBtn.disabled = false;\n        }\n      }, 200);\n    });\n    rerollBtn.addEventListener(\'click\', () =&gt; {\n      resultSection.hidden = true;\n      wheel.spin();\n    });\n    clearNamesBtn.addEventListener(\'click\', () =&gt; {\n      if (confirm(\'Clear all names?\')) {\n        wheel.clearNames();\n        updateUI();\n      }\n    });\n    themeSelect.addEventListener(\'change\', (e) =&gt; {\n      const t = e.target.value;\n      document.body.className = \'theme-\' + t;\n      wheel.setTheme(t);\n    });\n    function onWinner(result) {\n      winnerNameDiv.textContent = result.name || \'—\';\n      resultSection.hidden = false;\n      // Flash the winner item in the list (if still present)\n      const items = Array.from(nameList.children);\n      items.forEach((li, idx) =&gt; { li.classList.toggle(\'winner\', idx === result.index); });\n      showMessage(`Winner: ${result.name}`, \'success\', 4000);\n    }\n    // Simple message area\n    function showMessage(text, type = \'info\', duration = 2200) {\n      // create small toast\n      const t = document.createElement(\'div\');\n      t.className = \'tmp-toast \' + type;\n      t.textContent = text;\n      document.body.appendChild(t);\n      // Force reflow to pick up transitions\n      window.getComputedStyle(t).opacity;\n      setTimeout(()=&gt; { t.style.opacity = \'0\'; t.style.transform = \'translateY(-10px)\'; }, duration - 300);\n      setTimeout(()=&gt; { try { t.remove(); } catch(e){} }, duration);\n    }\n    // Export/import CSV\n    exportBtn.addEventListener(\'click\', () =&gt; {\n      if (wheel.names.length === 0) { showMessage(\'No names to export.\', \'warn\'); return; }\n      const csv = wheel.names.map(n =&gt; `"${(n||\'\').replace(/"/g,\'""\')}"`).join(\'\\n\');\n      const blob = new Blob([csv], { type: \'text/csv\' });\n      const url = URL.createObjectURL(blob);\n      const a = document.createElement(\'a\');\n      a.href = url;\n      a.download = \'participants.csv\';\n      document.body.appendChild(a);\n      a.click();\n      a.remove();\n      URL.revokeObjectURL(url);\n      showMessage(\'Exported CSV\', \'info\');\n    });\n    importBtn.addEventListener(\'click\', () =&gt; { importFile.click(); });\n    importFile.addEventListener(\'change\', (e) =&gt; {\n      const file = e.target.files[0];\n      if (!file) return;\n      const reader = new FileReader();\n      reader.onload = (ev) =&gt; {\n        const txt = ev.target.result;\n        const lines = txt.split(/\\r?\\n/).map(s =&gt; s.trim()).filter(s =&gt; s);\n        // basic CSV unquote\n        const parsed = lines.map(l =&gt; {\n          // simple CSV single-column parse: handle quoted fields\n          if (l.startsWith(\'"\') &amp;&amp; l.endsWith(\'"\')) {\n            return l.slice(1,-1).replace(/""/g,\'"\');\n          }\n          return l;\n        });\n        parsed.forEach(p =&gt; wheel.addName(p));\n        updateUI();\n        showMessage(`Imported ${parsed.length} names`, \'info\');\n      };\n      reader.readAsText(file);\n      importFile.value = \'\';\n    });\n    // Initial sample (optional)\n    // wheel.addName(\'Alice\'); wheel.addName(\'Bob\'); wheel.addName(\'Charlie\');\n    updateUI();\n    // (Optional) keyboard shortcuts\n    window.addEventListener(\'keydown\', (e) =&gt; {\n      if ((e.ctrlKey || e.metaKey) &amp;&amp; e.key.toLowerCase() === \'k\') {\n        e.preventDefault();\n        nameInput.focus();\n      }\n      if (e.key === \' \') {\n        // space triggers spin if not focusing an input\n        if (document.activeElement.tagName !== \'INPUT\' &amp;&amp; document.activeElement.tagName !== \'TEXTAREA\') {\n          e.preventDefault();\n          spinBtn.click();\n        }\n      }\n    });\n  });\n})(); \n\n\n', 'images': '', 'comments': " The files contain literal Python-style triple-quoted DOCSTRING blocks (''' ... ''') at the top of index.html, styles.css and script.js. Those triple-single-quote lines are not valid HTML/CSS/JS and will break parsing — the site will fail to load or script/style will not be applied. Fix immediately by replacing them with proper comments or removing them.\n\nWhy this is highest priority:\n- Browsers will try to interpret those lines as part of the document and will throw syntax errors (CSS/JS), so nothing else will work even if all logic is correct.\n\nHow to fix (step-by-step):\n1. index.html\n   - Remove the block that starts with '''DOCSTRING and ends with ''' (or convert it to an HTML comment).\n   - Replace with an HTML comment if you want to keep the documentation. Example:\n     \n   - Ensure the file begins with &lt;!doctype html&gt; (no stray quotes/characters before it).\n\n2. styles.css\n   - Remove the leading triple-quoted string and convert it to a CSS comment:\n     /\n       Stylesheet for the Random Winner Wheel.\n       Defines layout, themes, wheel container sizing, animations, and toast styles.\n     /\n   - Make sure no remaining ''' lines exist anywhere in the CSS.\n\n3. script.js\n   - Remove all '''DOCSTRING''' lines and any duplicated triple quotes. Replace them with JS block comments:\n     /\n       Script for the Random Winner Wheel.\n       Contains the Wheel class to draw and spin the canvas-based wheel and UI glue code to manage names and themes.\n     /\n   - There are two occurrences of identical docstrings at the top of the JS — keep just one proper comment block, remove duplicates.\n   - Verify there are no stray single or triple quote lines that would create unterminated strings.\n\n4. After replacing/removing:\n   - Open the browser DevTools console and check for errors (SyntaxError, CSS parse errors).\n   - Verify:\n     - CSS is applied (themes change UI colors).\n     - JS loads and console does not show parse errors.\n     - UI buttons (Add, Bulk Add, Spin, Import/Export) function as expected.\n\nOptional additional sanity checks (recommended):\n- Search the whole project for any remaining ''' occurrences and remove them.\n- Run the page locally (open index.html) and test:\n  - Add names, bulk add, sample add.\n  - Switch themes and confirm wheel color palette updates.\n  - Spin and confirm winner appears and list highlights.\n  - Export/import CSV works as expected.\n- If you keep descriptive headers, prefer consistent comment style per file type (HTML , CSS / / and JS / / or //).\n\nImplementing these replacements will resolve the critical syntax errors preventing the site from running."} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_3_5_TURBO |

[2025-17-09 13:45:25 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Programmer |
| **user_role_name** | Code Reviewer |
| **assistant_role_prompt** | {chatdev_prompt} You are Programmer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. You can write/create computer software or applications by providing a specific programming language to the computer. You have extensive computing and coding experience in many varieties of programming languages and platforms, such as Python, Java, C, C++, HTML, CSS, JavaScript, XML, SQL, PHP, etc,. Here is a new customer's task: {task}. To complete the task, you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Code Reviewer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. You can help programmers to assess source codes for software troubleshooting, fix bugs to increase code quality and robustness, and offer proposals to improve the source codes. Here is a new customer's task: {task}. To complete the task, you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **task_prompt** | [Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes. Do it in HTML, CSS, and JavaScript.] |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_3_5_TURBO |
| **background_prompt** | ChatDev is a software company powered by multiple intelligent agents, such as chief executive officer, chief human resources officer, chief product officer, chief technology officer, etc, with a multi-agent organizational structure and the mission of 'changing the digital world through programming'. |

[2025-17-09 13:45:25 INFO] Code Reviewer: **[Start Chat]**

[ChatDev is a software company powered by multiple intelligent agents, such as chief executive officer, chief human resources officer, chief product officer, chief technology officer, etc, with a multi-agent organizational structure and the mission of 'changing the digital world through programming'.
You are Programmer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer.
You can write/create computer software or applications by providing a specific programming language to the computer. You have extensive computing and coding experience in many varieties of programming languages and platforms, such as Python, Java, C, C++, HTML, CSS, JavaScript, XML, SQL, PHP, etc,.
Here is a new customer's task: [Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes. Do it in HTML, CSS, and JavaScript.].
To complete the task, you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]

According to the new user's task, our designed product modality, languages and ideas, our developed first-edition source codes are listed below: 
Task: "[Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes. Do it in HTML, CSS, and JavaScript.]".
Modality: "website".
Programming Language: " JavaScript"
Ideas: ""
Codes: 
"index.html
```html
'''
DOCSTRING
This is the main HTML file for the Random Winner Wheel.
It contains the structure: input fields to add names, a canvas for the wheel,
controls (spin, clear, bulk add), theme selector, and placeholders for CSS/JS.
'''
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Random Winner Wheel</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body class="theme-light">
  <header>
    <h1>Random Winner Wheel</h1>
    <p>Enter participant names, choose a theme, and spin to pick a winner.</p>
  </header>
  <main>
    <section class="controls">
      <div class="add-single">
        <input id="nameInput" type="text" placeholder="Enter a name and press Add" aria-label="Name input" />
        <button id="addBtn">Add</button>
        <button id="addRandomBtn" title="Add a few sample random names">Add Sample</button>
      </div>
      <div class="bulk-add">
        <label for="bulkInput">Bulk add (comma, newline or semicolon separated):</label>
        <textarea id="bulkInput" placeholder="Alice, Bob, Charlie"></textarea>
        <div class="bulk-actions">
          <button id="bulkAddBtn">Bulk Add</button>
          <button id="clearBulkBtn">Clear Bulk</button>
        </div>
      </div>
      <div class="list-actions">
        <div class="theme-select">
          <label for="themeSelect">Theme:</label>
          <select id="themeSelect">
            <option value="light">Light</option>
            <option value="dark">Dark</option>
            <option value="neon">Neon</option>
            <option value="pastel">Pastel</option>
            <option value="retro">Retro</option>
          </select>
        </div>
        <div class="wheel-controls">
          <button id="spinBtn" class="primary">Spin</button>
          <button id="clearNamesBtn">Clear Names</button>
          <button id="exportBtn">Export CSV</button>
          <input id="importFile" type="file" accept=".csv,text/csv" style="display:none">
          <button id="importBtn">Import CSV</button>
        </div>
      </div>
    </section>
    <section class="wheel-area">
      <div class="wheel-container">
        <canvas id="wheelCanvas" width="600" height="600" aria-label="Spinning wheel"></canvas>
        <div class="pointer" aria-hidden="true">▼</div>
      </div>
      <aside class="participants">
        <h2>Participants (<span id="count">0</span>)</h2>
        <ul id="nameList" aria-live="polite"></ul>
      </aside>
    </section>
    <section class="result" id="result" aria-live="polite" hidden>
      <h2>Winner</h2>
      <div id="winnerName" class="winnerName"></div>
      <button id="rerollBtn">Spin Again</button>
    </section>
  </main>
  <footer>
    <small>Built with HTML, CSS, and JavaScript. Themes change both UI and wheel colors.</small>
  </footer>
  <script src="script.js"></script>
</body>
</html>
```

styles.css
```css
'''
DOCSTRING
Stylesheet for the Random Winner Wheel.
Defines layout, themes, wheel container sizing, animations, and toast styles.
'''
/* Reset & base */
* { box-sizing: border-box; margin: 0; padding: 0; }
html,body { height: 100%; font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; background: var(--bg); color: var(--fg); }
:root {
  --bg: #f7f8fb;
  --fg: #222;
  --muted: #666;
  --accent: #2b8cff;
  --card: #ffffff;
  --primary-btn-bg: var(--accent);
  --primary-btn-fg: #fff;
  --shadow: rgba(15,15,15,0.08);
}
/* Themes */
body.theme-light {
  --bg: #f7f8fb;
  --fg: #222;
  --muted: #5b6170;
  --accent: #2b8cff;
  --card: #fff;
  --wheel-seq: 0;
}
body.theme-dark {
  --bg: #0f1724;
  --fg: #e6eef8;
  --muted: #a9b1c2;
  --accent: #7c5cff;
  --card: #0b1220;
}
body.theme-neon {
  --bg: #0a0a0f;
  --fg: #e9f9ff;
  --muted: #a6f3ff;
  --accent: #39ff14;
  --card: #09101a;
}
body.theme-pastel {
  --bg: #fffaf6;
  --fg: #3c3a3a;
  --muted: #8d8a8a;
  --accent: #ff7aa2;
  --card: #fff;
}
body.theme-retro {
  --bg: #fff6e7;
  --fg: #402b2b;
  --muted: #856e6e;
  --accent: #ffb86b;
  --card: #fff0e6;
}
/* Layout */
header { padding: 18px 24px; text-align: center; background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent); }
header h1 { font-size: 1.5rem; margin-bottom: 6px; }
main { padding: 18px; max-width: 1100px; margin: 0 auto; }
.controls { display: grid; gap: 12px; margin-bottom: 18px; }
.add-single { display:flex; gap:8px; }
.add-single input[type="text"] { flex:1; padding:10px; border-radius:8px; border:1px solid rgba(0,0,0,0.08); background:var(--card); color:var(--fg); }
.add-single button { padding:10px 12px; border-radius:8px; border: none; cursor:pointer; background: var(--primary-btn-bg); color: var(--primary-btn-fg); }
.add-single button#addRandomBtn { background: transparent; border: 1px solid rgba(0,0,0,0.06); color: var(--fg); }
.bulk-add textarea { width:100%; min-height:64px; margin-top:6px; padding:8px; border-radius:8px; border:1px solid rgba(0,0,0,0.06); background:var(--card); color:var(--fg); }
.bulk-actions { display:flex; gap:8px; margin-top:8px; }
.list-actions { display:flex; justify-content:space-between; align-items:center; gap:16px; flex-wrap:wrap; }
.theme-select select { padding:8px; border-radius:8px; border:1px solid rgba(0,0,0,0.06); }
.wheel-area { display:flex; gap:18px; align-items:start; flex-wrap:wrap; }
.wheel-container { position: relative; width: 600px; height: 600px; max-width: 90vw; max-height: 90vw; display:flex; align-items:center; justify-content:center; background: transparent; }
.pointer {
  /* Centered triangular pointer positioned above the wheel.
     This ensures the visual pointer aligns with the wheel math (top-center).
     Hides the fallback glyph in the HTML and draws a sharp triangle instead. */
  position: absolute;
  top: 8px;               /* vertical offset from top of wheel container */
  left: 50%;              /* center horizontally */
  transform: translateX(-50%); /* center on the X axis */
  width: 0;
  height: 0;
  border-left: 12px solid transparent;
  border-right: 12px solid transparent;
  border-bottom: 18px solid var(--accent);
  z-index: 10;            /* ensure it's above the canvas */
  pointer-events: none;
  /* hide textual glyph fallback content (the ▼ in HTML) */
  font-size: 0;
  line-height: 0;
  text-indent: -9999px;
}
/* Participants panel and wheel styles */
.participants { width: 320px; max-width: 40vw; background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent); padding:12px; border-radius:10px; box-shadow: 0 6px 18px var(--shadow); }
.participants h2 { margin-bottom:8px; font-size:1.05rem; }
#nameList { list-style:none; max-height:420px; overflow:auto; display:block; }
#nameList li { padding:8px; border-radius:6px; display:flex; justify-content:space-between; align-items:center; gap:8px; margin-bottom:8px; background: var(--card); border:1px solid rgba(0,0,0,0.04); }
#nameList li button { background: transparent; border: none; color: var(--muted); cursor:pointer; }
.result { margin-top:18px; padding:12px; border-radius:8px; background: var(--card); text-align:center; box-shadow: 0 6px 18px var(--shadow); }
.result .winnerName { font-size:1.4rem; font-weight:700; margin:8px 0; color: var(--accent); }
/* Buttons */
button { cursor:pointer; padding:8px 12px; border-radius:8px; border:1px solid rgba(0,0,0,0.06); background: transparent; color:var(--fg); }
button.primary { background: var(--primary-btn-bg); color: var(--primary-btn-fg); border: none; }
/* Responsive */
@media (max-width: 900px) {
  .wheel-area { flex-direction:column; align-items:center; }
  .participants { width: 100%; max-width: 100%; }
}
/* Wheel canvas scaling helper */
#wheelCanvas { border-radius:50%; box-shadow: 0 12px 26px rgba(0,0,0,0.12); background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.02), transparent); }
/* Toast / temporary message styles (used by showMessage) */
.tmp-toast {
  position: fixed;
  left: 50%;
  transform: translateX(-50%);
  top: 18px;
  background: rgba(0,0,0,0.85);
  color: #fff;
  padding: 8px 12px;
  border-radius: 6px;
  z-index: 9999;
  transition: opacity 0.25s, transform 0.25s;
  opacity: 1;
  pointer-events: none;
  font-size: 0.95rem;
  box-shadow: 0 6px 18px rgba(0,0,0,0.18);
}
.tmp-toast.success { background: rgba(56, 198, 123, 0.95); }
.tmp-toast.warn    { background: rgba(255, 159, 67, 0.95); color: #2b1500; }
.tmp-toast.info    { background: rgba(12, 74, 255, 0.95); }
/* Winner highlight for participants list */
#nameList li.winner {
  outline: 3px solid rgba(255,215,0,0.15);
  box-shadow: 0 6px 18px rgba(255,215,0,0.06);
  transform: scale(1.01);
}
```

script.js
```js
'''
DOCSTRING
Script for the Random Winner Wheel.
Contains the Wheel class to draw and spin the canvas-based wheel and UI glue code to manage names and themes.
'''
/* 
DOCSTRING
Script for the Random Winner Wheel.
Contains the Wheel class to draw and spin the canvas-based wheel and UI glue code to manage names and themes.
*/
/* Main JavaScript - Wheel + UI logic */
(() => {
  // Utilities
  function rand(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }
  function easeOutCubic(t) { return 1 - Math.pow(1 - t, 3); }
  // Color palettes for themes (will be used to paint wheel segments)
  const THEME_PALETTES = {
    light: ['#FF8A80','#FFD180','#FFF59D','#C8E6C9','#80DEEA','#A7FFEB','#B39DDB','#90CAF9'],
    dark: ['#ff6b6b','#ffd166','#faff8e','#b9f6ca','#4dd0e1','#80cbc4','#b388ff','#64b5f6'],
    neon: ['#ff2d95','#7cff01','#00ffff','#ffdd00','#ff6a00','#00ff9e','#ff00ff','#47ffa2'],
    pastel: ['#ffdbe9','#fff0b3','#d1ffd6','#cfefff','#e7dfff','#ffd6e7','#fbe7d6','#e6f7ff'],
    retro: ['#ffb86b','#ffd3a8','#f3e2a9','#b8e0d2','#c0b9ff','#ffb6c1','#f6c49f','#c3d69b']
  };
  // Wheel class
  class Wheel {
    /*
    Manage wheel: drawing, recalculating segments, spinning animation, and determining winner.
    */
    constructor(canvas, options = {}) {
      this.canvas = canvas;
      this.ctx = canvas.getContext('2d');
      this.names = [];
      this.rotation = 0; // radians
      this.isSpinning = false;
      this.frame = null;
      this.onResult = options.onResult || function() {};
      this.theme = options.theme || 'light';
      this.padAngle = 0.02; // radians padding between segments
      this.textColor = '#111';
      this._devicePixelRatioFix();
      window.addEventListener('resize', () => { this._devicePixelRatioFix(); this.draw(); });
    }
    _devicePixelRatioFix() {
      const dpr = window.devicePixelRatio || 1;
      const rect = this.canvas.getBoundingClientRect();
      // If rect has zero size (canvas not yet laid out), use current width/height attributes as fallback
      const width = rect.width || (this.canvas.width / dpr);
      const height = rect.height || (this.canvas.height / dpr);
      this.canvas.width = width * dpr;
      this.canvas.height = height * dpr;
      this.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      this.centerX = width / 2;
      this.centerY = height / 2;
      this.radius = Math.min(width, height) / 2 - 18;
    }
    setTheme(themeId) { this.theme = themeId; this.draw(); }
    setNames(names) {
      this.names = names.slice();
      this.draw();
    }
    addName(name) {
      this.names.push(name);
      this.draw();
    }
    removeName(index) {
      if (index >= 0 && index < this.names.length) {
        this.names.splice(index,1);
        this.draw();
      }
    }
    clearNames() {
      this.names = [];
      this.draw();
    }
    draw() {
      const ctx = this.ctx;
      const w = this.canvas.width / (window.devicePixelRatio || 1);
      const h = this.canvas.height / (window.devicePixelRatio || 1);
      ctx.clearRect(0,0,w,h);
      ctx.save();
      ctx.translate(this.centerX, this.centerY);
      ctx.rotate(this.rotation);
      // draw segments
      const count = Math.max(this.names.length, 1);
      const palette = THEME_PALETTES[this.theme] || THEME_PALETTES.light;
      for (let i = 0; i < count; i++) {
        const start = (i / count) * Math.PI * 2;
        const end = ((i + 1) / count) * Math.PI * 2;
        ctx.beginPath();
        ctx.moveTo(0,0);
        ctx.arc(0,0,this.radius, start + this.padAngle, end - this.padAngle, false);
        ctx.closePath();
        const color = palette[i % palette.length];
        ctx.fillStyle = color;
        ctx.fill();
        ctx.strokeStyle = (i % 2 === 0) ? 'rgba(0,0,0,0.06)' : 'rgba(0,0,0,0.03)';
        ctx.lineWidth = 1;
        ctx.stroke();
        // draw text label
        const mid = (start + end) / 2;
        ctx.save();
        ctx.rotate(mid);
        ctx.translate(this.radius * 0.6, 0);
        ctx.rotate(Math.PI/2);
        ctx.fillStyle = getTextColor(color);
        ctx.font = `${Math.max(12, Math.min(22, this.radius / 8))}px sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        const label = (this.names.length === 0) ? 'Add names' : this.names[i % this.names.length];
        wrapFillText(ctx, label, 0, 0, this.radius * 0.5, 16);
        ctx.restore();
      }
      // draw center circle
      ctx.beginPath();
      ctx.arc(0,0, this.radius * 0.16, 0, Math.PI*2);
      ctx.fillStyle = 'rgba(255,255,255,0.9)';
      ctx.fill();
      ctx.strokeStyle = 'rgba(0,0,0,0.06)';
      ctx.stroke();
      ctx.restore();
      // draw outer ring (pointer side neutral)
      ctx.beginPath();
      ctx.arc(this.centerX, this.centerY, this.radius + 10, 0, Math.PI*2);
      ctx.strokeStyle = 'rgba(0,0,0,0.03)';
      ctx.lineWidth = 2;
      ctx.stroke();
    }
    spin() {
      if (this.isSpinning || this.names.length === 0) return;
      this.isSpinning = true;
      const count = this.names.length;
      // Determine random winner index to land on:
      const winnerIndex = rand(0, count - 1);
      // Calculate final rotation so that winner segment lines up with pointer at top (pointer at canvas top - rotation must align)
      // Our pointer is at the top (canvas 0 angle). The segment mid-angle for index i (without rotation) is ((i + 0.5)/count)*2pi
      const segmentMid = ((winnerIndex + 0.5) / count) * Math.PI * 2;
      // We want segmentMid + rotation_final == -Math.PI/2 (so it points at the top pointer), so rotation_final = -Math.PI/2 - segmentMid + 2pi*N
      const extraTurns = rand(5, 8); // full spins
      const rotationFinal = -Math.PI/2 - segmentMid + extraTurns * Math.PI * 2;
      const startRotation = this.rotation % (Math.PI * 2);
      const delta = rotationFinal - startRotation;
      const duration = 4000 + Math.random() * 1500; // ms
      const startTime = performance.now();
      const animate = (now) => {
        const elapsed = now - startTime;
        const t = Math.min(elapsed / duration, 1);
        const eased = easeOutCubic(t);
        this.rotation = startRotation + delta * eased;
        this.draw();
        if (t < 1) {
          this.frame = requestAnimationFrame(animate);
        } else {
          this.isSpinning = false;
          // Normalize rotation within 0..2pi
          this.rotation = ((this.rotation % (Math.PI*2)) + Math.PI*2) % (Math.PI*2);
          this.draw();
          // Compute final winner index again from rotation
          // finalAngle: the angle of the segment at pointer (0 at right, +counterclockwise). We compute a normalized angle that maps to segment index.
          const finalAngle = ((-this.rotation - Math.PI/2) % (Math.PI*2) + Math.PI*2) % (Math.PI*2);
          const resultingIndex = Math.floor((finalAngle / (Math.PI*2)) * count) % count;
          const winner = this.names[resultingIndex];
          this.onResult({ index: resultingIndex, name: winner });
        }
      };
      this.frame = requestAnimationFrame(animate);
    }
  }
  // Helper: pick readable text color for a background
  function getTextColor(hex) {
    // remove # and convert
    const h = hex.replace('#','');
    const r = parseInt(h.substring(0,2),16);
    const g = parseInt(h.substring(2,4),16);
    const b = parseInt(h.substring(4,6),16);
    // luminance
    const lum = (0.299*r + 0.587*g + 0.114*b) / 255;
    return lum > 0.65 ? '#111' : '#fff';
  }
  // Helper: wrap text within a given width (draws multi-line if necessary)
  function wrapFillText(ctx, text, x, y, maxWidth, lineHeight) {
    const words = (text || '').split(/\s+/);
    if (words.length === 0) return;
    let line = '';
    const lines = [];
    for (let n = 0; n < words.length; n++) {
      const testLine = line ? line + ' ' + words[n] : words[n];
      const metrics = ctx.measureText(testLine);
      if (metrics.width > maxWidth && line) {
        lines.push(line);
        line = words[n];
      } else {
        line = testLine;
      }
    }
    if (line) lines.push(line);
    // If still too many lines, just draw what's possible (we rely on font size)
    for (let i=0;i<lines.length;i++){
      ctx.fillText(lines[i], x, y + (i - (lines.length-1)/2) * lineHeight);
    }
  }
  // UI glue
  document.addEventListener('DOMContentLoaded', () => {
    const canvas = document.getElementById('wheelCanvas');
    const wheel = new Wheel(canvas, { theme: 'light', onResult: onWinner });
    const nameInput = document.getElementById('nameInput');
    const addBtn = document.getElementById('addBtn');
    const addRandomBtn = document.getElementById('addRandomBtn');
    const bulkInput = document.getElementById('bulkInput');
    const bulkAddBtn = document.getElementById('bulkAddBtn');
    const clearBulkBtn = document.getElementById('clearBulkBtn');
    const nameList = document.getElementById('nameList');
    const countSpan = document.getElementById('count');
    const spinBtn = document.getElementById('spinBtn');
    const rerollBtn = document.getElementById('rerollBtn');
    const clearNamesBtn = document.getElementById('clearNamesBtn');
    const themeSelect = document.getElementById('themeSelect');
    const resultSection = document.getElementById('result');
    const winnerNameDiv = document.getElementById('winnerName');
    const exportBtn = document.getElementById('exportBtn');
    const importBtn = document.getElementById('importBtn');
    const importFile = document.getElementById('importFile');
    // Initial draw
    wheel.draw();
    function updateUI() {
      const names = wheel.names;
      countSpan.textContent = names.length;
      renderNameList();
    }
    function renderNameList() {
      nameList.innerHTML = '';
      wheel.names.forEach((n, i) => {
        const li = document.createElement('li');
        const span = document.createElement('span');
        span.textContent = n;
        li.appendChild(span);
        const btn = document.createElement('button');
        btn.title = 'Remove';
        btn.setAttribute('aria-label', `Remove ${n}`);
        btn.innerHTML = '✕';
        btn.addEventListener('click', () => {
          wheel.removeName(i);
          updateUI();
        });
        li.appendChild(btn);
        nameList.appendChild(li);
      });
    }
    function addNameFromInput() {
      const v = nameInput.value.trim();
      if (!v) { showMessage('Please enter a name.', 'warn'); return; }
      wheel.addName(v);
      nameInput.value = '';
      updateUI();
    }
    addBtn.addEventListener('click', addNameFromInput);
    nameInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') addNameFromInput(); });
    addRandomBtn.addEventListener('click', () => {
      const samples = ['Alex','Jordan','Taylor','Sam','Jamie','Casey','Morgan','Riley','Avery','Dana'];
      const count = rand(3,6);
      for (let i=0;i<count;i++) wheel.addName(samples[rand(0,samples.length-1)] + (rand(1,100)));
      updateUI();
    });
    bulkAddBtn.addEventListener('click', () => {
      const text = bulkInput.value.trim();
      if (!text) { showMessage('Bulk input is empty.', 'warn'); return; }
      const parsed = text.split(/[\n,;]+/).map(s => s.trim()).filter(s => s);
      parsed.forEach(p => wheel.addName(p));
      bulkInput.value = '';
      updateUI();
      showMessage(`Added ${parsed.length} names.`, 'info');
    });
    clearBulkBtn.addEventListener('click', () => { bulkInput.value = ''; });
    spinBtn.addEventListener('click', () => {
      if (wheel.names.length === 0) { showMessage('Add at least one name to spin.', 'warn'); return; }
      resultSection.hidden = true;
      winnerNameDiv.textContent = '';
      wheel.spin();
      spinBtn.disabled = true;
      const checkFinish = setInterval(() => {
        if (!wheel.isSpinning) {
          clearInterval(checkFinish);
          spinBtn.disabled = false;
        }
      }, 200);
    });
    rerollBtn.addEventListener('click', () => {
      resultSection.hidden = true;
      wheel.spin();
    });
    clearNamesBtn.addEventListener('click', () => {
      if (confirm('Clear all names?')) {
        wheel.clearNames();
        updateUI();
      }
    });
    themeSelect.addEventListener('change', (e) => {
      const t = e.target.value;
      document.body.className = 'theme-' + t;
      wheel.setTheme(t);
    });
    function onWinner(result) {
      winnerNameDiv.textContent = result.name || '—';
      resultSection.hidden = false;
      // Flash the winner item in the list (if still present)
      const items = Array.from(nameList.children);
      items.forEach((li, idx) => { li.classList.toggle('winner', idx === result.index); });
      showMessage(`Winner: ${result.name}`, 'success', 4000);
    }
    // Simple message area
    function showMessage(text, type = 'info', duration = 2200) {
      // create small toast
      const t = document.createElement('div');
      t.className = 'tmp-toast ' + type;
      t.textContent = text;
      document.body.appendChild(t);
      // Force reflow to pick up transitions
      window.getComputedStyle(t).opacity;
      setTimeout(()=> { t.style.opacity = '0'; t.style.transform = 'translateY(-10px)'; }, duration - 300);
      setTimeout(()=> { try { t.remove(); } catch(e){} }, duration);
    }
    // Export/import CSV
    exportBtn.addEventListener('click', () => {
      if (wheel.names.length === 0) { showMessage('No names to export.', 'warn'); return; }
      const csv = wheel.names.map(n => `"${(n||'').replace(/"/g,'""')}"`).join('\n');
      const blob = new Blob([csv], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'participants.csv';
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
      showMessage('Exported CSV', 'info');
    });
    importBtn.addEventListener('click', () => { importFile.click(); });
    importFile.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (ev) => {
        const txt = ev.target.result;
        const lines = txt.split(/\r?\n/).map(s => s.trim()).filter(s => s);
        // basic CSV unquote
        const parsed = lines.map(l => {
          // simple CSV single-column parse: handle quoted fields
          if (l.startsWith('"') && l.endsWith('"')) {
            return l.slice(1,-1).replace(/""/g,'"');
          }
          return l;
        });
        parsed.forEach(p => wheel.addName(p));
        updateUI();
        showMessage(`Imported ${parsed.length} names`, 'info');
      };
      reader.readAsText(file);
      importFile.value = '';
    });
    // Initial sample (optional)
    // wheel.addName('Alice'); wheel.addName('Bob'); wheel.addName('Charlie');
    updateUI();
    // (Optional) keyboard shortcuts
    window.addEventListener('keydown', (e) => {
      if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'k') {
        e.preventDefault();
        nameInput.focus();
      }
      if (e.key === ' ') {
        // space triggers spin if not focusing an input
        if (document.activeElement.tagName !== 'INPUT' && document.activeElement.tagName !== 'TEXTAREA') {
          e.preventDefault();
          spinBtn.click();
        }
      }
    });
  });
})(); 
```

"
Comments on Codes:
"<CRITICAL> The files contain literal Python-style triple-quoted DOCSTRING blocks (''' ... ''') at the top of index.html, styles.css and script.js. Those triple-single-quote lines are not valid HTML/CSS/JS and will break parsing — the site will fail to load or script/style will not be applied. Fix immediately by replacing them with proper comments or removing them.

Why this is highest priority:
- Browsers will try to interpret those lines as part of the document and will throw syntax errors (CSS/JS), so nothing else will work even if all logic is correct.

How to fix (step-by-step):
1. index.html
   - Remove the block that starts with '''DOCSTRING and ends with ''' (or convert it to an HTML comment).
   - Replace with an HTML comment if you want to keep the documentation. Example:
     <!--
       This is the main HTML file for the Random Winner Wheel.
       It contains the structure: input fields to add names, a canvas for the wheel,
       controls (spin, clear, bulk add), theme selector, and placeholders for CSS/JS.
     -->
   - Ensure the file begins with <!doctype html> (no stray quotes/characters before it).

2. styles.css
   - Remove the leading triple-quoted string and convert it to a CSS comment:
     /*
       Stylesheet for the Random Winner Wheel.
       Defines layout, themes, wheel container sizing, animations, and toast styles.
     */
   - Make sure no remaining ''' lines exist anywhere in the CSS.

3. script.js
   - Remove all '''DOCSTRING''' lines and any duplicated triple quotes. Replace them with JS block comments:
     /*
       Script for the Random Winner Wheel.
       Contains the Wheel class to draw and spin the canvas-based wheel and UI glue code to manage names and themes.
     */
   - There are two occurrences of identical docstrings at the top of the JS — keep just one proper comment block, remove duplicates.
   - Verify there are no stray single or triple quote lines that would create unterminated strings.

4. After replacing/removing:
   - Open the browser DevTools console and check for errors (SyntaxError, CSS parse errors).
   - Verify:
     - CSS is applied (themes change UI colors).
     - JS loads and console does not show parse errors.
     - UI buttons (Add, Bulk Add, Spin, Import/Export) function as expected.

Optional additional sanity checks (recommended):
- Search the whole project for any remaining ''' occurrences and remove them.
- Run the page locally (open index.html) and test:
  - Add names, bulk add, sample add.
  - Switch themes and confirm wheel color palette updates.
  - Spin and confirm winner appears and list highlights.
  - Export/import CSV works as expected.
- If you keep descriptive headers, prefer consistent comment style per file type (HTML <!-- -->, CSS /* */ and JS /* */ or //).

Implementing these replacements will resolve the critical syntax errors preventing the site from running."
In the software, each file must strictly follow a markdown code block format, where the following tokens must be replaced such that "FILENAME" is the lowercase file name including the file extension, "LANGUAGE" in the programming language, "DOCSTRING" is a string literal specified in source code that is used to document a specific segment of code, and "CODE" is the original code. Format:
FILENAME
```LANGUAGE
'''
DOCSTRING
'''
CODE
```
As the Programmer, to satisfy the new user's demand and make the software creative, executive and robust, you should modify corresponding codes according to the comments. Then, output the full and complete codes with all bugs fixed based on the comments. Return all codes strictly following the required format.

[2025-17-09 13:47:48 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2025-17-09 13:47:48 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 7874
completion_tokens: 7940
total_tokens: 15814
cost: $-1.000000


[2025-17-09 13:47:49 INFO] Programmer: **Programmer<->Code Reviewer on : CodeReviewModification, turn 0**

[ChatDev is a software company powered by multiple intelligent agents, such as chief executive officer, chief human resources officer, chief product officer, chief technology officer, etc, with a multi-agent organizational structure and the mission of 'changing the digital world through programming'.
You are Code Reviewer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer.
You can help programmers to assess source codes for software troubleshooting, fix bugs to increase code quality and robustness, and offer proposals to improve the source codes.
Here is a new customer's task: [Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes. Do it in HTML, CSS, and JavaScript.].
To complete the task, you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]

index.html
```html
'''
This is the main HTML file for the Random Winner Wheel.
It contains the structure: input fields to add names, a canvas for the wheel,
controls (spin, clear, bulk add), theme selector, and placeholders for CSS/JS.
'''
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Random Winner Wheel</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body class="theme-light">
  <!--
    This is the main HTML file for the Random Winner Wheel.
    It contains the structure: input fields to add names, a canvas for the wheel,
    controls (spin, clear, bulk add), theme selector, and placeholders for CSS/JS.
  -->
  <header>
    <h1>Random Winner Wheel</h1>
    <p>Enter participant names, choose a theme, and spin to pick a winner.</p>
  </header>
  <main>
    <section class="controls">
      <div class="add-single">
        <input id="nameInput" type="text" placeholder="Enter a name and press Add" aria-label="Name input" />
        <button id="addBtn">Add</button>
        <button id="addRandomBtn" title="Add a few sample random names">Add Sample</button>
      </div>
      <div class="bulk-add">
        <label for="bulkInput">Bulk add (comma, newline or semicolon separated):</label>
        <textarea id="bulkInput" placeholder="Alice, Bob, Charlie"></textarea>
        <div class="bulk-actions">
          <button id="bulkAddBtn">Bulk Add</button>
          <button id="clearBulkBtn">Clear Bulk</button>
        </div>
      </div>
      <div class="list-actions">
        <div class="theme-select">
          <label for="themeSelect">Theme:</label>
          <select id="themeSelect">
            <option value="light">Light</option>
            <option value="dark">Dark</option>
            <option value="neon">Neon</option>
            <option value="pastel">Pastel</option>
            <option value="retro">Retro</option>
          </select>
        </div>
        <div class="wheel-controls">
          <button id="spinBtn" class="primary">Spin</button>
          <button id="clearNamesBtn">Clear Names</button>
          <button id="exportBtn">Export CSV</button>
          <input id="importFile" type="file" accept=".csv,text/csv" style="display:none">
          <button id="importBtn">Import CSV</button>
        </div>
      </div>
    </section>
    <section class="wheel-area">
      <div class="wheel-container">
        <canvas id="wheelCanvas" width="600" height="600" aria-label="Spinning wheel"></canvas>
        <div class="pointer" aria-hidden="true">▼</div>
      </div>
      <aside class="participants">
        <h2>Participants (<span id="count">0</span>)</h2>
        <ul id="nameList" aria-live="polite"></ul>
      </aside>
    </section>
    <section class="result" id="result" aria-live="polite" hidden>
      <h2>Winner</h2>
      <div id="winnerName" class="winnerName"></div>
      <button id="rerollBtn">Spin Again</button>
    </section>
  </main>
  <footer>
    <small>Built with HTML, CSS, and JavaScript. Themes change both UI and wheel colors.</small>
  </footer>
  <script src="script.js"></script>
</body>
</html>
```

styles.css
```css
'''
Stylesheet for the Random Winner Wheel.
Defines layout, themes, wheel container sizing, animations, and toast styles.
'''
/*
 Stylesheet for the Random Winner Wheel.
 Defines layout, themes, wheel container sizing, animations, and toast styles.
*/
/* Reset & base */
* { box-sizing: border-box; margin: 0; padding: 0; }
html,body { height: 100%; font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; background: var(--bg); color: var(--fg); }
:root {
  --bg: #f7f8fb;
  --fg: #222;
  --muted: #666;
  --accent: #2b8cff;
  --card: #ffffff;
  --primary-btn-bg: var(--accent);
  --primary-btn-fg: #fff;
  --shadow: rgba(15,15,15,0.08);
}
/* Themes */
body.theme-light {
  --bg: #f7f8fb;
  --fg: #222;
  --muted: #5b6170;
  --accent: #2b8cff;
  --card: #fff;
  --wheel-seq: 0;
}
body.theme-dark {
  --bg: #0f1724;
  --fg: #e6eef8;
  --muted: #a9b1c2;
  --accent: #7c5cff;
  --card: #0b1220;
}
body.theme-neon {
  --bg: #0a0a0f;
  --fg: #e9f9ff;
  --muted: #a6f3ff;
  --accent: #39ff14;
  --card: #09101a;
}
body.theme-pastel {
  --bg: #fffaf6;
  --fg: #3c3a3a;
  --muted: #8d8a8a;
  --accent: #ff7aa2;
  --card: #fff;
}
body.theme-retro {
  --bg: #fff6e7;
  --fg: #402b2b;
  --muted: #856e6e;
  --accent: #ffb86b;
  --card: #fff0e6;
}
/* Layout */
header { padding: 18px 24px; text-align: center; background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent); }
header h1 { font-size: 1.5rem; margin-bottom: 6px; }
main { padding: 18px; max-width: 1100px; margin: 0 auto; }
.controls { display: grid; gap: 12px; margin-bottom: 18px; }
.add-single { display:flex; gap:8px; }
.add-single input[type="text"] { flex:1; padding:10px; border-radius:8px; border:1px solid rgba(0,0,0,0.08); background:var(--card); color:var(--fg); }
.add-single button { padding:10px 12px; border-radius:8px; border: none; cursor:pointer; background: var(--primary-btn-bg); color: var(--primary-btn-fg); }
.add-single button#addRandomBtn { background: transparent; border: 1px solid rgba(0,0,0,0.06); color: var(--fg); }
.bulk-add textarea { width:100%; min-height:64px; margin-top:6px; padding:8px; border-radius:8px; border:1px solid rgba(0,0,0,0.06); background:var(--card); color:var(--fg); }
.bulk-actions { display:flex; gap:8px; margin-top:8px; }
.list-actions { display:flex; justify-content:space-between; align-items:center; gap:16px; flex-wrap:wrap; }
.theme-select select { padding:8px; border-radius:8px; border:1px solid rgba(0,0,0,0.06); }
.wheel-area { display:flex; gap:18px; align-items:start; flex-wrap:wrap; }
.wheel-container { position: relative; width: 600px; height: 600px; max-width: 90vw; max-height: 90vw; display:flex; align-items:center; justify-content:center; background: transparent; }
.pointer {
  /* Centered triangular pointer positioned above the wheel.
     This ensures the visual pointer aligns with the wheel math (top-center).
     Hides the fallback glyph in the HTML and draws a sharp triangle instead. */
  position: absolute;
  top: 8px;               /* vertical offset from top of wheel container */
  left: 50%;              /* center horizontally */
  transform: translateX(-50%); /* center on the X axis */
  width: 0;
  height: 0;
  border-left: 12px solid transparent;
  border-right: 12px solid transparent;
  border-bottom: 18px solid var(--accent);
  z-index: 10;            /* ensure it's above the canvas */
  pointer-events: none;
  /* hide textual glyph fallback content (the ▼ in HTML) */
  font-size: 0;
  line-height: 0;
  text-indent: -9999px;
}
/* Participants panel and wheel styles */
.participants { width: 320px; max-width: 40vw; background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent); padding:12px; border-radius:10px; box-shadow: 0 6px 18px var(--shadow); }
.participants h2 { margin-bottom:8px; font-size:1.05rem; }
#nameList { list-style:none; max-height:420px; overflow:auto; display:block; }
#nameList li { padding:8px; border-radius:6px; display:flex; justify-content:space-between; align-items:center; gap:8px; margin-bottom:8px; background: var(--card); border:1px solid rgba(0,0,0,0.04); }
#nameList li button { background: transparent; border: none; color: var(--muted); cursor:pointer; }
.result { margin-top:18px; padding:12px; border-radius:8px; background: var(--card); text-align:center; box-shadow: 0 6px 18px var(--shadow); }
.result .winnerName { font-size:1.4rem; font-weight:700; margin:8px 0; color: var(--accent); }
/* Buttons */
button { cursor:pointer; padding:8px 12px; border-radius:8px; border:1px solid rgba(0,0,0,0.06); background: transparent; color:var(--fg); }
button.primary { background: var(--primary-btn-bg); color: var(--primary-btn-fg); border: none; }
/* Responsive */
@media (max-width: 900px) {
  .wheel-area { flex-direction:column; align-items:center; }
  .participants { width: 100%; max-width: 100%; }
}
/* Wheel canvas scaling helper */
#wheelCanvas { border-radius:50%; box-shadow: 0 12px 26px rgba(0,0,0,0.12); background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.02), transparent); }
/* Toast / temporary message styles (used by showMessage) */
.tmp-toast {
  position: fixed;
  left: 50%;
  transform: translateX(-50%);
  top: 18px;
  background: rgba(0,0,0,0.85);
  color: #fff;
  padding: 8px 12px;
  border-radius: 6px;
  z-index: 9999;
  transition: opacity 0.25s, transform 0.25s;
  opacity: 1;
  pointer-events: none;
  font-size: 0.95rem;
  box-shadow: 0 6px 18px rgba(0,0,0,0.18);
}
.tmp-toast.success { background: rgba(56, 198, 123, 0.95); }
.tmp-toast.warn    { background: rgba(255, 159, 67, 0.95); color: #2b1500; }
.tmp-toast.info    { background: rgba(12, 74, 255, 0.95); }
/* Winner highlight for participants list */
#nameList li.winner {
  outline: 3px solid rgba(255,215,0,0.15);
  box-shadow: 0 6px 18px rgba(255,215,0,0.06);
  transform: scale(1.01);
}
```

script.js
```javascript
'''
Script for the Random Winner Wheel.
Contains the Wheel class to draw and spin the canvas-based wheel and UI glue code to manage names and themes.
'''
/*
 Script for the Random Winner Wheel.
 Contains the Wheel class to draw and spin the canvas-based wheel and UI glue code to manage names and themes.
*/
/* Main JavaScript - Wheel + UI logic */
(() => {
  // Utilities
  function rand(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }
  function easeOutCubic(t) { return 1 - Math.pow(1 - t, 3); }
  // Color palettes for themes (will be used to paint wheel segments)
  const THEME_PALETTES = {
    light: ['#FF8A80','#FFD180','#FFF59D','#C8E6C9','#80DEEA','#A7FFEB','#B39DDB','#90CAF9'],
    dark: ['#ff6b6b','#ffd166','#faff8e','#b9f6ca','#4dd0e1','#80cbc4','#b388ff','#64b5f6'],
    neon: ['#ff2d95','#7cff01','#00ffff','#ffdd00','#ff6a00','#00ff9e','#ff00ff','#47ffa2'],
    pastel: ['#ffdbe9','#fff0b3','#d1ffd6','#cfefff','#e7dfff','#ffd6e7','#fbe7d6','#e6f7ff'],
    retro: ['#ffb86b','#ffd3a8','#f3e2a9','#b8e0d2','#c0b9ff','#ffb6c1','#f6c49f','#c3d69b']
  };
  // Wheel class
  class Wheel {
    /*
    Manage wheel: drawing, recalculating segments, spinning animation, and determining winner.
    */
    constructor(canvas, options = {}) {
      this.canvas = canvas;
      this.ctx = canvas.getContext('2d');
      this.names = [];
      this.rotation = 0; // radians
      this.isSpinning = false;
      this.frame = null;
      this.onResult = options.onResult || function() {};
      this.theme = options.theme || 'light';
      this.padAngle = 0.02; // radians padding between segments
      this.textColor = '#111';
      this._devicePixelRatioFix();
      window.addEventListener('resize', () => { this._devicePixelRatioFix(); this.draw(); });
    }
    _devicePixelRatioFix() {
      const dpr = window.devicePixelRatio || 1;
      const rect = this.canvas.getBoundingClientRect();
      // If rect has zero size (canvas not yet laid out), use current width/height attributes as fallback
      const width = rect.width || (this.canvas.width / dpr);
      const height = rect.height || (this.canvas.height / dpr);
      this.canvas.width = width * dpr;
      this.canvas.height = height * dpr;
      this.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      this.centerX = width / 2;
      this.centerY = height / 2;
      this.radius = Math.min(width, height) / 2 - 18;
    }
    setTheme(themeId) { this.theme = themeId; this.draw(); }
    setNames(names) {
      this.names = names.slice();
      this.draw();
    }
    addName(name) {
      this.names.push(name);
      this.draw();
    }
    removeName(index) {
      if (index >= 0 && index < this.names.length) {
        this.names.splice(index,1);
        this.draw();
      }
    }
    clearNames() {
      this.names = [];
      this.draw();
    }
    draw() {
      const ctx = this.ctx;
      const w = this.canvas.width / (window.devicePixelRatio || 1);
      const h = this.canvas.height / (window.devicePixelRatio || 1);
      ctx.clearRect(0,0,w,h);
      ctx.save();
      ctx.translate(this.centerX, this.centerY);
      ctx.rotate(this.rotation);
      // draw segments
      const count = Math.max(this.names.length, 1);
      const palette = THEME_PALETTES[this.theme] || THEME_PALETTES.light;
      for (let i = 0; i < count; i++) {
        const start = (i / count) * Math.PI * 2;
        const end = ((i + 1) / count) * Math.PI * 2;
        ctx.beginPath();
        ctx.moveTo(0,0);
        ctx.arc(0,0,this.radius, start + this.padAngle, end - this.padAngle, false);
        ctx.closePath();
        const color = palette[i % palette.length];
        ctx.fillStyle = color;
        ctx.fill();
        ctx.strokeStyle = (i % 2 === 0) ? 'rgba(0,0,0,0.06)' : 'rgba(0,0,0,0.03)';
        ctx.lineWidth = 1;
        ctx.stroke();
        // draw text label
        const mid = (start + end) / 2;
        ctx.save();
        ctx.rotate(mid);
        ctx.translate(this.radius * 0.6, 0);
        ctx.rotate(Math.PI/2);
        ctx.fillStyle = getTextColor(color);
        ctx.font = `${Math.max(12, Math.min(22, this.radius / 8))}px sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        const label = (this.names.length === 0) ? 'Add names' : this.names[i % this.names.length];
        wrapFillText(ctx, label, 0, 0, this.radius * 0.5, 16);
        ctx.restore();
      }
      // draw center circle
      ctx.beginPath();
      ctx.arc(0,0, this.radius * 0.16, 0, Math.PI*2);
      ctx.fillStyle = 'rgba(255,255,255,0.9)';
      ctx.fill();
      ctx.strokeStyle = 'rgba(0,0,0,0.06)';
      ctx.stroke();
      ctx.restore();
      // draw outer ring (pointer side neutral)
      ctx.beginPath();
      ctx.arc(this.centerX, this.centerY, this.radius + 10, 0, Math.PI*2);
      ctx.strokeStyle = 'rgba(0,0,0,0.03)';
      ctx.lineWidth = 2;
      ctx.stroke();
    }
    spin() {
      if (this.isSpinning || this.names.length === 0) return;
      this.isSpinning = true;
      const count = this.names.length;
      // Determine random winner index to land on:
      const winnerIndex = rand(0, count - 1);
      // Calculate final rotation so that winner segment lines up with pointer at top (pointer at canvas top - rotation must align)
      // Our pointer is at the top (canvas 0 angle). The segment mid-angle for index i (without rotation) is ((i + 0.5)/count)*2pi
      const segmentMid = ((winnerIndex + 0.5) / count) * Math.PI * 2;
      // We want segmentMid + rotation_final == -Math.PI/2 (so it points at the top pointer), so rotation_final = -Math.PI/2 - segmentMid + 2pi*N
      const extraTurns = rand(5, 8); // full spins
      const rotationFinal = -Math.PI/2 - segmentMid + extraTurns * Math.PI * 2;
      const startRotation = this.rotation % (Math.PI * 2);
      const delta = rotationFinal - startRotation;
      const duration = 4000 + Math.random() * 1500; // ms
      const startTime = performance.now();
      const animate = (now) => {
        const elapsed = now - startTime;
        const t = Math.min(elapsed / duration, 1);
        const eased = easeOutCubic(t);
        this.rotation = startRotation + delta * eased;
        this.draw();
        if (t < 1) {
          this.frame = requestAnimationFrame(animate);
        } else {
          this.isSpinning = false;
          // Normalize rotation within 0..2pi
          this.rotation = ((this.rotation % (Math.PI*2)) + Math.PI*2) % (Math.PI*2);
          this.draw();
          // Compute final winner index again from rotation
          // finalAngle: the angle of the segment at pointer (0 at right, +counterclockwise). We compute a normalized angle that maps to segment index.
          const finalAngle = ((-this.rotation - Math.PI/2) % (Math.PI*2) + Math.PI*2) % (Math.PI*2);
          const resultingIndex = Math.floor((finalAngle / (Math.PI*2)) * count) % count;
          const winner = this.names[resultingIndex];
          this.onResult({ index: resultingIndex, name: winner });
        }
      };
      this.frame = requestAnimationFrame(animate);
    }
  }
  // Helper: pick readable text color for a background
  function getTextColor(hex) {
    // remove # and convert
    const h = hex.replace('#','');
    const r = parseInt(h.substring(0,2),16);
    const g = parseInt(h.substring(2,4),16);
    const b = parseInt(h.substring(4,6),16);
    // luminance
    const lum = (0.299*r + 0.587*g + 0.114*b) / 255;
    return lum > 0.65 ? '#111' : '#fff';
  }
  // Helper: wrap text within a given width (draws multi-line if necessary)
  function wrapFillText(ctx, text, x, y, maxWidth, lineHeight) {
    const words = (text || '').split(/\s+/);
    if (words.length === 0) return;
    let line = '';
    const lines = [];
    for (let n = 0; n < words.length; n++) {
      const testLine = line ? line + ' ' + words[n] : words[n];
      const metrics = ctx.measureText(testLine);
      if (metrics.width > maxWidth && line) {
        lines.push(line);
        line = words[n];
      } else {
        line = testLine;
      }
    }
    if (line) lines.push(line);
    // If still too many lines, just draw what's possible (we rely on font size)
    for (let i=0;i<lines.length;i++){
      ctx.fillText(lines[i], x, y + (i - (lines.length-1)/2) * lineHeight);
    }
  }
  // UI glue
  document.addEventListener('DOMContentLoaded', () => {
    const canvas = document.getElementById('wheelCanvas');
    const wheel = new Wheel(canvas, { theme: 'light', onResult: onWinner });
    const nameInput = document.getElementById('nameInput');
    const addBtn = document.getElementById('addBtn');
    const addRandomBtn = document.getElementById('addRandomBtn');
    const bulkInput = document.getElementById('bulkInput');
    const bulkAddBtn = document.getElementById('bulkAddBtn');
    const clearBulkBtn = document.getElementById('clearBulkBtn');
    const nameList = document.getElementById('nameList');
    const countSpan = document.getElementById('count');
    const spinBtn = document.getElementById('spinBtn');
    const rerollBtn = document.getElementById('rerollBtn');
    const clearNamesBtn = document.getElementById('clearNamesBtn');
    const themeSelect = document.getElementById('themeSelect');
    const resultSection = document.getElementById('result');
    const winnerNameDiv = document.getElementById('winnerName');
    const exportBtn = document.getElementById('exportBtn');
    const importBtn = document.getElementById('importBtn');
    const importFile = document.getElementById('importFile');
    // Initial draw
    wheel.draw();
    function updateUI() {
      const names = wheel.names;
      countSpan.textContent = names.length;
      renderNameList();
    }
    function renderNameList() {
      nameList.innerHTML = '';
      wheel.names.forEach((n, i) => {
        const li = document.createElement('li');
        const span = document.createElement('span');
        span.textContent = n;
        li.appendChild(span);
        const btn = document.createElement('button');
        btn.title = 'Remove';
        btn.setAttribute('aria-label', `Remove ${n}`);
        btn.innerHTML = '✕';
        btn.addEventListener('click', () => {
          wheel.removeName(i);
          updateUI();
        });
        li.appendChild(btn);
        nameList.appendChild(li);
      });
    }
    function addNameFromInput() {
      const v = nameInput.value.trim();
      if (!v) { showMessage('Please enter a name.', 'warn'); return; }
      wheel.addName(v);
      nameInput.value = '';
      updateUI();
    }
    addBtn.addEventListener('click', addNameFromInput);
    nameInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') addNameFromInput(); });
    addRandomBtn.addEventListener('click', () => {
      const samples = ['Alex','Jordan','Taylor','Sam','Jamie','Casey','Morgan','Riley','Avery','Dana'];
      const count = rand(3,6);
      for (let i=0;i<count;i++) wheel.addName(samples[rand(0,samples.length-1)] + (rand(1,100)));
      updateUI();
    });
    bulkAddBtn.addEventListener('click', () => {
      const text = bulkInput.value.trim();
      if (!text) { showMessage('Bulk input is empty.', 'warn'); return; }
      const parsed = text.split(/[\n,;]+/).map(s => s.trim()).filter(s => s);
      parsed.forEach(p => wheel.addName(p));
      bulkInput.value = '';
      updateUI();
      showMessage(`Added ${parsed.length} names.`, 'info');
    });
    clearBulkBtn.addEventListener('click', () => { bulkInput.value = ''; });
    spinBtn.addEventListener('click', () => {
      if (wheel.names.length === 0) { showMessage('Add at least one name to spin.', 'warn'); return; }
      resultSection.hidden = true;
      winnerNameDiv.textContent = '';
      wheel.spin();
      spinBtn.disabled = true;
      const checkFinish = setInterval(() => {
        if (!wheel.isSpinning) {
          clearInterval(checkFinish);
          spinBtn.disabled = false;
        }
      }, 200);
    });
    rerollBtn.addEventListener('click', () => {
      resultSection.hidden = true;
      wheel.spin();
    });
    clearNamesBtn.addEventListener('click', () => {
      if (confirm('Clear all names?')) {
        wheel.clearNames();
        updateUI();
      }
    });
    themeSelect.addEventListener('change', (e) => {
      const t = e.target.value;
      document.body.className = 'theme-' + t;
      wheel.setTheme(t);
    });
    function onWinner(result) {
      winnerNameDiv.textContent = result.name || '—';
      resultSection.hidden = false;
      // Flash the winner item in the list (if still present)
      const items = Array.from(nameList.children);
      items.forEach((li, idx) => { li.classList.toggle('winner', idx === result.index); });
      showMessage(`Winner: ${result.name}`, 'success', 4000);
    }
    // Simple message area
    function showMessage(text, type = 'info', duration = 2200) {
      // create small toast
      const t = document.createElement('div');
      t.className = 'tmp-toast ' + type;
      t.textContent = text;
      document.body.appendChild(t);
      // Force reflow to pick up transitions
      window.getComputedStyle(t).opacity;
      setTimeout(()=> { t.style.opacity = '0'; t.style.transform = 'translateY(-10px)'; }, duration - 300);
      setTimeout(()=> { try { t.remove(); } catch(e){} }, duration);
    }
    // Export/import CSV
    exportBtn.addEventListener('click', () => {
      if (wheel.names.length === 0) { showMessage('No names to export.', 'warn'); return; }
      const csv = wheel.names.map(n => `"${(n||'').replace(/"/g,'""')}"`).join('\n');
      const blob = new Blob([csv], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'participants.csv';
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
      showMessage('Exported CSV', 'info');
    });
    importBtn.addEventListener('click', () => { importFile.click(); });
    importFile.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (ev) => {
        const txt = ev.target.result;
        const lines = txt.split(/\r?\n/).map(s => s.trim()).filter(s => s);
        // basic CSV unquote
        const parsed = lines.map(l => {
          // simple CSV single-column parse: handle quoted fields
          if (l.startsWith('"') && l.endsWith('"')) {
            return l.slice(1,-1).replace(/""/g,'"');
          }
          return l;
        });
        parsed.forEach(p => wheel.addName(p));
        updateUI();
        showMessage(`Imported ${parsed.length} names`, 'info');
      };
      reader.readAsText(file);
      importFile.value = '';
    });
    // Initial sample (optional)
    // wheel.addName('Alice'); wheel.addName('Bob'); wheel.addName('Charlie');
    updateUI();
    // (Optional) keyboard shortcuts
    window.addEventListener('keydown', (e) => {
      if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'k') {
        e.preventDefault();
        nameInput.focus();
      }
      if (e.key === ' ') {
        // space triggers spin if not focusing an input
        if (document.activeElement.tagName !== 'INPUT' && document.activeElement.tagName !== 'TEXTAREA') {
          e.preventDefault();
          spinBtn.click();
        }
      }
    });
  });
})(); 
```

[2025-17-09 13:47:49 INFO] **[Seminar Conclusion]**:

 index.html
```html
'''
This is the main HTML file for the Random Winner Wheel.
It contains the structure: input fields to add names, a canvas for the wheel,
controls (spin, clear, bulk add), theme selector, and placeholders for CSS/JS.
'''
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Random Winner Wheel</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body class="theme-light">
  <!--
    This is the main HTML file for the Random Winner Wheel.
    It contains the structure: input fields to add names, a canvas for the wheel,
    controls (spin, clear, bulk add), theme selector, and placeholders for CSS/JS.
  -->
  <header>
    <h1>Random Winner Wheel</h1>
    <p>Enter participant names, choose a theme, and spin to pick a winner.</p>
  </header>
  <main>
    <section class="controls">
      <div class="add-single">
        <input id="nameInput" type="text" placeholder="Enter a name and press Add" aria-label="Name input" />
        <button id="addBtn">Add</button>
        <button id="addRandomBtn" title="Add a few sample random names">Add Sample</button>
      </div>
      <div class="bulk-add">
        <label for="bulkInput">Bulk add (comma, newline or semicolon separated):</label>
        <textarea id="bulkInput" placeholder="Alice, Bob, Charlie"></textarea>
        <div class="bulk-actions">
          <button id="bulkAddBtn">Bulk Add</button>
          <button id="clearBulkBtn">Clear Bulk</button>
        </div>
      </div>
      <div class="list-actions">
        <div class="theme-select">
          <label for="themeSelect">Theme:</label>
          <select id="themeSelect">
            <option value="light">Light</option>
            <option value="dark">Dark</option>
            <option value="neon">Neon</option>
            <option value="pastel">Pastel</option>
            <option value="retro">Retro</option>
          </select>
        </div>
        <div class="wheel-controls">
          <button id="spinBtn" class="primary">Spin</button>
          <button id="clearNamesBtn">Clear Names</button>
          <button id="exportBtn">Export CSV</button>
          <input id="importFile" type="file" accept=".csv,text/csv" style="display:none">
          <button id="importBtn">Import CSV</button>
        </div>
      </div>
    </section>
    <section class="wheel-area">
      <div class="wheel-container">
        <canvas id="wheelCanvas" width="600" height="600" aria-label="Spinning wheel"></canvas>
        <div class="pointer" aria-hidden="true">▼</div>
      </div>
      <aside class="participants">
        <h2>Participants (<span id="count">0</span>)</h2>
        <ul id="nameList" aria-live="polite"></ul>
      </aside>
    </section>
    <section class="result" id="result" aria-live="polite" hidden>
      <h2>Winner</h2>
      <div id="winnerName" class="winnerName"></div>
      <button id="rerollBtn">Spin Again</button>
    </section>
  </main>
  <footer>
    <small>Built with HTML, CSS, and JavaScript. Themes change both UI and wheel colors.</small>
  </footer>
  <script src="script.js"></script>
</body>
</html>
```

styles.css
```css
'''
Stylesheet for the Random Winner Wheel.
Defines layout, themes, wheel container sizing, animations, and toast styles.
'''
/*
 Stylesheet for the Random Winner Wheel.
 Defines layout, themes, wheel container sizing, animations, and toast styles.
*/
/* Reset & base */
* { box-sizing: border-box; margin: 0; padding: 0; }
html,body { height: 100%; font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; background: var(--bg); color: var(--fg); }
:root {
  --bg: #f7f8fb;
  --fg: #222;
  --muted: #666;
  --accent: #2b8cff;
  --card: #ffffff;
  --primary-btn-bg: var(--accent);
  --primary-btn-fg: #fff;
  --shadow: rgba(15,15,15,0.08);
}
/* Themes */
body.theme-light {
  --bg: #f7f8fb;
  --fg: #222;
  --muted: #5b6170;
  --accent: #2b8cff;
  --card: #fff;
  --wheel-seq: 0;
}
body.theme-dark {
  --bg: #0f1724;
  --fg: #e6eef8;
  --muted: #a9b1c2;
  --accent: #7c5cff;
  --card: #0b1220;
}
body.theme-neon {
  --bg: #0a0a0f;
  --fg: #e9f9ff;
  --muted: #a6f3ff;
  --accent: #39ff14;
  --card: #09101a;
}
body.theme-pastel {
  --bg: #fffaf6;
  --fg: #3c3a3a;
  --muted: #8d8a8a;
  --accent: #ff7aa2;
  --card: #fff;
}
body.theme-retro {
  --bg: #fff6e7;
  --fg: #402b2b;
  --muted: #856e6e;
  --accent: #ffb86b;
  --card: #fff0e6;
}
/* Layout */
header { padding: 18px 24px; text-align: center; background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent); }
header h1 { font-size: 1.5rem; margin-bottom: 6px; }
main { padding: 18px; max-width: 1100px; margin: 0 auto; }
.controls { display: grid; gap: 12px; margin-bottom: 18px; }
.add-single { display:flex; gap:8px; }
.add-single input[type="text"] { flex:1; padding:10px; border-radius:8px; border:1px solid rgba(0,0,0,0.08); background:var(--card); color:var(--fg); }
.add-single button { padding:10px 12px; border-radius:8px; border: none; cursor:pointer; background: var(--primary-btn-bg); color: var(--primary-btn-fg); }
.add-single button#addRandomBtn { background: transparent; border: 1px solid rgba(0,0,0,0.06); color: var(--fg); }
.bulk-add textarea { width:100%; min-height:64px; margin-top:6px; padding:8px; border-radius:8px; border:1px solid rgba(0,0,0,0.06); background:var(--card); color:var(--fg); }
.bulk-actions { display:flex; gap:8px; margin-top:8px; }
.list-actions { display:flex; justify-content:space-between; align-items:center; gap:16px; flex-wrap:wrap; }
.theme-select select { padding:8px; border-radius:8px; border:1px solid rgba(0,0,0,0.06); }
.wheel-area { display:flex; gap:18px; align-items:start; flex-wrap:wrap; }
.wheel-container { position: relative; width: 600px; height: 600px; max-width: 90vw; max-height: 90vw; display:flex; align-items:center; justify-content:center; background: transparent; }
.pointer {
  /* Centered triangular pointer positioned above the wheel.
     This ensures the visual pointer aligns with the wheel math (top-center).
     Hides the fallback glyph in the HTML and draws a sharp triangle instead. */
  position: absolute;
  top: 8px;               /* vertical offset from top of wheel container */
  left: 50%;              /* center horizontally */
  transform: translateX(-50%); /* center on the X axis */
  width: 0;
  height: 0;
  border-left: 12px solid transparent;
  border-right: 12px solid transparent;
  border-bottom: 18px solid var(--accent);
  z-index: 10;            /* ensure it's above the canvas */
  pointer-events: none;
  /* hide textual glyph fallback content (the ▼ in HTML) */
  font-size: 0;
  line-height: 0;
  text-indent: -9999px;
}
/* Participants panel and wheel styles */
.participants { width: 320px; max-width: 40vw; background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent); padding:12px; border-radius:10px; box-shadow: 0 6px 18px var(--shadow); }
.participants h2 { margin-bottom:8px; font-size:1.05rem; }
#nameList { list-style:none; max-height:420px; overflow:auto; display:block; }
#nameList li { padding:8px; border-radius:6px; display:flex; justify-content:space-between; align-items:center; gap:8px; margin-bottom:8px; background: var(--card); border:1px solid rgba(0,0,0,0.04); }
#nameList li button { background: transparent; border: none; color: var(--muted); cursor:pointer; }
.result { margin-top:18px; padding:12px; border-radius:8px; background: var(--card); text-align:center; box-shadow: 0 6px 18px var(--shadow); }
.result .winnerName { font-size:1.4rem; font-weight:700; margin:8px 0; color: var(--accent); }
/* Buttons */
button { cursor:pointer; padding:8px 12px; border-radius:8px; border:1px solid rgba(0,0,0,0.06); background: transparent; color:var(--fg); }
button.primary { background: var(--primary-btn-bg); color: var(--primary-btn-fg); border: none; }
/* Responsive */
@media (max-width: 900px) {
  .wheel-area { flex-direction:column; align-items:center; }
  .participants { width: 100%; max-width: 100%; }
}
/* Wheel canvas scaling helper */
#wheelCanvas { border-radius:50%; box-shadow: 0 12px 26px rgba(0,0,0,0.12); background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.02), transparent); }
/* Toast / temporary message styles (used by showMessage) */
.tmp-toast {
  position: fixed;
  left: 50%;
  transform: translateX(-50%);
  top: 18px;
  background: rgba(0,0,0,0.85);
  color: #fff;
  padding: 8px 12px;
  border-radius: 6px;
  z-index: 9999;
  transition: opacity 0.25s, transform 0.25s;
  opacity: 1;
  pointer-events: none;
  font-size: 0.95rem;
  box-shadow: 0 6px 18px rgba(0,0,0,0.18);
}
.tmp-toast.success { background: rgba(56, 198, 123, 0.95); }
.tmp-toast.warn    { background: rgba(255, 159, 67, 0.95); color: #2b1500; }
.tmp-toast.info    { background: rgba(12, 74, 255, 0.95); }
/* Winner highlight for participants list */
#nameList li.winner {
  outline: 3px solid rgba(255,215,0,0.15);
  box-shadow: 0 6px 18px rgba(255,215,0,0.06);
  transform: scale(1.01);
}
```

script.js
```javascript
'''
Script for the Random Winner Wheel.
Contains the Wheel class to draw and spin the canvas-based wheel and UI glue code to manage names and themes.
'''
/*
 Script for the Random Winner Wheel.
 Contains the Wheel class to draw and spin the canvas-based wheel and UI glue code to manage names and themes.
*/
/* Main JavaScript - Wheel + UI logic */
(() => {
  // Utilities
  function rand(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }
  function easeOutCubic(t) { return 1 - Math.pow(1 - t, 3); }
  // Color palettes for themes (will be used to paint wheel segments)
  const THEME_PALETTES = {
    light: ['#FF8A80','#FFD180','#FFF59D','#C8E6C9','#80DEEA','#A7FFEB','#B39DDB','#90CAF9'],
    dark: ['#ff6b6b','#ffd166','#faff8e','#b9f6ca','#4dd0e1','#80cbc4','#b388ff','#64b5f6'],
    neon: ['#ff2d95','#7cff01','#00ffff','#ffdd00','#ff6a00','#00ff9e','#ff00ff','#47ffa2'],
    pastel: ['#ffdbe9','#fff0b3','#d1ffd6','#cfefff','#e7dfff','#ffd6e7','#fbe7d6','#e6f7ff'],
    retro: ['#ffb86b','#ffd3a8','#f3e2a9','#b8e0d2','#c0b9ff','#ffb6c1','#f6c49f','#c3d69b']
  };
  // Wheel class
  class Wheel {
    /*
    Manage wheel: drawing, recalculating segments, spinning animation, and determining winner.
    */
    constructor(canvas, options = {}) {
      this.canvas = canvas;
      this.ctx = canvas.getContext('2d');
      this.names = [];
      this.rotation = 0; // radians
      this.isSpinning = false;
      this.frame = null;
      this.onResult = options.onResult || function() {};
      this.theme = options.theme || 'light';
      this.padAngle = 0.02; // radians padding between segments
      this.textColor = '#111';
      this._devicePixelRatioFix();
      window.addEventListener('resize', () => { this._devicePixelRatioFix(); this.draw(); });
    }
    _devicePixelRatioFix() {
      const dpr = window.devicePixelRatio || 1;
      const rect = this.canvas.getBoundingClientRect();
      // If rect has zero size (canvas not yet laid out), use current width/height attributes as fallback
      const width = rect.width || (this.canvas.width / dpr);
      const height = rect.height || (this.canvas.height / dpr);
      this.canvas.width = width * dpr;
      this.canvas.height = height * dpr;
      this.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      this.centerX = width / 2;
      this.centerY = height / 2;
      this.radius = Math.min(width, height) / 2 - 18;
    }
    setTheme(themeId) { this.theme = themeId; this.draw(); }
    setNames(names) {
      this.names = names.slice();
      this.draw();
    }
    addName(name) {
      this.names.push(name);
      this.draw();
    }
    removeName(index) {
      if (index >= 0 && index < this.names.length) {
        this.names.splice(index,1);
        this.draw();
      }
    }
    clearNames() {
      this.names = [];
      this.draw();
    }
    draw() {
      const ctx = this.ctx;
      const w = this.canvas.width / (window.devicePixelRatio || 1);
      const h = this.canvas.height / (window.devicePixelRatio || 1);
      ctx.clearRect(0,0,w,h);
      ctx.save();
      ctx.translate(this.centerX, this.centerY);
      ctx.rotate(this.rotation);
      // draw segments
      const count = Math.max(this.names.length, 1);
      const palette = THEME_PALETTES[this.theme] || THEME_PALETTES.light;
      for (let i = 0; i < count; i++) {
        const start = (i / count) * Math.PI * 2;
        const end = ((i + 1) / count) * Math.PI * 2;
        ctx.beginPath();
        ctx.moveTo(0,0);
        ctx.arc(0,0,this.radius, start + this.padAngle, end - this.padAngle, false);
        ctx.closePath();
        const color = palette[i % palette.length];
        ctx.fillStyle = color;
        ctx.fill();
        ctx.strokeStyle = (i % 2 === 0) ? 'rgba(0,0,0,0.06)' : 'rgba(0,0,0,0.03)';
        ctx.lineWidth = 1;
        ctx.stroke();
        // draw text label
        const mid = (start + end) / 2;
        ctx.save();
        ctx.rotate(mid);
        ctx.translate(this.radius * 0.6, 0);
        ctx.rotate(Math.PI/2);
        ctx.fillStyle = getTextColor(color);
        ctx.font = `${Math.max(12, Math.min(22, this.radius / 8))}px sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        const label = (this.names.length === 0) ? 'Add names' : this.names[i % this.names.length];
        wrapFillText(ctx, label, 0, 0, this.radius * 0.5, 16);
        ctx.restore();
      }
      // draw center circle
      ctx.beginPath();
      ctx.arc(0,0, this.radius * 0.16, 0, Math.PI*2);
      ctx.fillStyle = 'rgba(255,255,255,0.9)';
      ctx.fill();
      ctx.strokeStyle = 'rgba(0,0,0,0.06)';
      ctx.stroke();
      ctx.restore();
      // draw outer ring (pointer side neutral)
      ctx.beginPath();
      ctx.arc(this.centerX, this.centerY, this.radius + 10, 0, Math.PI*2);
      ctx.strokeStyle = 'rgba(0,0,0,0.03)';
      ctx.lineWidth = 2;
      ctx.stroke();
    }
    spin() {
      if (this.isSpinning || this.names.length === 0) return;
      this.isSpinning = true;
      const count = this.names.length;
      // Determine random winner index to land on:
      const winnerIndex = rand(0, count - 1);
      // Calculate final rotation so that winner segment lines up with pointer at top (pointer at canvas top - rotation must align)
      // Our pointer is at the top (canvas 0 angle). The segment mid-angle for index i (without rotation) is ((i + 0.5)/count)*2pi
      const segmentMid = ((winnerIndex + 0.5) / count) * Math.PI * 2;
      // We want segmentMid + rotation_final == -Math.PI/2 (so it points at the top pointer), so rotation_final = -Math.PI/2 - segmentMid + 2pi*N
      const extraTurns = rand(5, 8); // full spins
      const rotationFinal = -Math.PI/2 - segmentMid + extraTurns * Math.PI * 2;
      const startRotation = this.rotation % (Math.PI * 2);
      const delta = rotationFinal - startRotation;
      const duration = 4000 + Math.random() * 1500; // ms
      const startTime = performance.now();
      const animate = (now) => {
        const elapsed = now - startTime;
        const t = Math.min(elapsed / duration, 1);
        const eased = easeOutCubic(t);
        this.rotation = startRotation + delta * eased;
        this.draw();
        if (t < 1) {
          this.frame = requestAnimationFrame(animate);
        } else {
          this.isSpinning = false;
          // Normalize rotation within 0..2pi
          this.rotation = ((this.rotation % (Math.PI*2)) + Math.PI*2) % (Math.PI*2);
          this.draw();
          // Compute final winner index again from rotation
          // finalAngle: the angle of the segment at pointer (0 at right, +counterclockwise). We compute a normalized angle that maps to segment index.
          const finalAngle = ((-this.rotation - Math.PI/2) % (Math.PI*2) + Math.PI*2) % (Math.PI*2);
          const resultingIndex = Math.floor((finalAngle / (Math.PI*2)) * count) % count;
          const winner = this.names[resultingIndex];
          this.onResult({ index: resultingIndex, name: winner });
        }
      };
      this.frame = requestAnimationFrame(animate);
    }
  }
  // Helper: pick readable text color for a background
  function getTextColor(hex) {
    // remove # and convert
    const h = hex.replace('#','');
    const r = parseInt(h.substring(0,2),16);
    const g = parseInt(h.substring(2,4),16);
    const b = parseInt(h.substring(4,6),16);
    // luminance
    const lum = (0.299*r + 0.587*g + 0.114*b) / 255;
    return lum > 0.65 ? '#111' : '#fff';
  }
  // Helper: wrap text within a given width (draws multi-line if necessary)
  function wrapFillText(ctx, text, x, y, maxWidth, lineHeight) {
    const words = (text || '').split(/\s+/);
    if (words.length === 0) return;
    let line = '';
    const lines = [];
    for (let n = 0; n < words.length; n++) {
      const testLine = line ? line + ' ' + words[n] : words[n];
      const metrics = ctx.measureText(testLine);
      if (metrics.width > maxWidth && line) {
        lines.push(line);
        line = words[n];
      } else {
        line = testLine;
      }
    }
    if (line) lines.push(line);
    // If still too many lines, just draw what's possible (we rely on font size)
    for (let i=0;i<lines.length;i++){
      ctx.fillText(lines[i], x, y + (i - (lines.length-1)/2) * lineHeight);
    }
  }
  // UI glue
  document.addEventListener('DOMContentLoaded', () => {
    const canvas = document.getElementById('wheelCanvas');
    const wheel = new Wheel(canvas, { theme: 'light', onResult: onWinner });
    const nameInput = document.getElementById('nameInput');
    const addBtn = document.getElementById('addBtn');
    const addRandomBtn = document.getElementById('addRandomBtn');
    const bulkInput = document.getElementById('bulkInput');
    const bulkAddBtn = document.getElementById('bulkAddBtn');
    const clearBulkBtn = document.getElementById('clearBulkBtn');
    const nameList = document.getElementById('nameList');
    const countSpan = document.getElementById('count');
    const spinBtn = document.getElementById('spinBtn');
    const rerollBtn = document.getElementById('rerollBtn');
    const clearNamesBtn = document.getElementById('clearNamesBtn');
    const themeSelect = document.getElementById('themeSelect');
    const resultSection = document.getElementById('result');
    const winnerNameDiv = document.getElementById('winnerName');
    const exportBtn = document.getElementById('exportBtn');
    const importBtn = document.getElementById('importBtn');
    const importFile = document.getElementById('importFile');
    // Initial draw
    wheel.draw();
    function updateUI() {
      const names = wheel.names;
      countSpan.textContent = names.length;
      renderNameList();
    }
    function renderNameList() {
      nameList.innerHTML = '';
      wheel.names.forEach((n, i) => {
        const li = document.createElement('li');
        const span = document.createElement('span');
        span.textContent = n;
        li.appendChild(span);
        const btn = document.createElement('button');
        btn.title = 'Remove';
        btn.setAttribute('aria-label', `Remove ${n}`);
        btn.innerHTML = '✕';
        btn.addEventListener('click', () => {
          wheel.removeName(i);
          updateUI();
        });
        li.appendChild(btn);
        nameList.appendChild(li);
      });
    }
    function addNameFromInput() {
      const v = nameInput.value.trim();
      if (!v) { showMessage('Please enter a name.', 'warn'); return; }
      wheel.addName(v);
      nameInput.value = '';
      updateUI();
    }
    addBtn.addEventListener('click', addNameFromInput);
    nameInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') addNameFromInput(); });
    addRandomBtn.addEventListener('click', () => {
      const samples = ['Alex','Jordan','Taylor','Sam','Jamie','Casey','Morgan','Riley','Avery','Dana'];
      const count = rand(3,6);
      for (let i=0;i<count;i++) wheel.addName(samples[rand(0,samples.length-1)] + (rand(1,100)));
      updateUI();
    });
    bulkAddBtn.addEventListener('click', () => {
      const text = bulkInput.value.trim();
      if (!text) { showMessage('Bulk input is empty.', 'warn'); return; }
      const parsed = text.split(/[\n,;]+/).map(s => s.trim()).filter(s => s);
      parsed.forEach(p => wheel.addName(p));
      bulkInput.value = '';
      updateUI();
      showMessage(`Added ${parsed.length} names.`, 'info');
    });
    clearBulkBtn.addEventListener('click', () => { bulkInput.value = ''; });
    spinBtn.addEventListener('click', () => {
      if (wheel.names.length === 0) { showMessage('Add at least one name to spin.', 'warn'); return; }
      resultSection.hidden = true;
      winnerNameDiv.textContent = '';
      wheel.spin();
      spinBtn.disabled = true;
      const checkFinish = setInterval(() => {
        if (!wheel.isSpinning) {
          clearInterval(checkFinish);
          spinBtn.disabled = false;
        }
      }, 200);
    });
    rerollBtn.addEventListener('click', () => {
      resultSection.hidden = true;
      wheel.spin();
    });
    clearNamesBtn.addEventListener('click', () => {
      if (confirm('Clear all names?')) {
        wheel.clearNames();
        updateUI();
      }
    });
    themeSelect.addEventListener('change', (e) => {
      const t = e.target.value;
      document.body.className = 'theme-' + t;
      wheel.setTheme(t);
    });
    function onWinner(result) {
      winnerNameDiv.textContent = result.name || '—';
      resultSection.hidden = false;
      // Flash the winner item in the list (if still present)
      const items = Array.from(nameList.children);
      items.forEach((li, idx) => { li.classList.toggle('winner', idx === result.index); });
      showMessage(`Winner: ${result.name}`, 'success', 4000);
    }
    // Simple message area
    function showMessage(text, type = 'info', duration = 2200) {
      // create small toast
      const t = document.createElement('div');
      t.className = 'tmp-toast ' + type;
      t.textContent = text;
      document.body.appendChild(t);
      // Force reflow to pick up transitions
      window.getComputedStyle(t).opacity;
      setTimeout(()=> { t.style.opacity = '0'; t.style.transform = 'translateY(-10px)'; }, duration - 300);
      setTimeout(()=> { try { t.remove(); } catch(e){} }, duration);
    }
    // Export/import CSV
    exportBtn.addEventListener('click', () => {
      if (wheel.names.length === 0) { showMessage('No names to export.', 'warn'); return; }
      const csv = wheel.names.map(n => `"${(n||'').replace(/"/g,'""')}"`).join('\n');
      const blob = new Blob([csv], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'participants.csv';
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
      showMessage('Exported CSV', 'info');
    });
    importBtn.addEventListener('click', () => { importFile.click(); });
    importFile.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (ev) => {
        const txt = ev.target.result;
        const lines = txt.split(/\r?\n/).map(s => s.trim()).filter(s => s);
        // basic CSV unquote
        const parsed = lines.map(l => {
          // simple CSV single-column parse: handle quoted fields
          if (l.startsWith('"') && l.endsWith('"')) {
            return l.slice(1,-1).replace(/""/g,'"');
          }
          return l;
        });
        parsed.forEach(p => wheel.addName(p));
        updateUI();
        showMessage(`Imported ${parsed.length} names`, 'info');
      };
      reader.readAsText(file);
      importFile.value = '';
    });
    // Initial sample (optional)
    // wheel.addName('Alice'); wheel.addName('Bob'); wheel.addName('Charlie');
    updateUI();
    // (Optional) keyboard shortcuts
    window.addEventListener('keydown', (e) => {
      if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'k') {
        e.preventDefault();
        nameInput.focus();
      }
      if (e.key === ' ') {
        // space triggers spin if not focusing an input
        if (document.activeElement.tagName !== 'INPUT' && document.activeElement.tagName !== 'TEXTAREA') {
          e.preventDefault();
          spinBtn.click();
        }
      }
    });
  });
})(); 
```

[2025-17-09 13:47:49 INFO] **[Update Codes]**

index.html updated.


```
'''

'''
--- Old
+++ New
@@ -1,5 +1,4 @@
 '''
-DOCSTRING
 This is the main HTML file for the Random Winner Wheel.
 It contains the structure: input fields to add names, a canvas for the wheel,
 controls (spin, clear, bulk add), theme selector, and placeholders for CSS/JS.
@@ -13,6 +12,11 @@
   <link rel="stylesheet" href="styles.css">
 </head>
 <body class="theme-light">
+  <!--
+    This is the main HTML file for the Random Winner Wheel.
+    It contains the structure: input fields to add names, a canvas for the wheel,
+    controls (spin, clear, bulk add), theme selector, and placeholders for CSS/JS.
+  -->
   <header>
     <h1>Random Winner Wheel</h1>
     <p>Enter participant names, choose a theme, and spin to pick a winner.</p>
```

[2025-17-09 13:47:49 INFO] **[Update Codes]**

styles.css updated.


```
'''

'''
--- Old
+++ New
@@ -1,8 +1,11 @@
 '''
-DOCSTRING
 Stylesheet for the Random Winner Wheel.
 Defines layout, themes, wheel container sizing, animations, and toast styles.
 '''
+/*
+ Stylesheet for the Random Winner Wheel.
+ Defines layout, themes, wheel container sizing, animations, and toast styles.
+*/
 /* Reset & base */
 * { box-sizing: border-box; margin: 0; padding: 0; }
 html,body { height: 100%; font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; background: var(--bg); color: var(--fg); }
```

[2025-17-09 13:47:49 INFO] **[Update Codes]**

script.js updated.


```
'''

'''
--- Old
+++ New
@@ -1,12 +1,10 @@
 '''
-DOCSTRING
 Script for the Random Winner Wheel.
 Contains the Wheel class to draw and spin the canvas-based wheel and UI glue code to manage names and themes.
 '''
-/* 
-DOCSTRING
-Script for the Random Winner Wheel.
-Contains the Wheel class to draw and spin the canvas-based wheel and UI glue code to manage names and themes.
+/*
+ Script for the Random Winner Wheel.
+ Contains the Wheel class to draw and spin the canvas-based wheel and UI glue code to manage names and themes.
 */
 /* Main JavaScript - Wheel + UI logic */
 (() => {
```

[2025-17-09 13:47:49 INFO] **[Software Info]**:

 

💰**cost**=$0.082360

🔨**version_updates**=-1

📃**num_code_files**=0

🏞**num_png_files**=0

📚**num_doc_files**=7

📃**code_lines**=0

📋**env_lines**=-1

📒**manual_lines**=-1

🗣**num_utterances**=19

🤔**num_self_reflections**=0

❓**num_prompt_tokens**=45934

❗**num_completion_tokens**=39595

🌟**num_total_tokens**=85529

[2025-17-09 13:47:49 INFO] **[Execute Detail]**

execute SimplePhase:[TestErrorSummary] in ComposedPhase:[Test], cycle 1

[2025-17-09 13:47:52 INFO] **[Test Reports]**:

The software run successfully without errors.

[2025-17-09 13:47:52 INFO] **[Test Info]**

AI User (Software Test Engineer):
Test Pass!


[2025-17-09 13:47:52 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | [Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes. Do it in HTML, CSS, and JavaScript.] |
| **need_reflect** | True |
| **assistant_role_name** | Programmer |
| **user_role_name** | Chief Technology Officer |
| **phase_prompt** | The new user's task and our developed codes are listed:  Task: "{task}". Modality: "{modality}". Programming Language: "{language}" Ideas: "{ideas}" Codes:  "{codes}" As the {assistant_role}, you should write a requirements.txt file, which is commonly used in Python projects to specify the dependencies or packages required for the project to run properly. It serves as a way to document and manage the project's dependencies in a standardized format. For example: requirements.txt ``` numpy==1.19.2 pandas&gt;=1.1.4 ``` According to the codes and file format listed above, write a requirements.txt file to specify the dependencies or packages required for the project to run properly. |
| **phase_name** | EnvironmentDoc |
| **assistant_role_prompt** | {chatdev_prompt} You are Programmer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. You can write/create computer software or applications by providing a specific programming language to the computer. You have extensive computing and coding experience in many varieties of programming languages and platforms, such as Python, Java, C, C++, HTML, CSS, JavaScript, XML, SQL, PHP, etc,. Here is a new customer's task: {task}. To complete the task, you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Chief Technology Officer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. You are very familiar to information technology. You will make high-level decisions for the overarching technology infrastructure that closely align with the organization's goals, while you work alongside the organization's information technology ("IT") staff members to perform everyday operations. Here is a new customer's task: {task}. To complete the task, You must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'task': '[Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes. Do it in HTML, CSS, and JavaScript.]', 'modality': 'website', 'ideas': '', 'language': ' JavaScript', 'codes': 'index.html\nhtml\n\'\'\'\nThis is the main HTML file for the Random Winner Wheel.\nIt contains the structure: input fields to add names, a canvas for the wheel,\ncontrols (spin, clear, bulk add), theme selector, and placeholders for CSS/JS.\n\'\'\'\n&lt;!doctype html&gt;\n&lt;html lang="en"&gt;\n&lt;head&gt;\n  &lt;meta charset="utf-8" /&gt;\n  &lt;meta name="viewport" content="width=device-width,initial-scale=1" /&gt;\n  &lt;title&gt;Random Winner Wheel&lt;/title&gt;\n  &lt;link rel="stylesheet" href="styles.css"&gt;\n&lt;/head&gt;\n&lt;body class="theme-light"&gt;\n  &lt;!--\n    This is the main HTML file for the Random Winner Wheel.\n    It contains the structure: input fields to add names, a canvas for the wheel,\n    controls (spin, clear, bulk add), theme selector, and placeholders for CSS/JS.\n  --&gt;\n  &lt;header&gt;\n    &lt;h1&gt;Random Winner Wheel&lt;/h1&gt;\n    &lt;p&gt;Enter participant names, choose a theme, and spin to pick a winner.&lt;/p&gt;\n  &lt;/header&gt;\n  &lt;main&gt;\n    &lt;section class="controls"&gt;\n      &lt;div class="add-single"&gt;\n        &lt;input id="nameInput" type="text" placeholder="Enter a name and press Add" aria-label="Name input" /&gt;\n        &lt;button id="addBtn"&gt;Add&lt;/button&gt;\n        &lt;button id="addRandomBtn" title="Add a few sample random names"&gt;Add Sample&lt;/button&gt;\n      &lt;/div&gt;\n      &lt;div class="bulk-add"&gt;\n        &lt;label for="bulkInput"&gt;Bulk add (comma, newline or semicolon separated):&lt;/label&gt;\n        &lt;textarea id="bulkInput" placeholder="Alice, Bob, Charlie"&gt;&lt;/textarea&gt;\n        &lt;div class="bulk-actions"&gt;\n          &lt;button id="bulkAddBtn"&gt;Bulk Add&lt;/button&gt;\n          &lt;button id="clearBulkBtn"&gt;Clear Bulk&lt;/button&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;\n      &lt;div class="list-actions"&gt;\n        &lt;div class="theme-select"&gt;\n          &lt;label for="themeSelect"&gt;Theme:&lt;/label&gt;\n          &lt;select id="themeSelect"&gt;\n            &lt;option value="light"&gt;Light&lt;/option&gt;\n            &lt;option value="dark"&gt;Dark&lt;/option&gt;\n            &lt;option value="neon"&gt;Neon&lt;/option&gt;\n            &lt;option value="pastel"&gt;Pastel&lt;/option&gt;\n            &lt;option value="retro"&gt;Retro&lt;/option&gt;\n          &lt;/select&gt;\n        &lt;/div&gt;\n        &lt;div class="wheel-controls"&gt;\n          &lt;button id="spinBtn" class="primary"&gt;Spin&lt;/button&gt;\n          &lt;button id="clearNamesBtn"&gt;Clear Names&lt;/button&gt;\n          &lt;button id="exportBtn"&gt;Export CSV&lt;/button&gt;\n          &lt;input id="importFile" type="file" accept=".csv,text/csv" style="display:none"&gt;\n          &lt;button id="importBtn"&gt;Import CSV&lt;/button&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;\n    &lt;/section&gt;\n    &lt;section class="wheel-area"&gt;\n      &lt;div class="wheel-container"&gt;\n        &lt;canvas id="wheelCanvas" width="600" height="600" aria-label="Spinning wheel"&gt;&lt;/canvas&gt;\n        &lt;div class="pointer" aria-hidden="true"&gt;▼&lt;/div&gt;\n      &lt;/div&gt;\n      &lt;aside class="participants"&gt;\n        &lt;h2&gt;Participants (&lt;span id="count"&gt;0&lt;/span&gt;)&lt;/h2&gt;\n        &lt;ul id="nameList" aria-live="polite"&gt;&lt;/ul&gt;\n      &lt;/aside&gt;\n    &lt;/section&gt;\n    &lt;section class="result" id="result" aria-live="polite" hidden&gt;\n      &lt;h2&gt;Winner&lt;/h2&gt;\n      &lt;div id="winnerName" class="winnerName"&gt;&lt;/div&gt;\n      &lt;button id="rerollBtn"&gt;Spin Again&lt;/button&gt;\n    &lt;/section&gt;\n  &lt;/main&gt;\n  &lt;footer&gt;\n    &lt;small&gt;Built with HTML, CSS, and JavaScript. Themes change both UI and wheel colors.&lt;/small&gt;\n  &lt;/footer&gt;\n  &lt;script src="script.js"&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\n\nstyles.css\ncss\n\'\'\'\nStylesheet for the Random Winner Wheel.\nDefines layout, themes, wheel container sizing, animations, and toast styles.\n\'\'\'\n/*\n Stylesheet for the Random Winner Wheel.\n Defines layout, themes, wheel container sizing, animations, and toast styles.\n*/\n/* Reset &amp; base */\n* { box-sizing: border-box; margin: 0; padding: 0; }\nhtml,body { height: 100%; font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; background: var(--bg); color: var(--fg); }\n:root {\n  --bg: #f7f8fb;\n  --fg: #222;\n  --muted: #666;\n  --accent: #2b8cff;\n  --card: #ffffff;\n  --primary-btn-bg: var(--accent);\n  --primary-btn-fg: #fff;\n  --shadow: rgba(15,15,15,0.08);\n}\n/* Themes */\nbody.theme-light {\n  --bg: #f7f8fb;\n  --fg: #222;\n  --muted: #5b6170;\n  --accent: #2b8cff;\n  --card: #fff;\n  --wheel-seq: 0;\n}\nbody.theme-dark {\n  --bg: #0f1724;\n  --fg: #e6eef8;\n  --muted: #a9b1c2;\n  --accent: #7c5cff;\n  --card: #0b1220;\n}\nbody.theme-neon {\n  --bg: #0a0a0f;\n  --fg: #e9f9ff;\n  --muted: #a6f3ff;\n  --accent: #39ff14;\n  --card: #09101a;\n}\nbody.theme-pastel {\n  --bg: #fffaf6;\n  --fg: #3c3a3a;\n  --muted: #8d8a8a;\n  --accent: #ff7aa2;\n  --card: #fff;\n}\nbody.theme-retro {\n  --bg: #fff6e7;\n  --fg: #402b2b;\n  --muted: #856e6e;\n  --accent: #ffb86b;\n  --card: #fff0e6;\n}\n/* Layout */\nheader { padding: 18px 24px; text-align: center; background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent); }\nheader h1 { font-size: 1.5rem; margin-bottom: 6px; }\nmain { padding: 18px; max-width: 1100px; margin: 0 auto; }\n.controls { display: grid; gap: 12px; margin-bottom: 18px; }\n.add-single { display:flex; gap:8px; }\n.add-single input[type="text"] { flex:1; padding:10px; border-radius:8px; border:1px solid rgba(0,0,0,0.08); background:var(--card); color:var(--fg); }\n.add-single button { padding:10px 12px; border-radius:8px; border: none; cursor:pointer; background: var(--primary-btn-bg); color: var(--primary-btn-fg); }\n.add-single button#addRandomBtn { background: transparent; border: 1px solid rgba(0,0,0,0.06); color: var(--fg); }\n.bulk-add textarea { width:100%; min-height:64px; margin-top:6px; padding:8px; border-radius:8px; border:1px solid rgba(0,0,0,0.06); background:var(--card); color:var(--fg); }\n.bulk-actions { display:flex; gap:8px; margin-top:8px; }\n.list-actions { display:flex; justify-content:space-between; align-items:center; gap:16px; flex-wrap:wrap; }\n.theme-select select { padding:8px; border-radius:8px; border:1px solid rgba(0,0,0,0.06); }\n.wheel-area { display:flex; gap:18px; align-items:start; flex-wrap:wrap; }\n.wheel-container { position: relative; width: 600px; height: 600px; max-width: 90vw; max-height: 90vw; display:flex; align-items:center; justify-content:center; background: transparent; }\n.pointer {\n  /* Centered triangular pointer positioned above the wheel.\n     This ensures the visual pointer aligns with the wheel math (top-center).\n     Hides the fallback glyph in the HTML and draws a sharp triangle instead. */\n  position: absolute;\n  top: 8px;               /* vertical offset from top of wheel container */\n  left: 50%;              /* center horizontally */\n  transform: translateX(-50%); /* center on the X axis */\n  width: 0;\n  height: 0;\n  border-left: 12px solid transparent;\n  border-right: 12px solid transparent;\n  border-bottom: 18px solid var(--accent);\n  z-index: 10;            /* ensure it\'s above the canvas */\n  pointer-events: none;\n  /* hide textual glyph fallback content (the ▼ in HTML) */\n  font-size: 0;\n  line-height: 0;\n  text-indent: -9999px;\n}\n/* Participants panel and wheel styles */\n.participants { width: 320px; max-width: 40vw; background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent); padding:12px; border-radius:10px; box-shadow: 0 6px 18px var(--shadow); }\n.participants h2 { margin-bottom:8px; font-size:1.05rem; }\n#nameList { list-style:none; max-height:420px; overflow:auto; display:block; }\n#nameList li { padding:8px; border-radius:6px; display:flex; justify-content:space-between; align-items:center; gap:8px; margin-bottom:8px; background: var(--card); border:1px solid rgba(0,0,0,0.04); }\n#nameList li button { background: transparent; border: none; color: var(--muted); cursor:pointer; }\n.result { margin-top:18px; padding:12px; border-radius:8px; background: var(--card); text-align:center; box-shadow: 0 6px 18px var(--shadow); }\n.result .winnerName { font-size:1.4rem; font-weight:700; margin:8px 0; color: var(--accent); }\n/* Buttons */\nbutton { cursor:pointer; padding:8px 12px; border-radius:8px; border:1px solid rgba(0,0,0,0.06); background: transparent; color:var(--fg); }\nbutton.primary { background: var(--primary-btn-bg); color: var(--primary-btn-fg); border: none; }\n/* Responsive */\n@media (max-width: 900px) {\n  .wheel-area { flex-direction:column; align-items:center; }\n  .participants { width: 100%; max-width: 100%; }\n}\n/* Wheel canvas scaling helper */\n#wheelCanvas { border-radius:50%; box-shadow: 0 12px 26px rgba(0,0,0,0.12); background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.02), transparent); }\n/* Toast / temporary message styles (used by showMessage) */\n.tmp-toast {\n  position: fixed;\n  left: 50%;\n  transform: translateX(-50%);\n  top: 18px;\n  background: rgba(0,0,0,0.85);\n  color: #fff;\n  padding: 8px 12px;\n  border-radius: 6px;\n  z-index: 9999;\n  transition: opacity 0.25s, transform 0.25s;\n  opacity: 1;\n  pointer-events: none;\n  font-size: 0.95rem;\n  box-shadow: 0 6px 18px rgba(0,0,0,0.18);\n}\n.tmp-toast.success { background: rgba(56, 198, 123, 0.95); }\n.tmp-toast.warn    { background: rgba(255, 159, 67, 0.95); color: #2b1500; }\n.tmp-toast.info    { background: rgba(12, 74, 255, 0.95); }\n/* Winner highlight for participants list */\n#nameList li.winner {\n  outline: 3px solid rgba(255,215,0,0.15);\n  box-shadow: 0 6px 18px rgba(255,215,0,0.06);\n  transform: scale(1.01);\n}\n\n\nscript.js\njs\n\'\'\'\nScript for the Random Winner Wheel.\nContains the Wheel class to draw and spin the canvas-based wheel and UI glue code to manage names and themes.\n\'\'\'\n/*\n Script for the Random Winner Wheel.\n Contains the Wheel class to draw and spin the canvas-based wheel and UI glue code to manage names and themes.\n*/\n/* Main JavaScript - Wheel + UI logic */\n(() =&gt; {\n  // Utilities\n  function rand(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }\n  function easeOutCubic(t) { return 1 - Math.pow(1 - t, 3); }\n  // Color palettes for themes (will be used to paint wheel segments)\n  const THEME_PALETTES = {\n    light: [\'#FF8A80\',\'#FFD180\',\'#FFF59D\',\'#C8E6C9\',\'#80DEEA\',\'#A7FFEB\',\'#B39DDB\',\'#90CAF9\'],\n    dark: [\'#ff6b6b\',\'#ffd166\',\'#faff8e\',\'#b9f6ca\',\'#4dd0e1\',\'#80cbc4\',\'#b388ff\',\'#64b5f6\'],\n    neon: [\'#ff2d95\',\'#7cff01\',\'#00ffff\',\'#ffdd00\',\'#ff6a00\',\'#00ff9e\',\'#ff00ff\',\'#47ffa2\'],\n    pastel: [\'#ffdbe9\',\'#fff0b3\',\'#d1ffd6\',\'#cfefff\',\'#e7dfff\',\'#ffd6e7\',\'#fbe7d6\',\'#e6f7ff\'],\n    retro: [\'#ffb86b\',\'#ffd3a8\',\'#f3e2a9\',\'#b8e0d2\',\'#c0b9ff\',\'#ffb6c1\',\'#f6c49f\',\'#c3d69b\']\n  };\n  // Wheel class\n  class Wheel {\n    /*\n    Manage wheel: drawing, recalculating segments, spinning animation, and determining winner.\n    */\n    constructor(canvas, options = {}) {\n      this.canvas = canvas;\n      this.ctx = canvas.getContext(\'2d\');\n      this.names = [];\n      this.rotation = 0; // radians\n      this.isSpinning = false;\n      this.frame = null;\n      this.onResult = options.onResult || function() {};\n      this.theme = options.theme || \'light\';\n      this.padAngle = 0.02; // radians padding between segments\n      this.textColor = \'#111\';\n      this._devicePixelRatioFix();\n      window.addEventListener(\'resize\', () =&gt; { this._devicePixelRatioFix(); this.draw(); });\n    }\n    _devicePixelRatioFix() {\n      const dpr = window.devicePixelRatio || 1;\n      const rect = this.canvas.getBoundingClientRect();\n      // If rect has zero size (canvas not yet laid out), use current width/height attributes as fallback\n      const width = rect.width || (this.canvas.width / dpr);\n      const height = rect.height || (this.canvas.height / dpr);\n      this.canvas.width = width * dpr;\n      this.canvas.height = height * dpr;\n      this.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n      this.centerX = width / 2;\n      this.centerY = height / 2;\n      this.radius = Math.min(width, height) / 2 - 18;\n    }\n    setTheme(themeId) { this.theme = themeId; this.draw(); }\n    setNames(names) {\n      this.names = names.slice();\n      this.draw();\n    }\n    addName(name) {\n      this.names.push(name);\n      this.draw();\n    }\n    removeName(index) {\n      if (index &gt;= 0 &amp;&amp; index &lt; this.names.length) {\n        this.names.splice(index,1);\n        this.draw();\n      }\n    }\n    clearNames() {\n      this.names = [];\n      this.draw();\n    }\n    draw() {\n      const ctx = this.ctx;\n      const w = this.canvas.width / (window.devicePixelRatio || 1);\n      const h = this.canvas.height / (window.devicePixelRatio || 1);\n      ctx.clearRect(0,0,w,h);\n      ctx.save();\n      ctx.translate(this.centerX, this.centerY);\n      ctx.rotate(this.rotation);\n      // draw segments\n      const count = Math.max(this.names.length, 1);\n      const palette = THEME_PALETTES[this.theme] || THEME_PALETTES.light;\n      for (let i = 0; i &lt; count; i++) {\n        const start = (i / count) * Math.PI * 2;\n        const end = ((i + 1) / count) * Math.PI * 2;\n        ctx.beginPath();\n        ctx.moveTo(0,0);\n        ctx.arc(0,0,this.radius, start + this.padAngle, end - this.padAngle, false);\n        ctx.closePath();\n        const color = palette[i % palette.length];\n        ctx.fillStyle = color;\n        ctx.fill();\n        ctx.strokeStyle = (i % 2 === 0) ? \'rgba(0,0,0,0.06)\' : \'rgba(0,0,0,0.03)\';\n        ctx.lineWidth = 1;\n        ctx.stroke();\n        // draw text label\n        const mid = (start + end) / 2;\n        ctx.save();\n        ctx.rotate(mid);\n        ctx.translate(this.radius * 0.6, 0);\n        ctx.rotate(Math.PI/2);\n        ctx.fillStyle = getTextColor(color);\n        ctx.font = `${Math.max(12, Math.min(22, this.radius / 8))}px sans-serif`;\n        ctx.textAlign = \'center\';\n        ctx.textBaseline = \'middle\';\n        const label = (this.names.length === 0) ? \'Add names\' : this.names[i % this.names.length];\n        wrapFillText(ctx, label, 0, 0, this.radius * 0.5, 16);\n        ctx.restore();\n      }\n      // draw center circle\n      ctx.beginPath();\n      ctx.arc(0,0, this.radius * 0.16, 0, Math.PI*2);\n      ctx.fillStyle = \'rgba(255,255,255,0.9)\';\n      ctx.fill();\n      ctx.strokeStyle = \'rgba(0,0,0,0.06)\';\n      ctx.stroke();\n      ctx.restore();\n      // draw outer ring (pointer side neutral)\n      ctx.beginPath();\n      ctx.arc(this.centerX, this.centerY, this.radius + 10, 0, Math.PI*2);\n      ctx.strokeStyle = \'rgba(0,0,0,0.03)\';\n      ctx.lineWidth = 2;\n      ctx.stroke();\n    }\n    spin() {\n      if (this.isSpinning || this.names.length === 0) return;\n      this.isSpinning = true;\n      const count = this.names.length;\n      // Determine random winner index to land on:\n      const winnerIndex = rand(0, count - 1);\n      // Calculate final rotation so that winner segment lines up with pointer at top (pointer at canvas top - rotation must align)\n      // Our pointer is at the top (canvas 0 angle). The segment mid-angle for index i (without rotation) is ((i + 0.5)/count)*2pi\n      const segmentMid = ((winnerIndex + 0.5) / count) * Math.PI * 2;\n      // We want segmentMid + rotation_final == -Math.PI/2 (so it points at the top pointer), so rotation_final = -Math.PI/2 - segmentMid + 2pi*N\n      const extraTurns = rand(5, 8); // full spins\n      const rotationFinal = -Math.PI/2 - segmentMid + extraTurns * Math.PI * 2;\n      const startRotation = this.rotation % (Math.PI * 2);\n      const delta = rotationFinal - startRotation;\n      const duration = 4000 + Math.random() * 1500; // ms\n      const startTime = performance.now();\n      const animate = (now) =&gt; {\n        const elapsed = now - startTime;\n        const t = Math.min(elapsed / duration, 1);\n        const eased = easeOutCubic(t);\n        this.rotation = startRotation + delta * eased;\n        this.draw();\n        if (t &lt; 1) {\n          this.frame = requestAnimationFrame(animate);\n        } else {\n          this.isSpinning = false;\n          // Normalize rotation within 0..2pi\n          this.rotation = ((this.rotation % (Math.PI*2)) + Math.PI*2) % (Math.PI*2);\n          this.draw();\n          // Compute final winner index again from rotation\n          // finalAngle: the angle of the segment at pointer (0 at right, +counterclockwise). We compute a normalized angle that maps to segment index.\n          const finalAngle = ((-this.rotation - Math.PI/2) % (Math.PI*2) + Math.PI*2) % (Math.PI*2);\n          const resultingIndex = Math.floor((finalAngle / (Math.PI*2)) * count) % count;\n          const winner = this.names[resultingIndex];\n          this.onResult({ index: resultingIndex, name: winner });\n        }\n      };\n      this.frame = requestAnimationFrame(animate);\n    }\n  }\n  // Helper: pick readable text color for a background\n  function getTextColor(hex) {\n    // remove # and convert\n    const h = hex.replace(\'#\',\'\');\n    const r = parseInt(h.substring(0,2),16);\n    const g = parseInt(h.substring(2,4),16);\n    const b = parseInt(h.substring(4,6),16);\n    // luminance\n    const lum = (0.299*r + 0.587*g + 0.114*b) / 255;\n    return lum &gt; 0.65 ? \'#111\' : \'#fff\';\n  }\n  // Helper: wrap text within a given width (draws multi-line if necessary)\n  function wrapFillText(ctx, text, x, y, maxWidth, lineHeight) {\n    const words = (text || \'\').split(/\\s+/);\n    if (words.length === 0) return;\n    let line = \'\';\n    const lines = [];\n    for (let n = 0; n &lt; words.length; n++) {\n      const testLine = line ? line + \' \' + words[n] : words[n];\n      const metrics = ctx.measureText(testLine);\n      if (metrics.width &gt; maxWidth &amp;&amp; line) {\n        lines.push(line);\n        line = words[n];\n      } else {\n        line = testLine;\n      }\n    }\n    if (line) lines.push(line);\n    // If still too many lines, just draw what\'s possible (we rely on font size)\n    for (let i=0;i&lt;lines.length;i++){\n      ctx.fillText(lines[i], x, y + (i - (lines.length-1)/2) * lineHeight);\n    }\n  }\n  // UI glue\n  document.addEventListener(\'DOMContentLoaded\', () =&gt; {\n    const canvas = document.getElementById(\'wheelCanvas\');\n    const wheel = new Wheel(canvas, { theme: \'light\', onResult: onWinner });\n    const nameInput = document.getElementById(\'nameInput\');\n    const addBtn = document.getElementById(\'addBtn\');\n    const addRandomBtn = document.getElementById(\'addRandomBtn\');\n    const bulkInput = document.getElementById(\'bulkInput\');\n    const bulkAddBtn = document.getElementById(\'bulkAddBtn\');\n    const clearBulkBtn = document.getElementById(\'clearBulkBtn\');\n    const nameList = document.getElementById(\'nameList\');\n    const countSpan = document.getElementById(\'count\');\n    const spinBtn = document.getElementById(\'spinBtn\');\n    const rerollBtn = document.getElementById(\'rerollBtn\');\n    const clearNamesBtn = document.getElementById(\'clearNamesBtn\');\n    const themeSelect = document.getElementById(\'themeSelect\');\n    const resultSection = document.getElementById(\'result\');\n    const winnerNameDiv = document.getElementById(\'winnerName\');\n    const exportBtn = document.getElementById(\'exportBtn\');\n    const importBtn = document.getElementById(\'importBtn\');\n    const importFile = document.getElementById(\'importFile\');\n    // Initial draw\n    wheel.draw();\n    function updateUI() {\n      const names = wheel.names;\n      countSpan.textContent = names.length;\n      renderNameList();\n    }\n    function renderNameList() {\n      nameList.innerHTML = \'\';\n      wheel.names.forEach((n, i) =&gt; {\n        const li = document.createElement(\'li\');\n        const span = document.createElement(\'span\');\n        span.textContent = n;\n        li.appendChild(span);\n        const btn = document.createElement(\'button\');\n        btn.title = \'Remove\';\n        btn.setAttribute(\'aria-label\', `Remove ${n}`);\n        btn.innerHTML = \'✕\';\n        btn.addEventListener(\'click\', () =&gt; {\n          wheel.removeName(i);\n          updateUI();\n        });\n        li.appendChild(btn);\n        nameList.appendChild(li);\n      });\n    }\n    function addNameFromInput() {\n      const v = nameInput.value.trim();\n      if (!v) { showMessage(\'Please enter a name.\', \'warn\'); return; }\n      wheel.addName(v);\n      nameInput.value = \'\';\n      updateUI();\n    }\n    addBtn.addEventListener(\'click\', addNameFromInput);\n    nameInput.addEventListener(\'keydown\', (e) =&gt; { if (e.key === \'Enter\') addNameFromInput(); });\n    addRandomBtn.addEventListener(\'click\', () =&gt; {\n      const samples = [\'Alex\',\'Jordan\',\'Taylor\',\'Sam\',\'Jamie\',\'Casey\',\'Morgan\',\'Riley\',\'Avery\',\'Dana\'];\n      const count = rand(3,6);\n      for (let i=0;i&lt;count;i++) wheel.addName(samples[rand(0,samples.length-1)] + (rand(1,100)));\n      updateUI();\n    });\n    bulkAddBtn.addEventListener(\'click\', () =&gt; {\n      const text = bulkInput.value.trim();\n      if (!text) { showMessage(\'Bulk input is empty.\', \'warn\'); return; }\n      const parsed = text.split(/[\\n,;]+/).map(s =&gt; s.trim()).filter(s =&gt; s);\n      parsed.forEach(p =&gt; wheel.addName(p));\n      bulkInput.value = \'\';\n      updateUI();\n      showMessage(`Added ${parsed.length} names.`, \'info\');\n    });\n    clearBulkBtn.addEventListener(\'click\', () =&gt; { bulkInput.value = \'\'; });\n    spinBtn.addEventListener(\'click\', () =&gt; {\n      if (wheel.names.length === 0) { showMessage(\'Add at least one name to spin.\', \'warn\'); return; }\n      resultSection.hidden = true;\n      winnerNameDiv.textContent = \'\';\n      wheel.spin();\n      spinBtn.disabled = true;\n      const checkFinish = setInterval(() =&gt; {\n        if (!wheel.isSpinning) {\n          clearInterval(checkFinish);\n          spinBtn.disabled = false;\n        }\n      }, 200);\n    });\n    rerollBtn.addEventListener(\'click\', () =&gt; {\n      resultSection.hidden = true;\n      wheel.spin();\n    });\n    clearNamesBtn.addEventListener(\'click\', () =&gt; {\n      if (confirm(\'Clear all names?\')) {\n        wheel.clearNames();\n        updateUI();\n      }\n    });\n    themeSelect.addEventListener(\'change\', (e) =&gt; {\n      const t = e.target.value;\n      document.body.className = \'theme-\' + t;\n      wheel.setTheme(t);\n    });\n    function onWinner(result) {\n      winnerNameDiv.textContent = result.name || \'—\';\n      resultSection.hidden = false;\n      // Flash the winner item in the list (if still present)\n      const items = Array.from(nameList.children);\n      items.forEach((li, idx) =&gt; { li.classList.toggle(\'winner\', idx === result.index); });\n      showMessage(`Winner: ${result.name}`, \'success\', 4000);\n    }\n    // Simple message area\n    function showMessage(text, type = \'info\', duration = 2200) {\n      // create small toast\n      const t = document.createElement(\'div\');\n      t.className = \'tmp-toast \' + type;\n      t.textContent = text;\n      document.body.appendChild(t);\n      // Force reflow to pick up transitions\n      window.getComputedStyle(t).opacity;\n      setTimeout(()=&gt; { t.style.opacity = \'0\'; t.style.transform = \'translateY(-10px)\'; }, duration - 300);\n      setTimeout(()=&gt; { try { t.remove(); } catch(e){} }, duration);\n    }\n    // Export/import CSV\n    exportBtn.addEventListener(\'click\', () =&gt; {\n      if (wheel.names.length === 0) { showMessage(\'No names to export.\', \'warn\'); return; }\n      const csv = wheel.names.map(n =&gt; `"${(n||\'\').replace(/"/g,\'""\')}"`).join(\'\\n\');\n      const blob = new Blob([csv], { type: \'text/csv\' });\n      const url = URL.createObjectURL(blob);\n      const a = document.createElement(\'a\');\n      a.href = url;\n      a.download = \'participants.csv\';\n      document.body.appendChild(a);\n      a.click();\n      a.remove();\n      URL.revokeObjectURL(url);\n      showMessage(\'Exported CSV\', \'info\');\n    });\n    importBtn.addEventListener(\'click\', () =&gt; { importFile.click(); });\n    importFile.addEventListener(\'change\', (e) =&gt; {\n      const file = e.target.files[0];\n      if (!file) return;\n      const reader = new FileReader();\n      reader.onload = (ev) =&gt; {\n        const txt = ev.target.result;\n        const lines = txt.split(/\\r?\\n/).map(s =&gt; s.trim()).filter(s =&gt; s);\n        // basic CSV unquote\n        const parsed = lines.map(l =&gt; {\n          // simple CSV single-column parse: handle quoted fields\n          if (l.startsWith(\'"\') &amp;&amp; l.endsWith(\'"\')) {\n            return l.slice(1,-1).replace(/""/g,\'"\');\n          }\n          return l;\n        });\n        parsed.forEach(p =&gt; wheel.addName(p));\n        updateUI();\n        showMessage(`Imported ${parsed.length} names`, \'info\');\n      };\n      reader.readAsText(file);\n      importFile.value = \'\';\n    });\n    // Initial sample (optional)\n    // wheel.addName(\'Alice\'); wheel.addName(\'Bob\'); wheel.addName(\'Charlie\');\n    updateUI();\n    // (Optional) keyboard shortcuts\n    window.addEventListener(\'keydown\', (e) =&gt; {\n      if ((e.ctrlKey || e.metaKey) &amp;&amp; e.key.toLowerCase() === \'k\') {\n        e.preventDefault();\n        nameInput.focus();\n      }\n      if (e.key === \' \') {\n        // space triggers spin if not focusing an input\n        if (document.activeElement.tagName !== \'INPUT\' &amp;&amp; document.activeElement.tagName !== \'TEXTAREA\') {\n          e.preventDefault();\n          spinBtn.click();\n        }\n      }\n    });\n  });\n})(); \n\n\n'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_3_5_TURBO |

[2025-17-09 13:47:52 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Programmer |
| **user_role_name** | Chief Technology Officer |
| **assistant_role_prompt** | {chatdev_prompt} You are Programmer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. You can write/create computer software or applications by providing a specific programming language to the computer. You have extensive computing and coding experience in many varieties of programming languages and platforms, such as Python, Java, C, C++, HTML, CSS, JavaScript, XML, SQL, PHP, etc,. Here is a new customer's task: {task}. To complete the task, you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Chief Technology Officer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. You are very familiar to information technology. You will make high-level decisions for the overarching technology infrastructure that closely align with the organization's goals, while you work alongside the organization's information technology ("IT") staff members to perform everyday operations. Here is a new customer's task: {task}. To complete the task, You must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **task_prompt** | [Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes. Do it in HTML, CSS, and JavaScript.] |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_3_5_TURBO |
| **background_prompt** | ChatDev is a software company powered by multiple intelligent agents, such as chief executive officer, chief human resources officer, chief product officer, chief technology officer, etc, with a multi-agent organizational structure and the mission of 'changing the digital world through programming'. |

[2025-17-09 13:47:52 INFO] Chief Technology Officer: **[Start Chat]**

[ChatDev is a software company powered by multiple intelligent agents, such as chief executive officer, chief human resources officer, chief product officer, chief technology officer, etc, with a multi-agent organizational structure and the mission of 'changing the digital world through programming'.
You are Programmer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer.
You can write/create computer software or applications by providing a specific programming language to the computer. You have extensive computing and coding experience in many varieties of programming languages and platforms, such as Python, Java, C, C++, HTML, CSS, JavaScript, XML, SQL, PHP, etc,.
Here is a new customer's task: [Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes. Do it in HTML, CSS, and JavaScript.].
To complete the task, you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]

The new user's task and our developed codes are listed: 

Task: "[Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes. Do it in HTML, CSS, and JavaScript.]".

Modality: "website".

Programming Language: " JavaScript"

Ideas: ""

Codes: 

"index.html
```html
'''
This is the main HTML file for the Random Winner Wheel.
It contains the structure: input fields to add names, a canvas for the wheel,
controls (spin, clear, bulk add), theme selector, and placeholders for CSS/JS.
'''
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Random Winner Wheel</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body class="theme-light">
  <!--
    This is the main HTML file for the Random Winner Wheel.
    It contains the structure: input fields to add names, a canvas for the wheel,
    controls (spin, clear, bulk add), theme selector, and placeholders for CSS/JS.
  -->
  <header>
    <h1>Random Winner Wheel</h1>
    <p>Enter participant names, choose a theme, and spin to pick a winner.</p>
  </header>
  <main>
    <section class="controls">
      <div class="add-single">
        <input id="nameInput" type="text" placeholder="Enter a name and press Add" aria-label="Name input" />
        <button id="addBtn">Add</button>
        <button id="addRandomBtn" title="Add a few sample random names">Add Sample</button>
      </div>
      <div class="bulk-add">
        <label for="bulkInput">Bulk add (comma, newline or semicolon separated):</label>
        <textarea id="bulkInput" placeholder="Alice, Bob, Charlie"></textarea>
        <div class="bulk-actions">
          <button id="bulkAddBtn">Bulk Add</button>
          <button id="clearBulkBtn">Clear Bulk</button>
        </div>
      </div>
      <div class="list-actions">
        <div class="theme-select">
          <label for="themeSelect">Theme:</label>
          <select id="themeSelect">
            <option value="light">Light</option>
            <option value="dark">Dark</option>
            <option value="neon">Neon</option>
            <option value="pastel">Pastel</option>
            <option value="retro">Retro</option>
          </select>
        </div>
        <div class="wheel-controls">
          <button id="spinBtn" class="primary">Spin</button>
          <button id="clearNamesBtn">Clear Names</button>
          <button id="exportBtn">Export CSV</button>
          <input id="importFile" type="file" accept=".csv,text/csv" style="display:none">
          <button id="importBtn">Import CSV</button>
        </div>
      </div>
    </section>
    <section class="wheel-area">
      <div class="wheel-container">
        <canvas id="wheelCanvas" width="600" height="600" aria-label="Spinning wheel"></canvas>
        <div class="pointer" aria-hidden="true">▼</div>
      </div>
      <aside class="participants">
        <h2>Participants (<span id="count">0</span>)</h2>
        <ul id="nameList" aria-live="polite"></ul>
      </aside>
    </section>
    <section class="result" id="result" aria-live="polite" hidden>
      <h2>Winner</h2>
      <div id="winnerName" class="winnerName"></div>
      <button id="rerollBtn">Spin Again</button>
    </section>
  </main>
  <footer>
    <small>Built with HTML, CSS, and JavaScript. Themes change both UI and wheel colors.</small>
  </footer>
  <script src="script.js"></script>
</body>
</html>
```

styles.css
```css
'''
Stylesheet for the Random Winner Wheel.
Defines layout, themes, wheel container sizing, animations, and toast styles.
'''
/*
 Stylesheet for the Random Winner Wheel.
 Defines layout, themes, wheel container sizing, animations, and toast styles.
*/
/* Reset & base */
* { box-sizing: border-box; margin: 0; padding: 0; }
html,body { height: 100%; font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; background: var(--bg); color: var(--fg); }
:root {
  --bg: #f7f8fb;
  --fg: #222;
  --muted: #666;
  --accent: #2b8cff;
  --card: #ffffff;
  --primary-btn-bg: var(--accent);
  --primary-btn-fg: #fff;
  --shadow: rgba(15,15,15,0.08);
}
/* Themes */
body.theme-light {
  --bg: #f7f8fb;
  --fg: #222;
  --muted: #5b6170;
  --accent: #2b8cff;
  --card: #fff;
  --wheel-seq: 0;
}
body.theme-dark {
  --bg: #0f1724;
  --fg: #e6eef8;
  --muted: #a9b1c2;
  --accent: #7c5cff;
  --card: #0b1220;
}
body.theme-neon {
  --bg: #0a0a0f;
  --fg: #e9f9ff;
  --muted: #a6f3ff;
  --accent: #39ff14;
  --card: #09101a;
}
body.theme-pastel {
  --bg: #fffaf6;
  --fg: #3c3a3a;
  --muted: #8d8a8a;
  --accent: #ff7aa2;
  --card: #fff;
}
body.theme-retro {
  --bg: #fff6e7;
  --fg: #402b2b;
  --muted: #856e6e;
  --accent: #ffb86b;
  --card: #fff0e6;
}
/* Layout */
header { padding: 18px 24px; text-align: center; background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent); }
header h1 { font-size: 1.5rem; margin-bottom: 6px; }
main { padding: 18px; max-width: 1100px; margin: 0 auto; }
.controls { display: grid; gap: 12px; margin-bottom: 18px; }
.add-single { display:flex; gap:8px; }
.add-single input[type="text"] { flex:1; padding:10px; border-radius:8px; border:1px solid rgba(0,0,0,0.08); background:var(--card); color:var(--fg); }
.add-single button { padding:10px 12px; border-radius:8px; border: none; cursor:pointer; background: var(--primary-btn-bg); color: var(--primary-btn-fg); }
.add-single button#addRandomBtn { background: transparent; border: 1px solid rgba(0,0,0,0.06); color: var(--fg); }
.bulk-add textarea { width:100%; min-height:64px; margin-top:6px; padding:8px; border-radius:8px; border:1px solid rgba(0,0,0,0.06); background:var(--card); color:var(--fg); }
.bulk-actions { display:flex; gap:8px; margin-top:8px; }
.list-actions { display:flex; justify-content:space-between; align-items:center; gap:16px; flex-wrap:wrap; }
.theme-select select { padding:8px; border-radius:8px; border:1px solid rgba(0,0,0,0.06); }
.wheel-area { display:flex; gap:18px; align-items:start; flex-wrap:wrap; }
.wheel-container { position: relative; width: 600px; height: 600px; max-width: 90vw; max-height: 90vw; display:flex; align-items:center; justify-content:center; background: transparent; }
.pointer {
  /* Centered triangular pointer positioned above the wheel.
     This ensures the visual pointer aligns with the wheel math (top-center).
     Hides the fallback glyph in the HTML and draws a sharp triangle instead. */
  position: absolute;
  top: 8px;               /* vertical offset from top of wheel container */
  left: 50%;              /* center horizontally */
  transform: translateX(-50%); /* center on the X axis */
  width: 0;
  height: 0;
  border-left: 12px solid transparent;
  border-right: 12px solid transparent;
  border-bottom: 18px solid var(--accent);
  z-index: 10;            /* ensure it's above the canvas */
  pointer-events: none;
  /* hide textual glyph fallback content (the ▼ in HTML) */
  font-size: 0;
  line-height: 0;
  text-indent: -9999px;
}
/* Participants panel and wheel styles */
.participants { width: 320px; max-width: 40vw; background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent); padding:12px; border-radius:10px; box-shadow: 0 6px 18px var(--shadow); }
.participants h2 { margin-bottom:8px; font-size:1.05rem; }
#nameList { list-style:none; max-height:420px; overflow:auto; display:block; }
#nameList li { padding:8px; border-radius:6px; display:flex; justify-content:space-between; align-items:center; gap:8px; margin-bottom:8px; background: var(--card); border:1px solid rgba(0,0,0,0.04); }
#nameList li button { background: transparent; border: none; color: var(--muted); cursor:pointer; }
.result { margin-top:18px; padding:12px; border-radius:8px; background: var(--card); text-align:center; box-shadow: 0 6px 18px var(--shadow); }
.result .winnerName { font-size:1.4rem; font-weight:700; margin:8px 0; color: var(--accent); }
/* Buttons */
button { cursor:pointer; padding:8px 12px; border-radius:8px; border:1px solid rgba(0,0,0,0.06); background: transparent; color:var(--fg); }
button.primary { background: var(--primary-btn-bg); color: var(--primary-btn-fg); border: none; }
/* Responsive */
@media (max-width: 900px) {
  .wheel-area { flex-direction:column; align-items:center; }
  .participants { width: 100%; max-width: 100%; }
}
/* Wheel canvas scaling helper */
#wheelCanvas { border-radius:50%; box-shadow: 0 12px 26px rgba(0,0,0,0.12); background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.02), transparent); }
/* Toast / temporary message styles (used by showMessage) */
.tmp-toast {
  position: fixed;
  left: 50%;
  transform: translateX(-50%);
  top: 18px;
  background: rgba(0,0,0,0.85);
  color: #fff;
  padding: 8px 12px;
  border-radius: 6px;
  z-index: 9999;
  transition: opacity 0.25s, transform 0.25s;
  opacity: 1;
  pointer-events: none;
  font-size: 0.95rem;
  box-shadow: 0 6px 18px rgba(0,0,0,0.18);
}
.tmp-toast.success { background: rgba(56, 198, 123, 0.95); }
.tmp-toast.warn    { background: rgba(255, 159, 67, 0.95); color: #2b1500; }
.tmp-toast.info    { background: rgba(12, 74, 255, 0.95); }
/* Winner highlight for participants list */
#nameList li.winner {
  outline: 3px solid rgba(255,215,0,0.15);
  box-shadow: 0 6px 18px rgba(255,215,0,0.06);
  transform: scale(1.01);
}
```

script.js
```js
'''
Script for the Random Winner Wheel.
Contains the Wheel class to draw and spin the canvas-based wheel and UI glue code to manage names and themes.
'''
/*
 Script for the Random Winner Wheel.
 Contains the Wheel class to draw and spin the canvas-based wheel and UI glue code to manage names and themes.
*/
/* Main JavaScript - Wheel + UI logic */
(() => {
  // Utilities
  function rand(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }
  function easeOutCubic(t) { return 1 - Math.pow(1 - t, 3); }
  // Color palettes for themes (will be used to paint wheel segments)
  const THEME_PALETTES = {
    light: ['#FF8A80','#FFD180','#FFF59D','#C8E6C9','#80DEEA','#A7FFEB','#B39DDB','#90CAF9'],
    dark: ['#ff6b6b','#ffd166','#faff8e','#b9f6ca','#4dd0e1','#80cbc4','#b388ff','#64b5f6'],
    neon: ['#ff2d95','#7cff01','#00ffff','#ffdd00','#ff6a00','#00ff9e','#ff00ff','#47ffa2'],
    pastel: ['#ffdbe9','#fff0b3','#d1ffd6','#cfefff','#e7dfff','#ffd6e7','#fbe7d6','#e6f7ff'],
    retro: ['#ffb86b','#ffd3a8','#f3e2a9','#b8e0d2','#c0b9ff','#ffb6c1','#f6c49f','#c3d69b']
  };
  // Wheel class
  class Wheel {
    /*
    Manage wheel: drawing, recalculating segments, spinning animation, and determining winner.
    */
    constructor(canvas, options = {}) {
      this.canvas = canvas;
      this.ctx = canvas.getContext('2d');
      this.names = [];
      this.rotation = 0; // radians
      this.isSpinning = false;
      this.frame = null;
      this.onResult = options.onResult || function() {};
      this.theme = options.theme || 'light';
      this.padAngle = 0.02; // radians padding between segments
      this.textColor = '#111';
      this._devicePixelRatioFix();
      window.addEventListener('resize', () => { this._devicePixelRatioFix(); this.draw(); });
    }
    _devicePixelRatioFix() {
      const dpr = window.devicePixelRatio || 1;
      const rect = this.canvas.getBoundingClientRect();
      // If rect has zero size (canvas not yet laid out), use current width/height attributes as fallback
      const width = rect.width || (this.canvas.width / dpr);
      const height = rect.height || (this.canvas.height / dpr);
      this.canvas.width = width * dpr;
      this.canvas.height = height * dpr;
      this.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      this.centerX = width / 2;
      this.centerY = height / 2;
      this.radius = Math.min(width, height) / 2 - 18;
    }
    setTheme(themeId) { this.theme = themeId; this.draw(); }
    setNames(names) {
      this.names = names.slice();
      this.draw();
    }
    addName(name) {
      this.names.push(name);
      this.draw();
    }
    removeName(index) {
      if (index >= 0 && index < this.names.length) {
        this.names.splice(index,1);
        this.draw();
      }
    }
    clearNames() {
      this.names = [];
      this.draw();
    }
    draw() {
      const ctx = this.ctx;
      const w = this.canvas.width / (window.devicePixelRatio || 1);
      const h = this.canvas.height / (window.devicePixelRatio || 1);
      ctx.clearRect(0,0,w,h);
      ctx.save();
      ctx.translate(this.centerX, this.centerY);
      ctx.rotate(this.rotation);
      // draw segments
      const count = Math.max(this.names.length, 1);
      const palette = THEME_PALETTES[this.theme] || THEME_PALETTES.light;
      for (let i = 0; i < count; i++) {
        const start = (i / count) * Math.PI * 2;
        const end = ((i + 1) / count) * Math.PI * 2;
        ctx.beginPath();
        ctx.moveTo(0,0);
        ctx.arc(0,0,this.radius, start + this.padAngle, end - this.padAngle, false);
        ctx.closePath();
        const color = palette[i % palette.length];
        ctx.fillStyle = color;
        ctx.fill();
        ctx.strokeStyle = (i % 2 === 0) ? 'rgba(0,0,0,0.06)' : 'rgba(0,0,0,0.03)';
        ctx.lineWidth = 1;
        ctx.stroke();
        // draw text label
        const mid = (start + end) / 2;
        ctx.save();
        ctx.rotate(mid);
        ctx.translate(this.radius * 0.6, 0);
        ctx.rotate(Math.PI/2);
        ctx.fillStyle = getTextColor(color);
        ctx.font = `${Math.max(12, Math.min(22, this.radius / 8))}px sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        const label = (this.names.length === 0) ? 'Add names' : this.names[i % this.names.length];
        wrapFillText(ctx, label, 0, 0, this.radius * 0.5, 16);
        ctx.restore();
      }
      // draw center circle
      ctx.beginPath();
      ctx.arc(0,0, this.radius * 0.16, 0, Math.PI*2);
      ctx.fillStyle = 'rgba(255,255,255,0.9)';
      ctx.fill();
      ctx.strokeStyle = 'rgba(0,0,0,0.06)';
      ctx.stroke();
      ctx.restore();
      // draw outer ring (pointer side neutral)
      ctx.beginPath();
      ctx.arc(this.centerX, this.centerY, this.radius + 10, 0, Math.PI*2);
      ctx.strokeStyle = 'rgba(0,0,0,0.03)';
      ctx.lineWidth = 2;
      ctx.stroke();
    }
    spin() {
      if (this.isSpinning || this.names.length === 0) return;
      this.isSpinning = true;
      const count = this.names.length;
      // Determine random winner index to land on:
      const winnerIndex = rand(0, count - 1);
      // Calculate final rotation so that winner segment lines up with pointer at top (pointer at canvas top - rotation must align)
      // Our pointer is at the top (canvas 0 angle). The segment mid-angle for index i (without rotation) is ((i + 0.5)/count)*2pi
      const segmentMid = ((winnerIndex + 0.5) / count) * Math.PI * 2;
      // We want segmentMid + rotation_final == -Math.PI/2 (so it points at the top pointer), so rotation_final = -Math.PI/2 - segmentMid + 2pi*N
      const extraTurns = rand(5, 8); // full spins
      const rotationFinal = -Math.PI/2 - segmentMid + extraTurns * Math.PI * 2;
      const startRotation = this.rotation % (Math.PI * 2);
      const delta = rotationFinal - startRotation;
      const duration = 4000 + Math.random() * 1500; // ms
      const startTime = performance.now();
      const animate = (now) => {
        const elapsed = now - startTime;
        const t = Math.min(elapsed / duration, 1);
        const eased = easeOutCubic(t);
        this.rotation = startRotation + delta * eased;
        this.draw();
        if (t < 1) {
          this.frame = requestAnimationFrame(animate);
        } else {
          this.isSpinning = false;
          // Normalize rotation within 0..2pi
          this.rotation = ((this.rotation % (Math.PI*2)) + Math.PI*2) % (Math.PI*2);
          this.draw();
          // Compute final winner index again from rotation
          // finalAngle: the angle of the segment at pointer (0 at right, +counterclockwise). We compute a normalized angle that maps to segment index.
          const finalAngle = ((-this.rotation - Math.PI/2) % (Math.PI*2) + Math.PI*2) % (Math.PI*2);
          const resultingIndex = Math.floor((finalAngle / (Math.PI*2)) * count) % count;
          const winner = this.names[resultingIndex];
          this.onResult({ index: resultingIndex, name: winner });
        }
      };
      this.frame = requestAnimationFrame(animate);
    }
  }
  // Helper: pick readable text color for a background
  function getTextColor(hex) {
    // remove # and convert
    const h = hex.replace('#','');
    const r = parseInt(h.substring(0,2),16);
    const g = parseInt(h.substring(2,4),16);
    const b = parseInt(h.substring(4,6),16);
    // luminance
    const lum = (0.299*r + 0.587*g + 0.114*b) / 255;
    return lum > 0.65 ? '#111' : '#fff';
  }
  // Helper: wrap text within a given width (draws multi-line if necessary)
  function wrapFillText(ctx, text, x, y, maxWidth, lineHeight) {
    const words = (text || '').split(/\s+/);
    if (words.length === 0) return;
    let line = '';
    const lines = [];
    for (let n = 0; n < words.length; n++) {
      const testLine = line ? line + ' ' + words[n] : words[n];
      const metrics = ctx.measureText(testLine);
      if (metrics.width > maxWidth && line) {
        lines.push(line);
        line = words[n];
      } else {
        line = testLine;
      }
    }
    if (line) lines.push(line);
    // If still too many lines, just draw what's possible (we rely on font size)
    for (let i=0;i<lines.length;i++){
      ctx.fillText(lines[i], x, y + (i - (lines.length-1)/2) * lineHeight);
    }
  }
  // UI glue
  document.addEventListener('DOMContentLoaded', () => {
    const canvas = document.getElementById('wheelCanvas');
    const wheel = new Wheel(canvas, { theme: 'light', onResult: onWinner });
    const nameInput = document.getElementById('nameInput');
    const addBtn = document.getElementById('addBtn');
    const addRandomBtn = document.getElementById('addRandomBtn');
    const bulkInput = document.getElementById('bulkInput');
    const bulkAddBtn = document.getElementById('bulkAddBtn');
    const clearBulkBtn = document.getElementById('clearBulkBtn');
    const nameList = document.getElementById('nameList');
    const countSpan = document.getElementById('count');
    const spinBtn = document.getElementById('spinBtn');
    const rerollBtn = document.getElementById('rerollBtn');
    const clearNamesBtn = document.getElementById('clearNamesBtn');
    const themeSelect = document.getElementById('themeSelect');
    const resultSection = document.getElementById('result');
    const winnerNameDiv = document.getElementById('winnerName');
    const exportBtn = document.getElementById('exportBtn');
    const importBtn = document.getElementById('importBtn');
    const importFile = document.getElementById('importFile');
    // Initial draw
    wheel.draw();
    function updateUI() {
      const names = wheel.names;
      countSpan.textContent = names.length;
      renderNameList();
    }
    function renderNameList() {
      nameList.innerHTML = '';
      wheel.names.forEach((n, i) => {
        const li = document.createElement('li');
        const span = document.createElement('span');
        span.textContent = n;
        li.appendChild(span);
        const btn = document.createElement('button');
        btn.title = 'Remove';
        btn.setAttribute('aria-label', `Remove ${n}`);
        btn.innerHTML = '✕';
        btn.addEventListener('click', () => {
          wheel.removeName(i);
          updateUI();
        });
        li.appendChild(btn);
        nameList.appendChild(li);
      });
    }
    function addNameFromInput() {
      const v = nameInput.value.trim();
      if (!v) { showMessage('Please enter a name.', 'warn'); return; }
      wheel.addName(v);
      nameInput.value = '';
      updateUI();
    }
    addBtn.addEventListener('click', addNameFromInput);
    nameInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') addNameFromInput(); });
    addRandomBtn.addEventListener('click', () => {
      const samples = ['Alex','Jordan','Taylor','Sam','Jamie','Casey','Morgan','Riley','Avery','Dana'];
      const count = rand(3,6);
      for (let i=0;i<count;i++) wheel.addName(samples[rand(0,samples.length-1)] + (rand(1,100)));
      updateUI();
    });
    bulkAddBtn.addEventListener('click', () => {
      const text = bulkInput.value.trim();
      if (!text) { showMessage('Bulk input is empty.', 'warn'); return; }
      const parsed = text.split(/[\n,;]+/).map(s => s.trim()).filter(s => s);
      parsed.forEach(p => wheel.addName(p));
      bulkInput.value = '';
      updateUI();
      showMessage(`Added ${parsed.length} names.`, 'info');
    });
    clearBulkBtn.addEventListener('click', () => { bulkInput.value = ''; });
    spinBtn.addEventListener('click', () => {
      if (wheel.names.length === 0) { showMessage('Add at least one name to spin.', 'warn'); return; }
      resultSection.hidden = true;
      winnerNameDiv.textContent = '';
      wheel.spin();
      spinBtn.disabled = true;
      const checkFinish = setInterval(() => {
        if (!wheel.isSpinning) {
          clearInterval(checkFinish);
          spinBtn.disabled = false;
        }
      }, 200);
    });
    rerollBtn.addEventListener('click', () => {
      resultSection.hidden = true;
      wheel.spin();
    });
    clearNamesBtn.addEventListener('click', () => {
      if (confirm('Clear all names?')) {
        wheel.clearNames();
        updateUI();
      }
    });
    themeSelect.addEventListener('change', (e) => {
      const t = e.target.value;
      document.body.className = 'theme-' + t;
      wheel.setTheme(t);
    });
    function onWinner(result) {
      winnerNameDiv.textContent = result.name || '—';
      resultSection.hidden = false;
      // Flash the winner item in the list (if still present)
      const items = Array.from(nameList.children);
      items.forEach((li, idx) => { li.classList.toggle('winner', idx === result.index); });
      showMessage(`Winner: ${result.name}`, 'success', 4000);
    }
    // Simple message area
    function showMessage(text, type = 'info', duration = 2200) {
      // create small toast
      const t = document.createElement('div');
      t.className = 'tmp-toast ' + type;
      t.textContent = text;
      document.body.appendChild(t);
      // Force reflow to pick up transitions
      window.getComputedStyle(t).opacity;
      setTimeout(()=> { t.style.opacity = '0'; t.style.transform = 'translateY(-10px)'; }, duration - 300);
      setTimeout(()=> { try { t.remove(); } catch(e){} }, duration);
    }
    // Export/import CSV
    exportBtn.addEventListener('click', () => {
      if (wheel.names.length === 0) { showMessage('No names to export.', 'warn'); return; }
      const csv = wheel.names.map(n => `"${(n||'').replace(/"/g,'""')}"`).join('\n');
      const blob = new Blob([csv], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'participants.csv';
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
      showMessage('Exported CSV', 'info');
    });
    importBtn.addEventListener('click', () => { importFile.click(); });
    importFile.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (ev) => {
        const txt = ev.target.result;
        const lines = txt.split(/\r?\n/).map(s => s.trim()).filter(s => s);
        // basic CSV unquote
        const parsed = lines.map(l => {
          // simple CSV single-column parse: handle quoted fields
          if (l.startsWith('"') && l.endsWith('"')) {
            return l.slice(1,-1).replace(/""/g,'"');
          }
          return l;
        });
        parsed.forEach(p => wheel.addName(p));
        updateUI();
        showMessage(`Imported ${parsed.length} names`, 'info');
      };
      reader.readAsText(file);
      importFile.value = '';
    });
    // Initial sample (optional)
    // wheel.addName('Alice'); wheel.addName('Bob'); wheel.addName('Charlie');
    updateUI();
    // (Optional) keyboard shortcuts
    window.addEventListener('keydown', (e) => {
      if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'k') {
        e.preventDefault();
        nameInput.focus();
      }
      if (e.key === ' ') {
        // space triggers spin if not focusing an input
        if (document.activeElement.tagName !== 'INPUT' && document.activeElement.tagName !== 'TEXTAREA') {
          e.preventDefault();
          spinBtn.click();
        }
      }
    });
  });
})(); 
```

"

As the Programmer, you should write a requirements.txt file, which is commonly used in Python projects to specify the dependencies or packages required for the project to run properly. It serves as a way to document and manage the project's dependencies in a standardized format. For example:

requirements.txt

```

numpy==1.19.2

pandas>=1.1.4

```

According to the codes and file format listed above, write a requirements.txt file to specify the dependencies or packages required for the project to run properly.

[2025-17-09 13:48:01 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2025-17-09 13:48:01 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 7255
completion_tokens: 250
total_tokens: 7505
cost: $-1.000000


[2025-17-09 13:48:01 INFO] Programmer: **Programmer<->Chief Technology Officer on : EnvironmentDoc, turn 0**

[ChatDev is a software company powered by multiple intelligent agents, such as chief executive officer, chief human resources officer, chief product officer, chief technology officer, etc, with a multi-agent organizational structure and the mission of 'changing the digital world through programming'.
You are Chief Technology Officer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer.
You are very familiar to information technology. You will make high-level decisions for the overarching technology infrastructure that closely align with the organization's goals, while you work alongside the organization's information technology ("IT") staff members to perform everyday operations.
Here is a new customer's task: [Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes. Do it in HTML, CSS, and JavaScript.].
To complete the task, You must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]

# No Python packages are required for this project (pure HTML/CSS/JavaScript).
# If you later add a Python backend, list packages here, e.g.:
# flask==2.2.3

# (No dependencies)

[2025-17-09 13:48:01 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | [Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes. Do it in HTML, CSS, and JavaScript.] |
| **assistant_role_name** | Chief Executive Officer |
| **user_role_name** | Counselor |
| **phase_prompt** | Here is a conversation between two roles: {conversations} {question} |
| **phase_name** | Reflection |
| **assistant_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully complete a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. To complete the task, I will give you one or more instructions, and you must help me to write a specific solution that appropriately solves the requested instruction based on your expertise and my needs. |
| **user_role_prompt** | {chatdev_prompt} You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer. Your main responsibilities include asking what user and customer think and provide your valuable suggestions.  Here is a new customer's task: {task}. To complete the task, I will give you one or more instructions, and you must help me to write a specific solution that appropriately solves the requested instruction based on your expertise and my needs. |
| **placeholders** | {'conversations': 'Programmer: ChatDev is a software company powered by multiple intelligent agents, such as chief executive officer, chief human resources officer, chief product officer, chief technology officer, etc, with a multi-agent organizational structure and the mission of \'changing the digital world through programming\'.\nYou are Programmer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer.\nYou can write/create computer software or applications by providing a specific programming language to the computer. You have extensive computing and coding experience in many varieties of programming languages and platforms, such as Python, Java, C, C++, HTML, CSS, JavaScript, XML, SQL, PHP, etc,.\nHere is a new customer\'s task: [Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes. Do it in HTML, CSS, and JavaScript.].\nTo complete the task, you must write a response that appropriately solves the requested instruction based on your expertise and customer\'s needs.\n\nChief Technology Officer: The new user\'s task and our developed codes are listed: \nTask: "[Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes. Do it in HTML, CSS, and JavaScript.]".\nModality: "website".\nProgramming Language: " JavaScript"\nIdeas: ""\nCodes: \n"index.html\nhtml\n\'\'\'\nThis is the main HTML file for the Random Winner Wheel.\nIt contains the structure: input fields to add names, a canvas for the wheel,\ncontrols (spin, clear, bulk add), theme selector, and placeholders for CSS/JS.\n\'\'\'\n&lt;!doctype html&gt;\n&lt;html lang="en"&gt;\n&lt;head&gt;\n  &lt;meta charset="utf-8" /&gt;\n  &lt;meta name="viewport" content="width=device-width,initial-scale=1" /&gt;\n  &lt;title&gt;Random Winner Wheel&lt;/title&gt;\n  &lt;link rel="stylesheet" href="styles.css"&gt;\n&lt;/head&gt;\n&lt;body class="theme-light"&gt;\n  &lt;!--\n    This is the main HTML file for the Random Winner Wheel.\n    It contains the structure: input fields to add names, a canvas for the wheel,\n    controls (spin, clear, bulk add), theme selector, and placeholders for CSS/JS.\n  --&gt;\n  &lt;header&gt;\n    &lt;h1&gt;Random Winner Wheel&lt;/h1&gt;\n    &lt;p&gt;Enter participant names, choose a theme, and spin to pick a winner.&lt;/p&gt;\n  &lt;/header&gt;\n  &lt;main&gt;\n    &lt;section class="controls"&gt;\n      &lt;div class="add-single"&gt;\n        &lt;input id="nameInput" type="text" placeholder="Enter a name and press Add" aria-label="Name input" /&gt;\n        &lt;button id="addBtn"&gt;Add&lt;/button&gt;\n        &lt;button id="addRandomBtn" title="Add a few sample random names"&gt;Add Sample&lt;/button&gt;\n      &lt;/div&gt;\n      &lt;div class="bulk-add"&gt;\n        &lt;label for="bulkInput"&gt;Bulk add (comma, newline or semicolon separated):&lt;/label&gt;\n        &lt;textarea id="bulkInput" placeholder="Alice, Bob, Charlie"&gt;&lt;/textarea&gt;\n        &lt;div class="bulk-actions"&gt;\n          &lt;button id="bulkAddBtn"&gt;Bulk Add&lt;/button&gt;\n          &lt;button id="clearBulkBtn"&gt;Clear Bulk&lt;/button&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;\n      &lt;div class="list-actions"&gt;\n        &lt;div class="theme-select"&gt;\n          &lt;label for="themeSelect"&gt;Theme:&lt;/label&gt;\n          &lt;select id="themeSelect"&gt;\n            &lt;option value="light"&gt;Light&lt;/option&gt;\n            &lt;option value="dark"&gt;Dark&lt;/option&gt;\n            &lt;option value="neon"&gt;Neon&lt;/option&gt;\n            &lt;option value="pastel"&gt;Pastel&lt;/option&gt;\n            &lt;option value="retro"&gt;Retro&lt;/option&gt;\n          &lt;/select&gt;\n        &lt;/div&gt;\n        &lt;div class="wheel-controls"&gt;\n          &lt;button id="spinBtn" class="primary"&gt;Spin&lt;/button&gt;\n          &lt;button id="clearNamesBtn"&gt;Clear Names&lt;/button&gt;\n          &lt;button id="exportBtn"&gt;Export CSV&lt;/button&gt;\n          &lt;input id="importFile" type="file" accept=".csv,text/csv" style="display:none"&gt;\n          &lt;button id="importBtn"&gt;Import CSV&lt;/button&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;\n    &lt;/section&gt;\n    &lt;section class="wheel-area"&gt;\n      &lt;div class="wheel-container"&gt;\n        &lt;canvas id="wheelCanvas" width="600" height="600" aria-label="Spinning wheel"&gt;&lt;/canvas&gt;\n        &lt;div class="pointer" aria-hidden="true"&gt;▼&lt;/div&gt;\n      &lt;/div&gt;\n      &lt;aside class="participants"&gt;\n        &lt;h2&gt;Participants (&lt;span id="count"&gt;0&lt;/span&gt;)&lt;/h2&gt;\n        &lt;ul id="nameList" aria-live="polite"&gt;&lt;/ul&gt;\n      &lt;/aside&gt;\n    &lt;/section&gt;\n    &lt;section class="result" id="result" aria-live="polite" hidden&gt;\n      &lt;h2&gt;Winner&lt;/h2&gt;\n      &lt;div id="winnerName" class="winnerName"&gt;&lt;/div&gt;\n      &lt;button id="rerollBtn"&gt;Spin Again&lt;/button&gt;\n    &lt;/section&gt;\n  &lt;/main&gt;\n  &lt;footer&gt;\n    &lt;small&gt;Built with HTML, CSS, and JavaScript. Themes change both UI and wheel colors.&lt;/small&gt;\n  &lt;/footer&gt;\n  &lt;script src="script.js"&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\nstyles.css\ncss\n\'\'\'\nStylesheet for the Random Winner Wheel.\nDefines layout, themes, wheel container sizing, animations, and toast styles.\n\'\'\'\n/*\n Stylesheet for the Random Winner Wheel.\n Defines layout, themes, wheel container sizing, animations, and toast styles.\n*/\n/* Reset &amp; base */\n* { box-sizing: border-box; margin: 0; padding: 0; }\nhtml,body { height: 100%; font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; background: var(--bg); color: var(--fg); }\n:root {\n  --bg: #f7f8fb;\n  --fg: #222;\n  --muted: #666;\n  --accent: #2b8cff;\n  --card: #ffffff;\n  --primary-btn-bg: var(--accent);\n  --primary-btn-fg: #fff;\n  --shadow: rgba(15,15,15,0.08);\n}\n/* Themes */\nbody.theme-light {\n  --bg: #f7f8fb;\n  --fg: #222;\n  --muted: #5b6170;\n  --accent: #2b8cff;\n  --card: #fff;\n  --wheel-seq: 0;\n}\nbody.theme-dark {\n  --bg: #0f1724;\n  --fg: #e6eef8;\n  --muted: #a9b1c2;\n  --accent: #7c5cff;\n  --card: #0b1220;\n}\nbody.theme-neon {\n  --bg: #0a0a0f;\n  --fg: #e9f9ff;\n  --muted: #a6f3ff;\n  --accent: #39ff14;\n  --card: #09101a;\n}\nbody.theme-pastel {\n  --bg: #fffaf6;\n  --fg: #3c3a3a;\n  --muted: #8d8a8a;\n  --accent: #ff7aa2;\n  --card: #fff;\n}\nbody.theme-retro {\n  --bg: #fff6e7;\n  --fg: #402b2b;\n  --muted: #856e6e;\n  --accent: #ffb86b;\n  --card: #fff0e6;\n}\n/* Layout */\nheader { padding: 18px 24px; text-align: center; background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent); }\nheader h1 { font-size: 1.5rem; margin-bottom: 6px; }\nmain { padding: 18px; max-width: 1100px; margin: 0 auto; }\n.controls { display: grid; gap: 12px; margin-bottom: 18px; }\n.add-single { display:flex; gap:8px; }\n.add-single input[type="text"] { flex:1; padding:10px; border-radius:8px; border:1px solid rgba(0,0,0,0.08); background:var(--card); color:var(--fg); }\n.add-single button { padding:10px 12px; border-radius:8px; border: none; cursor:pointer; background: var(--primary-btn-bg); color: var(--primary-btn-fg); }\n.add-single button#addRandomBtn { background: transparent; border: 1px solid rgba(0,0,0,0.06); color: var(--fg); }\n.bulk-add textarea { width:100%; min-height:64px; margin-top:6px; padding:8px; border-radius:8px; border:1px solid rgba(0,0,0,0.06); background:var(--card); color:var(--fg); }\n.bulk-actions { display:flex; gap:8px; margin-top:8px; }\n.list-actions { display:flex; justify-content:space-between; align-items:center; gap:16px; flex-wrap:wrap; }\n.theme-select select { padding:8px; border-radius:8px; border:1px solid rgba(0,0,0,0.06); }\n.wheel-area { display:flex; gap:18px; align-items:start; flex-wrap:wrap; }\n.wheel-container { position: relative; width: 600px; height: 600px; max-width: 90vw; max-height: 90vw; display:flex; align-items:center; justify-content:center; background: transparent; }\n.pointer {\n  /* Centered triangular pointer positioned above the wheel.\n     This ensures the visual pointer aligns with the wheel math (top-center).\n     Hides the fallback glyph in the HTML and draws a sharp triangle instead. */\n  position: absolute;\n  top: 8px;               /* vertical offset from top of wheel container */\n  left: 50%;              /* center horizontally */\n  transform: translateX(-50%); /* center on the X axis */\n  width: 0;\n  height: 0;\n  border-left: 12px solid transparent;\n  border-right: 12px solid transparent;\n  border-bottom: 18px solid var(--accent);\n  z-index: 10;            /* ensure it\'s above the canvas */\n  pointer-events: none;\n  /* hide textual glyph fallback content (the ▼ in HTML) */\n  font-size: 0;\n  line-height: 0;\n  text-indent: -9999px;\n}\n/* Participants panel and wheel styles */\n.participants { width: 320px; max-width: 40vw; background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent); padding:12px; border-radius:10px; box-shadow: 0 6px 18px var(--shadow); }\n.participants h2 { margin-bottom:8px; font-size:1.05rem; }\n#nameList { list-style:none; max-height:420px; overflow:auto; display:block; }\n#nameList li { padding:8px; border-radius:6px; display:flex; justify-content:space-between; align-items:center; gap:8px; margin-bottom:8px; background: var(--card); border:1px solid rgba(0,0,0,0.04); }\n#nameList li button { background: transparent; border: none; color: var(--muted); cursor:pointer; }\n.result { margin-top:18px; padding:12px; border-radius:8px; background: var(--card); text-align:center; box-shadow: 0 6px 18px var(--shadow); }\n.result .winnerName { font-size:1.4rem; font-weight:700; margin:8px 0; color: var(--accent); }\n/* Buttons */\nbutton { cursor:pointer; padding:8px 12px; border-radius:8px; border:1px solid rgba(0,0,0,0.06); background: transparent; color:var(--fg); }\nbutton.primary { background: var(--primary-btn-bg); color: var(--primary-btn-fg); border: none; }\n/* Responsive */\n@media (max-width: 900px) {\n  .wheel-area { flex-direction:column; align-items:center; }\n  .participants { width: 100%; max-width: 100%; }\n}\n/* Wheel canvas scaling helper */\n#wheelCanvas { border-radius:50%; box-shadow: 0 12px 26px rgba(0,0,0,0.12); background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.02), transparent); }\n/* Toast / temporary message styles (used by showMessage) */\n.tmp-toast {\n  position: fixed;\n  left: 50%;\n  transform: translateX(-50%);\n  top: 18px;\n  background: rgba(0,0,0,0.85);\n  color: #fff;\n  padding: 8px 12px;\n  border-radius: 6px;\n  z-index: 9999;\n  transition: opacity 0.25s, transform 0.25s;\n  opacity: 1;\n  pointer-events: none;\n  font-size: 0.95rem;\n  box-shadow: 0 6px 18px rgba(0,0,0,0.18);\n}\n.tmp-toast.success { background: rgba(56, 198, 123, 0.95); }\n.tmp-toast.warn    { background: rgba(255, 159, 67, 0.95); color: #2b1500; }\n.tmp-toast.info    { background: rgba(12, 74, 255, 0.95); }\n/* Winner highlight for participants list */\n#nameList li.winner {\n  outline: 3px solid rgba(255,215,0,0.15);\n  box-shadow: 0 6px 18px rgba(255,215,0,0.06);\n  transform: scale(1.01);\n}\n\nscript.js\njs\n\'\'\'\nScript for the Random Winner Wheel.\nContains the Wheel class to draw and spin the canvas-based wheel and UI glue code to manage names and themes.\n\'\'\'\n/*\n Script for the Random Winner Wheel.\n Contains the Wheel class to draw and spin the canvas-based wheel and UI glue code to manage names and themes.\n*/\n/* Main JavaScript - Wheel + UI logic */\n(() =&gt; {\n  // Utilities\n  function rand(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }\n  function easeOutCubic(t) { return 1 - Math.pow(1 - t, 3); }\n  // Color palettes for themes (will be used to paint wheel segments)\n  const THEME_PALETTES = {\n    light: [\'#FF8A80\',\'#FFD180\',\'#FFF59D\',\'#C8E6C9\',\'#80DEEA\',\'#A7FFEB\',\'#B39DDB\',\'#90CAF9\'],\n    dark: [\'#ff6b6b\',\'#ffd166\',\'#faff8e\',\'#b9f6ca\',\'#4dd0e1\',\'#80cbc4\',\'#b388ff\',\'#64b5f6\'],\n    neon: [\'#ff2d95\',\'#7cff01\',\'#00ffff\',\'#ffdd00\',\'#ff6a00\',\'#00ff9e\',\'#ff00ff\',\'#47ffa2\'],\n    pastel: [\'#ffdbe9\',\'#fff0b3\',\'#d1ffd6\',\'#cfefff\',\'#e7dfff\',\'#ffd6e7\',\'#fbe7d6\',\'#e6f7ff\'],\n    retro: [\'#ffb86b\',\'#ffd3a8\',\'#f3e2a9\',\'#b8e0d2\',\'#c0b9ff\',\'#ffb6c1\',\'#f6c49f\',\'#c3d69b\']\n  };\n  // Wheel class\n  class Wheel {\n    /*\n    Manage wheel: drawing, recalculating segments, spinning animation, and determining winner.\n    */\n    constructor(canvas, options = {}) {\n      this.canvas = canvas;\n      this.ctx = canvas.getContext(\'2d\');\n      this.names = [];\n      this.rotation = 0; // radians\n      this.isSpinning = false;\n      this.frame = null;\n      this.onResult = options.onResult || function() {};\n      this.theme = options.theme || \'light\';\n      this.padAngle = 0.02; // radians padding between segments\n      this.textColor = \'#111\';\n      this._devicePixelRatioFix();\n      window.addEventListener(\'resize\', () =&gt; { this._devicePixelRatioFix(); this.draw(); });\n    }\n    _devicePixelRatioFix() {\n      const dpr = window.devicePixelRatio || 1;\n      const rect = this.canvas.getBoundingClientRect();\n      // If rect has zero size (canvas not yet laid out), use current width/height attributes as fallback\n      const width = rect.width || (this.canvas.width / dpr);\n      const height = rect.height || (this.canvas.height / dpr);\n      this.canvas.width = width * dpr;\n      this.canvas.height = height * dpr;\n      this.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n      this.centerX = width / 2;\n      this.centerY = height / 2;\n      this.radius = Math.min(width, height) / 2 - 18;\n    }\n    setTheme(themeId) { this.theme = themeId; this.draw(); }\n    setNames(names) {\n      this.names = names.slice();\n      this.draw();\n    }\n    addName(name) {\n      this.names.push(name);\n      this.draw();\n    }\n    removeName(index) {\n      if (index &gt;= 0 &amp;&amp; index &lt; this.names.length) {\n        this.names.splice(index,1);\n        this.draw();\n      }\n    }\n    clearNames() {\n      this.names = [];\n      this.draw();\n    }\n    draw() {\n      const ctx = this.ctx;\n      const w = this.canvas.width / (window.devicePixelRatio || 1);\n      const h = this.canvas.height / (window.devicePixelRatio || 1);\n      ctx.clearRect(0,0,w,h);\n      ctx.save();\n      ctx.translate(this.centerX, this.centerY);\n      ctx.rotate(this.rotation);\n      // draw segments\n      const count = Math.max(this.names.length, 1);\n      const palette = THEME_PALETTES[this.theme] || THEME_PALETTES.light;\n      for (let i = 0; i &lt; count; i++) {\n        const start = (i / count) * Math.PI * 2;\n        const end = ((i + 1) / count) * Math.PI * 2;\n        ctx.beginPath();\n        ctx.moveTo(0,0);\n        ctx.arc(0,0,this.radius, start + this.padAngle, end - this.padAngle, false);\n        ctx.closePath();\n        const color = palette[i % palette.length];\n        ctx.fillStyle = color;\n        ctx.fill();\n        ctx.strokeStyle = (i % 2 === 0) ? \'rgba(0,0,0,0.06)\' : \'rgba(0,0,0,0.03)\';\n        ctx.lineWidth = 1;\n        ctx.stroke();\n        // draw text label\n        const mid = (start + end) / 2;\n        ctx.save();\n        ctx.rotate(mid);\n        ctx.translate(this.radius * 0.6, 0);\n        ctx.rotate(Math.PI/2);\n        ctx.fillStyle = getTextColor(color);\n        ctx.font = `${Math.max(12, Math.min(22, this.radius / 8))}px sans-serif`;\n        ctx.textAlign = \'center\';\n        ctx.textBaseline = \'middle\';\n        const label = (this.names.length === 0) ? \'Add names\' : this.names[i % this.names.length];\n        wrapFillText(ctx, label, 0, 0, this.radius * 0.5, 16);\n        ctx.restore();\n      }\n      // draw center circle\n      ctx.beginPath();\n      ctx.arc(0,0, this.radius * 0.16, 0, Math.PI*2);\n      ctx.fillStyle = \'rgba(255,255,255,0.9)\';\n      ctx.fill();\n      ctx.strokeStyle = \'rgba(0,0,0,0.06)\';\n      ctx.stroke();\n      ctx.restore();\n      // draw outer ring (pointer side neutral)\n      ctx.beginPath();\n      ctx.arc(this.centerX, this.centerY, this.radius + 10, 0, Math.PI*2);\n      ctx.strokeStyle = \'rgba(0,0,0,0.03)\';\n      ctx.lineWidth = 2;\n      ctx.stroke();\n    }\n    spin() {\n      if (this.isSpinning || this.names.length === 0) return;\n      this.isSpinning = true;\n      const count = this.names.length;\n      // Determine random winner index to land on:\n      const winnerIndex = rand(0, count - 1);\n      // Calculate final rotation so that winner segment lines up with pointer at top (pointer at canvas top - rotation must align)\n      // Our pointer is at the top (canvas 0 angle). The segment mid-angle for index i (without rotation) is ((i + 0.5)/count)*2pi\n      const segmentMid = ((winnerIndex + 0.5) / count) * Math.PI * 2;\n      // We want segmentMid + rotation_final == -Math.PI/2 (so it points at the top pointer), so rotation_final = -Math.PI/2 - segmentMid + 2pi*N\n      const extraTurns = rand(5, 8); // full spins\n      const rotationFinal = -Math.PI/2 - segmentMid + extraTurns * Math.PI * 2;\n      const startRotation = this.rotation % (Math.PI * 2);\n      const delta = rotationFinal - startRotation;\n      const duration = 4000 + Math.random() * 1500; // ms\n      const startTime = performance.now();\n      const animate = (now) =&gt; {\n        const elapsed = now - startTime;\n        const t = Math.min(elapsed / duration, 1);\n        const eased = easeOutCubic(t);\n        this.rotation = startRotation + delta * eased;\n        this.draw();\n        if (t &lt; 1) {\n          this.frame = requestAnimationFrame(animate);\n        } else {\n          this.isSpinning = false;\n          // Normalize rotation within 0..2pi\n          this.rotation = ((this.rotation % (Math.PI*2)) + Math.PI*2) % (Math.PI*2);\n          this.draw();\n          // Compute final winner index again from rotation\n          // finalAngle: the angle of the segment at pointer (0 at right, +counterclockwise). We compute a normalized angle that maps to segment index.\n          const finalAngle = ((-this.rotation - Math.PI/2) % (Math.PI*2) + Math.PI*2) % (Math.PI*2);\n          const resultingIndex = Math.floor((finalAngle / (Math.PI*2)) * count) % count;\n          const winner = this.names[resultingIndex];\n          this.onResult({ index: resultingIndex, name: winner });\n        }\n      };\n      this.frame = requestAnimationFrame(animate);\n    }\n  }\n  // Helper: pick readable text color for a background\n  function getTextColor(hex) {\n    // remove # and convert\n    const h = hex.replace(\'#\',\'\');\n    const r = parseInt(h.substring(0,2),16);\n    const g = parseInt(h.substring(2,4),16);\n    const b = parseInt(h.substring(4,6),16);\n    // luminance\n    const lum = (0.299*r + 0.587*g + 0.114*b) / 255;\n    return lum &gt; 0.65 ? \'#111\' : \'#fff\';\n  }\n  // Helper: wrap text within a given width (draws multi-line if necessary)\n  function wrapFillText(ctx, text, x, y, maxWidth, lineHeight) {\n    const words = (text || \'\').split(/\\s+/);\n    if (words.length === 0) return;\n    let line = \'\';\n    const lines = [];\n    for (let n = 0; n &lt; words.length; n++) {\n      const testLine = line ? line + \' \' + words[n] : words[n];\n      const metrics = ctx.measureText(testLine);\n      if (metrics.width &gt; maxWidth &amp;&amp; line) {\n        lines.push(line);\n        line = words[n];\n      } else {\n        line = testLine;\n      }\n    }\n    if (line) lines.push(line);\n    // If still too many lines, just draw what\'s possible (we rely on font size)\n    for (let i=0;i&lt;lines.length;i++){\n      ctx.fillText(lines[i], x, y + (i - (lines.length-1)/2) * lineHeight);\n    }\n  }\n  // UI glue\n  document.addEventListener(\'DOMContentLoaded\', () =&gt; {\n    const canvas = document.getElementById(\'wheelCanvas\');\n    const wheel = new Wheel(canvas, { theme: \'light\', onResult: onWinner });\n    const nameInput = document.getElementById(\'nameInput\');\n    const addBtn = document.getElementById(\'addBtn\');\n    const addRandomBtn = document.getElementById(\'addRandomBtn\');\n    const bulkInput = document.getElementById(\'bulkInput\');\n    const bulkAddBtn = document.getElementById(\'bulkAddBtn\');\n    const clearBulkBtn = document.getElementById(\'clearBulkBtn\');\n    const nameList = document.getElementById(\'nameList\');\n    const countSpan = document.getElementById(\'count\');\n    const spinBtn = document.getElementById(\'spinBtn\');\n    const rerollBtn = document.getElementById(\'rerollBtn\');\n    const clearNamesBtn = document.getElementById(\'clearNamesBtn\');\n    const themeSelect = document.getElementById(\'themeSelect\');\n    const resultSection = document.getElementById(\'result\');\n    const winnerNameDiv = document.getElementById(\'winnerName\');\n    const exportBtn = document.getElementById(\'exportBtn\');\n    const importBtn = document.getElementById(\'importBtn\');\n    const importFile = document.getElementById(\'importFile\');\n    // Initial draw\n    wheel.draw();\n    function updateUI() {\n      const names = wheel.names;\n      countSpan.textContent = names.length;\n      renderNameList();\n    }\n    function renderNameList() {\n      nameList.innerHTML = \'\';\n      wheel.names.forEach((n, i) =&gt; {\n        const li = document.createElement(\'li\');\n        const span = document.createElement(\'span\');\n        span.textContent = n;\n        li.appendChild(span);\n        const btn = document.createElement(\'button\');\n        btn.title = \'Remove\';\n        btn.setAttribute(\'aria-label\', `Remove ${n}`);\n        btn.innerHTML = \'✕\';\n        btn.addEventListener(\'click\', () =&gt; {\n          wheel.removeName(i);\n          updateUI();\n        });\n        li.appendChild(btn);\n        nameList.appendChild(li);\n      });\n    }\n    function addNameFromInput() {\n      const v = nameInput.value.trim();\n      if (!v) { showMessage(\'Please enter a name.\', \'warn\'); return; }\n      wheel.addName(v);\n      nameInput.value = \'\';\n      updateUI();\n    }\n    addBtn.addEventListener(\'click\', addNameFromInput);\n    nameInput.addEventListener(\'keydown\', (e) =&gt; { if (e.key === \'Enter\') addNameFromInput(); });\n    addRandomBtn.addEventListener(\'click\', () =&gt; {\n      const samples = [\'Alex\',\'Jordan\',\'Taylor\',\'Sam\',\'Jamie\',\'Casey\',\'Morgan\',\'Riley\',\'Avery\',\'Dana\'];\n      const count = rand(3,6);\n      for (let i=0;i&lt;count;i++) wheel.addName(samples[rand(0,samples.length-1)] + (rand(1,100)));\n      updateUI();\n    });\n    bulkAddBtn.addEventListener(\'click\', () =&gt; {\n      const text = bulkInput.value.trim();\n      if (!text) { showMessage(\'Bulk input is empty.\', \'warn\'); return; }\n      const parsed = text.split(/[\\n,;]+/).map(s =&gt; s.trim()).filter(s =&gt; s);\n      parsed.forEach(p =&gt; wheel.addName(p));\n      bulkInput.value = \'\';\n      updateUI();\n      showMessage(`Added ${parsed.length} names.`, \'info\');\n    });\n    clearBulkBtn.addEventListener(\'click\', () =&gt; { bulkInput.value = \'\'; });\n    spinBtn.addEventListener(\'click\', () =&gt; {\n      if (wheel.names.length === 0) { showMessage(\'Add at least one name to spin.\', \'warn\'); return; }\n      resultSection.hidden = true;\n      winnerNameDiv.textContent = \'\';\n      wheel.spin();\n      spinBtn.disabled = true;\n      const checkFinish = setInterval(() =&gt; {\n        if (!wheel.isSpinning) {\n          clearInterval(checkFinish);\n          spinBtn.disabled = false;\n        }\n      }, 200);\n    });\n    rerollBtn.addEventListener(\'click\', () =&gt; {\n      resultSection.hidden = true;\n      wheel.spin();\n    });\n    clearNamesBtn.addEventListener(\'click\', () =&gt; {\n      if (confirm(\'Clear all names?\')) {\n        wheel.clearNames();\n        updateUI();\n      }\n    });\n    themeSelect.addEventListener(\'change\', (e) =&gt; {\n      const t = e.target.value;\n      document.body.className = \'theme-\' + t;\n      wheel.setTheme(t);\n    });\n    function onWinner(result) {\n      winnerNameDiv.textContent = result.name || \'—\';\n      resultSection.hidden = false;\n      // Flash the winner item in the list (if still present)\n      const items = Array.from(nameList.children);\n      items.forEach((li, idx) =&gt; { li.classList.toggle(\'winner\', idx === result.index); });\n      showMessage(`Winner: ${result.name}`, \'success\', 4000);\n    }\n    // Simple message area\n    function showMessage(text, type = \'info\', duration = 2200) {\n      // create small toast\n      const t = document.createElement(\'div\');\n      t.className = \'tmp-toast \' + type;\n      t.textContent = text;\n      document.body.appendChild(t);\n      // Force reflow to pick up transitions\n      window.getComputedStyle(t).opacity;\n      setTimeout(()=&gt; { t.style.opacity = \'0\'; t.style.transform = \'translateY(-10px)\'; }, duration - 300);\n      setTimeout(()=&gt; { try { t.remove(); } catch(e){} }, duration);\n    }\n    // Export/import CSV\n    exportBtn.addEventListener(\'click\', () =&gt; {\n      if (wheel.names.length === 0) { showMessage(\'No names to export.\', \'warn\'); return; }\n      const csv = wheel.names.map(n =&gt; `"${(n||\'\').replace(/"/g,\'""\')}"`).join(\'\\n\');\n      const blob = new Blob([csv], { type: \'text/csv\' });\n      const url = URL.createObjectURL(blob);\n      const a = document.createElement(\'a\');\n      a.href = url;\n      a.download = \'participants.csv\';\n      document.body.appendChild(a);\n      a.click();\n      a.remove();\n      URL.revokeObjectURL(url);\n      showMessage(\'Exported CSV\', \'info\');\n    });\n    importBtn.addEventListener(\'click\', () =&gt; { importFile.click(); });\n    importFile.addEventListener(\'change\', (e) =&gt; {\n      const file = e.target.files[0];\n      if (!file) return;\n      const reader = new FileReader();\n      reader.onload = (ev) =&gt; {\n        const txt = ev.target.result;\n        const lines = txt.split(/\\r?\\n/).map(s =&gt; s.trim()).filter(s =&gt; s);\n        // basic CSV unquote\n        const parsed = lines.map(l =&gt; {\n          // simple CSV single-column parse: handle quoted fields\n          if (l.startsWith(\'"\') &amp;&amp; l.endsWith(\'"\')) {\n            return l.slice(1,-1).replace(/""/g,\'"\');\n          }\n          return l;\n        });\n        parsed.forEach(p =&gt; wheel.addName(p));\n        updateUI();\n        showMessage(`Imported ${parsed.length} names`, \'info\');\n      };\n      reader.readAsText(file);\n      importFile.value = \'\';\n    });\n    // Initial sample (optional)\n    // wheel.addName(\'Alice\'); wheel.addName(\'Bob\'); wheel.addName(\'Charlie\');\n    updateUI();\n    // (Optional) keyboard shortcuts\n    window.addEventListener(\'keydown\', (e) =&gt; {\n      if ((e.ctrlKey || e.metaKey) &amp;&amp; e.key.toLowerCase() === \'k\') {\n        e.preventDefault();\n        nameInput.focus();\n      }\n      if (e.key === \' \') {\n        // space triggers spin if not focusing an input\n        if (document.activeElement.tagName !== \'INPUT\' &amp;&amp; document.activeElement.tagName !== \'TEXTAREA\') {\n          e.preventDefault();\n          spinBtn.click();\n        }\n      }\n    });\n  });\n})(); \n\n"\nAs the Programmer, you should write a requirements.txt file, which is commonly used in Python projects to specify the dependencies or packages required for the project to run properly. It serves as a way to document and manage the project\'s dependencies in a standardized format. For example:\nrequirements.txt\n\nnumpy==1.19.2\npandas&gt;=1.1.4\n\nAccording to the codes and file format listed above, write a requirements.txt file to specify the dependencies or packages required for the project to run properly.\n\nProgrammer: # No Python packages are required for this project (pure HTML/CSS/JavaScript).\n# If you later add a Python backend, list packages here, e.g.:\n# flask==2.2.3\n# (No dependencies)', 'question': 'According to the codes and file format listed above, write a requirements.txt file to specify the dependencies or packages required for the project to run properly." '} |
| **need_reflect** | False |
| **memory** | No existed memory |
| **chat_turn_limit** | 1 |
| **model_type** | ModelType.GPT_3_5_TURBO |

[2025-17-09 13:48:01 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Chief Executive Officer |
| **user_role_name** | Counselor |
| **assistant_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully complete a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. To complete the task, I will give you one or more instructions, and you must help me to write a specific solution that appropriately solves the requested instruction based on your expertise and my needs. |
| **user_role_prompt** | {chatdev_prompt} You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer. Your main responsibilities include asking what user and customer think and provide your valuable suggestions.  Here is a new customer's task: {task}. To complete the task, I will give you one or more instructions, and you must help me to write a specific solution that appropriately solves the requested instruction based on your expertise and my needs. |
| **task_prompt** | [Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes. Do it in HTML, CSS, and JavaScript.] |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_3_5_TURBO |
| **background_prompt** | ChatDev is a software company powered by multiple intelligent agents, such as chief executive officer, chief human resources officer, chief product officer, chief technology officer, etc, with a multi-agent organizational structure and the mission of 'changing the digital world through programming'. |

[2025-17-09 13:48:01 INFO] Counselor: **[Start Chat]**

[ChatDev is a software company powered by multiple intelligent agents, such as chief executive officer, chief human resources officer, chief product officer, chief technology officer, etc, with a multi-agent organizational structure and the mission of 'changing the digital world through programming'.
You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully complete a task assigned by a new customer.
Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees.
Here is a new customer's task: [Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes. Do it in HTML, CSS, and JavaScript.].
To complete the task, I will give you one or more instructions, and you must help me to write a specific solution that appropriately solves the requested instruction based on your expertise and my needs.]

Here is a conversation between two roles: Programmer: ChatDev is a software company powered by multiple intelligent agents, such as chief executive officer, chief human resources officer, chief product officer, chief technology officer, etc, with a multi-agent organizational structure and the mission of 'changing the digital world through programming'.
You are Programmer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer.
You can write/create computer software or applications by providing a specific programming language to the computer. You have extensive computing and coding experience in many varieties of programming languages and platforms, such as Python, Java, C, C++, HTML, CSS, JavaScript, XML, SQL, PHP, etc,.
Here is a new customer's task: [Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes. Do it in HTML, CSS, and JavaScript.].
To complete the task, you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.

Chief Technology Officer: The new user's task and our developed codes are listed: 
Task: "[Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes. Do it in HTML, CSS, and JavaScript.]".
Modality: "website".
Programming Language: " JavaScript"
Ideas: ""
Codes: 
"index.html
```html
'''
This is the main HTML file for the Random Winner Wheel.
It contains the structure: input fields to add names, a canvas for the wheel,
controls (spin, clear, bulk add), theme selector, and placeholders for CSS/JS.
'''
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Random Winner Wheel</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body class="theme-light">
  <!--
    This is the main HTML file for the Random Winner Wheel.
    It contains the structure: input fields to add names, a canvas for the wheel,
    controls (spin, clear, bulk add), theme selector, and placeholders for CSS/JS.
  -->
  <header>
    <h1>Random Winner Wheel</h1>
    <p>Enter participant names, choose a theme, and spin to pick a winner.</p>
  </header>
  <main>
    <section class="controls">
      <div class="add-single">
        <input id="nameInput" type="text" placeholder="Enter a name and press Add" aria-label="Name input" />
        <button id="addBtn">Add</button>
        <button id="addRandomBtn" title="Add a few sample random names">Add Sample</button>
      </div>
      <div class="bulk-add">
        <label for="bulkInput">Bulk add (comma, newline or semicolon separated):</label>
        <textarea id="bulkInput" placeholder="Alice, Bob, Charlie"></textarea>
        <div class="bulk-actions">
          <button id="bulkAddBtn">Bulk Add</button>
          <button id="clearBulkBtn">Clear Bulk</button>
        </div>
      </div>
      <div class="list-actions">
        <div class="theme-select">
          <label for="themeSelect">Theme:</label>
          <select id="themeSelect">
            <option value="light">Light</option>
            <option value="dark">Dark</option>
            <option value="neon">Neon</option>
            <option value="pastel">Pastel</option>
            <option value="retro">Retro</option>
          </select>
        </div>
        <div class="wheel-controls">
          <button id="spinBtn" class="primary">Spin</button>
          <button id="clearNamesBtn">Clear Names</button>
          <button id="exportBtn">Export CSV</button>
          <input id="importFile" type="file" accept=".csv,text/csv" style="display:none">
          <button id="importBtn">Import CSV</button>
        </div>
      </div>
    </section>
    <section class="wheel-area">
      <div class="wheel-container">
        <canvas id="wheelCanvas" width="600" height="600" aria-label="Spinning wheel"></canvas>
        <div class="pointer" aria-hidden="true">▼</div>
      </div>
      <aside class="participants">
        <h2>Participants (<span id="count">0</span>)</h2>
        <ul id="nameList" aria-live="polite"></ul>
      </aside>
    </section>
    <section class="result" id="result" aria-live="polite" hidden>
      <h2>Winner</h2>
      <div id="winnerName" class="winnerName"></div>
      <button id="rerollBtn">Spin Again</button>
    </section>
  </main>
  <footer>
    <small>Built with HTML, CSS, and JavaScript. Themes change both UI and wheel colors.</small>
  </footer>
  <script src="script.js"></script>
</body>
</html>
```
styles.css
```css
'''
Stylesheet for the Random Winner Wheel.
Defines layout, themes, wheel container sizing, animations, and toast styles.
'''
/*
 Stylesheet for the Random Winner Wheel.
 Defines layout, themes, wheel container sizing, animations, and toast styles.
*/
/* Reset & base */
* { box-sizing: border-box; margin: 0; padding: 0; }
html,body { height: 100%; font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; background: var(--bg); color: var(--fg); }
:root {
  --bg: #f7f8fb;
  --fg: #222;
  --muted: #666;
  --accent: #2b8cff;
  --card: #ffffff;
  --primary-btn-bg: var(--accent);
  --primary-btn-fg: #fff;
  --shadow: rgba(15,15,15,0.08);
}
/* Themes */
body.theme-light {
  --bg: #f7f8fb;
  --fg: #222;
  --muted: #5b6170;
  --accent: #2b8cff;
  --card: #fff;
  --wheel-seq: 0;
}
body.theme-dark {
  --bg: #0f1724;
  --fg: #e6eef8;
  --muted: #a9b1c2;
  --accent: #7c5cff;
  --card: #0b1220;
}
body.theme-neon {
  --bg: #0a0a0f;
  --fg: #e9f9ff;
  --muted: #a6f3ff;
  --accent: #39ff14;
  --card: #09101a;
}
body.theme-pastel {
  --bg: #fffaf6;
  --fg: #3c3a3a;
  --muted: #8d8a8a;
  --accent: #ff7aa2;
  --card: #fff;
}
body.theme-retro {
  --bg: #fff6e7;
  --fg: #402b2b;
  --muted: #856e6e;
  --accent: #ffb86b;
  --card: #fff0e6;
}
/* Layout */
header { padding: 18px 24px; text-align: center; background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent); }
header h1 { font-size: 1.5rem; margin-bottom: 6px; }
main { padding: 18px; max-width: 1100px; margin: 0 auto; }
.controls { display: grid; gap: 12px; margin-bottom: 18px; }
.add-single { display:flex; gap:8px; }
.add-single input[type="text"] { flex:1; padding:10px; border-radius:8px; border:1px solid rgba(0,0,0,0.08); background:var(--card); color:var(--fg); }
.add-single button { padding:10px 12px; border-radius:8px; border: none; cursor:pointer; background: var(--primary-btn-bg); color: var(--primary-btn-fg); }
.add-single button#addRandomBtn { background: transparent; border: 1px solid rgba(0,0,0,0.06); color: var(--fg); }
.bulk-add textarea { width:100%; min-height:64px; margin-top:6px; padding:8px; border-radius:8px; border:1px solid rgba(0,0,0,0.06); background:var(--card); color:var(--fg); }
.bulk-actions { display:flex; gap:8px; margin-top:8px; }
.list-actions { display:flex; justify-content:space-between; align-items:center; gap:16px; flex-wrap:wrap; }
.theme-select select { padding:8px; border-radius:8px; border:1px solid rgba(0,0,0,0.06); }
.wheel-area { display:flex; gap:18px; align-items:start; flex-wrap:wrap; }
.wheel-container { position: relative; width: 600px; height: 600px; max-width: 90vw; max-height: 90vw; display:flex; align-items:center; justify-content:center; background: transparent; }
.pointer {
  /* Centered triangular pointer positioned above the wheel.
     This ensures the visual pointer aligns with the wheel math (top-center).
     Hides the fallback glyph in the HTML and draws a sharp triangle instead. */
  position: absolute;
  top: 8px;               /* vertical offset from top of wheel container */
  left: 50%;              /* center horizontally */
  transform: translateX(-50%); /* center on the X axis */
  width: 0;
  height: 0;
  border-left: 12px solid transparent;
  border-right: 12px solid transparent;
  border-bottom: 18px solid var(--accent);
  z-index: 10;            /* ensure it's above the canvas */
  pointer-events: none;
  /* hide textual glyph fallback content (the ▼ in HTML) */
  font-size: 0;
  line-height: 0;
  text-indent: -9999px;
}
/* Participants panel and wheel styles */
.participants { width: 320px; max-width: 40vw; background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent); padding:12px; border-radius:10px; box-shadow: 0 6px 18px var(--shadow); }
.participants h2 { margin-bottom:8px; font-size:1.05rem; }
#nameList { list-style:none; max-height:420px; overflow:auto; display:block; }
#nameList li { padding:8px; border-radius:6px; display:flex; justify-content:space-between; align-items:center; gap:8px; margin-bottom:8px; background: var(--card); border:1px solid rgba(0,0,0,0.04); }
#nameList li button { background: transparent; border: none; color: var(--muted); cursor:pointer; }
.result { margin-top:18px; padding:12px; border-radius:8px; background: var(--card); text-align:center; box-shadow: 0 6px 18px var(--shadow); }
.result .winnerName { font-size:1.4rem; font-weight:700; margin:8px 0; color: var(--accent); }
/* Buttons */
button { cursor:pointer; padding:8px 12px; border-radius:8px; border:1px solid rgba(0,0,0,0.06); background: transparent; color:var(--fg); }
button.primary { background: var(--primary-btn-bg); color: var(--primary-btn-fg); border: none; }
/* Responsive */
@media (max-width: 900px) {
  .wheel-area { flex-direction:column; align-items:center; }
  .participants { width: 100%; max-width: 100%; }
}
/* Wheel canvas scaling helper */
#wheelCanvas { border-radius:50%; box-shadow: 0 12px 26px rgba(0,0,0,0.12); background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.02), transparent); }
/* Toast / temporary message styles (used by showMessage) */
.tmp-toast {
  position: fixed;
  left: 50%;
  transform: translateX(-50%);
  top: 18px;
  background: rgba(0,0,0,0.85);
  color: #fff;
  padding: 8px 12px;
  border-radius: 6px;
  z-index: 9999;
  transition: opacity 0.25s, transform 0.25s;
  opacity: 1;
  pointer-events: none;
  font-size: 0.95rem;
  box-shadow: 0 6px 18px rgba(0,0,0,0.18);
}
.tmp-toast.success { background: rgba(56, 198, 123, 0.95); }
.tmp-toast.warn    { background: rgba(255, 159, 67, 0.95); color: #2b1500; }
.tmp-toast.info    { background: rgba(12, 74, 255, 0.95); }
/* Winner highlight for participants list */
#nameList li.winner {
  outline: 3px solid rgba(255,215,0,0.15);
  box-shadow: 0 6px 18px rgba(255,215,0,0.06);
  transform: scale(1.01);
}
```
script.js
```js
'''
Script for the Random Winner Wheel.
Contains the Wheel class to draw and spin the canvas-based wheel and UI glue code to manage names and themes.
'''
/*
 Script for the Random Winner Wheel.
 Contains the Wheel class to draw and spin the canvas-based wheel and UI glue code to manage names and themes.
*/
/* Main JavaScript - Wheel + UI logic */
(() => {
  // Utilities
  function rand(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }
  function easeOutCubic(t) { return 1 - Math.pow(1 - t, 3); }
  // Color palettes for themes (will be used to paint wheel segments)
  const THEME_PALETTES = {
    light: ['#FF8A80','#FFD180','#FFF59D','#C8E6C9','#80DEEA','#A7FFEB','#B39DDB','#90CAF9'],
    dark: ['#ff6b6b','#ffd166','#faff8e','#b9f6ca','#4dd0e1','#80cbc4','#b388ff','#64b5f6'],
    neon: ['#ff2d95','#7cff01','#00ffff','#ffdd00','#ff6a00','#00ff9e','#ff00ff','#47ffa2'],
    pastel: ['#ffdbe9','#fff0b3','#d1ffd6','#cfefff','#e7dfff','#ffd6e7','#fbe7d6','#e6f7ff'],
    retro: ['#ffb86b','#ffd3a8','#f3e2a9','#b8e0d2','#c0b9ff','#ffb6c1','#f6c49f','#c3d69b']
  };
  // Wheel class
  class Wheel {
    /*
    Manage wheel: drawing, recalculating segments, spinning animation, and determining winner.
    */
    constructor(canvas, options = {}) {
      this.canvas = canvas;
      this.ctx = canvas.getContext('2d');
      this.names = [];
      this.rotation = 0; // radians
      this.isSpinning = false;
      this.frame = null;
      this.onResult = options.onResult || function() {};
      this.theme = options.theme || 'light';
      this.padAngle = 0.02; // radians padding between segments
      this.textColor = '#111';
      this._devicePixelRatioFix();
      window.addEventListener('resize', () => { this._devicePixelRatioFix(); this.draw(); });
    }
    _devicePixelRatioFix() {
      const dpr = window.devicePixelRatio || 1;
      const rect = this.canvas.getBoundingClientRect();
      // If rect has zero size (canvas not yet laid out), use current width/height attributes as fallback
      const width = rect.width || (this.canvas.width / dpr);
      const height = rect.height || (this.canvas.height / dpr);
      this.canvas.width = width * dpr;
      this.canvas.height = height * dpr;
      this.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      this.centerX = width / 2;
      this.centerY = height / 2;
      this.radius = Math.min(width, height) / 2 - 18;
    }
    setTheme(themeId) { this.theme = themeId; this.draw(); }
    setNames(names) {
      this.names = names.slice();
      this.draw();
    }
    addName(name) {
      this.names.push(name);
      this.draw();
    }
    removeName(index) {
      if (index >= 0 && index < this.names.length) {
        this.names.splice(index,1);
        this.draw();
      }
    }
    clearNames() {
      this.names = [];
      this.draw();
    }
    draw() {
      const ctx = this.ctx;
      const w = this.canvas.width / (window.devicePixelRatio || 1);
      const h = this.canvas.height / (window.devicePixelRatio || 1);
      ctx.clearRect(0,0,w,h);
      ctx.save();
      ctx.translate(this.centerX, this.centerY);
      ctx.rotate(this.rotation);
      // draw segments
      const count = Math.max(this.names.length, 1);
      const palette = THEME_PALETTES[this.theme] || THEME_PALETTES.light;
      for (let i = 0; i < count; i++) {
        const start = (i / count) * Math.PI * 2;
        const end = ((i + 1) / count) * Math.PI * 2;
        ctx.beginPath();
        ctx.moveTo(0,0);
        ctx.arc(0,0,this.radius, start + this.padAngle, end - this.padAngle, false);
        ctx.closePath();
        const color = palette[i % palette.length];
        ctx.fillStyle = color;
        ctx.fill();
        ctx.strokeStyle = (i % 2 === 0) ? 'rgba(0,0,0,0.06)' : 'rgba(0,0,0,0.03)';
        ctx.lineWidth = 1;
        ctx.stroke();
        // draw text label
        const mid = (start + end) / 2;
        ctx.save();
        ctx.rotate(mid);
        ctx.translate(this.radius * 0.6, 0);
        ctx.rotate(Math.PI/2);
        ctx.fillStyle = getTextColor(color);
        ctx.font = `${Math.max(12, Math.min(22, this.radius / 8))}px sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        const label = (this.names.length === 0) ? 'Add names' : this.names[i % this.names.length];
        wrapFillText(ctx, label, 0, 0, this.radius * 0.5, 16);
        ctx.restore();
      }
      // draw center circle
      ctx.beginPath();
      ctx.arc(0,0, this.radius * 0.16, 0, Math.PI*2);
      ctx.fillStyle = 'rgba(255,255,255,0.9)';
      ctx.fill();
      ctx.strokeStyle = 'rgba(0,0,0,0.06)';
      ctx.stroke();
      ctx.restore();
      // draw outer ring (pointer side neutral)
      ctx.beginPath();
      ctx.arc(this.centerX, this.centerY, this.radius + 10, 0, Math.PI*2);
      ctx.strokeStyle = 'rgba(0,0,0,0.03)';
      ctx.lineWidth = 2;
      ctx.stroke();
    }
    spin() {
      if (this.isSpinning || this.names.length === 0) return;
      this.isSpinning = true;
      const count = this.names.length;
      // Determine random winner index to land on:
      const winnerIndex = rand(0, count - 1);
      // Calculate final rotation so that winner segment lines up with pointer at top (pointer at canvas top - rotation must align)
      // Our pointer is at the top (canvas 0 angle). The segment mid-angle for index i (without rotation) is ((i + 0.5)/count)*2pi
      const segmentMid = ((winnerIndex + 0.5) / count) * Math.PI * 2;
      // We want segmentMid + rotation_final == -Math.PI/2 (so it points at the top pointer), so rotation_final = -Math.PI/2 - segmentMid + 2pi*N
      const extraTurns = rand(5, 8); // full spins
      const rotationFinal = -Math.PI/2 - segmentMid + extraTurns * Math.PI * 2;
      const startRotation = this.rotation % (Math.PI * 2);
      const delta = rotationFinal - startRotation;
      const duration = 4000 + Math.random() * 1500; // ms
      const startTime = performance.now();
      const animate = (now) => {
        const elapsed = now - startTime;
        const t = Math.min(elapsed / duration, 1);
        const eased = easeOutCubic(t);
        this.rotation = startRotation + delta * eased;
        this.draw();
        if (t < 1) {
          this.frame = requestAnimationFrame(animate);
        } else {
          this.isSpinning = false;
          // Normalize rotation within 0..2pi
          this.rotation = ((this.rotation % (Math.PI*2)) + Math.PI*2) % (Math.PI*2);
          this.draw();
          // Compute final winner index again from rotation
          // finalAngle: the angle of the segment at pointer (0 at right, +counterclockwise). We compute a normalized angle that maps to segment index.
          const finalAngle = ((-this.rotation - Math.PI/2) % (Math.PI*2) + Math.PI*2) % (Math.PI*2);
          const resultingIndex = Math.floor((finalAngle / (Math.PI*2)) * count) % count;
          const winner = this.names[resultingIndex];
          this.onResult({ index: resultingIndex, name: winner });
        }
      };
      this.frame = requestAnimationFrame(animate);
    }
  }
  // Helper: pick readable text color for a background
  function getTextColor(hex) {
    // remove # and convert
    const h = hex.replace('#','');
    const r = parseInt(h.substring(0,2),16);
    const g = parseInt(h.substring(2,4),16);
    const b = parseInt(h.substring(4,6),16);
    // luminance
    const lum = (0.299*r + 0.587*g + 0.114*b) / 255;
    return lum > 0.65 ? '#111' : '#fff';
  }
  // Helper: wrap text within a given width (draws multi-line if necessary)
  function wrapFillText(ctx, text, x, y, maxWidth, lineHeight) {
    const words = (text || '').split(/\s+/);
    if (words.length === 0) return;
    let line = '';
    const lines = [];
    for (let n = 0; n < words.length; n++) {
      const testLine = line ? line + ' ' + words[n] : words[n];
      const metrics = ctx.measureText(testLine);
      if (metrics.width > maxWidth && line) {
        lines.push(line);
        line = words[n];
      } else {
        line = testLine;
      }
    }
    if (line) lines.push(line);
    // If still too many lines, just draw what's possible (we rely on font size)
    for (let i=0;i<lines.length;i++){
      ctx.fillText(lines[i], x, y + (i - (lines.length-1)/2) * lineHeight);
    }
  }
  // UI glue
  document.addEventListener('DOMContentLoaded', () => {
    const canvas = document.getElementById('wheelCanvas');
    const wheel = new Wheel(canvas, { theme: 'light', onResult: onWinner });
    const nameInput = document.getElementById('nameInput');
    const addBtn = document.getElementById('addBtn');
    const addRandomBtn = document.getElementById('addRandomBtn');
    const bulkInput = document.getElementById('bulkInput');
    const bulkAddBtn = document.getElementById('bulkAddBtn');
    const clearBulkBtn = document.getElementById('clearBulkBtn');
    const nameList = document.getElementById('nameList');
    const countSpan = document.getElementById('count');
    const spinBtn = document.getElementById('spinBtn');
    const rerollBtn = document.getElementById('rerollBtn');
    const clearNamesBtn = document.getElementById('clearNamesBtn');
    const themeSelect = document.getElementById('themeSelect');
    const resultSection = document.getElementById('result');
    const winnerNameDiv = document.getElementById('winnerName');
    const exportBtn = document.getElementById('exportBtn');
    const importBtn = document.getElementById('importBtn');
    const importFile = document.getElementById('importFile');
    // Initial draw
    wheel.draw();
    function updateUI() {
      const names = wheel.names;
      countSpan.textContent = names.length;
      renderNameList();
    }
    function renderNameList() {
      nameList.innerHTML = '';
      wheel.names.forEach((n, i) => {
        const li = document.createElement('li');
        const span = document.createElement('span');
        span.textContent = n;
        li.appendChild(span);
        const btn = document.createElement('button');
        btn.title = 'Remove';
        btn.setAttribute('aria-label', `Remove ${n}`);
        btn.innerHTML = '✕';
        btn.addEventListener('click', () => {
          wheel.removeName(i);
          updateUI();
        });
        li.appendChild(btn);
        nameList.appendChild(li);
      });
    }
    function addNameFromInput() {
      const v = nameInput.value.trim();
      if (!v) { showMessage('Please enter a name.', 'warn'); return; }
      wheel.addName(v);
      nameInput.value = '';
      updateUI();
    }
    addBtn.addEventListener('click', addNameFromInput);
    nameInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') addNameFromInput(); });
    addRandomBtn.addEventListener('click', () => {
      const samples = ['Alex','Jordan','Taylor','Sam','Jamie','Casey','Morgan','Riley','Avery','Dana'];
      const count = rand(3,6);
      for (let i=0;i<count;i++) wheel.addName(samples[rand(0,samples.length-1)] + (rand(1,100)));
      updateUI();
    });
    bulkAddBtn.addEventListener('click', () => {
      const text = bulkInput.value.trim();
      if (!text) { showMessage('Bulk input is empty.', 'warn'); return; }
      const parsed = text.split(/[\n,;]+/).map(s => s.trim()).filter(s => s);
      parsed.forEach(p => wheel.addName(p));
      bulkInput.value = '';
      updateUI();
      showMessage(`Added ${parsed.length} names.`, 'info');
    });
    clearBulkBtn.addEventListener('click', () => { bulkInput.value = ''; });
    spinBtn.addEventListener('click', () => {
      if (wheel.names.length === 0) { showMessage('Add at least one name to spin.', 'warn'); return; }
      resultSection.hidden = true;
      winnerNameDiv.textContent = '';
      wheel.spin();
      spinBtn.disabled = true;
      const checkFinish = setInterval(() => {
        if (!wheel.isSpinning) {
          clearInterval(checkFinish);
          spinBtn.disabled = false;
        }
      }, 200);
    });
    rerollBtn.addEventListener('click', () => {
      resultSection.hidden = true;
      wheel.spin();
    });
    clearNamesBtn.addEventListener('click', () => {
      if (confirm('Clear all names?')) {
        wheel.clearNames();
        updateUI();
      }
    });
    themeSelect.addEventListener('change', (e) => {
      const t = e.target.value;
      document.body.className = 'theme-' + t;
      wheel.setTheme(t);
    });
    function onWinner(result) {
      winnerNameDiv.textContent = result.name || '—';
      resultSection.hidden = false;
      // Flash the winner item in the list (if still present)
      const items = Array.from(nameList.children);
      items.forEach((li, idx) => { li.classList.toggle('winner', idx === result.index); });
      showMessage(`Winner: ${result.name}`, 'success', 4000);
    }
    // Simple message area
    function showMessage(text, type = 'info', duration = 2200) {
      // create small toast
      const t = document.createElement('div');
      t.className = 'tmp-toast ' + type;
      t.textContent = text;
      document.body.appendChild(t);
      // Force reflow to pick up transitions
      window.getComputedStyle(t).opacity;
      setTimeout(()=> { t.style.opacity = '0'; t.style.transform = 'translateY(-10px)'; }, duration - 300);
      setTimeout(()=> { try { t.remove(); } catch(e){} }, duration);
    }
    // Export/import CSV
    exportBtn.addEventListener('click', () => {
      if (wheel.names.length === 0) { showMessage('No names to export.', 'warn'); return; }
      const csv = wheel.names.map(n => `"${(n||'').replace(/"/g,'""')}"`).join('\n');
      const blob = new Blob([csv], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'participants.csv';
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
      showMessage('Exported CSV', 'info');
    });
    importBtn.addEventListener('click', () => { importFile.click(); });
    importFile.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (ev) => {
        const txt = ev.target.result;
        const lines = txt.split(/\r?\n/).map(s => s.trim()).filter(s => s);
        // basic CSV unquote
        const parsed = lines.map(l => {
          // simple CSV single-column parse: handle quoted fields
          if (l.startsWith('"') && l.endsWith('"')) {
            return l.slice(1,-1).replace(/""/g,'"');
          }
          return l;
        });
        parsed.forEach(p => wheel.addName(p));
        updateUI();
        showMessage(`Imported ${parsed.length} names`, 'info');
      };
      reader.readAsText(file);
      importFile.value = '';
    });
    // Initial sample (optional)
    // wheel.addName('Alice'); wheel.addName('Bob'); wheel.addName('Charlie');
    updateUI();
    // (Optional) keyboard shortcuts
    window.addEventListener('keydown', (e) => {
      if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'k') {
        e.preventDefault();
        nameInput.focus();
      }
      if (e.key === ' ') {
        // space triggers spin if not focusing an input
        if (document.activeElement.tagName !== 'INPUT' && document.activeElement.tagName !== 'TEXTAREA') {
          e.preventDefault();
          spinBtn.click();
        }
      }
    });
  });
})(); 
```
"
As the Programmer, you should write a requirements.txt file, which is commonly used in Python projects to specify the dependencies or packages required for the project to run properly. It serves as a way to document and manage the project's dependencies in a standardized format. For example:
requirements.txt
```
numpy==1.19.2
pandas>=1.1.4
```
According to the codes and file format listed above, write a requirements.txt file to specify the dependencies or packages required for the project to run properly.

Programmer: # No Python packages are required for this project (pure HTML/CSS/JavaScript).
# If you later add a Python backend, list packages here, e.g.:
# flask==2.2.3
# (No dependencies) According to the codes and file format listed above, write a requirements.txt file to specify the dependencies or packages required for the project to run properly." 

[2025-17-09 13:48:13 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2025-17-09 13:48:13 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 7578
completion_tokens: 251
total_tokens: 7829
cost: $-1.000000


[2025-17-09 13:48:13 INFO] Chief Executive Officer: **Chief Executive Officer<->Counselor on : Reflection, turn 0**

[ChatDev is a software company powered by multiple intelligent agents, such as chief executive officer, chief human resources officer, chief product officer, chief technology officer, etc, with a multi-agent organizational structure and the mission of 'changing the digital world through programming'.
You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer.
Your main responsibilities include asking what user and customer think and provide your valuable suggestions. 
Here is a new customer's task: [Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes. Do it in HTML, CSS, and JavaScript.].
To complete the task, I will give you one or more instructions, and you must help me to write a specific solution that appropriately solves the requested instruction based on your expertise and my needs.]

# No Python dependencies required for this project (pure HTML/CSS/JavaScript)
# If you add a Python backend later, list packages here, for example:
# flask==2.2.3
# requests>=2.28.0

[2025-17-09 13:48:13 INFO] **[Seminar Conclusion]**:

 # No Python dependencies required for this project (pure HTML/CSS/JavaScript)
# If you add a Python backend later, list packages here, for example:
# flask==2.2.3
# requests>=2.28.0

[2025-17-09 13:48:13 INFO] **[Seminar Conclusion]**:

 <INFO> # No Python dependencies required for this project (pure HTML/CSS/JavaScript)
# If you add a Python backend later, list packages here, for example:
# flask==2.2.3
# requests>=2.28.0

[2025-17-09 13:48:13 INFO] **[Software Info]**:

 

💰**cost**=$0.090527

🔨**version_updates**=-1

📃**num_code_files**=0

🏞**num_png_files**=0

📚**num_doc_files**=7

📃**code_lines**=0

📋**env_lines**=-1

📒**manual_lines**=-1

🗣**num_utterances**=23

🤔**num_self_reflections**=1

❓**num_prompt_tokens**=60767

❗**num_completion_tokens**=40096

🌟**num_total_tokens**=100863

[2025-17-09 13:48:14 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | [Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes. Do it in HTML, CSS, and JavaScript.] |
| **need_reflect** | False |
| **assistant_role_name** | Chief Product Officer |
| **user_role_name** | Chief Executive Officer |
| **phase_prompt** | The new user's task, our developed codes and required dependencies are listed:  Task: "{task}". Modality: "{modality}". Programming Language: "{language}" Ideas: "{ideas}" Codes:  "{codes}" Requirements: "{requirements}" As the {assistant_role}, by using Markdown, you should write a manual.md file which is a detailed user manual to use the software, including introducing main functions of the software, how to install environment dependencies and how to use/play it. For example: manual.md ``` LangChain Building applications with LLMs through composability Looking for the JS/TS version? Check out LangChain.js. Production Support: As you move your LangChains into production, we'd love to offer more comprehensive support. Please fill out this form and we'll set up a dedicated support Slack channel. Quick Install pip install langchain or conda install langchain -c conda-forge 🤔 What is this? Large language models (LLMs) are emerging as a transformative technology, enabling developers to build applications that they previously could not. However, using these LLMs in isolation is often insufficient for creating a truly powerful app - the real power comes when you can combine them with other sources of computation or knowledge. This library aims to assist in the development of those types of applications. Common examples of these applications include: ❓ Question Answering over specific documents   Documentation   End-to-end Example: Question Answering over Notion Database   🤖 Agents   Documentation   End-to-end Example: GPT+WolframAlpha   📖 Documentation Please see here for full documentation on:   Getting started (installation, setting up the environment, simple examples)   How-To examples (demos, integrations, helper functions)   Reference (full API docs)   Resources (high-level explanation of core concepts)   ``` |
| **phase_name** | Manual |
| **assistant_role_prompt** | {chatdev_prompt} You are Chief Product Officer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. You are responsible for all product-related matters in ChatDev. Usually includes product design, product strategy, product vision, product innovation, project management and product marketing. Here is a new customer's task: {task}. To complete the task, you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully complete a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. To complete the task, I will give you one or more instructions, and you must help me to write a specific solution that appropriately solves the requested instruction based on your expertise and my needs. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'task': '[Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes. Do it in HTML, CSS, and JavaScript.]', 'modality': 'website', 'ideas': '', 'language': ' JavaScript', 'codes': 'index.html\nhtml\n\'\'\'\nThis is the main HTML file for the Random Winner Wheel.\nIt contains the structure: input fields to add names, a canvas for the wheel,\ncontrols (spin, clear, bulk add), theme selector, and placeholders for CSS/JS.\n\'\'\'\n&lt;!doctype html&gt;\n&lt;html lang="en"&gt;\n&lt;head&gt;\n  &lt;meta charset="utf-8" /&gt;\n  &lt;meta name="viewport" content="width=device-width,initial-scale=1" /&gt;\n  &lt;title&gt;Random Winner Wheel&lt;/title&gt;\n  &lt;link rel="stylesheet" href="styles.css"&gt;\n&lt;/head&gt;\n&lt;body class="theme-light"&gt;\n  &lt;!--\n    This is the main HTML file for the Random Winner Wheel.\n    It contains the structure: input fields to add names, a canvas for the wheel,\n    controls (spin, clear, bulk add), theme selector, and placeholders for CSS/JS.\n  --&gt;\n  &lt;header&gt;\n    &lt;h1&gt;Random Winner Wheel&lt;/h1&gt;\n    &lt;p&gt;Enter participant names, choose a theme, and spin to pick a winner.&lt;/p&gt;\n  &lt;/header&gt;\n  &lt;main&gt;\n    &lt;section class="controls"&gt;\n      &lt;div class="add-single"&gt;\n        &lt;input id="nameInput" type="text" placeholder="Enter a name and press Add" aria-label="Name input" /&gt;\n        &lt;button id="addBtn"&gt;Add&lt;/button&gt;\n        &lt;button id="addRandomBtn" title="Add a few sample random names"&gt;Add Sample&lt;/button&gt;\n      &lt;/div&gt;\n      &lt;div class="bulk-add"&gt;\n        &lt;label for="bulkInput"&gt;Bulk add (comma, newline or semicolon separated):&lt;/label&gt;\n        &lt;textarea id="bulkInput" placeholder="Alice, Bob, Charlie"&gt;&lt;/textarea&gt;\n        &lt;div class="bulk-actions"&gt;\n          &lt;button id="bulkAddBtn"&gt;Bulk Add&lt;/button&gt;\n          &lt;button id="clearBulkBtn"&gt;Clear Bulk&lt;/button&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;\n      &lt;div class="list-actions"&gt;\n        &lt;div class="theme-select"&gt;\n          &lt;label for="themeSelect"&gt;Theme:&lt;/label&gt;\n          &lt;select id="themeSelect"&gt;\n            &lt;option value="light"&gt;Light&lt;/option&gt;\n            &lt;option value="dark"&gt;Dark&lt;/option&gt;\n            &lt;option value="neon"&gt;Neon&lt;/option&gt;\n            &lt;option value="pastel"&gt;Pastel&lt;/option&gt;\n            &lt;option value="retro"&gt;Retro&lt;/option&gt;\n          &lt;/select&gt;\n        &lt;/div&gt;\n        &lt;div class="wheel-controls"&gt;\n          &lt;button id="spinBtn" class="primary"&gt;Spin&lt;/button&gt;\n          &lt;button id="clearNamesBtn"&gt;Clear Names&lt;/button&gt;\n          &lt;button id="exportBtn"&gt;Export CSV&lt;/button&gt;\n          &lt;input id="importFile" type="file" accept=".csv,text/csv" style="display:none"&gt;\n          &lt;button id="importBtn"&gt;Import CSV&lt;/button&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;\n    &lt;/section&gt;\n    &lt;section class="wheel-area"&gt;\n      &lt;div class="wheel-container"&gt;\n        &lt;canvas id="wheelCanvas" width="600" height="600" aria-label="Spinning wheel"&gt;&lt;/canvas&gt;\n        &lt;div class="pointer" aria-hidden="true"&gt;▼&lt;/div&gt;\n      &lt;/div&gt;\n      &lt;aside class="participants"&gt;\n        &lt;h2&gt;Participants (&lt;span id="count"&gt;0&lt;/span&gt;)&lt;/h2&gt;\n        &lt;ul id="nameList" aria-live="polite"&gt;&lt;/ul&gt;\n      &lt;/aside&gt;\n    &lt;/section&gt;\n    &lt;section class="result" id="result" aria-live="polite" hidden&gt;\n      &lt;h2&gt;Winner&lt;/h2&gt;\n      &lt;div id="winnerName" class="winnerName"&gt;&lt;/div&gt;\n      &lt;button id="rerollBtn"&gt;Spin Again&lt;/button&gt;\n    &lt;/section&gt;\n  &lt;/main&gt;\n  &lt;footer&gt;\n    &lt;small&gt;Built with HTML, CSS, and JavaScript. Themes change both UI and wheel colors.&lt;/small&gt;\n  &lt;/footer&gt;\n  &lt;script src="script.js"&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\n\nstyles.css\ncss\n\'\'\'\nStylesheet for the Random Winner Wheel.\nDefines layout, themes, wheel container sizing, animations, and toast styles.\n\'\'\'\n/*\n Stylesheet for the Random Winner Wheel.\n Defines layout, themes, wheel container sizing, animations, and toast styles.\n*/\n/* Reset &amp; base */\n* { box-sizing: border-box; margin: 0; padding: 0; }\nhtml,body { height: 100%; font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; background: var(--bg); color: var(--fg); }\n:root {\n  --bg: #f7f8fb;\n  --fg: #222;\n  --muted: #666;\n  --accent: #2b8cff;\n  --card: #ffffff;\n  --primary-btn-bg: var(--accent);\n  --primary-btn-fg: #fff;\n  --shadow: rgba(15,15,15,0.08);\n}\n/* Themes */\nbody.theme-light {\n  --bg: #f7f8fb;\n  --fg: #222;\n  --muted: #5b6170;\n  --accent: #2b8cff;\n  --card: #fff;\n  --wheel-seq: 0;\n}\nbody.theme-dark {\n  --bg: #0f1724;\n  --fg: #e6eef8;\n  --muted: #a9b1c2;\n  --accent: #7c5cff;\n  --card: #0b1220;\n}\nbody.theme-neon {\n  --bg: #0a0a0f;\n  --fg: #e9f9ff;\n  --muted: #a6f3ff;\n  --accent: #39ff14;\n  --card: #09101a;\n}\nbody.theme-pastel {\n  --bg: #fffaf6;\n  --fg: #3c3a3a;\n  --muted: #8d8a8a;\n  --accent: #ff7aa2;\n  --card: #fff;\n}\nbody.theme-retro {\n  --bg: #fff6e7;\n  --fg: #402b2b;\n  --muted: #856e6e;\n  --accent: #ffb86b;\n  --card: #fff0e6;\n}\n/* Layout */\nheader { padding: 18px 24px; text-align: center; background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent); }\nheader h1 { font-size: 1.5rem; margin-bottom: 6px; }\nmain { padding: 18px; max-width: 1100px; margin: 0 auto; }\n.controls { display: grid; gap: 12px; margin-bottom: 18px; }\n.add-single { display:flex; gap:8px; }\n.add-single input[type="text"] { flex:1; padding:10px; border-radius:8px; border:1px solid rgba(0,0,0,0.08); background:var(--card); color:var(--fg); }\n.add-single button { padding:10px 12px; border-radius:8px; border: none; cursor:pointer; background: var(--primary-btn-bg); color: var(--primary-btn-fg); }\n.add-single button#addRandomBtn { background: transparent; border: 1px solid rgba(0,0,0,0.06); color: var(--fg); }\n.bulk-add textarea { width:100%; min-height:64px; margin-top:6px; padding:8px; border-radius:8px; border:1px solid rgba(0,0,0,0.06); background:var(--card); color:var(--fg); }\n.bulk-actions { display:flex; gap:8px; margin-top:8px; }\n.list-actions { display:flex; justify-content:space-between; align-items:center; gap:16px; flex-wrap:wrap; }\n.theme-select select { padding:8px; border-radius:8px; border:1px solid rgba(0,0,0,0.06); }\n.wheel-area { display:flex; gap:18px; align-items:start; flex-wrap:wrap; }\n.wheel-container { position: relative; width: 600px; height: 600px; max-width: 90vw; max-height: 90vw; display:flex; align-items:center; justify-content:center; background: transparent; }\n.pointer {\n  /* Centered triangular pointer positioned above the wheel.\n     This ensures the visual pointer aligns with the wheel math (top-center).\n     Hides the fallback glyph in the HTML and draws a sharp triangle instead. */\n  position: absolute;\n  top: 8px;               /* vertical offset from top of wheel container */\n  left: 50%;              /* center horizontally */\n  transform: translateX(-50%); /* center on the X axis */\n  width: 0;\n  height: 0;\n  border-left: 12px solid transparent;\n  border-right: 12px solid transparent;\n  border-bottom: 18px solid var(--accent);\n  z-index: 10;            /* ensure it\'s above the canvas */\n  pointer-events: none;\n  /* hide textual glyph fallback content (the ▼ in HTML) */\n  font-size: 0;\n  line-height: 0;\n  text-indent: -9999px;\n}\n/* Participants panel and wheel styles */\n.participants { width: 320px; max-width: 40vw; background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent); padding:12px; border-radius:10px; box-shadow: 0 6px 18px var(--shadow); }\n.participants h2 { margin-bottom:8px; font-size:1.05rem; }\n#nameList { list-style:none; max-height:420px; overflow:auto; display:block; }\n#nameList li { padding:8px; border-radius:6px; display:flex; justify-content:space-between; align-items:center; gap:8px; margin-bottom:8px; background: var(--card); border:1px solid rgba(0,0,0,0.04); }\n#nameList li button { background: transparent; border: none; color: var(--muted); cursor:pointer; }\n.result { margin-top:18px; padding:12px; border-radius:8px; background: var(--card); text-align:center; box-shadow: 0 6px 18px var(--shadow); }\n.result .winnerName { font-size:1.4rem; font-weight:700; margin:8px 0; color: var(--accent); }\n/* Buttons */\nbutton { cursor:pointer; padding:8px 12px; border-radius:8px; border:1px solid rgba(0,0,0,0.06); background: transparent; color:var(--fg); }\nbutton.primary { background: var(--primary-btn-bg); color: var(--primary-btn-fg); border: none; }\n/* Responsive */\n@media (max-width: 900px) {\n  .wheel-area { flex-direction:column; align-items:center; }\n  .participants { width: 100%; max-width: 100%; }\n}\n/* Wheel canvas scaling helper */\n#wheelCanvas { border-radius:50%; box-shadow: 0 12px 26px rgba(0,0,0,0.12); background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.02), transparent); }\n/* Toast / temporary message styles (used by showMessage) */\n.tmp-toast {\n  position: fixed;\n  left: 50%;\n  transform: translateX(-50%);\n  top: 18px;\n  background: rgba(0,0,0,0.85);\n  color: #fff;\n  padding: 8px 12px;\n  border-radius: 6px;\n  z-index: 9999;\n  transition: opacity 0.25s, transform 0.25s;\n  opacity: 1;\n  pointer-events: none;\n  font-size: 0.95rem;\n  box-shadow: 0 6px 18px rgba(0,0,0,0.18);\n}\n.tmp-toast.success { background: rgba(56, 198, 123, 0.95); }\n.tmp-toast.warn    { background: rgba(255, 159, 67, 0.95); color: #2b1500; }\n.tmp-toast.info    { background: rgba(12, 74, 255, 0.95); }\n/* Winner highlight for participants list */\n#nameList li.winner {\n  outline: 3px solid rgba(255,215,0,0.15);\n  box-shadow: 0 6px 18px rgba(255,215,0,0.06);\n  transform: scale(1.01);\n}\n\n\nscript.js\njs\n\'\'\'\nScript for the Random Winner Wheel.\nContains the Wheel class to draw and spin the canvas-based wheel and UI glue code to manage names and themes.\n\'\'\'\n/*\n Script for the Random Winner Wheel.\n Contains the Wheel class to draw and spin the canvas-based wheel and UI glue code to manage names and themes.\n*/\n/* Main JavaScript - Wheel + UI logic */\n(() =&gt; {\n  // Utilities\n  function rand(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }\n  function easeOutCubic(t) { return 1 - Math.pow(1 - t, 3); }\n  // Color palettes for themes (will be used to paint wheel segments)\n  const THEME_PALETTES = {\n    light: [\'#FF8A80\',\'#FFD180\',\'#FFF59D\',\'#C8E6C9\',\'#80DEEA\',\'#A7FFEB\',\'#B39DDB\',\'#90CAF9\'],\n    dark: [\'#ff6b6b\',\'#ffd166\',\'#faff8e\',\'#b9f6ca\',\'#4dd0e1\',\'#80cbc4\',\'#b388ff\',\'#64b5f6\'],\n    neon: [\'#ff2d95\',\'#7cff01\',\'#00ffff\',\'#ffdd00\',\'#ff6a00\',\'#00ff9e\',\'#ff00ff\',\'#47ffa2\'],\n    pastel: [\'#ffdbe9\',\'#fff0b3\',\'#d1ffd6\',\'#cfefff\',\'#e7dfff\',\'#ffd6e7\',\'#fbe7d6\',\'#e6f7ff\'],\n    retro: [\'#ffb86b\',\'#ffd3a8\',\'#f3e2a9\',\'#b8e0d2\',\'#c0b9ff\',\'#ffb6c1\',\'#f6c49f\',\'#c3d69b\']\n  };\n  // Wheel class\n  class Wheel {\n    /*\n    Manage wheel: drawing, recalculating segments, spinning animation, and determining winner.\n    */\n    constructor(canvas, options = {}) {\n      this.canvas = canvas;\n      this.ctx = canvas.getContext(\'2d\');\n      this.names = [];\n      this.rotation = 0; // radians\n      this.isSpinning = false;\n      this.frame = null;\n      this.onResult = options.onResult || function() {};\n      this.theme = options.theme || \'light\';\n      this.padAngle = 0.02; // radians padding between segments\n      this.textColor = \'#111\';\n      this._devicePixelRatioFix();\n      window.addEventListener(\'resize\', () =&gt; { this._devicePixelRatioFix(); this.draw(); });\n    }\n    _devicePixelRatioFix() {\n      const dpr = window.devicePixelRatio || 1;\n      const rect = this.canvas.getBoundingClientRect();\n      // If rect has zero size (canvas not yet laid out), use current width/height attributes as fallback\n      const width = rect.width || (this.canvas.width / dpr);\n      const height = rect.height || (this.canvas.height / dpr);\n      this.canvas.width = width * dpr;\n      this.canvas.height = height * dpr;\n      this.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n      this.centerX = width / 2;\n      this.centerY = height / 2;\n      this.radius = Math.min(width, height) / 2 - 18;\n    }\n    setTheme(themeId) { this.theme = themeId; this.draw(); }\n    setNames(names) {\n      this.names = names.slice();\n      this.draw();\n    }\n    addName(name) {\n      this.names.push(name);\n      this.draw();\n    }\n    removeName(index) {\n      if (index &gt;= 0 &amp;&amp; index &lt; this.names.length) {\n        this.names.splice(index,1);\n        this.draw();\n      }\n    }\n    clearNames() {\n      this.names = [];\n      this.draw();\n    }\n    draw() {\n      const ctx = this.ctx;\n      const w = this.canvas.width / (window.devicePixelRatio || 1);\n      const h = this.canvas.height / (window.devicePixelRatio || 1);\n      ctx.clearRect(0,0,w,h);\n      ctx.save();\n      ctx.translate(this.centerX, this.centerY);\n      ctx.rotate(this.rotation);\n      // draw segments\n      const count = Math.max(this.names.length, 1);\n      const palette = THEME_PALETTES[this.theme] || THEME_PALETTES.light;\n      for (let i = 0; i &lt; count; i++) {\n        const start = (i / count) * Math.PI * 2;\n        const end = ((i + 1) / count) * Math.PI * 2;\n        ctx.beginPath();\n        ctx.moveTo(0,0);\n        ctx.arc(0,0,this.radius, start + this.padAngle, end - this.padAngle, false);\n        ctx.closePath();\n        const color = palette[i % palette.length];\n        ctx.fillStyle = color;\n        ctx.fill();\n        ctx.strokeStyle = (i % 2 === 0) ? \'rgba(0,0,0,0.06)\' : \'rgba(0,0,0,0.03)\';\n        ctx.lineWidth = 1;\n        ctx.stroke();\n        // draw text label\n        const mid = (start + end) / 2;\n        ctx.save();\n        ctx.rotate(mid);\n        ctx.translate(this.radius * 0.6, 0);\n        ctx.rotate(Math.PI/2);\n        ctx.fillStyle = getTextColor(color);\n        ctx.font = `${Math.max(12, Math.min(22, this.radius / 8))}px sans-serif`;\n        ctx.textAlign = \'center\';\n        ctx.textBaseline = \'middle\';\n        const label = (this.names.length === 0) ? \'Add names\' : this.names[i % this.names.length];\n        wrapFillText(ctx, label, 0, 0, this.radius * 0.5, 16);\n        ctx.restore();\n      }\n      // draw center circle\n      ctx.beginPath();\n      ctx.arc(0,0, this.radius * 0.16, 0, Math.PI*2);\n      ctx.fillStyle = \'rgba(255,255,255,0.9)\';\n      ctx.fill();\n      ctx.strokeStyle = \'rgba(0,0,0,0.06)\';\n      ctx.stroke();\n      ctx.restore();\n      // draw outer ring (pointer side neutral)\n      ctx.beginPath();\n      ctx.arc(this.centerX, this.centerY, this.radius + 10, 0, Math.PI*2);\n      ctx.strokeStyle = \'rgba(0,0,0,0.03)\';\n      ctx.lineWidth = 2;\n      ctx.stroke();\n    }\n    spin() {\n      if (this.isSpinning || this.names.length === 0) return;\n      this.isSpinning = true;\n      const count = this.names.length;\n      // Determine random winner index to land on:\n      const winnerIndex = rand(0, count - 1);\n      // Calculate final rotation so that winner segment lines up with pointer at top (pointer at canvas top - rotation must align)\n      // Our pointer is at the top (canvas 0 angle). The segment mid-angle for index i (without rotation) is ((i + 0.5)/count)*2pi\n      const segmentMid = ((winnerIndex + 0.5) / count) * Math.PI * 2;\n      // We want segmentMid + rotation_final == -Math.PI/2 (so it points at the top pointer), so rotation_final = -Math.PI/2 - segmentMid + 2pi*N\n      const extraTurns = rand(5, 8); // full spins\n      const rotationFinal = -Math.PI/2 - segmentMid + extraTurns * Math.PI * 2;\n      const startRotation = this.rotation % (Math.PI * 2);\n      const delta = rotationFinal - startRotation;\n      const duration = 4000 + Math.random() * 1500; // ms\n      const startTime = performance.now();\n      const animate = (now) =&gt; {\n        const elapsed = now - startTime;\n        const t = Math.min(elapsed / duration, 1);\n        const eased = easeOutCubic(t);\n        this.rotation = startRotation + delta * eased;\n        this.draw();\n        if (t &lt; 1) {\n          this.frame = requestAnimationFrame(animate);\n        } else {\n          this.isSpinning = false;\n          // Normalize rotation within 0..2pi\n          this.rotation = ((this.rotation % (Math.PI*2)) + Math.PI*2) % (Math.PI*2);\n          this.draw();\n          // Compute final winner index again from rotation\n          // finalAngle: the angle of the segment at pointer (0 at right, +counterclockwise). We compute a normalized angle that maps to segment index.\n          const finalAngle = ((-this.rotation - Math.PI/2) % (Math.PI*2) + Math.PI*2) % (Math.PI*2);\n          const resultingIndex = Math.floor((finalAngle / (Math.PI*2)) * count) % count;\n          const winner = this.names[resultingIndex];\n          this.onResult({ index: resultingIndex, name: winner });\n        }\n      };\n      this.frame = requestAnimationFrame(animate);\n    }\n  }\n  // Helper: pick readable text color for a background\n  function getTextColor(hex) {\n    // remove # and convert\n    const h = hex.replace(\'#\',\'\');\n    const r = parseInt(h.substring(0,2),16);\n    const g = parseInt(h.substring(2,4),16);\n    const b = parseInt(h.substring(4,6),16);\n    // luminance\n    const lum = (0.299*r + 0.587*g + 0.114*b) / 255;\n    return lum &gt; 0.65 ? \'#111\' : \'#fff\';\n  }\n  // Helper: wrap text within a given width (draws multi-line if necessary)\n  function wrapFillText(ctx, text, x, y, maxWidth, lineHeight) {\n    const words = (text || \'\').split(/\\s+/);\n    if (words.length === 0) return;\n    let line = \'\';\n    const lines = [];\n    for (let n = 0; n &lt; words.length; n++) {\n      const testLine = line ? line + \' \' + words[n] : words[n];\n      const metrics = ctx.measureText(testLine);\n      if (metrics.width &gt; maxWidth &amp;&amp; line) {\n        lines.push(line);\n        line = words[n];\n      } else {\n        line = testLine;\n      }\n    }\n    if (line) lines.push(line);\n    // If still too many lines, just draw what\'s possible (we rely on font size)\n    for (let i=0;i&lt;lines.length;i++){\n      ctx.fillText(lines[i], x, y + (i - (lines.length-1)/2) * lineHeight);\n    }\n  }\n  // UI glue\n  document.addEventListener(\'DOMContentLoaded\', () =&gt; {\n    const canvas = document.getElementById(\'wheelCanvas\');\n    const wheel = new Wheel(canvas, { theme: \'light\', onResult: onWinner });\n    const nameInput = document.getElementById(\'nameInput\');\n    const addBtn = document.getElementById(\'addBtn\');\n    const addRandomBtn = document.getElementById(\'addRandomBtn\');\n    const bulkInput = document.getElementById(\'bulkInput\');\n    const bulkAddBtn = document.getElementById(\'bulkAddBtn\');\n    const clearBulkBtn = document.getElementById(\'clearBulkBtn\');\n    const nameList = document.getElementById(\'nameList\');\n    const countSpan = document.getElementById(\'count\');\n    const spinBtn = document.getElementById(\'spinBtn\');\n    const rerollBtn = document.getElementById(\'rerollBtn\');\n    const clearNamesBtn = document.getElementById(\'clearNamesBtn\');\n    const themeSelect = document.getElementById(\'themeSelect\');\n    const resultSection = document.getElementById(\'result\');\n    const winnerNameDiv = document.getElementById(\'winnerName\');\n    const exportBtn = document.getElementById(\'exportBtn\');\n    const importBtn = document.getElementById(\'importBtn\');\n    const importFile = document.getElementById(\'importFile\');\n    // Initial draw\n    wheel.draw();\n    function updateUI() {\n      const names = wheel.names;\n      countSpan.textContent = names.length;\n      renderNameList();\n    }\n    function renderNameList() {\n      nameList.innerHTML = \'\';\n      wheel.names.forEach((n, i) =&gt; {\n        const li = document.createElement(\'li\');\n        const span = document.createElement(\'span\');\n        span.textContent = n;\n        li.appendChild(span);\n        const btn = document.createElement(\'button\');\n        btn.title = \'Remove\';\n        btn.setAttribute(\'aria-label\', `Remove ${n}`);\n        btn.innerHTML = \'✕\';\n        btn.addEventListener(\'click\', () =&gt; {\n          wheel.removeName(i);\n          updateUI();\n        });\n        li.appendChild(btn);\n        nameList.appendChild(li);\n      });\n    }\n    function addNameFromInput() {\n      const v = nameInput.value.trim();\n      if (!v) { showMessage(\'Please enter a name.\', \'warn\'); return; }\n      wheel.addName(v);\n      nameInput.value = \'\';\n      updateUI();\n    }\n    addBtn.addEventListener(\'click\', addNameFromInput);\n    nameInput.addEventListener(\'keydown\', (e) =&gt; { if (e.key === \'Enter\') addNameFromInput(); });\n    addRandomBtn.addEventListener(\'click\', () =&gt; {\n      const samples = [\'Alex\',\'Jordan\',\'Taylor\',\'Sam\',\'Jamie\',\'Casey\',\'Morgan\',\'Riley\',\'Avery\',\'Dana\'];\n      const count = rand(3,6);\n      for (let i=0;i&lt;count;i++) wheel.addName(samples[rand(0,samples.length-1)] + (rand(1,100)));\n      updateUI();\n    });\n    bulkAddBtn.addEventListener(\'click\', () =&gt; {\n      const text = bulkInput.value.trim();\n      if (!text) { showMessage(\'Bulk input is empty.\', \'warn\'); return; }\n      const parsed = text.split(/[\\n,;]+/).map(s =&gt; s.trim()).filter(s =&gt; s);\n      parsed.forEach(p =&gt; wheel.addName(p));\n      bulkInput.value = \'\';\n      updateUI();\n      showMessage(`Added ${parsed.length} names.`, \'info\');\n    });\n    clearBulkBtn.addEventListener(\'click\', () =&gt; { bulkInput.value = \'\'; });\n    spinBtn.addEventListener(\'click\', () =&gt; {\n      if (wheel.names.length === 0) { showMessage(\'Add at least one name to spin.\', \'warn\'); return; }\n      resultSection.hidden = true;\n      winnerNameDiv.textContent = \'\';\n      wheel.spin();\n      spinBtn.disabled = true;\n      const checkFinish = setInterval(() =&gt; {\n        if (!wheel.isSpinning) {\n          clearInterval(checkFinish);\n          spinBtn.disabled = false;\n        }\n      }, 200);\n    });\n    rerollBtn.addEventListener(\'click\', () =&gt; {\n      resultSection.hidden = true;\n      wheel.spin();\n    });\n    clearNamesBtn.addEventListener(\'click\', () =&gt; {\n      if (confirm(\'Clear all names?\')) {\n        wheel.clearNames();\n        updateUI();\n      }\n    });\n    themeSelect.addEventListener(\'change\', (e) =&gt; {\n      const t = e.target.value;\n      document.body.className = \'theme-\' + t;\n      wheel.setTheme(t);\n    });\n    function onWinner(result) {\n      winnerNameDiv.textContent = result.name || \'—\';\n      resultSection.hidden = false;\n      // Flash the winner item in the list (if still present)\n      const items = Array.from(nameList.children);\n      items.forEach((li, idx) =&gt; { li.classList.toggle(\'winner\', idx === result.index); });\n      showMessage(`Winner: ${result.name}`, \'success\', 4000);\n    }\n    // Simple message area\n    function showMessage(text, type = \'info\', duration = 2200) {\n      // create small toast\n      const t = document.createElement(\'div\');\n      t.className = \'tmp-toast \' + type;\n      t.textContent = text;\n      document.body.appendChild(t);\n      // Force reflow to pick up transitions\n      window.getComputedStyle(t).opacity;\n      setTimeout(()=&gt; { t.style.opacity = \'0\'; t.style.transform = \'translateY(-10px)\'; }, duration - 300);\n      setTimeout(()=&gt; { try { t.remove(); } catch(e){} }, duration);\n    }\n    // Export/import CSV\n    exportBtn.addEventListener(\'click\', () =&gt; {\n      if (wheel.names.length === 0) { showMessage(\'No names to export.\', \'warn\'); return; }\n      const csv = wheel.names.map(n =&gt; `"${(n||\'\').replace(/"/g,\'""\')}"`).join(\'\\n\');\n      const blob = new Blob([csv], { type: \'text/csv\' });\n      const url = URL.createObjectURL(blob);\n      const a = document.createElement(\'a\');\n      a.href = url;\n      a.download = \'participants.csv\';\n      document.body.appendChild(a);\n      a.click();\n      a.remove();\n      URL.revokeObjectURL(url);\n      showMessage(\'Exported CSV\', \'info\');\n    });\n    importBtn.addEventListener(\'click\', () =&gt; { importFile.click(); });\n    importFile.addEventListener(\'change\', (e) =&gt; {\n      const file = e.target.files[0];\n      if (!file) return;\n      const reader = new FileReader();\n      reader.onload = (ev) =&gt; {\n        const txt = ev.target.result;\n        const lines = txt.split(/\\r?\\n/).map(s =&gt; s.trim()).filter(s =&gt; s);\n        // basic CSV unquote\n        const parsed = lines.map(l =&gt; {\n          // simple CSV single-column parse: handle quoted fields\n          if (l.startsWith(\'"\') &amp;&amp; l.endsWith(\'"\')) {\n            return l.slice(1,-1).replace(/""/g,\'"\');\n          }\n          return l;\n        });\n        parsed.forEach(p =&gt; wheel.addName(p));\n        updateUI();\n        showMessage(`Imported ${parsed.length} names`, \'info\');\n      };\n      reader.readAsText(file);\n      importFile.value = \'\';\n    });\n    // Initial sample (optional)\n    // wheel.addName(\'Alice\'); wheel.addName(\'Bob\'); wheel.addName(\'Charlie\');\n    updateUI();\n    // (Optional) keyboard shortcuts\n    window.addEventListener(\'keydown\', (e) =&gt; {\n      if ((e.ctrlKey || e.metaKey) &amp;&amp; e.key.toLowerCase() === \'k\') {\n        e.preventDefault();\n        nameInput.focus();\n      }\n      if (e.key === \' \') {\n        // space triggers spin if not focusing an input\n        if (document.activeElement.tagName !== \'INPUT\' &amp;&amp; document.activeElement.tagName !== \'TEXTAREA\') {\n          e.preventDefault();\n          spinBtn.click();\n        }\n      }\n    });\n  });\n})(); \n\n\n', 'requirements': ''} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_3_5_TURBO |

[2025-17-09 13:48:14 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Chief Product Officer |
| **user_role_name** | Chief Executive Officer |
| **assistant_role_prompt** | {chatdev_prompt} You are Chief Product Officer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. You are responsible for all product-related matters in ChatDev. Usually includes product design, product strategy, product vision, product innovation, project management and product marketing. Here is a new customer's task: {task}. To complete the task, you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully complete a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. To complete the task, I will give you one or more instructions, and you must help me to write a specific solution that appropriately solves the requested instruction based on your expertise and my needs. |
| **task_prompt** | [Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes. Do it in HTML, CSS, and JavaScript.] |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_3_5_TURBO |
| **background_prompt** | ChatDev is a software company powered by multiple intelligent agents, such as chief executive officer, chief human resources officer, chief product officer, chief technology officer, etc, with a multi-agent organizational structure and the mission of 'changing the digital world through programming'. |

[2025-17-09 13:48:14 INFO] Chief Executive Officer: **[Start Chat]**

[ChatDev is a software company powered by multiple intelligent agents, such as chief executive officer, chief human resources officer, chief product officer, chief technology officer, etc, with a multi-agent organizational structure and the mission of 'changing the digital world through programming'.
You are Chief Product Officer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer.
You are responsible for all product-related matters in ChatDev. Usually includes product design, product strategy, product vision, product innovation, project management and product marketing.
Here is a new customer's task: [Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes. Do it in HTML, CSS, and JavaScript.].
To complete the task, you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]

The new user's task, our developed codes and required dependencies are listed: 

Task: "[Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes. Do it in HTML, CSS, and JavaScript.]".

Modality: "website".

Programming Language: " JavaScript"

Ideas: ""

Codes: 

"index.html
```html
'''
This is the main HTML file for the Random Winner Wheel.
It contains the structure: input fields to add names, a canvas for the wheel,
controls (spin, clear, bulk add), theme selector, and placeholders for CSS/JS.
'''
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Random Winner Wheel</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body class="theme-light">
  <!--
    This is the main HTML file for the Random Winner Wheel.
    It contains the structure: input fields to add names, a canvas for the wheel,
    controls (spin, clear, bulk add), theme selector, and placeholders for CSS/JS.
  -->
  <header>
    <h1>Random Winner Wheel</h1>
    <p>Enter participant names, choose a theme, and spin to pick a winner.</p>
  </header>
  <main>
    <section class="controls">
      <div class="add-single">
        <input id="nameInput" type="text" placeholder="Enter a name and press Add" aria-label="Name input" />
        <button id="addBtn">Add</button>
        <button id="addRandomBtn" title="Add a few sample random names">Add Sample</button>
      </div>
      <div class="bulk-add">
        <label for="bulkInput">Bulk add (comma, newline or semicolon separated):</label>
        <textarea id="bulkInput" placeholder="Alice, Bob, Charlie"></textarea>
        <div class="bulk-actions">
          <button id="bulkAddBtn">Bulk Add</button>
          <button id="clearBulkBtn">Clear Bulk</button>
        </div>
      </div>
      <div class="list-actions">
        <div class="theme-select">
          <label for="themeSelect">Theme:</label>
          <select id="themeSelect">
            <option value="light">Light</option>
            <option value="dark">Dark</option>
            <option value="neon">Neon</option>
            <option value="pastel">Pastel</option>
            <option value="retro">Retro</option>
          </select>
        </div>
        <div class="wheel-controls">
          <button id="spinBtn" class="primary">Spin</button>
          <button id="clearNamesBtn">Clear Names</button>
          <button id="exportBtn">Export CSV</button>
          <input id="importFile" type="file" accept=".csv,text/csv" style="display:none">
          <button id="importBtn">Import CSV</button>
        </div>
      </div>
    </section>
    <section class="wheel-area">
      <div class="wheel-container">
        <canvas id="wheelCanvas" width="600" height="600" aria-label="Spinning wheel"></canvas>
        <div class="pointer" aria-hidden="true">▼</div>
      </div>
      <aside class="participants">
        <h2>Participants (<span id="count">0</span>)</h2>
        <ul id="nameList" aria-live="polite"></ul>
      </aside>
    </section>
    <section class="result" id="result" aria-live="polite" hidden>
      <h2>Winner</h2>
      <div id="winnerName" class="winnerName"></div>
      <button id="rerollBtn">Spin Again</button>
    </section>
  </main>
  <footer>
    <small>Built with HTML, CSS, and JavaScript. Themes change both UI and wheel colors.</small>
  </footer>
  <script src="script.js"></script>
</body>
</html>
```

styles.css
```css
'''
Stylesheet for the Random Winner Wheel.
Defines layout, themes, wheel container sizing, animations, and toast styles.
'''
/*
 Stylesheet for the Random Winner Wheel.
 Defines layout, themes, wheel container sizing, animations, and toast styles.
*/
/* Reset & base */
* { box-sizing: border-box; margin: 0; padding: 0; }
html,body { height: 100%; font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; background: var(--bg); color: var(--fg); }
:root {
  --bg: #f7f8fb;
  --fg: #222;
  --muted: #666;
  --accent: #2b8cff;
  --card: #ffffff;
  --primary-btn-bg: var(--accent);
  --primary-btn-fg: #fff;
  --shadow: rgba(15,15,15,0.08);
}
/* Themes */
body.theme-light {
  --bg: #f7f8fb;
  --fg: #222;
  --muted: #5b6170;
  --accent: #2b8cff;
  --card: #fff;
  --wheel-seq: 0;
}
body.theme-dark {
  --bg: #0f1724;
  --fg: #e6eef8;
  --muted: #a9b1c2;
  --accent: #7c5cff;
  --card: #0b1220;
}
body.theme-neon {
  --bg: #0a0a0f;
  --fg: #e9f9ff;
  --muted: #a6f3ff;
  --accent: #39ff14;
  --card: #09101a;
}
body.theme-pastel {
  --bg: #fffaf6;
  --fg: #3c3a3a;
  --muted: #8d8a8a;
  --accent: #ff7aa2;
  --card: #fff;
}
body.theme-retro {
  --bg: #fff6e7;
  --fg: #402b2b;
  --muted: #856e6e;
  --accent: #ffb86b;
  --card: #fff0e6;
}
/* Layout */
header { padding: 18px 24px; text-align: center; background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent); }
header h1 { font-size: 1.5rem; margin-bottom: 6px; }
main { padding: 18px; max-width: 1100px; margin: 0 auto; }
.controls { display: grid; gap: 12px; margin-bottom: 18px; }
.add-single { display:flex; gap:8px; }
.add-single input[type="text"] { flex:1; padding:10px; border-radius:8px; border:1px solid rgba(0,0,0,0.08); background:var(--card); color:var(--fg); }
.add-single button { padding:10px 12px; border-radius:8px; border: none; cursor:pointer; background: var(--primary-btn-bg); color: var(--primary-btn-fg); }
.add-single button#addRandomBtn { background: transparent; border: 1px solid rgba(0,0,0,0.06); color: var(--fg); }
.bulk-add textarea { width:100%; min-height:64px; margin-top:6px; padding:8px; border-radius:8px; border:1px solid rgba(0,0,0,0.06); background:var(--card); color:var(--fg); }
.bulk-actions { display:flex; gap:8px; margin-top:8px; }
.list-actions { display:flex; justify-content:space-between; align-items:center; gap:16px; flex-wrap:wrap; }
.theme-select select { padding:8px; border-radius:8px; border:1px solid rgba(0,0,0,0.06); }
.wheel-area { display:flex; gap:18px; align-items:start; flex-wrap:wrap; }
.wheel-container { position: relative; width: 600px; height: 600px; max-width: 90vw; max-height: 90vw; display:flex; align-items:center; justify-content:center; background: transparent; }
.pointer {
  /* Centered triangular pointer positioned above the wheel.
     This ensures the visual pointer aligns with the wheel math (top-center).
     Hides the fallback glyph in the HTML and draws a sharp triangle instead. */
  position: absolute;
  top: 8px;               /* vertical offset from top of wheel container */
  left: 50%;              /* center horizontally */
  transform: translateX(-50%); /* center on the X axis */
  width: 0;
  height: 0;
  border-left: 12px solid transparent;
  border-right: 12px solid transparent;
  border-bottom: 18px solid var(--accent);
  z-index: 10;            /* ensure it's above the canvas */
  pointer-events: none;
  /* hide textual glyph fallback content (the ▼ in HTML) */
  font-size: 0;
  line-height: 0;
  text-indent: -9999px;
}
/* Participants panel and wheel styles */
.participants { width: 320px; max-width: 40vw; background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent); padding:12px; border-radius:10px; box-shadow: 0 6px 18px var(--shadow); }
.participants h2 { margin-bottom:8px; font-size:1.05rem; }
#nameList { list-style:none; max-height:420px; overflow:auto; display:block; }
#nameList li { padding:8px; border-radius:6px; display:flex; justify-content:space-between; align-items:center; gap:8px; margin-bottom:8px; background: var(--card); border:1px solid rgba(0,0,0,0.04); }
#nameList li button { background: transparent; border: none; color: var(--muted); cursor:pointer; }
.result { margin-top:18px; padding:12px; border-radius:8px; background: var(--card); text-align:center; box-shadow: 0 6px 18px var(--shadow); }
.result .winnerName { font-size:1.4rem; font-weight:700; margin:8px 0; color: var(--accent); }
/* Buttons */
button { cursor:pointer; padding:8px 12px; border-radius:8px; border:1px solid rgba(0,0,0,0.06); background: transparent; color:var(--fg); }
button.primary { background: var(--primary-btn-bg); color: var(--primary-btn-fg); border: none; }
/* Responsive */
@media (max-width: 900px) {
  .wheel-area { flex-direction:column; align-items:center; }
  .participants { width: 100%; max-width: 100%; }
}
/* Wheel canvas scaling helper */
#wheelCanvas { border-radius:50%; box-shadow: 0 12px 26px rgba(0,0,0,0.12); background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.02), transparent); }
/* Toast / temporary message styles (used by showMessage) */
.tmp-toast {
  position: fixed;
  left: 50%;
  transform: translateX(-50%);
  top: 18px;
  background: rgba(0,0,0,0.85);
  color: #fff;
  padding: 8px 12px;
  border-radius: 6px;
  z-index: 9999;
  transition: opacity 0.25s, transform 0.25s;
  opacity: 1;
  pointer-events: none;
  font-size: 0.95rem;
  box-shadow: 0 6px 18px rgba(0,0,0,0.18);
}
.tmp-toast.success { background: rgba(56, 198, 123, 0.95); }
.tmp-toast.warn    { background: rgba(255, 159, 67, 0.95); color: #2b1500; }
.tmp-toast.info    { background: rgba(12, 74, 255, 0.95); }
/* Winner highlight for participants list */
#nameList li.winner {
  outline: 3px solid rgba(255,215,0,0.15);
  box-shadow: 0 6px 18px rgba(255,215,0,0.06);
  transform: scale(1.01);
}
```

script.js
```js
'''
Script for the Random Winner Wheel.
Contains the Wheel class to draw and spin the canvas-based wheel and UI glue code to manage names and themes.
'''
/*
 Script for the Random Winner Wheel.
 Contains the Wheel class to draw and spin the canvas-based wheel and UI glue code to manage names and themes.
*/
/* Main JavaScript - Wheel + UI logic */
(() => {
  // Utilities
  function rand(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }
  function easeOutCubic(t) { return 1 - Math.pow(1 - t, 3); }
  // Color palettes for themes (will be used to paint wheel segments)
  const THEME_PALETTES = {
    light: ['#FF8A80','#FFD180','#FFF59D','#C8E6C9','#80DEEA','#A7FFEB','#B39DDB','#90CAF9'],
    dark: ['#ff6b6b','#ffd166','#faff8e','#b9f6ca','#4dd0e1','#80cbc4','#b388ff','#64b5f6'],
    neon: ['#ff2d95','#7cff01','#00ffff','#ffdd00','#ff6a00','#00ff9e','#ff00ff','#47ffa2'],
    pastel: ['#ffdbe9','#fff0b3','#d1ffd6','#cfefff','#e7dfff','#ffd6e7','#fbe7d6','#e6f7ff'],
    retro: ['#ffb86b','#ffd3a8','#f3e2a9','#b8e0d2','#c0b9ff','#ffb6c1','#f6c49f','#c3d69b']
  };
  // Wheel class
  class Wheel {
    /*
    Manage wheel: drawing, recalculating segments, spinning animation, and determining winner.
    */
    constructor(canvas, options = {}) {
      this.canvas = canvas;
      this.ctx = canvas.getContext('2d');
      this.names = [];
      this.rotation = 0; // radians
      this.isSpinning = false;
      this.frame = null;
      this.onResult = options.onResult || function() {};
      this.theme = options.theme || 'light';
      this.padAngle = 0.02; // radians padding between segments
      this.textColor = '#111';
      this._devicePixelRatioFix();
      window.addEventListener('resize', () => { this._devicePixelRatioFix(); this.draw(); });
    }
    _devicePixelRatioFix() {
      const dpr = window.devicePixelRatio || 1;
      const rect = this.canvas.getBoundingClientRect();
      // If rect has zero size (canvas not yet laid out), use current width/height attributes as fallback
      const width = rect.width || (this.canvas.width / dpr);
      const height = rect.height || (this.canvas.height / dpr);
      this.canvas.width = width * dpr;
      this.canvas.height = height * dpr;
      this.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      this.centerX = width / 2;
      this.centerY = height / 2;
      this.radius = Math.min(width, height) / 2 - 18;
    }
    setTheme(themeId) { this.theme = themeId; this.draw(); }
    setNames(names) {
      this.names = names.slice();
      this.draw();
    }
    addName(name) {
      this.names.push(name);
      this.draw();
    }
    removeName(index) {
      if (index >= 0 && index < this.names.length) {
        this.names.splice(index,1);
        this.draw();
      }
    }
    clearNames() {
      this.names = [];
      this.draw();
    }
    draw() {
      const ctx = this.ctx;
      const w = this.canvas.width / (window.devicePixelRatio || 1);
      const h = this.canvas.height / (window.devicePixelRatio || 1);
      ctx.clearRect(0,0,w,h);
      ctx.save();
      ctx.translate(this.centerX, this.centerY);
      ctx.rotate(this.rotation);
      // draw segments
      const count = Math.max(this.names.length, 1);
      const palette = THEME_PALETTES[this.theme] || THEME_PALETTES.light;
      for (let i = 0; i < count; i++) {
        const start = (i / count) * Math.PI * 2;
        const end = ((i + 1) / count) * Math.PI * 2;
        ctx.beginPath();
        ctx.moveTo(0,0);
        ctx.arc(0,0,this.radius, start + this.padAngle, end - this.padAngle, false);
        ctx.closePath();
        const color = palette[i % palette.length];
        ctx.fillStyle = color;
        ctx.fill();
        ctx.strokeStyle = (i % 2 === 0) ? 'rgba(0,0,0,0.06)' : 'rgba(0,0,0,0.03)';
        ctx.lineWidth = 1;
        ctx.stroke();
        // draw text label
        const mid = (start + end) / 2;
        ctx.save();
        ctx.rotate(mid);
        ctx.translate(this.radius * 0.6, 0);
        ctx.rotate(Math.PI/2);
        ctx.fillStyle = getTextColor(color);
        ctx.font = `${Math.max(12, Math.min(22, this.radius / 8))}px sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        const label = (this.names.length === 0) ? 'Add names' : this.names[i % this.names.length];
        wrapFillText(ctx, label, 0, 0, this.radius * 0.5, 16);
        ctx.restore();
      }
      // draw center circle
      ctx.beginPath();
      ctx.arc(0,0, this.radius * 0.16, 0, Math.PI*2);
      ctx.fillStyle = 'rgba(255,255,255,0.9)';
      ctx.fill();
      ctx.strokeStyle = 'rgba(0,0,0,0.06)';
      ctx.stroke();
      ctx.restore();
      // draw outer ring (pointer side neutral)
      ctx.beginPath();
      ctx.arc(this.centerX, this.centerY, this.radius + 10, 0, Math.PI*2);
      ctx.strokeStyle = 'rgba(0,0,0,0.03)';
      ctx.lineWidth = 2;
      ctx.stroke();
    }
    spin() {
      if (this.isSpinning || this.names.length === 0) return;
      this.isSpinning = true;
      const count = this.names.length;
      // Determine random winner index to land on:
      const winnerIndex = rand(0, count - 1);
      // Calculate final rotation so that winner segment lines up with pointer at top (pointer at canvas top - rotation must align)
      // Our pointer is at the top (canvas 0 angle). The segment mid-angle for index i (without rotation) is ((i + 0.5)/count)*2pi
      const segmentMid = ((winnerIndex + 0.5) / count) * Math.PI * 2;
      // We want segmentMid + rotation_final == -Math.PI/2 (so it points at the top pointer), so rotation_final = -Math.PI/2 - segmentMid + 2pi*N
      const extraTurns = rand(5, 8); // full spins
      const rotationFinal = -Math.PI/2 - segmentMid + extraTurns * Math.PI * 2;
      const startRotation = this.rotation % (Math.PI * 2);
      const delta = rotationFinal - startRotation;
      const duration = 4000 + Math.random() * 1500; // ms
      const startTime = performance.now();
      const animate = (now) => {
        const elapsed = now - startTime;
        const t = Math.min(elapsed / duration, 1);
        const eased = easeOutCubic(t);
        this.rotation = startRotation + delta * eased;
        this.draw();
        if (t < 1) {
          this.frame = requestAnimationFrame(animate);
        } else {
          this.isSpinning = false;
          // Normalize rotation within 0..2pi
          this.rotation = ((this.rotation % (Math.PI*2)) + Math.PI*2) % (Math.PI*2);
          this.draw();
          // Compute final winner index again from rotation
          // finalAngle: the angle of the segment at pointer (0 at right, +counterclockwise). We compute a normalized angle that maps to segment index.
          const finalAngle = ((-this.rotation - Math.PI/2) % (Math.PI*2) + Math.PI*2) % (Math.PI*2);
          const resultingIndex = Math.floor((finalAngle / (Math.PI*2)) * count) % count;
          const winner = this.names[resultingIndex];
          this.onResult({ index: resultingIndex, name: winner });
        }
      };
      this.frame = requestAnimationFrame(animate);
    }
  }
  // Helper: pick readable text color for a background
  function getTextColor(hex) {
    // remove # and convert
    const h = hex.replace('#','');
    const r = parseInt(h.substring(0,2),16);
    const g = parseInt(h.substring(2,4),16);
    const b = parseInt(h.substring(4,6),16);
    // luminance
    const lum = (0.299*r + 0.587*g + 0.114*b) / 255;
    return lum > 0.65 ? '#111' : '#fff';
  }
  // Helper: wrap text within a given width (draws multi-line if necessary)
  function wrapFillText(ctx, text, x, y, maxWidth, lineHeight) {
    const words = (text || '').split(/\s+/);
    if (words.length === 0) return;
    let line = '';
    const lines = [];
    for (let n = 0; n < words.length; n++) {
      const testLine = line ? line + ' ' + words[n] : words[n];
      const metrics = ctx.measureText(testLine);
      if (metrics.width > maxWidth && line) {
        lines.push(line);
        line = words[n];
      } else {
        line = testLine;
      }
    }
    if (line) lines.push(line);
    // If still too many lines, just draw what's possible (we rely on font size)
    for (let i=0;i<lines.length;i++){
      ctx.fillText(lines[i], x, y + (i - (lines.length-1)/2) * lineHeight);
    }
  }
  // UI glue
  document.addEventListener('DOMContentLoaded', () => {
    const canvas = document.getElementById('wheelCanvas');
    const wheel = new Wheel(canvas, { theme: 'light', onResult: onWinner });
    const nameInput = document.getElementById('nameInput');
    const addBtn = document.getElementById('addBtn');
    const addRandomBtn = document.getElementById('addRandomBtn');
    const bulkInput = document.getElementById('bulkInput');
    const bulkAddBtn = document.getElementById('bulkAddBtn');
    const clearBulkBtn = document.getElementById('clearBulkBtn');
    const nameList = document.getElementById('nameList');
    const countSpan = document.getElementById('count');
    const spinBtn = document.getElementById('spinBtn');
    const rerollBtn = document.getElementById('rerollBtn');
    const clearNamesBtn = document.getElementById('clearNamesBtn');
    const themeSelect = document.getElementById('themeSelect');
    const resultSection = document.getElementById('result');
    const winnerNameDiv = document.getElementById('winnerName');
    const exportBtn = document.getElementById('exportBtn');
    const importBtn = document.getElementById('importBtn');
    const importFile = document.getElementById('importFile');
    // Initial draw
    wheel.draw();
    function updateUI() {
      const names = wheel.names;
      countSpan.textContent = names.length;
      renderNameList();
    }
    function renderNameList() {
      nameList.innerHTML = '';
      wheel.names.forEach((n, i) => {
        const li = document.createElement('li');
        const span = document.createElement('span');
        span.textContent = n;
        li.appendChild(span);
        const btn = document.createElement('button');
        btn.title = 'Remove';
        btn.setAttribute('aria-label', `Remove ${n}`);
        btn.innerHTML = '✕';
        btn.addEventListener('click', () => {
          wheel.removeName(i);
          updateUI();
        });
        li.appendChild(btn);
        nameList.appendChild(li);
      });
    }
    function addNameFromInput() {
      const v = nameInput.value.trim();
      if (!v) { showMessage('Please enter a name.', 'warn'); return; }
      wheel.addName(v);
      nameInput.value = '';
      updateUI();
    }
    addBtn.addEventListener('click', addNameFromInput);
    nameInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') addNameFromInput(); });
    addRandomBtn.addEventListener('click', () => {
      const samples = ['Alex','Jordan','Taylor','Sam','Jamie','Casey','Morgan','Riley','Avery','Dana'];
      const count = rand(3,6);
      for (let i=0;i<count;i++) wheel.addName(samples[rand(0,samples.length-1)] + (rand(1,100)));
      updateUI();
    });
    bulkAddBtn.addEventListener('click', () => {
      const text = bulkInput.value.trim();
      if (!text) { showMessage('Bulk input is empty.', 'warn'); return; }
      const parsed = text.split(/[\n,;]+/).map(s => s.trim()).filter(s => s);
      parsed.forEach(p => wheel.addName(p));
      bulkInput.value = '';
      updateUI();
      showMessage(`Added ${parsed.length} names.`, 'info');
    });
    clearBulkBtn.addEventListener('click', () => { bulkInput.value = ''; });
    spinBtn.addEventListener('click', () => {
      if (wheel.names.length === 0) { showMessage('Add at least one name to spin.', 'warn'); return; }
      resultSection.hidden = true;
      winnerNameDiv.textContent = '';
      wheel.spin();
      spinBtn.disabled = true;
      const checkFinish = setInterval(() => {
        if (!wheel.isSpinning) {
          clearInterval(checkFinish);
          spinBtn.disabled = false;
        }
      }, 200);
    });
    rerollBtn.addEventListener('click', () => {
      resultSection.hidden = true;
      wheel.spin();
    });
    clearNamesBtn.addEventListener('click', () => {
      if (confirm('Clear all names?')) {
        wheel.clearNames();
        updateUI();
      }
    });
    themeSelect.addEventListener('change', (e) => {
      const t = e.target.value;
      document.body.className = 'theme-' + t;
      wheel.setTheme(t);
    });
    function onWinner(result) {
      winnerNameDiv.textContent = result.name || '—';
      resultSection.hidden = false;
      // Flash the winner item in the list (if still present)
      const items = Array.from(nameList.children);
      items.forEach((li, idx) => { li.classList.toggle('winner', idx === result.index); });
      showMessage(`Winner: ${result.name}`, 'success', 4000);
    }
    // Simple message area
    function showMessage(text, type = 'info', duration = 2200) {
      // create small toast
      const t = document.createElement('div');
      t.className = 'tmp-toast ' + type;
      t.textContent = text;
      document.body.appendChild(t);
      // Force reflow to pick up transitions
      window.getComputedStyle(t).opacity;
      setTimeout(()=> { t.style.opacity = '0'; t.style.transform = 'translateY(-10px)'; }, duration - 300);
      setTimeout(()=> { try { t.remove(); } catch(e){} }, duration);
    }
    // Export/import CSV
    exportBtn.addEventListener('click', () => {
      if (wheel.names.length === 0) { showMessage('No names to export.', 'warn'); return; }
      const csv = wheel.names.map(n => `"${(n||'').replace(/"/g,'""')}"`).join('\n');
      const blob = new Blob([csv], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'participants.csv';
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
      showMessage('Exported CSV', 'info');
    });
    importBtn.addEventListener('click', () => { importFile.click(); });
    importFile.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (ev) => {
        const txt = ev.target.result;
        const lines = txt.split(/\r?\n/).map(s => s.trim()).filter(s => s);
        // basic CSV unquote
        const parsed = lines.map(l => {
          // simple CSV single-column parse: handle quoted fields
          if (l.startsWith('"') && l.endsWith('"')) {
            return l.slice(1,-1).replace(/""/g,'"');
          }
          return l;
        });
        parsed.forEach(p => wheel.addName(p));
        updateUI();
        showMessage(`Imported ${parsed.length} names`, 'info');
      };
      reader.readAsText(file);
      importFile.value = '';
    });
    // Initial sample (optional)
    // wheel.addName('Alice'); wheel.addName('Bob'); wheel.addName('Charlie');
    updateUI();
    // (Optional) keyboard shortcuts
    window.addEventListener('keydown', (e) => {
      if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'k') {
        e.preventDefault();
        nameInput.focus();
      }
      if (e.key === ' ') {
        // space triggers spin if not focusing an input
        if (document.activeElement.tagName !== 'INPUT' && document.activeElement.tagName !== 'TEXTAREA') {
          e.preventDefault();
          spinBtn.click();
        }
      }
    });
  });
})(); 
```

"

Requirements:

""

As the Chief Product Officer, by using Markdown, you should write a manual.md file which is a detailed user manual to use the software, including introducing main functions of the software, how to install environment dependencies and how to use/play it. For example:

manual.md

```

# LangChain

Building applications with LLMs through composability

Looking for the JS/TS version? Check out LangChain.js.

**Production Support:** As you move your LangChains into production, we'd love to offer more comprehensive support.

Please fill out this form and we'll set up a dedicated support Slack channel.

## Quick Install

`pip install langchain`

or

`conda install langchain -c conda-forge`

## 🤔 What is this?

Large language models (LLMs) are emerging as a transformative technology, enabling developers to build applications that they previously could not. However, using these LLMs in isolation is often insufficient for creating a truly powerful app - the real power comes when you can combine them with other sources of computation or knowledge.

This library aims to assist in the development of those types of applications. Common examples of these applications include:

**❓ Question Answering over specific documents**

- Documentation

- End-to-end Example: Question Answering over Notion Database

**🤖 Agents**

- Documentation

- End-to-end Example: GPT+WolframAlpha

## 📖 Documentation

Please see [here](https://python.langchain.com) for full documentation on:

- Getting started (installation, setting up the environment, simple examples)

- How-To examples (demos, integrations, helper functions)

- Reference (full API docs)

- Resources (high-level explanation of core concepts)

```

[2025-17-09 13:49:03 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2025-17-09 13:49:03 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 7479
completion_tokens: 3168
total_tokens: 10647
cost: $-1.000000


[2025-17-09 13:49:03 INFO] Chief Product Officer: **Chief Product Officer<->Chief Executive Officer on : Manual, turn 0**

[ChatDev is a software company powered by multiple intelligent agents, such as chief executive officer, chief human resources officer, chief product officer, chief technology officer, etc, with a multi-agent organizational structure and the mission of 'changing the digital world through programming'.
You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully complete a task assigned by a new customer.
Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees.
Here is a new customer's task: [Design a website  with a name input box and a spinning wheel to randomly pick a winner. I want the possibilite of choose a variety of themes. Do it in HTML, CSS, and JavaScript.].
To complete the task, I will give you one or more instructions, and you must help me to write a specific solution that appropriately solves the requested instruction based on your expertise and my needs.]

manual.md

# Random Winner Wheel — User Manual

Random Winner Wheel is a small, accessible, browser-based web app that lets you collect participant names and spin a visual wheel to randomly pick a winner. It is built with plain HTML, CSS and JavaScript, and requires no external libraries or build tools. The UI supports multiple themes, import/export of participant lists, keyboard shortcuts, and basic accessibility features.

Contents
- Overview
- What’s included (file list)
- System requirements & dependencies
- Quick start (run locally)
- Deploying (static hosting / GitHub Pages)
- Walkthrough — main features & UI
  - Adding names (single, sample, bulk)
  - Editing/removing names
  - Spinning and rerolling
  - Theme selection
  - Import / Export (CSV)
  - Keyboard shortcuts & accessibility
- Developer guide / Customization
  - How wheel chooses a winner (algorithm)
  - Changing theme palettes
  - Exposing the Wheel instance for scripting
  - Tuning animation & wheel appearance
  - File structure & key functions
- Troubleshooting & FAQs
- License & contact

---

Overview
A lightweight interactive wheel you can use for classroom raffles, team giveaways, decision-making, and more. Enter names manually or import them, spin the wheel, and see the winner highlighted.

What’s included (file list)
- index.html — Main page and UI.
- styles.css — All UI and theme styling.
- script.js — Wheel implementation and UI glue code.
- manual.md — This file.

System requirements & dependencies
- A modern web browser (Chrome, Firefox, Edge, Safari).
- No frameworks or packages required.
- Optional: a small static HTTP server if you prefer to serve rather than opening the file directly (recommended for import file handling in some browsers).

Quick start (run locally)
1. Download or clone the project files into a folder.
2. Open index.html directly in the browser, or run a simple static server:

- Using Python 3 (recommended):
  - In a terminal at the project folder:
    - python -m http.server 8000
  - Visit http://localhost:8000 in your browser.

- Using Node (http-server):
  - npm install -g http-server
  - http-server . -p 8000
  - Visit http://localhost:8000.

- Open index.html file directly:
  - Double-click index.html (works in most browsers). Some browsers restrict local file imports (CSV import), so serving via a simple HTTP server is safer.

Deploying (static hosting / GitHub Pages)
- This is a static site: upload the files to any static hosting provider (GitHub Pages, Netlify, Vercel, Surge, S3 + CloudFront).
- To host on GitHub Pages:
  - Create a repository and push the files.
  - Enable GitHub Pages on the repository (source: main branch root).
  - Access at https://<your-username>.github.io/<repo>.

Walkthrough — main features & UI

Main layout
- Header: Title and short description.
- Controls area: Single add, sample/random add, bulk add area, theme selector, spin/clear/import/export controls.
- Wheel area: Circular canvas with a pointer at the top.
- Participants list: Shows all added names with remove buttons and participant count.
- Result panel: Shows the winner after a spin and a "Spin Again" option.

Adding names
- Single add:
  - Type a name into the "Enter a name" input, press Add or hit Enter.
- Add sample:
  - Click "Add Sample" to add a small random batch of sample names (convenient for testing).
- Bulk add:
  - Paste or type multiple names into the bulk textarea separated by commas, semicolons, or newlines (e.g., "Alice, Bob; Charlie\nDana").
  - Click "Bulk Add".
  - The app trims, filters empty entries, and adds each name.

Editing/removing names
- Each participant in the list has a small ✕ button to remove that individual.
- "Clear Names" clears all participants (a confirmation prompt appears).

Spinning and rerolling
- Click "Spin" to animate the wheel and randomly pick a winner.
- While the wheel is spinning, the Spin button is temporarily disabled.
- After the spin completes, the winner is shown in the "Winner" section and the corresponding participant list entry is highlighted.
- Click "Spin Again" to reroll (the app chooses a new random outcome).

Theme selection
- Use the Theme dropdown to switch UI themes: Light, Dark, Neon, Pastel, Retro.
- Themes affect both page CSS variables and the wheel segment color palette.

Import / Export (CSV)
- Export: Click "Export CSV" to download the current list as a CSV file (one column, one name per line).
- Import: Click "Import CSV" and choose a CSV file (or text file). The app supports a single column per line, with quoted values (basic CSV).
- Note: Some browsers restrict file access when opening index.html locally — if CSV import fails, run a local static server.

Keyboard shortcuts & accessibility
- Ctrl/Cmd + K: Focus the name input for quick typing.
- Space: If not focused on an input/textarea, pressing Space triggers a spin.
- ARIA: The participants list and result area use aria-live attributes to notify assistive tech of changes.
- Pointer: A visual triangular pointer sits at the top of the wheel; the winner segment aligns with the pointer when spinning completes.

Developer guide / Customization

File structure & key functions
- script.js contains:
  - Wheel class — core drawing, spin animation, name management.
    - Methods: setNames, addName, removeName, clearNames, setTheme, draw, spin.
    - Constructor accepts options: { theme, onResult } where onResult receives { index, name }.
  - THEME_PALETTES — color palettes used per theme.
  - UI glue code inside DOMContentLoaded — connects DOM elements to Wheel calls and handles export/import, messages, etc.
- styles.css contains:
  - Theme variables controlled by body.theme-<name>.
  - Layout, responsive rules, toast styles, and wheel canvas appearance.

How the wheel chooses a winner (algorithm)
- The wheel divides the circle into N equal segments (N = number of participants).
- For a chosen winner index i, the code computes the mid-angle of the segment: segmentMid = ((i + 0.5)/N) * 2π.
- It computes a final rotation so the chosen segment mid-angle ends up under the fixed top pointer. Extra full rotations (random 5–8 spins) are added to make the spin feel natural.
- The animation uses an ease-out cubic easing for smooth deceleration.
- After animation, the code normalizes rotation and computes the resulting index from final rotation to confirm the winner.

Changing theme palettes
- Palette array: THEME_PALETTES in script.js maps theme id to an array of colors. Example:
  - light: ['#FF8A80', '#FFD180', ...]
- To add or modify theme colors, edit THEME_PALETTES.
- To add a new theme visually for the page, add a new body.theme-<id> block in styles.css with CSS variables (--bg, --fg, --accent, etc.), and add a matching option in the Theme select in index.html.

Exposing the Wheel instance for scripting
- By default the wheel instance is scoped to the script’s DOMContentLoaded closure.
- To access it in the browser console for debugging or programmatic control, modify script.js after wheel creation:
  - window.wheel = wheel;
- After that you can run commands in console:
  - wheel.addName('Zoe');
  - wheel.setTheme('dark');
  - wheel.spin();

Tuning animation & wheel appearance
- Animation duration: set duration variable in wheel.spin (currently 4000–5500ms).
- Extra turns: change rand(5,8) to fewer or more spins.
- Padding between segments: Wheel.padAngle (radians).
- Center circle size and font sizing are computed relative to canvas radius; adjust draw() if you want different sizing or font.

Saving state (optional)
- The example doesn’t persist names across sessions. To add persistence:
  - Use localStorage: on every add/remove/update, store JSON.stringify(wheel.names) to localStorage.
  - On DOMContentLoaded, read and restore if present.
  - Example (conceptual):
    - localStorage.setItem('wheel_names', JSON.stringify(wheel.names));
    - const saved = JSON.parse(localStorage.getItem('wheel_names') || '[]'); wheel.setNames(saved);

Troubleshooting & FAQs

Q: The wheel canvas is blank / not drawing!
- Make sure JavaScript is enabled.
- Ensure the canvas is visible on screen (some CSS rules or hidden parents can give a zero bounding rectangle; the script uses fallback width/height attributes).
- If the page is served via file:// you might have import restrictions, but drawing itself should still work.
- Open the browser console for errors.

Q: CSV import/export isn’t working when I open the file directly.
- Some browsers (Chrome especially) block file:// handling for security. Run a simple local HTTP server (see Quick start) and try again.

Q: I want to make the wheel fair — is it truly random?
- The selection uses Math.random-based seeding to pick a winner index and a random number of full rotations. Math.random is not cryptographically secure but is suitable for casual selections and giveaways. For higher guarantees, integrate a cryptographic RNG or server-side selection.

Q: How do I change text styles, fonts or the pointer shape?
- Edit styles.css for pointer look and font-family, or change the pointer HTML/CSS. The pointer is a CSS triangle positioned absolutely above the canvas.

Q: I want labels to wrap or use smaller fonts for long names — how?
- The wheel uses wrapFillText and sets dynamic font size relative to radius. For more control, adjust the font size computation in script.js draw() (ctx.font = ...).

FAQ: Accessibility
- The UI includes aria-live on the participant list and result area so screen readers receive updates. If you need further accessibility support:
  - Add aria-labels to interactive items.
  - Add a non-visual log of recent winners (text history) for assistive tech.
  - Consider keyboard-only operation improvements: add focus states, ensure buttons are reachable via tab order.

Extending the app
- Add new themes: edit styles.css and THEME_PALETTES.
- Save/Load presets: add UI to save palettes/names to JSON and fetch them later.
- Analytics or audit trail: append spin results to a list and store in localStorage or send to a server.
- Multi-wheel or weight support: modify wheel logic to accept weights per name (segment size proportional to weight) — this requires updating segment angle calculation and mapping of finalAngle to index.

Sample workflow / quick demo
1. Open the site in your browser (http://localhost:8000).
2. Click the name field, type "Alice", press Enter.
3. Click "Bulk Add", paste "Bob, Charlie, Dana" and click Bulk Add.
4. Choose "Neon" from Theme dropdown to preview wheel colors.
5. Click "Spin". Wait for the wheel to stop and see the winner shown in the Result panel and highlighted in the participant list.
6. Click "Export CSV" to download the current list; or "Import CSV" to load another set.

Developer notes (internal)
- The Wheel class redraws the canvas on each rotation frame. Device pixel ratio is honored by _devicePixelRatioFix().
- The winner computation uses angles with the pointer oriented at top (-π/2 alignment).
- The code tries to be resilient to zero-sized canvas by using fallback attributes.

Troubleshooting quick checklist
- Canvas blank: ensure canvas exists and is visible; resize can trigger re-draw.
- Spin button stuck disabled: check wheel.isSpinning in console; a race condition may exist if you interrupt the animation.
- CSV malformed: Export uses simple one-column CSV; imports parse single-column lines and basic quoted fields.

License & contact
- This project is a small utility demo — update or add a license file in your repo as needed (MIT is a common choice).
- For product questions, integration help, or feature requests, contact your project team (or add an issues tracker in the repo).

Changelog (example)
- v1.0 — Initial build: wheel drawing, spin animation, themes, CSV import/export, basic accessibility.

Thank you for using Random Winner Wheel. If you want, we can:
- Add persistent storage (localStorage or cloud save).
- Add weighted chances or multi-winner support.
- Create a printable or shareable "result" link after a spin.
Tell us which features you'd like next and we'll prioritize them.

[2025-17-09 13:49:03 INFO] **[Seminar Conclusion]**:

 manual.md

# Random Winner Wheel — User Manual

Random Winner Wheel is a small, accessible, browser-based web app that lets you collect participant names and spin a visual wheel to randomly pick a winner. It is built with plain HTML, CSS and JavaScript, and requires no external libraries or build tools. The UI supports multiple themes, import/export of participant lists, keyboard shortcuts, and basic accessibility features.

Contents
- Overview
- What’s included (file list)
- System requirements & dependencies
- Quick start (run locally)
- Deploying (static hosting / GitHub Pages)
- Walkthrough — main features & UI
  - Adding names (single, sample, bulk)
  - Editing/removing names
  - Spinning and rerolling
  - Theme selection
  - Import / Export (CSV)
  - Keyboard shortcuts & accessibility
- Developer guide / Customization
  - How wheel chooses a winner (algorithm)
  - Changing theme palettes
  - Exposing the Wheel instance for scripting
  - Tuning animation & wheel appearance
  - File structure & key functions
- Troubleshooting & FAQs
- License & contact

---

Overview
A lightweight interactive wheel you can use for classroom raffles, team giveaways, decision-making, and more. Enter names manually or import them, spin the wheel, and see the winner highlighted.

What’s included (file list)
- index.html — Main page and UI.
- styles.css — All UI and theme styling.
- script.js — Wheel implementation and UI glue code.
- manual.md — This file.

System requirements & dependencies
- A modern web browser (Chrome, Firefox, Edge, Safari).
- No frameworks or packages required.
- Optional: a small static HTTP server if you prefer to serve rather than opening the file directly (recommended for import file handling in some browsers).

Quick start (run locally)
1. Download or clone the project files into a folder.
2. Open index.html directly in the browser, or run a simple static server:

- Using Python 3 (recommended):
  - In a terminal at the project folder:
    - python -m http.server 8000
  - Visit http://localhost:8000 in your browser.

- Using Node (http-server):
  - npm install -g http-server
  - http-server . -p 8000
  - Visit http://localhost:8000.

- Open index.html file directly:
  - Double-click index.html (works in most browsers). Some browsers restrict local file imports (CSV import), so serving via a simple HTTP server is safer.

Deploying (static hosting / GitHub Pages)
- This is a static site: upload the files to any static hosting provider (GitHub Pages, Netlify, Vercel, Surge, S3 + CloudFront).
- To host on GitHub Pages:
  - Create a repository and push the files.
  - Enable GitHub Pages on the repository (source: main branch root).
  - Access at https://<your-username>.github.io/<repo>.

Walkthrough — main features & UI

Main layout
- Header: Title and short description.
- Controls area: Single add, sample/random add, bulk add area, theme selector, spin/clear/import/export controls.
- Wheel area: Circular canvas with a pointer at the top.
- Participants list: Shows all added names with remove buttons and participant count.
- Result panel: Shows the winner after a spin and a "Spin Again" option.

Adding names
- Single add:
  - Type a name into the "Enter a name" input, press Add or hit Enter.
- Add sample:
  - Click "Add Sample" to add a small random batch of sample names (convenient for testing).
- Bulk add:
  - Paste or type multiple names into the bulk textarea separated by commas, semicolons, or newlines (e.g., "Alice, Bob; Charlie\nDana").
  - Click "Bulk Add".
  - The app trims, filters empty entries, and adds each name.

Editing/removing names
- Each participant in the list has a small ✕ button to remove that individual.
- "Clear Names" clears all participants (a confirmation prompt appears).

Spinning and rerolling
- Click "Spin" to animate the wheel and randomly pick a winner.
- While the wheel is spinning, the Spin button is temporarily disabled.
- After the spin completes, the winner is shown in the "Winner" section and the corresponding participant list entry is highlighted.
- Click "Spin Again" to reroll (the app chooses a new random outcome).

Theme selection
- Use the Theme dropdown to switch UI themes: Light, Dark, Neon, Pastel, Retro.
- Themes affect both page CSS variables and the wheel segment color palette.

Import / Export (CSV)
- Export: Click "Export CSV" to download the current list as a CSV file (one column, one name per line).
- Import: Click "Import CSV" and choose a CSV file (or text file). The app supports a single column per line, with quoted values (basic CSV).
- Note: Some browsers restrict file access when opening index.html locally — if CSV import fails, run a local static server.

Keyboard shortcuts & accessibility
- Ctrl/Cmd + K: Focus the name input for quick typing.
- Space: If not focused on an input/textarea, pressing Space triggers a spin.
- ARIA: The participants list and result area use aria-live attributes to notify assistive tech of changes.
- Pointer: A visual triangular pointer sits at the top of the wheel; the winner segment aligns with the pointer when spinning completes.

Developer guide / Customization

File structure & key functions
- script.js contains:
  - Wheel class — core drawing, spin animation, name management.
    - Methods: setNames, addName, removeName, clearNames, setTheme, draw, spin.
    - Constructor accepts options: { theme, onResult } where onResult receives { index, name }.
  - THEME_PALETTES — color palettes used per theme.
  - UI glue code inside DOMContentLoaded — connects DOM elements to Wheel calls and handles export/import, messages, etc.
- styles.css contains:
  - Theme variables controlled by body.theme-<name>.
  - Layout, responsive rules, toast styles, and wheel canvas appearance.

How the wheel chooses a winner (algorithm)
- The wheel divides the circle into N equal segments (N = number of participants).
- For a chosen winner index i, the code computes the mid-angle of the segment: segmentMid = ((i + 0.5)/N) * 2π.
- It computes a final rotation so the chosen segment mid-angle ends up under the fixed top pointer. Extra full rotations (random 5–8 spins) are added to make the spin feel natural.
- The animation uses an ease-out cubic easing for smooth deceleration.
- After animation, the code normalizes rotation and computes the resulting index from final rotation to confirm the winner.

Changing theme palettes
- Palette array: THEME_PALETTES in script.js maps theme id to an array of colors. Example:
  - light: ['#FF8A80', '#FFD180', ...]
- To add or modify theme colors, edit THEME_PALETTES.
- To add a new theme visually for the page, add a new body.theme-<id> block in styles.css with CSS variables (--bg, --fg, --accent, etc.), and add a matching option in the Theme select in index.html.

Exposing the Wheel instance for scripting
- By default the wheel instance is scoped to the script’s DOMContentLoaded closure.
- To access it in the browser console for debugging or programmatic control, modify script.js after wheel creation:
  - window.wheel = wheel;
- After that you can run commands in console:
  - wheel.addName('Zoe');
  - wheel.setTheme('dark');
  - wheel.spin();

Tuning animation & wheel appearance
- Animation duration: set duration variable in wheel.spin (currently 4000–5500ms).
- Extra turns: change rand(5,8) to fewer or more spins.
- Padding between segments: Wheel.padAngle (radians).
- Center circle size and font sizing are computed relative to canvas radius; adjust draw() if you want different sizing or font.

Saving state (optional)
- The example doesn’t persist names across sessions. To add persistence:
  - Use localStorage: on every add/remove/update, store JSON.stringify(wheel.names) to localStorage.
  - On DOMContentLoaded, read and restore if present.
  - Example (conceptual):
    - localStorage.setItem('wheel_names', JSON.stringify(wheel.names));
    - const saved = JSON.parse(localStorage.getItem('wheel_names') || '[]'); wheel.setNames(saved);

Troubleshooting & FAQs

Q: The wheel canvas is blank / not drawing!
- Make sure JavaScript is enabled.
- Ensure the canvas is visible on screen (some CSS rules or hidden parents can give a zero bounding rectangle; the script uses fallback width/height attributes).
- If the page is served via file:// you might have import restrictions, but drawing itself should still work.
- Open the browser console for errors.

Q: CSV import/export isn’t working when I open the file directly.
- Some browsers (Chrome especially) block file:// handling for security. Run a simple local HTTP server (see Quick start) and try again.

Q: I want to make the wheel fair — is it truly random?
- The selection uses Math.random-based seeding to pick a winner index and a random number of full rotations. Math.random is not cryptographically secure but is suitable for casual selections and giveaways. For higher guarantees, integrate a cryptographic RNG or server-side selection.

Q: How do I change text styles, fonts or the pointer shape?
- Edit styles.css for pointer look and font-family, or change the pointer HTML/CSS. The pointer is a CSS triangle positioned absolutely above the canvas.

Q: I want labels to wrap or use smaller fonts for long names — how?
- The wheel uses wrapFillText and sets dynamic font size relative to radius. For more control, adjust the font size computation in script.js draw() (ctx.font = ...).

FAQ: Accessibility
- The UI includes aria-live on the participant list and result area so screen readers receive updates. If you need further accessibility support:
  - Add aria-labels to interactive items.
  - Add a non-visual log of recent winners (text history) for assistive tech.
  - Consider keyboard-only operation improvements: add focus states, ensure buttons are reachable via tab order.

Extending the app
- Add new themes: edit styles.css and THEME_PALETTES.
- Save/Load presets: add UI to save palettes/names to JSON and fetch them later.
- Analytics or audit trail: append spin results to a list and store in localStorage or send to a server.
- Multi-wheel or weight support: modify wheel logic to accept weights per name (segment size proportional to weight) — this requires updating segment angle calculation and mapping of finalAngle to index.

Sample workflow / quick demo
1. Open the site in your browser (http://localhost:8000).
2. Click the name field, type "Alice", press Enter.
3. Click "Bulk Add", paste "Bob, Charlie, Dana" and click Bulk Add.
4. Choose "Neon" from Theme dropdown to preview wheel colors.
5. Click "Spin". Wait for the wheel to stop and see the winner shown in the Result panel and highlighted in the participant list.
6. Click "Export CSV" to download the current list; or "Import CSV" to load another set.

Developer notes (internal)
- The Wheel class redraws the canvas on each rotation frame. Device pixel ratio is honored by _devicePixelRatioFix().
- The winner computation uses angles with the pointer oriented at top (-π/2 alignment).
- The code tries to be resilient to zero-sized canvas by using fallback attributes.

Troubleshooting quick checklist
- Canvas blank: ensure canvas exists and is visible; resize can trigger re-draw.
- Spin button stuck disabled: check wheel.isSpinning in console; a race condition may exist if you interrupt the animation.
- CSV malformed: Export uses simple one-column CSV; imports parse single-column lines and basic quoted fields.

License & contact
- This project is a small utility demo — update or add a license file in your repo as needed (MIT is a common choice).
- For product questions, integration help, or feature requests, contact your project team (or add an issues tracker in the repo).

Changelog (example)
- v1.0 — Initial build: wheel drawing, spin animation, themes, CSV import/export, basic accessibility.

Thank you for using Random Winner Wheel. If you want, we can:
- Add persistent storage (localStorage or cloud save).
- Add weighted chances or multi-winner support.
- Create a printable or shareable "result" link after a spin.
Tell us which features you'd like next and we'll prioritize them.

[2025-17-09 13:49:03 INFO] **[Post Info]**

Software Info: 

💰**cost**=$0.099019

🔨**version_updates**=5.0

📃**num_code_files**=0

🏞**num_png_files**=0

📚**num_doc_files**=9

📃**code_lines**=0

📋**env_lines**=-1

📒**manual_lines**=182

🗣**num_utterances**=25

🤔**num_self_reflections**=1

❓**num_prompt_tokens**=68246

❗**num_completion_tokens**=43264

🌟**num_total_tokens**=111510

🕑**duration**=1443.00s

ChatDev Starts (20250917132500)

ChatDev Ends (20250917134903)



